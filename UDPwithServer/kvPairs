put:RFC: 793
put:De:fense Advanced Research Projects Agency
put:I:nformation Processing Techniques Office
put:September 1981   :                                                       
put:PREFACE .....:................................................... iii
put:1.  INTRODUCTION :..................................................... 1
put:1.1  Motivation: .................................................... 1
put:1.2  Scope ....:..................................................... 2
put:1.3  About This: Document ........................................... 2
put:1.4  Interfaces: .................................................... 3
put:1.5  Operation :..................................................... 3
put:2.  PHILOSOPHY ..:..................................................... 7
put:2.1  Elements o:f the Internetwork System ........................... 7
put:2.2  Model of O:peration ............................................ 7
put:2.3  The Host E:nvironment .......................................... 8
put:2.4  Interfaces: .................................................... 9
put:2.5  Relation t:o Other Protocols ................................... 9
put:2.6  Reliable C:ommunication ........................................ 9
put:2.7  Connection: Establishment and Clearing ........................ 10
put:2.8  Data Commu:nication ........................................... 12
put:2.9  Precedence: and Security ...................................... 13
put:2.10 Robustness: Principle ......................................... 13
put:3.  FUNCTIONAL SP:ECIFICATION ........................................ 15
put:3.1  Header For:mat ................................................ 15
put:3.2  Terminolog:y .................................................. 19
put:3.3  Sequence N:umbers ............................................. 24
put:3.4  Establishi:ng a connection .................................... 30
put:3.5  Closing a :Connection ......................................... 37
put:3.6  Precedence: and Security ...................................... 40
put:3.7  Data Commu:nication ........................................... 40
put:3.8  Interfaces: ................................................... 44
put:3.9  Event Proc:essing ............................................. 52
put:GLOSSARY ........:.................................................... 79
put:REFERENCES ......:.................................................... 85
put:Transmission Cont:rol Protocol
put:[Page ii]        :                                                       
put:September 1981   :                                                       
put:This document des:cribes the DoD Standard Transmission Control Protocol
put:(TCP).  There hav:e been nine earlier editions of the ARPA TCP
put:specification on :which this standard is based, and the present text
put:draws heavily fro:m them.  There have been many contributors to this work
put:both in terms of :concepts and in terms of text.  This edition clarifies
put:several details a:nd removes the end-of-letter buffer-size adjustments,
put:and redescribes t:he letter mechanism as a push function.
put:RFC:  793
put:Replaces: RFC 761:
put:IENs:  129, 124, :112, 81,
put:55, 44, 40, 27, 2:1, 5
put:The Transmission :Control Protocol (TCP) is intended for use as a highly
put:reliable host-to-:host protocol between hosts in packet-switched computer
put:communication net:works, and in interconnected systems of such networks.
put:This document des:cribes the functions to be performed by the
put:Transmission Cont:rol Protocol, the program that implements it, and its
put:interface to prog:rams or users that require its services.
put:Computer commun:ication systems are playing an increasingly important
put:role in militar:y, government, and civilian environments.  This
put:document focuse:s its attention primarily on military computer
put:communication r:equirements, especially robustness in the presence of
put:communication u:nreliability and availability in the presence of
put:congestion, but: many of these problems are found in the civilian and
put:government sect:or as well.
put:As strategic an:d tactical computer communication networks are
put:developed and d:eployed, it is essential to provide means of
put:interconnecting: them and to provide standard interprocess
put:communication p:rotocols which can support a broad range of
put:applications.  :In anticipation of the need for such standards, the
put:Deputy Undersec:retary of Defense for Research and Engineering has
put:declared the Tr:ansmission Control Protocol (TCP) described herein to
put:be a basis for :DoD-wide inter-process communication protocol
put:standardization:.
put:TCP is a connec:tion-oriented, end-to-end reliable protocol designed to
put:fit into a laye:red hierarchy of protocols which support multi-network
put:applications.  :The TCP provides for reliable inter-process
put:communication b:etween pairs of processes in host computers attached to
put:distinct but in:terconnected computer communication networks.  Very few
put:assumptions are: made as to the reliability of the communication
put:protocols below: the TCP layer.  TCP assumes it can obtain a simple,
put:potentially unr:eliable datagram service from the lower level
put:protocols.  In :principle, the TCP should be able to operate above a
put:wide spectrum o:f communication systems ranging from hard-wired
put:connections to :packet-switched or circuit-switched networks.
put:Transmission Cont:rol Protocol
put:TCP is based on: concepts first described by Cerf and Kahn in [1].  The
put:TCP fits into a: layered protocol architecture just above a basic
put:Internet Protoc:ol [2] which provides a way for the TCP to send and
put:receive variabl:e-length segments of information enclosed in internet
put:datagram "envel:opes".  The internet datagram provides a means for
put:addressing sour:ce and destination TCPs in different networks.  The
put:internet protoc:ol also deals with any fragmentation or reassembly of
put:the TCP segment:s required to achieve transport and delivery through
put:multiple networ:ks and interconnecting gateways.  The internet protocol
put:also carries in:formation on the precedence, security classification
put:and compartment:ation of the TCP segments, so this information can be
put:communicated en:d-to-end across multiple networks.
put:Much of this do:cument is written in the context of TCP implementations
put:which are co-re:sident with higher level protocols in the host
put:computer.  Some: computer systems will be connected to networks via
put:front-end compu:ters which house the TCP and internet protocol layers,
put:as well as netw:ork specific software.  The TCP specification describes
put:an interface to: the higher level protocols which appears to be
put:implementable e:ven for the front-end case, as long as a suitable
put:host-to-front e:nd protocol is implemented.
put:The TCP is inte:nded to provide a reliable process-to-process
put:communication s:ervice in a multinetwork environment.  The TCP is
put:intended to be :a host-to-host protocol in common use in multiple
put:1.3.  About this :Document
put:This document r:epresents a specification of the behavior required of
put:any TCP impleme:ntation, both in its interactions with higher level
put:protocols and i:n its interactions with other TCPs.  The rest of this
put:[Page 2]         :                                                       
put:September 1981   :                                                       
put:section offers :a very brief view of the protocol interfaces and
put:operation.  Sec:tion 2 summarizes the philosophical basis for the TCP
put:design.  Sectio:n 3 offers both a detailed description of the actions
put:required of TCP: when various events occur (arrival of new segments,
put:user calls, err:ors, etc.) and the details of the formats of TCP
put:The TCP interfa:ces on one side to user or application processes and on
put:the other side :to a lower level protocol such as Internet Protocol.
put:The interface b:etween an application process and the TCP is
put:illustrated in :reasonable detail.  This interface consists of a set of
put:calls much like: the calls an operating system provides to an
put:application pro:cess for manipulating files.  For example, there are
put:calls to open a:nd close connections and to send and receive data on
put:established con:nections.  It is also expected that the TCP can
put:asynchronously :communicate with application programs.  Although
put:considerable fr:eedom is permitted to TCP implementors to design
put:interfaces whic:h are appropriate to a particular operating system
put:environment, a :minimum functionality is required at the TCP/user
put:interface for a:ny valid implementation.
put:The interface b:etween TCP and lower level protocol is essentially
put:unspecified exc:ept that it is assumed there is a mechanism whereby the
put:two levels can :asynchronously pass information to each other.
put:Typically, one :expects the lower level protocol to specify this
put:interface.  TCP: is designed to work in a very general environment of
put:interconnected :networks.  The lower level protocol which is assumed
put:throughout this: document is the Internet Protocol [2].
put:As noted above,: the primary purpose of the TCP is to provide reliable,
put:securable logic:al circuit or connection service between pairs of
put:processes.  To :provide this service on top of a less reliable internet
put:communication s:ystem requires facilities in the following areas:
put:Basic Data Tr:ansfer
put:Precedence an:d Security
put:The basic opera:tion of the TCP in each of these areas is described in
put:the following p:aragraphs.
put:Transmission Cont:rol Protocol
put:Basic Data Tran:sfer:
put:The TCP is ab:le to transfer a continuous stream of octets in each
put:direction bet:ween its users by packaging some number of octets into
put:segments for :transmission through the internet system.  In general,
put:the TCPs deci:de when to block and forward data at their own
put:Sometimes use:rs need to be sure that all the data they have
put:submitted to :the TCP has been transmitted.  For this purpose a push
put:function is d:efined.  To assure that data submitted to a TCP is
put:actually tran:smitted the sending user indicates that it should be
put:pushed throug:h to the receiving user.  A push causes the TCPs to
put:promptly forw:ard and deliver data up to that point to the receiver.
put:The exact pus:h point might not be visible to the receiving user and
put:the push func:tion does not supply a record boundary marker.
put:Reliability:
put:The TCP must :recover from data that is damaged, lost, duplicated, or
put:delivered out: of order by the internet communication system.  This
put:is achieved b:y assigning a sequence number to each octet
put:transmitted, :and requiring a positive acknowledgment (ACK) from the
put:receiving TCP:.  If the ACK is not received within a timeout
put:interval, the: data is retransmitted.  At the receiver, the sequence
put:numbers are u:sed to correctly order segments that may be received
put:out of order :and to eliminate duplicates.  Damage is handled by
put:adding a chec:ksum to each segment transmitted, checking it at the
put:receiver, and: discarding damaged segments.
put:As long as th:e TCPs continue to function properly and the internet
put:system does n:ot become completely partitioned, no transmission
put:errors will a:ffect the correct delivery of data.  TCP recovers from
put:internet comm:unication system errors.
put:Flow Control:
put:TCP provides :a means for the receiver to govern the amount of data
put:sent by the s:ender.  This is achieved by returning a "window" with
put:every ACK ind:icating a range of acceptable sequence numbers beyond
put:the last segm:ent successfully received.  The window indicates an
put:allowed numbe:r of octets that the sender may transmit before
put:receiving fur:ther permission.
put:[Page 4]         :                                                       
put:September 1981   :                                                       
put:Multiplexing:
put:To allow for :many processes within a single Host to use TCP
put:communication: facilities simultaneously, the TCP provides a set of
put:addresses or :ports within each host.  Concatenated with the network
put:and host addr:esses from the internet communication layer, this forms
put:a socket.  A :pair of sockets uniquely identifies each connection.
put:That is, a so:cket may be simultaneously used in multiple
put:The binding o:f ports to processes is handled independently by each
put:Host.  Howeve:r, it proves useful to attach frequently used processes
put:(e.g., a "log:ger" or timesharing service) to fixed sockets which are
put:made known to: the public.  These services can then be accessed
put:through the k:nown addresses.  Establishing and learning the port
put:addresses of :other processes may involve more dynamic mechanisms.
put:Connections:
put:The reliabili:ty and flow control mechanisms described above require
put:that TCPs ini:tialize and maintain certain status information for
put:each data str:eam.  The combination of this information, including
put:sockets, sequ:ence numbers, and window sizes, is called a connection.
put:Each connecti:on is uniquely specified by a pair of sockets
put:identifying i:ts two sides.
put:When two proc:esses wish to communicate, their TCP's must first
put:establish a c:onnection (initialize the status information on each
put:side).  When :their communication is complete, the connection is
put:terminated or: closed to free the resources for other uses.
put:Since connect:ions must be established between unreliable hosts and
put:over the unre:liable internet communication system, a handshake
put:mechanism wit:h clock-based sequence numbers is used to avoid
put:erroneous ini:tialization of connections.
put:Precedence and :Security:
put:The users of :TCP may indicate the security and precedence of their
put:communication:.  Provision is made for default values to be used when
put:these feature:s are not needed.
put:Transmission Cont:rol Protocol
put:[Page 6]         :                                                       
put:September 1981   :                                                       
put:2.1.  Elements of: the Internetwork System
put:The internetwor:k environment consists of hosts connected to networks
put:which are in tu:rn interconnected via gateways.  It is assumed here
put:that the networ:ks may be either local networks (e.g., the ETHERNET) or
put:large networks :(e.g., the ARPANET), but in any case are based on
put:packet switchin:g technology.  The active agents that produce and
put:consume message:s are processes.  Various levels of protocols in the
put:networks, the g:ateways, and the hosts support an interprocess
put:communication s:ystem that provides two-way data flow on logical
put:connections bet:ween process ports.
put:The term packet: is used generically here to mean the data of one
put:transaction bet:ween a host and its network.  The format of data blocks
put:exchanged withi:n the a network will generally not be of concern to us.
put:Hosts are compu:ters attached to a network, and from the communication
put:network's point: of view, are the sources and destinations of packets.
put:Processes are v:iewed as the active elements in host computers (in
put:accordance with: the fairly common definition of a process as a program
put:in execution). : Even terminals and files or other I/O devices are
put:viewed as commu:nicating with each other through the use of processes.
put:Thus, all commu:nication is viewed as inter-process communication.
put:Since a process: may need to distinguish among several communication
put:streams between: itself and another process (or processes), we imagine
put:that each proce:ss may have a number of ports through which it
put:communicates wi:th the ports of other processes.
put:2.2.  Model of Op:eration
put:Processes trans:mit data by calling on the TCP and passing buffers of
put:data as argumen:ts.  The TCP packages the data from these buffers into
put:segments and ca:lls on the internet module to transmit each segment to
put:the destination: TCP.  The receiving TCP places the data from a segment
put:into the receiv:ing user's buffer and notifies the receiving user.  The
put:TCPs include co:ntrol information in the segments which they use to
put:ensure reliable: ordered data transmission.
put:The model of in:ternet communication is that there is an internet
put:protocol module: associated with each TCP which provides an interface
put:to the local ne:twork.  This internet module packages TCP segments
put:inside internet: datagrams and routes these datagrams to a destination
put:internet module: or intermediate gateway.  To transmit the datagram
put:through the loc:al network, it is embedded in a local network packet.
put:The packet swit:ches may perform further packaging, fragmentation, or
put:Transmission Cont:rol Protocol
put:other operation:s to achieve the delivery of the local packet to the
put:destination int:ernet module.
put:At a gateway be:tween networks, the internet datagram is "unwrapped"
put:from its local :packet and examined to determine through which network
put:the internet da:tagram should travel next.  The internet datagram is
put:then "wrapped" :in a local packet suitable to the next network and
put:routed to the n:ext gateway, or to the final destination.
put:A gateway is pe:rmitted to break up an internet datagram into smaller
put:internet datagr:am fragments if this is necessary for transmission
put:through the nex:t network.  To do this, the gateway produces a set of
put:internet datagr:ams; each carrying a fragment.  Fragments may be
put:further broken :into smaller fragments at subsequent gateways.  The
put:internet datagr:am fragment format is designed so that the destination
put:internet module: can reassemble fragments into internet datagrams.
put:A destination i:nternet module unwraps the segment from the datagram
put:(after reassemb:ling the datagram, if necessary) and passes it to the
put:destination TCP:.
put:This simple mod:el of the operation glosses over many details.  One
put:important featu:re is the type of service.  This provides information
put:to the gateway :(or internet module) to guide it in selecting the
put:service paramet:ers to be used in traversing the next network.
put:Included in the: type of service information is the precedence of the
put:datagram.  Data:grams may also carry security information to permit
put:host and gatewa:ys that operate in multilevel secure environments to
put:properly segreg:ate datagrams for security considerations.
put:2.3.  The Host En:vironment
put:The TCP is assu:med to be a module in an operating system.  The users
put:access the TCP :much like they would access the file system.  The TCP
put:may call on oth:er operating system functions, for example, to manage
put:data structures:.  The actual interface to the network is assumed to be
put:controlled by a: device driver module.  The TCP does not call on the
put:network device :driver directly, but rather calls on the internet
put:datagram protoc:ol module which may in turn call on the device driver.
put:The mechanisms :of TCP do not preclude implementation of the TCP in a
put:front-end proce:ssor.  However, in such an implementation, a
put:host-to-front-e:nd protocol must provide the functionality to support
put:the type of TCP:-user interface described in this document.
put:[Page 8]         :                                                       
put:September 1981   :                                                       
put:The TCP/user in:terface provides for calls made by the user on the TCP
put:to OPEN or CLOS:E a connection, to SEND or RECEIVE data, or to obtain
put:STATUS about a :connection.  These calls are like other calls from user
put:programs on the: operating system, for example, the calls to open, read
put:from, and close: a file.
put:The TCP/interne:t interface provides calls to send and receive
put:datagrams addre:ssed to TCP modules in hosts anywhere in the internet
put:system.  These :calls have parameters for passing the address, type of
put:service, preced:ence, security, and other control information.
put:2.5.  Relation to: Other Protocols
put:The following d:iagram illustrates the place of the TCP in the protocol
put:hierarchy:
put:+------+ +:-----+ +-----+       +-----+                    
put:|Telnet| |: FTP | |Voice|  ...  |     |  Application Level 
put:+------+ +:-----+ +-----+       +-----+                    
put:|   :|         |             |                       
put:+----:-+     +-----+       +-----+                    
put:| TCP: |     | RTP |  ...  |     |  Host Level        
put:+----:-+     +-----+       +-----+                    
put:| :          |             |                       
put:+----:---------------------------+                    
put:|    :Internet Protocol & ICMP   |  Gateway Level     
put:+----:---------------------------+                    
put:+--:-------------------------+                      
put:|  : Local Network Protocol  |    Network Level     
put:+--:-------------------------+                      
put:It is expected :that the TCP will be able to support higher level
put:protocols effic:iently.  It should be easy to interface higher level
put:protocols like :the ARPANET Telnet or AUTODIN II THP to the TCP.
put:2.6.  Reliable Co:mmunication
put:A stream of dat:a sent on a TCP connection is delivered reliably and in
put:order at the de:stination.
put:Transmission Cont:rol Protocol
put:Transmission is: made reliable via the use of sequence numbers and
put:acknowledgments:.  Conceptually, each octet of data is assigned a
put:sequence number:.  The sequence number of the first octet of data in a
put:segment is tran:smitted with that segment and is called the segment
put:sequence number:.  Segments also carry an acknowledgment number which
put:is the sequence: number of the next expected data octet of
put:transmissions i:n the reverse direction.  When the TCP transmits a
put:segment contain:ing data, it puts a copy on a retransmission queue and
put:starts a timer;: when the acknowledgment for that data is received, the
put:segment is dele:ted from the queue.  If the acknowledgment is not
put:received before: the timer runs out, the segment is retransmitted.
put:An acknowledgme:nt by TCP does not guarantee that the data has been
put:delivered to th:e end user, but only that the receiving TCP has taken
put:the responsibil:ity to do so.
put:To govern the f:low of data between TCPs, a flow control mechanism is
put:employed.  The :receiving TCP reports a "window" to the sending TCP.
put:This window spe:cifies the number of octets, starting with the
put:acknowledgment :number, that the receiving TCP is currently prepared to
put:2.7.  Connection :Establishment and Clearing
put:To identify the: separate data streams that a TCP may handle, the TCP
put:provides a port: identifier.  Since port identifiers are selected
put:independently b:y each TCP they might not be unique.  To provide for
put:unique addresse:s within each TCP, we concatenate an internet address
put:identifying the: TCP with a port identifier to create a socket which
put:will be unique :throughout all networks connected together.
put:A connection is: fully specified by the pair of sockets at the ends.  A
put:local socket ma:y participate in many connections to different foreign
put:sockets.  A con:nection can be used to carry data in both directions,
put:that is, it is :"full duplex".
put:TCPs are free t:o associate ports with processes however they choose.
put:However, severa:l basic concepts are necessary in any implementation.
put:There must be w:ell-known sockets which the TCP associates only with
put:the "appropriat:e" processes by some means.  We envision that processes
put:may "own" ports:, and that processes can initiate connections only on
put:the ports they :own.  (Means for implementing ownership is a local
put:issue, but we e:nvision a Request Port user command, or a method of
put:uniquely alloca:ting a group of ports to a given process, e.g., by
put:associating the: high order bits of a port name with a given process.)
put:A connection is: specified in the OPEN call by the local port and
put:foreign socket :arguments.  In return, the TCP supplies a (short) local
put:[Page 10]        :                                                       
put:September 1981   :                                                       
put:connection name: by which the user refers to the connection in
put:subsequent call:s.  There are several things that must be remembered
put:about a connect:ion.  To store this information we imagine that there
put:is a data struc:ture called a Transmission Control Block (TCB).  One
put:implementation :strategy would have the local connection name be a
put:pointer to the :TCB for this connection.  The OPEN call also specifies
put:whether the con:nection establishment is to be actively pursued, or to
put:be passively wa:ited for.
put:A passive OPEN :request means that the process wants to accept incoming
put:connection requ:ests rather than attempting to initiate a connection.
put:Often the proce:ss requesting a passive OPEN will accept a connection
put:request from an:y caller.  In this case a foreign socket of all zeros
put:is used to deno:te an unspecified socket.  Unspecified foreign sockets
put:are allowed onl:y on passive OPENs.
put:A service proce:ss that wished to provide services for unknown other
put:processes would: issue a passive OPEN request with an unspecified
put:foreign socket.:  Then a connection could be made with any process that
put:requested a con:nection to this local socket.  It would help if this
put:local socket we:re known to be associated with this service.
put:Well-known sock:ets are a convenient mechanism for a priori associating
put:a socket addres:s with a standard service.  For instance, the
put:"Telnet-Server": process is permanently assigned to a particular
put:socket, and oth:er sockets are reserved for File Transfer, Remote Job
put:Entry, Text Gen:erator, Echoer, and Sink processes (the last three
put:being for test :purposes).  A socket address might be reserved for
put:access to a "Lo:ok-Up" service which would return the specific socket
put:at which a newl:y created service would be provided.  The concept of a
put:well-known sock:et is part of the TCP specification, but the assignment
put:of sockets to s:ervices is outside this specification.  (See [4].)
put:Processes can i:ssue passive OPENs and wait for matching active OPENs
put:from other proc:esses and be informed by the TCP when connections have
put:been establishe:d.  Two processes which issue active OPENs to each
put:other at the sa:me time will be correctly connected.  This flexibility
put:is critical for: the support of distributed computing in which
put:components act :asynchronously with respect to each other.
put:There are two p:rincipal cases for matching the sockets in the local
put:passive OPENs a:nd an foreign active OPENs.  In the first case, the
put:local passive O:PENs has fully specified the foreign socket.  In this
put:case, the match: must be exact.  In the second case, the local passive
put:OPENs has left :the foreign socket unspecified.  In this case, any
put:foreign socket :is acceptable as long as the local sockets match.
put:Other possibili:ties include partially restricted matches.
put:Transmission Cont:rol Protocol
put:If there are se:veral pending passive OPENs (recorded in TCBs) with the
put:same local sock:et, an foreign active OPEN will be matched to a TCB
put:with the specif:ic foreign socket in the foreign active OPEN, if such a
put:TCB exists, bef:ore selecting a TCB with an unspecified foreign socket.
put:The procedures :to establish connections utilize the synchronize (SYN)
put:control flag an:d involves an exchange of three messages.  This
put:exchange has be:en termed a three-way hand shake [3].
put:A connection is: initiated by the rendezvous of an arriving segment
put:containing a SY:N and a waiting TCB entry each created by a user OPEN
put:command.  The m:atching of local and foreign sockets determines when a
put:connection has :been initiated.  The connection becomes "established"
put:when sequence n:umbers have been synchronized in both directions.
put:The clearing of: a connection also involves the exchange of segments,
put:in this case ca:rrying the FIN control flag.
put:2.8.  Data Commun:ication
put:The data that f:lows on a connection may be thought of as a stream of
put:octets.  The se:nding user indicates in each SEND call whether the data
put:in that call (a:nd any preceeding calls) should be immediately pushed
put:through to the :receiving user by the setting of the PUSH flag.
put:A sending TCP i:s allowed to collect data from the sending user and to
put:send that data :in segments at its own convenience, until the push
put:function is sig:naled, then it must send all unsent data.  When a
put:receiving TCP s:ees the PUSH flag, it must not wait for more data from
put:the sending TCP: before passing the data to the receiving process.
put:There is no nec:essary relationship between push functions and segment
put:boundaries.  Th:e data in any particular segment may be the result of a
put:single SEND cal:l, in whole or part, or of multiple SEND calls.
put:The purpose of :push function and the PUSH flag is to push data through
put:from the sendin:g user to the receiving user.  It does not provide a
put:record service.:
put:There is a coup:ling between the push function and the use of buffers
put:of data that cr:oss the TCP/user interface.  Each time a PUSH flag is
put:associated with: data placed into the receiving user's buffer, the
put:buffer is retur:ned to the user for processing even if the buffer is
put:not filled.  If: data arrives that fills the user's buffer before a
put:PUSH is seen, t:he data is passed to the user in buffer size units.
put:TCP also provid:es a means to communicate to the receiver of data that
put:at some point f:urther along in the data stream than the receiver is
put:[Page 12]        :                                                       
put:September 1981   :                                                       
put:currently readi:ng there is urgent data.  TCP does not attempt to
put:define what the: user specifically does upon being notified of pending
put:urgent data, bu:t the general notion is that the receiving process will
put:take action to :process the urgent data quickly.
put:2.9.  Precedence :and Security
put:The TCP makes u:se of the internet protocol type of service field and
put:security option: to provide precedence and security on a per connection
put:basis to TCP us:ers.  Not all TCP modules will necessarily function in
put:a multilevel se:cure environment; some may be limited to unclassified
put:use only, and o:thers may operate at only one security level and
put:compartment.  C:onsequently, some TCP implementations and services to
put:users may be li:mited to a subset of the multilevel secure case.
put:TCP modules whi:ch operate in a multilevel secure environment must
put:properly mark o:utgoing segments with the security, compartment, and
put:precedence.  Su:ch TCP modules must also provide to their users or
put:higher level pr:otocols such as Telnet or THP an interface to allow
put:them to specify: the desired security level, compartment, and
put:precedence of c:onnections.
put:2.10.  Robustness: Principle
put:TCP implementat:ions will follow a general principle of robustness:  be
put:conservative in: what you do, be liberal in what you accept from
put:Transmission Cont:rol Protocol
put:[Page 14]        :                                                       
put:September 1981   :                                                       
put:3.1.  Header Form:at
put:TCP segments ar:e sent as internet datagrams.  The Internet Protocol
put:header carries :several information fields, including the source and
put:destination hos:t addresses [2].  A TCP header follows the internet
put:header, supplyi:ng information specific to the TCP protocol.  This
put:division allows: for the existence of host level protocols other than
put:TCP Header Form:at
put:0            :       1                   2                   3   
put:0 1 2 3 4 5 6: 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 
put:+-+-+-+-+-+-+-:+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
put:|          Sou:rce Port          |       Destination Port        |
put:+-+-+-+-+-+-+-:+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
put:|             :           Sequence Number                        |
put:+-+-+-+-+-+-+-:+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
put:|             :       Acknowledgment Number                      |
put:+-+-+-+-+-+-+-:+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
put:|  Data |     :      |U|A|P|R|S|F|                               |
put:| Offset| Rese:rved  |R|C|S|S|Y|I|            Window             |
put:|       |     :      |G|K|H|T|N|N|                               |
put:+-+-+-+-+-+-+-:+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
put:|           Ch:ecksum            |         Urgent Pointer        |
put:+-+-+-+-+-+-+-:+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
put:|             :       Options                    |    Padding    |
put:+-+-+-+-+-+-+-:+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
put:|             :                data                              |
put:+-+-+-+-+-+-+-:+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
put:Note th:at one tick mark represents one bit position.
put:Source Port:  1:6 bits
put:The source po:rt number.
put:Destination Por:t:  16 bits
put:The destinati:on port number.
put:Transmission Cont:rol Protocol
put:Functional Specif:ication
put:Sequence Number::  32 bits
put:The sequence :number of the first data octet in this segment (except
put:when SYN is p:resent). If SYN is present the sequence number is the
put:initial seque:nce number (ISN) and the first data octet is ISN+1.
put:Acknowledgment :Number:  32 bits
put:If the ACK co:ntrol bit is set this field contains the value of the
put:next sequence: number the sender of the segment is expecting to
put:receive.  Onc:e a connection is established this is always sent.
put:Data Offset:  4: bits
put:The number of: 32 bit words in the TCP Header.  This indicates where
put:the data begi:ns.  The TCP header (even one including options) is an
put:integral numb:er of 32 bits long.
put:Reserved:  6 bi:ts
put:Reserved for :future use.  Must be zero.
put:Control Bits:  :6 bits (from left to right):
put:URG:  Urgent :Pointer field significant
put:ACK:  Acknowl:edgment field significant
put:PSH:  Push Fu:nction
put:RST:  Reset t:he connection
put:SYN:  Synchro:nize sequence numbers
put:FIN:  No more: data from sender
put:Window:  16 bit:s
put:The number of: data octets beginning with the one indicated in the
put:acknowledgmen:t field which the sender of this segment is willing to
put:Checksum:  16 b:its
put:The checksum :field is the 16 bit one's complement of the one's
put:complement su:m of all 16 bit words in the header and text.  If a
put:segment conta:ins an odd number of header and text octets to be
put:checksummed, :the last octet is padded on the right with zeros to
put:form a 16 bit: word for checksum purposes.  The pad is not
put:transmitted a:s part of the segment.  While computing the checksum,
put:the checksum :field itself is replaced with zeros.
put:The checksum :also covers a 96 bit pseudo header conceptually
put:[Page 16]        :                                                       
put:September 1981   :                                                       
put:prefixed to t:he TCP header.  This pseudo header contains the Source
put:Address, the :Destination Address, the Protocol, and TCP length.
put:This gives th:e TCP protection against misrouted segments.  This
put:information i:s carried in the Internet Protocol and is transferred
put:across the TC:P/Network interface in the arguments or results of
put:calls by the :TCP on the IP.
put:The TCP Len:gth is the TCP header length plus the data length in
put:octets (thi:s is not an explicitly transmitted quantity, but is
put:computed), :and it does not count the 12 octets of the pseudo
put:Urgent Pointer::  16 bits
put:This field co:mmunicates the current value of the urgent pointer as a
put:positive offs:et from the sequence number in this segment.  The
put:urgent pointe:r points to the sequence number of the octet following
put:the urgent da:ta.  This field is only be interpreted in segments with
put:the URG contr:ol bit set.
put:Options:  varia:ble
put:Options may o:ccupy space at the end of the TCP header and are a
put:multiple of 8: bits in length.  All options are included in the
put:checksum.  An: option may begin on any octet boundary.  There are two
put:cases for the: format of an option:
put:Case 1:  A :single octet of option-kind.
put:Case 2:  An: octet of option-kind, an octet of option-length, and
put:th:e actual option-data octets.
put:The option-le:ngth counts the two octets of option-kind and
put:option-length: as well as the option-data octets.
put:Note that the: list of options may be shorter than the data offset
put:field might i:mply.  The content of the header beyond the
put:End-of-Option: option must be header padding (i.e., zero).
put:A TCP must im:plement all options.
put:Transmission Cont:rol Protocol
put:Functional Specif:ication
put:Currently def:ined options include (kind indicated in octal):
put:Kind     Le:ngth    Meaning
put:----     --:----    -------
put:0         :-       End of option list.
put:1         :-       No-Operation.
put:2         :4       Maximum Segment Size.
put:Specific Opti:on Definitions
put:End of Opti:on List
put:+--------:+
put:|00000000:|
put:+--------:+
put:This opti:on code indicates the end of the option list.  This
put:might not: coincide with the end of the TCP header according to
put:the Data :Offset field.  This is used at the end of all options,
put:not the e:nd of each option, and need only be used if the end of
put:the optio:ns would not otherwise coincide with the end of the TCP
put:No-Operatio:n
put:+--------:+
put:|00000001:|
put:+--------:+
put:This opti:on code may be used between options, for example, to
put:align the: beginning of a subsequent option on a word boundary.
put:There is :no guarantee that senders will use this option, so
put:receivers: must be prepared to process options even if they do
put:not begin: on a word boundary.
put:Maximum Seg:ment Size
put:+--------:+--------+---------+--------+
put:|00000010:|00000100|   max seg size   |
put:+--------:+--------+---------+--------+
put:Kind=2  : Length=4
put:[Page 18]        :                                                       
put:September 1981   :                                                       
put:Maximum S:egment Size Option Data:  16 bits
put:If this: option is present, then it communicates the maximum
put:receive: segment size at the TCP which sends this segment.
put:This fi:eld must only be sent in the initial connection request
put:(i.e., :in segments with the SYN control bit set).  If this
put:option :is not used, any segment size is allowed.
put:Padding:  varia:ble
put:The TCP heade:r padding is used to ensure that the TCP header ends
put:and data begi:ns on a 32 bit boundary.  The padding is composed of
put:3.2.  Terminology:
put:Before we can d:iscuss very much about the operation of the TCP we need
put:to introduce so:me detailed terminology.  The maintenance of a TCP
put:connection requ:ires the remembering of several variables.  We conceive
put:of these variab:les being stored in a connection record called a
put:Transmission Co:ntrol Block or TCB.  Among the variables stored in the
put:TCB are the loc:al and remote socket numbers, the security and
put:precedence of t:he connection, pointers to the user's send and receive
put:buffers, pointe:rs to the retransmit queue and to the current segment.
put:In addition sev:eral variables relating to the send and receive
put:sequence number:s are stored in the TCB.
put:Send Sequence: Variables
put:SND.UNA - s:end unacknowledged
put:SND.NXT - s:end next
put:SND.WND - s:end window
put:SND.UP  - s:end urgent pointer
put:SND.WL1 - s:egment sequence number used for last window update
put:SND.WL2 - s:egment acknowledgment number used for last window
put:u:pdate
put:ISS     - i:nitial send sequence number
put:Receive Seque:nce Variables
put:RCV.NXT - r:eceive next
put:RCV.WND - r:eceive window
put:RCV.UP  - r:eceive urgent pointer
put:IRS     - i:nitial receive sequence number
put:Transmission Cont:rol Protocol
put:Functional Specif:ication
put:The following d:iagrams may help to relate some of these variables to
put:the sequence sp:ace.
put:Send Sequence S:pace
put:---:-------|----------|----------|---------- 
put:1 - old s:equence numbers which have been acknowledged  
put:2 - seque:nce numbers of unacknowledged data            
put:3 - seque:nce numbers allowed for new data transmission 
put:4 - futur:e sequence numbers which are not yet allowed  
put:The send window: is the portion of the sequence space labeled 3 in
put:Receive Sequenc:e Space
put:1 - old s:equence numbers which have been acknowledged  
put:2 - seque:nce numbers allowed for new reception         
put:3 - futur:e sequence numbers which are not yet allowed  
put:The receive win:dow is the portion of the sequence space labeled 2 in
put:There are also :some variables used frequently in the discussion that
put:take their valu:es from the fields of the current segment.
put:[Page 20]        :                                                       
put:September 1981   :                                                       
put:Current Segme:nt Variables
put:SEG.SEQ - s:egment sequence number
put:SEG.ACK - s:egment acknowledgment number
put:SEG.LEN - s:egment length
put:SEG.WND - s:egment window
put:SEG.UP  - s:egment urgent pointer
put:SEG.PRC - s:egment precedence value
put:A connection pr:ogresses through a series of states during its
put:lifetime.  The :states are:  LISTEN, SYN-SENT, SYN-RECEIVED,
put:ESTABLISHED, FI:N-WAIT-1, FIN-WAIT-2, CLOSE-WAIT, CLOSING, LAST-ACK,
put:TIME-WAIT, and :the fictional state CLOSED.  CLOSED is fictional
put:because it repr:esents the state when there is no TCB, and therefore,
put:no connection. : Briefly the meanings of the states are:
put:LISTEN - repr:esents waiting for a connection request from any remote
put:TCP and port.:
put:SYN-SENT - re:presents waiting for a matching connection request
put:after having :sent a connection request.
put:SYN-RECEIVED :- represents waiting for a confirming connection
put:request ackno:wledgment after having both received and sent a
put:connection re:quest.
put:ESTABLISHED -: represents an open connection, data received can be
put:delivered to :the user.  The normal state for the data transfer phase
put:of the connec:tion.
put:FIN-WAIT-1 - :represents waiting for a connection termination request
put:from the remo:te TCP, or an acknowledgment of the connection
put:termination r:equest previously sent.
put:FIN-WAIT-2 - :represents waiting for a connection termination request
put:from the remo:te TCP.
put:CLOSE-WAIT - :represents waiting for a connection termination request
put:from the loca:l user.
put:CLOSING - rep:resents waiting for a connection termination request
put:acknowledgmen:t from the remote TCP.
put:LAST-ACK - re:presents waiting for an acknowledgment of the
put:connection te:rmination request previously sent to the remote TCP
put:(which includ:es an acknowledgment of its connection termination
put:Transmission Cont:rol Protocol
put:Functional Specif:ication
put:TIME-WAIT - r:epresents waiting for enough time to pass to be sure
put:the remote TC:P received the acknowledgment of its connection
put:termination r:equest.
put:CLOSED - repr:esents no connection state at all.
put:A TCP connectio:n progresses from one state to another in response to
put:events.  The ev:ents are the user calls, OPEN, SEND, RECEIVE, CLOSE,
put:ABORT, and STAT:US; the incoming segments, particularly those
put:containing the :SYN, ACK, RST and FIN flags; and timeouts.
put:The state diagr:am in figure 6 illustrates only state changes, together
put:with the causin:g events and resulting actions, but addresses neither
put:error condition:s nor actions which are not connected with state
put:changes.  In a :later section, more detail is offered with respect to
put:the reaction of: the TCP to events.
put:NOTE BENE:  thi:s diagram is only a summary and must not be taken as
put:the total speci:fication.
put:[Page 22]        :                                                       
put:September 1981   :                                                       
put:+---------+     : snd SYN,ACK  /       \   snd SYN          +---------+
put:|         |<----:-------------           ------------------>|         |
put:|   SYN   |     :               rcv SYN                     |   SYN   |
put:|   RCVD  |<----:-------------------------------------------|   SENT  |
put:|         |     :               snd ACK                     |         |
put:|         |-----:-------------           -------------------|         |
put:+---------+   rc:v ACK of SYN  \       /  rcv SYN,ACK       +---------+
put:|           --:------------   |     |   -----------                  
put:|             :     x         |     |     snd ACK                    
put:|             :               V     V                                
put:|  CLOSE      :             +---------+                              
put:| -------     :             |  ESTAB  |                              
put:| snd FIN     :             +---------+                              
put:|             :      CLOSE    |     |    rcv FIN                     
put:V             :     -------   |     |    -------                     
put:+---------+     :     snd FIN  /       \   snd ACK          +---------+
put:|  FIN    |<----:-------------           ------------------>|  CLOSE  |
put:| WAIT-1  |-----:-------------                              |   WAIT  |
put:+---------+     :     rcv FIN  \                            +---------+
put:| rcv ACK of F:IN   -------   |                            CLOSE  |  
put:| ------------:--   snd ACK   |                           ------- |  
put:V        x    :               V                           snd FIN V  
put:+---------+     :             +---------+                   +---------+
put:|FINWAIT-2|     :             | CLOSING |                   | LAST-ACK|
put:+---------+     :             +---------+                   +---------+
put:|             :   rcv ACK of FIN |                 rcv ACK of FIN |  
put:|  rcv FIN    :   -------------- |    Timeout=2MSL -------------- |  
put:|  -------    :          x       V    ------------        x       V  
put:\ snd ACK    :             +---------+delete TCB         +---------+
put:------------:------------>|TIME WAIT|------------------>| CLOSED  |
put:Transmission Cont:rol Protocol
put:Functional Specif:ication
put:3.3.  Sequence Nu:mbers
put:A fundamental n:otion in the design is that every octet of data sent
put:over a TCP conn:ection has a sequence number.  Since every octet is
put:sequenced, each: of them can be acknowledged.  The acknowledgment
put:mechanism emplo:yed is cumulative so that an acknowledgment of sequence
put:number X indica:tes that all octets up to but not including X have been
put:received.  This: mechanism allows for straight-forward duplicate
put:detection in th:e presence of retransmission.  Numbering of octets
put:within a segmen:t is that the first data octet immediately following
put:the header is t:he lowest numbered, and the following octets are
put:numbered consec:utively.
put:It is essential: to remember that the actual sequence number space is
put:finite, though :very large.  This space ranges from 0 to 2**32 - 1.
put:Since the space: is finite, all arithmetic dealing with sequence
put:numbers must be: performed modulo 2**32.  This unsigned arithmetic
put:preserves the r:elationship of sequence numbers as they cycle from
put:2**32 - 1 to 0 :again.  There are some subtleties to computer modulo
put:arithmetic, so :great care should be taken in programming the
put:comparison of s:uch values.  The symbol "=<" means "less than or equal"
put:(modulo 2**32).:
put:The typical kin:ds of sequence number comparisons which the TCP must
put:perform include::
put:(a)  Determin:ing that an acknowledgment refers to some sequence
put:number s:ent but not yet acknowledged.
put:(b)  Determin:ing that all sequence numbers occupied by a segment
put:have bee:n acknowledged (e.g., to remove the segment from a
put:retransm:ission queue).
put:(c)  Determin:ing that an incoming segment contains sequence numbers
put:which ar:e expected (i.e., that the segment "overlaps" the
put:receive :window).
put:[Page 24]        :                                                       
put:September 1981   :                                                       
put:In response to :sending data the TCP will receive acknowledgments.  The
put:following compa:risons are needed to process the acknowledgments.
put:SND.UNA = old:est unacknowledged sequence number
put:SND.NXT = nex:t sequence number to be sent
put:SEG.ACK = ack:nowledgment from the receiving TCP (next sequence
put:num:ber expected by the receiving TCP)
put:SEG.SEQ = fir:st sequence number of a segment
put:SEG.LEN = the: number of octets occupied by the data in the segment
put:(co:unting SYN and FIN)
put:SEG.SEQ+SEG.L:EN-1 = last sequence number of a segment
put:A new acknowled:gment (called an "acceptable ack"), is one for which
put:the inequality :below holds:
put:SND.UNA < SEG:.ACK =< SND.NXT
put:A segment on th:e retransmission queue is fully acknowledged if the sum
put:of its sequence: number and length is less or equal than the
put:acknowledgment :value in the incoming segment.
put:When data is re:ceived the following comparisons are needed:
put:RCV.NXT = nex:t sequence number expected on an incoming segments, and
put:is the le:ft or lower edge of the receive window
put:RCV.NXT+RCV.W:ND-1 = last sequence number expected on an incoming
put:segment, :and is the right or upper edge of the receive window
put:SEG.SEQ = fir:st sequence number occupied by the incoming segment
put:SEG.SEQ+SEG.L:EN-1 = last sequence number occupied by the incoming
put:A segment is ju:dged to occupy a portion of valid receive sequence
put:RCV.NXT =< SE:G.SEQ < RCV.NXT+RCV.WND
put:RCV.NXT =< SE:G.SEQ+SEG.LEN-1 < RCV.NXT+RCV.WND
put:Transmission Cont:rol Protocol
put:Functional Specif:ication
put:The first part :of this test checks to see if the beginning of the
put:segment falls i:n the window, the second part of the test checks to see
put:if the end of t:he segment falls in the window; if the segment passes
put:either part of :the test it contains data in the window.
put:Actually, it is: a little more complicated than this.  Due to zero
put:windows and zer:o length segments, we have four cases for the
put:acceptability o:f an incoming segment:
put:Segment Recei:ve  Test
put:Length  Windo:w
put:------- -----:--  -------------------------------------------
put:0       0 :    SEG.SEQ = RCV.NXT
put:0      >0 :    RCV.NXT =< SEG.SEQ < RCV.NXT+RCV.WND
put:>0       0 :    not acceptable
put:>0      >0 :    RCV.NXT =< SEG.SEQ < RCV.NXT+RCV.WND
put:Note that when :the receive window is zero no segments should be
put:acceptable exce:pt ACK segments.  Thus, it is be possible for a TCP to
put:maintain a zero: receive window while transmitting data and receiving
put:ACKs.  However,: even when the receive window is zero, a TCP must
put:process the RST: and URG fields of all incoming segments.
put:We have taken a:dvantage of the numbering scheme to protect certain
put:control informa:tion as well.  This is achieved by implicitly including
put:some control fl:ags in the sequence space so they can be retransmitted
put:and acknowledge:d without confusion (i.e., one and only one copy of the
put:control will be: acted upon).  Control information is not physically
put:carried in the :segment data space.  Consequently, we must adopt rules
put:for implicitly :assigning sequence numbers to control.  The SYN and FIN
put:are the only co:ntrols requiring this protection, and these controls
put:are used only a:t connection opening and closing.  For sequence number
put:purposes, the S:YN is considered to occur before the first actual data
put:octet of the se:gment in which it occurs, while the FIN is considered
put:to occur after :the last actual data octet in a segment in which it
put:occurs.  The se:gment length (SEG.LEN) includes both data and sequence
put:space occupying: controls.  When a SYN is present then SEG.SEQ is the
put:sequence number: of the SYN.
put:[Page 26]        :                                                       
put:September 1981   :                                                       
put:Initial Sequenc:e Number Selection
put:The protocol pl:aces no restriction on a particular connection being
put:used over and o:ver again.  A connection is defined by a pair of
put:sockets.  New i:nstances of a connection will be referred to as
put:incarnations of: the connection.  The problem that arises from this is
put:-- "how does th:e TCP identify duplicate segments from previous
put:incarnations of: the connection?"  This problem becomes apparent if the
put:connection is b:eing opened and closed in quick succession, or if the
put:connection brea:ks with loss of memory and is then reestablished.
put:To avoid confus:ion we must prevent segments from one incarnation of a
put:connection from: being used while the same sequence numbers may still
put:be present in t:he network from an earlier incarnation.  We want to
put:assure this, ev:en if a TCP crashes and loses all knowledge of the
put:sequence number:s it has been using.  When new connections are created,
put:an initial sequ:ence number (ISN) generator is employed which selects a
put:new 32 bit ISN.:  The generator is bound to a (possibly fictitious) 32
put:bit clock whose: low order bit is incremented roughly every 4
put:microseconds.  :Thus, the ISN cycles approximately every 4.55 hours.
put:Since we assume: that segments will stay in the network no more than
put:the Maximum Seg:ment Lifetime (MSL) and that the MSL is less than 4.55
put:hours we can re:asonably assume that ISN's will be unique.
put:For each connec:tion there is a send sequence number and a receive
put:sequence number:.  The initial send sequence number (ISS) is chosen by
put:the data sendin:g TCP, and the initial receive sequence number (IRS) is
put:learned during :the connection establishing procedure.
put:For a connectio:n to be established or initialized, the two TCPs must
put:synchronize on :each other's initial sequence numbers.  This is done in
put:an exchange of :connection establishing segments carrying a control bit
put:called "SYN" (f:or synchronize) and the initial sequence numbers.  As a
put:shorthand, segm:ents carrying the SYN bit are also called "SYNs".
put:Hence, the solu:tion requires a suitable mechanism for picking an
put:initial sequenc:e number and a slightly involved handshake to exchange
put:The synchroniza:tion requires each side to send it's own initial
put:sequence number: and to receive a confirmation of it in acknowledgment
put:from the other :side.  Each side must also receive the other side's
put:initial sequenc:e number and send a confirming acknowledgment.
put:1) A --> B  S:YN my sequence number is X
put:2) A <-- B  A:CK your sequence number is X
put:3) A <-- B  S:YN my sequence number is Y
put:4) A --> B  A:CK your sequence number is Y
put:Transmission Cont:rol Protocol
put:Functional Specif:ication
put:Because steps 2: and 3 can be combined in a single message this is
put:called the thre:e way (or three message) handshake.
put:A three way han:dshake is necessary because sequence numbers are not
put:tied to a globa:l clock in the network, and TCPs may have different
put:mechanisms for :picking the ISN's.  The receiver of the first SYN has
put:no way of knowi:ng whether the segment was an old delayed one or not,
put:unless it remem:bers the last sequence number used on the connection
put:(which is not a:lways possible), and so it must ask the sender to
put:verify this SYN:.  The three way handshake and the advantages of a
put:clock-driven sc:heme are discussed in [3].
put:Knowing When to: Keep Quiet
put:To be sure that: a TCP does not create a segment that carries a
put:sequence number: which may be duplicated by an old segment remaining in
put:the network, th:e TCP must keep quiet for a maximum segment lifetime
put:(MSL) before as:signing any sequence numbers upon starting up or
put:recovering from: a crash in which memory of sequence numbers in use was
put:lost.  For this: specification the MSL is taken to be 2 minutes.  This
put:is an engineeri:ng choice, and may be changed if experience indicates
put:it is desirable: to do so.  Note that if a TCP is reinitialized in some
put:sense, yet reta:ins its memory of sequence numbers in use, then it need
put:not wait at all:; it must only be sure to use sequence numbers larger
put:than those rece:ntly used.
put:The TCP Quiet T:ime Concept
put:This specific:ation provides that hosts which "crash" without
put:retaining any: knowledge of the last sequence numbers transmitted on
put:each active (:i.e., not closed) connection shall delay emitting any
put:TCP segments :for at least the agreed Maximum Segment Lifetime (MSL)
put:in the intern:et system of which the host is a part.  In the
put:paragraphs be:low, an explanation for this specification is given.
put:TCP implement:ors may violate the "quiet time" restriction, but only
put:at the risk o:f causing some old data to be accepted as new or new
put:data rejected: as old duplicated by some receivers in the internet
put:TCPs consume :sequence number space each time a segment is formed and
put:entered into :the network output queue at a source host. The
put:duplicate det:ection and sequencing algorithm in the TCP protocol
put:relies on the: unique binding of segment data to sequence space to
put:the extent th:at sequence numbers will not cycle through all 2**32
put:values before: the segment data bound to those sequence numbers has
put:been delivere:d and acknowledged by the receiver and all duplicate
put:copies of the: segments have "drained" from the internet.  Without
put:such an assum:ption, two distinct TCP segments could conceivably be
put:[Page 28]        :                                                       
put:September 1981   :                                                       
put:assigned the :same or overlapping sequence numbers, causing confusion
put:at the receiv:er as to which data is new and which is old.  Remember
put:that each seg:ment is bound to as many consecutive sequence numbers
put:as there are :octets of data in the segment.
put:Under normal :conditions, TCPs keep track of the next sequence number
put:to emit and t:he oldest awaiting acknowledgment so as to avoid
put:mistakenly us:ing a sequence number over before its first use has
put:been acknowle:dged.  This alone does not guarantee that old duplicate
put:data is drain:ed from the net, so the sequence space has been made
put:very large to: reduce the probability that a wandering duplicate will
put:cause trouble: upon arrival.  At 2 megabits/sec. it takes 4.5 hours
put:to use up 2**:32 octets of sequence space.  Since the maximum segment
put:lifetime in t:he net is not likely to exceed a few tens of seconds,
put:this is deeme:d ample protection for foreseeable nets, even if data
put:rates escalat:e to l0's of megabits/sec.  At 100 megabits/sec, the
put:cycle time is: 5.4 minutes which may be a little short, but still
put:within reason:.
put:The basic dup:licate detection and sequencing algorithm in TCP can be
put:defeated, how:ever, if a source TCP does not have any memory of the
put:sequence numb:ers it last used on a given connection. For example, if
put:the TCP were :to start all connections with sequence number 0, then
put:upon crashing: and restarting, a TCP might re-form an earlier
put:connection (p:ossibly after half-open connection resolution) and emit
put:packets with :sequence numbers identical to or overlapping with
put:packets still: in the network which were emitted on an earlier
put:incarnation o:f the same connection.  In the absence of knowledge
put:about the seq:uence numbers used on a particular connection, the TCP
put:specification: recommends that the source delay for MSL seconds
put:before emitti:ng segments on the connection, to allow time for
put:segments from: the earlier connection incarnation to drain from the
put:Even hosts wh:ich can remember the time of day and used it to select
put:initial seque:nce number values are not immune from this problem
put:(i.e., even i:f time of day is used to select an initial sequence
put:number for ea:ch new connection incarnation).
put:Suppose, for :example, that a connection is opened starting with
put:sequence numb:er S.  Suppose that this connection is not used much
put:and that even:tually the initial sequence number function (ISN(t))
put:takes on a va:lue equal to the sequence number, say S1, of the last
put:segment sent :by this TCP on a particular connection.  Now suppose,
put:at this insta:nt, the host crashes, recovers, and establishes a new
put:incarnation o:f the connection. The initial sequence number chosen is
put:S1 = ISN(t) -:- last used sequence number on old incarnation of
put:connection!  :If the recovery occurs quickly enough, any old
put:Transmission Cont:rol Protocol
put:Functional Specif:ication
put:duplicates in: the net bearing sequence numbers in the neighborhood
put:of S1 may arr:ive and be treated as new packets by the receiver of
put:the new incar:nation of the connection.
put:The problem i:s that the recovering host may not know for how long it
put:crashed nor d:oes it know whether there are still old duplicates in
put:the system fr:om earlier connection incarnations.
put:One way to de:al with this problem is to deliberately delay emitting
put:segments for :one MSL after recovery from a crash- this is the "quite
put:time" specifi:cation.  Hosts which prefer to avoid waiting are
put:willing to ri:sk possible confusion of old and new packets at a given
put:destination m:ay choose not to wait for the "quite time".
put:Implementors :may provide TCP users with the ability to select on a
put:connection by: connection basis whether to wait after a crash, or may
put:informally im:plement the "quite time" for all connections.
put:Obviously, ev:en where a user selects to "wait," this is not
put:necessary aft:er the host has been "up" for at least MSL seconds.
put:To summarize:: every segment emitted occupies one or more sequence
put:numbers in th:e sequence space, the numbers occupied by a segment are
put:"busy" or "in: use" until MSL seconds have passed, upon crashing a
put:block of spac:e-time is occupied by the octets of the last emitted
put:segment, if a: new connection is started too soon and uses any of the
put:sequence numb:ers in the space-time footprint of the last segment of
put:the previous :connection incarnation, there is a potential sequence
put:number overla:p area which could cause confusion at the receiver.
put:3.4.  Establishin:g a connection
put:The "three-way :handshake" is the procedure used to establish a
put:connection.  Th:is procedure normally is initiated by one TCP and
put:responded to by: another TCP.  The procedure also works if two TCP
put:simultaneously :initiate the procedure.  When simultaneous attempt
put:occurs, each TC:P receives a "SYN" segment which carries no
put:acknowledgment :after it has sent a "SYN".  Of course, the arrival of
put:an old duplicat:e "SYN" segment can potentially make it appear, to the
put:recipient, that: a simultaneous connection initiation is in progress.
put:Proper use of ":reset" segments can disambiguate these cases.
put:Several example:s of connection initiation follow.  Although these
put:examples do not: show connection synchronization using data-carrying
put:segments, this :is perfectly legitimate, so long as the receiving TCP
put:doesn't deliver: the data to the user until it is clear the data is
put:valid (i.e., th:e data must be buffered at the receiver until the
put:connection reac:hes the ESTABLISHED state).  The three-way handshake
put:reduces the pos:sibility of false connections.  It is the
put:[Page 30]        :                                                       
put:September 1981   :                                                       
put:implementation :of a trade-off between memory and messages to provide
put:information for: this checking.
put:The simplest th:ree-way handshake is shown in figure 7 below.  The
put:figures should :be interpreted in the following way.  Each line is
put:numbered for re:ference purposes.  Right arrows (-->) indicate
put:departure of a :TCP segment from TCP A to TCP B, or arrival of a
put:segment at B fr:om A.  Left arrows (<--), indicate the reverse.
put:Ellipsis (...) :indicates a segment which is still in the network
put:(delayed).  An :"XXX" indicates a segment which is lost or rejected.
put:Comments appear: in parentheses.  TCP states represent the state AFTER
put:the departure o:r arrival of the segment (whose contents are shown in
put:the center of e:ach line).  Segment contents are shown in abbreviated
put:form, with sequ:ence number, control flags, and ACK field.  Other
put:fields such as :window, addresses, lengths, and text have been left out
put:in the interest: of clarity.
put:TCP A      :                                          TCP B
put:1.  CLOSED     :                                          LISTEN
put:2.  SYN-SENT   : --> <SEQ=100><CTL=SYN>               --> SYN-RECEIVED
put:3.  ESTABLISHED: <-- <SEQ=300><ACK=101><CTL=SYN,ACK>  <-- SYN-RECEIVED
put:4.  ESTABLISHED: --> <SEQ=101><ACK=301><CTL=ACK>       --> ESTABLISHED
put:5.  ESTABLISHED: --> <SEQ=101><ACK=301><CTL=ACK><DATA> --> ESTABLISHED
put:Basic 3:-Way Handshake for Connection Synchronization
put:In line 2 of fi:gure 7, TCP A begins by sending a SYN segment
put:indicating that: it will use sequence numbers starting with sequence
put:number 100.  In: line 3, TCP B sends a SYN and acknowledges the SYN it
put:received from T:CP A.  Note that the acknowledgment field indicates TCP
put:B is now expect:ing to hear sequence 101, acknowledging the SYN which
put:occupied sequen:ce 100.
put:At line 4, TCP :A responds with an empty segment containing an ACK for
put:TCP B's SYN; an:d in line 5, TCP A sends some data.  Note that the
put:sequence number: of the segment in line 5 is the same as in line 4
put:because the ACK: does not occupy sequence number space (if it did, we
put:would wind up A:CKing ACK's!).
put:Transmission Cont:rol Protocol
put:Functional Specif:ication
put:Simultaneous in:itiation is only slightly more complex, as is shown in
put:figure 8.  Each: TCP cycles from CLOSED to SYN-SENT to SYN-RECEIVED to
put:TCP A      :                                      TCP B
put:1.  CLOSED     :                                      CLOSED
put:2.  SYN-SENT   :  --> <SEQ=100><CTL=SYN>              ...
put:3.  SYN-RECEIVE:D <-- <SEQ=300><CTL=SYN>              <-- SYN-SENT
put:4.             :  ... <SEQ=100><CTL=SYN>              --> SYN-RECEIVED
put:5.  SYN-RECEIVE:D --> <SEQ=100><ACK=301><CTL=SYN,ACK> ...
put:6.  ESTABLISHED:  <-- <SEQ=300><ACK=101><CTL=SYN,ACK> <-- SYN-RECEIVED
put:7.             :  ... <SEQ=101><ACK=301><CTL=ACK>     --> ESTABLISHED
put:S:imultaneous Connection Synchronization
put:The principle r:eason for the three-way handshake is to prevent old
put:duplicate conne:ction initiations from causing confusion.  To deal with
put:this, a special: control message, reset, has been devised.  If the
put:receiving TCP i:s in a  non-synchronized state (i.e., SYN-SENT,
put:SYN-RECEIVED), :it returns to LISTEN on receiving an acceptable reset.
put:If the TCP is i:n one of the synchronized states (ESTABLISHED,
put:FIN-WAIT-1, FIN:-WAIT-2, CLOSE-WAIT, CLOSING, LAST-ACK, TIME-WAIT), it
put:aborts the conn:ection and informs its user.  We discuss this latter
put:case under "hal:f-open" connections below.
put:[Page 32]        :                                                       
put:September 1981   :                                                       
put:TCP A      :                                          TCP B
put:1.  CLOSED     :                                          LISTEN
put:2.  SYN-SENT   : --> <SEQ=100><CTL=SYN>               ...
put:3.  (duplicate): ... <SEQ=90><CTL=SYN>               --> SYN-RECEIVED
put:4.  SYN-SENT   : <-- <SEQ=300><ACK=91><CTL=SYN,ACK>  <-- SYN-RECEIVED
put:5.  SYN-SENT   : --> <SEQ=91><CTL=RST>               --> LISTEN
put:6.             : ... <SEQ=100><CTL=SYN>               --> SYN-RECEIVED
put:7.  SYN-SENT   : <-- <SEQ=400><ACK=101><CTL=SYN,ACK>  <-- SYN-RECEIVED
put:8.  ESTABLISHED: --> <SEQ=101><ACK=401><CTL=ACK>      --> ESTABLISHED
put:As a simple exa:mple of recovery from old duplicates, consider
put:figure 9.  At l:ine 3, an old duplicate SYN arrives at TCP B.  TCP B
put:cannot tell tha:t this is an old duplicate, so it responds normally
put:(line 4).  TCP :A detects that the ACK field is incorrect and returns a
put:RST (reset) wit:h its SEQ field selected to make the segment
put:believable.  TC:P B, on receiving the RST, returns to the LISTEN state.
put:When the origin:al SYN (pun intended) finally arrives at line 6, the
put:synchronization: proceeds normally.  If the SYN at line 6 had arrived
put:before the RST,: a more complex exchange might have occurred with RST's
put:sent in both di:rections.
put:Half-Open Conne:ctions and Other Anomalies
put:An established :connection is said to be  "half-open" if one of the
put:TCPs has closed: or aborted the connection at its end without the
put:knowledge of th:e other, or if the two ends of the connection have
put:become desynchr:onized owing to a crash that resulted in loss of
put:memory.  Such c:onnections will automatically become reset if an
put:attempt is made: to send data in either direction.  However, half-open
put:connections are: expected to be unusual, and the recovery procedure is
put:mildly involved:.
put:If at site A th:e connection no longer exists, then an attempt by the
put:Transmission Cont:rol Protocol
put:Functional Specif:ication
put:user at site B :to send any data on it will result in the site B TCP
put:receiving a res:et control message.  Such a message indicates to the
put:site B TCP that: something is wrong, and it is expected to abort the
put:Assume that two: user processes A and B are communicating with one
put:another when a :crash occurs causing loss of memory to A's TCP.
put:Depending on th:e operating system supporting A's TCP, it is likely
put:that some error: recovery mechanism exists.  When the TCP is up again,
put:A is likely to :start again from the beginning or from a recovery
put:point.  As a re:sult, A will probably try to OPEN the connection again
put:or try to SEND :on the connection it believes open.  In the latter
put:case, it receiv:es the error message "connection not open" from the
put:local (A's) TCP:.  In an attempt to establish the connection, A's TCP
put:will send a seg:ment containing SYN.  This scenario leads to the
put:example shown i:n figure 10.  After TCP A crashes, the user attempts to
put:re-open the con:nection.  TCP B, in the meantime, thinks the connection
put:TCP A      :                                     TCP B
put:1.  (CRASH)    :                           (send 300,receive 100)
put:2.  CLOSED     :                                      ESTABLISHED
put:3.  SYN-SENT --:> <SEQ=400><CTL=SYN>              --> (??)
put:4.  (!!)     <-:- <SEQ=300><ACK=100><CTL=ACK>     <-- ESTABLISHED
put:5.  SYN-SENT --:> <SEQ=100><CTL=RST>              --> (Abort!!)
put:6.  SYN-SENT   :                                      CLOSED
put:7.  SYN-SENT --:> <SEQ=400><CTL=SYN>              -->
put:When the SYN ar:rives at line 3, TCP B, being in a synchronized state,
put:and the incomin:g segment outside the window, responds with an
put:acknowledgment :indicating what sequence it next expects to hear (ACK
put:100).  TCP A se:es that this segment does not acknowledge anything it
put:sent and, being: unsynchronized, sends a reset (RST) because it has
put:detected a half:-open connection.  TCP B aborts at line 5.  TCP A will
put:[Page 34]        :                                                       
put:September 1981   :                                                       
put:continue to try: to establish the connection; the problem is now
put:reduced to the :basic 3-way handshake of figure 7.
put:An interesting :alternative case occurs when TCP A crashes and TCP B
put:tries to send d:ata on what it thinks is a synchronized connection.
put:This is illustr:ated in figure 11.  In this case, the data arriving at
put:TCP A from TCP :B (line 2) is unacceptable because no such connection
put:exists, so TCP :A sends a RST.  The RST is acceptable so TCP B
put:processes it an:d aborts the connection.
put:TCP A    :                                          TCP B
put:1.  (CRASH)    :                               (send 300,receive 100)
put:2.  (??)    <--: <SEQ=300><ACK=100><DATA=10><CTL=ACK> <-- ESTABLISHED
put:3.          -->: <SEQ=100><CTL=RST>                   --> (ABORT!!)
put:Active: Side Causes Half-Open Connection Discovery
put:In figure 12, w:e find the two TCPs A and B with passive connections
put:waiting for SYN:.  An old duplicate arriving at TCP B (line 2) stirs B
put:into action.  A: SYN-ACK is returned (line 3) and causes TCP A to
put:generate a RST :(the ACK in line 3 is not acceptable).  TCP B accepts
put:the reset and r:eturns to its passive LISTEN state.
put:TCP A      :                                   TCP B
put:1.  LISTEN     :                                   LISTEN
put:2.       ... <S:EQ=Z><CTL=SYN>                -->  SYN-RECEIVED
put:3.  (??) <-- <S:EQ=X><ACK=Z+1><CTL=SYN,ACK>   <--  SYN-RECEIVED
put:4.       --> <S:EQ=Z+1><CTL=RST>              -->  (return to LISTEN!)
put:5.  LISTEN     :                                   LISTEN
put:Old Duplic:ate SYN Initiates a Reset on two Passive Sockets
put:Transmission Cont:rol Protocol
put:Functional Specif:ication
put:A variety of ot:her cases are possible, all of which are accounted for
put:by the followin:g rules for RST generation and processing.
put:Reset Generatio:n
put:As a general ru:le, reset (RST) must be sent whenever a segment arrives
put:which apparentl:y is not intended for the current connection.  A reset
put:must not be sen:t if it is not clear that this is the case.
put:There are three: groups of states:
put:1.  If the co:nnection does not exist (CLOSED) then a reset is sent
put:in response t:o any incoming segment except another reset.  In
put:particular, S:YNs addressed to a non-existent connection are rejected
put:by this means:.
put:If the incomi:ng segment has an ACK field, the reset takes its
put:sequence numb:er from the ACK field of the segment, otherwise the
put:reset has seq:uence number zero and the ACK field is set to the sum
put:of the sequen:ce number and segment length of the incoming segment.
put:The connectio:n remains in the CLOSED state.
put:2.  If the co:nnection is in any non-synchronized state (LISTEN,
put:SYN-SENT, SYN:-RECEIVED), and the incoming segment acknowledges
put:something not: yet sent (the segment carries an unacceptable ACK), or
put:if an incomin:g segment has a security level or compartment which
put:does not exac:tly match the level and compartment requested for the
put:connection, a: reset is sent.
put:If our SYN ha:s not been acknowledged and the precedence level of the
put:incoming segm:ent is higher than the precedence level requested then
put:either raise :the local precedence level (if allowed by the user and
put:the system) o:r send a reset; or if the precedence level of the
put:incoming segm:ent is lower than the precedence level requested then
put:continue as i:f the precedence matched exactly (if the remote TCP
put:cannot raise :the precedence level to match ours this will be
put:detected in t:he next segment it sends, and the connection will be
put:terminated th:en).  If our SYN has been acknowledged (perhaps in this
put:incoming segm:ent) the precedence level of the incoming segment must
put:match the loc:al precedence level exactly, if it does not a reset
put:must be sent.:
put:If the incomi:ng segment has an ACK field, the reset takes its
put:sequence numb:er from the ACK field of the segment, otherwise the
put:reset has seq:uence number zero and the ACK field is set to the sum
put:of the sequen:ce number and segment length of the incoming segment.
put:The connectio:n remains in the same state.
put:[Page 36]        :                                                       
put:September 1981   :                                                       
put:3.  If the co:nnection is in a synchronized state (ESTABLISHED,
put:FIN-WAIT-1, F:IN-WAIT-2, CLOSE-WAIT, CLOSING, LAST-ACK, TIME-WAIT),
put:any unaccepta:ble segment (out of window sequence number or
put:unacceptible :acknowledgment number) must elicit only an empty
put:acknowledgmen:t segment containing the current send-sequence number
put:and an acknow:ledgment indicating the next sequence number expected
put:to be receive:d, and the connection remains in the same state.
put:If an incomin:g segment has a security level, or compartment, or
put:precedence wh:ich does not exactly match the level, and compartment,
put:and precedenc:e requested for the connection,a reset is sent and
put:connection go:es to the CLOSED state.  The reset takes its sequence
put:number from t:he ACK field of the incoming segment.
put:Reset Processin:g
put:In all states e:xcept SYN-SENT, all reset (RST) segments are validated
put:by checking the:ir SEQ-fields.  A reset is valid if its sequence number
put:is in the windo:w.  In the SYN-SENT state (a RST received in response
put:to an initial S:YN), the RST is acceptable if the ACK field
put:acknowledges th:e SYN.
put:The receiver of: a RST first validates it, then changes state.  If the
put:receiver was in: the LISTEN state, it ignores it.  If the receiver was
put:in SYN-RECEIVED: state and had previously been in the LISTEN state,
put:then the receiv:er returns to the LISTEN state, otherwise the receiver
put:aborts the conn:ection and goes to the CLOSED state.  If the receiver
put:was in any othe:r state, it aborts the connection and advises the user
put:and goes to the: CLOSED state.
put:3.5.  Closing a C:onnection
put:CLOSE is an ope:ration meaning "I have no more data to send."  The
put:notion of closi:ng a full-duplex connection is subject to ambiguous
put:interpretation,: of course, since it may not be obvious how to treat
put:the receiving s:ide of the connection.  We have chosen to treat CLOSE
put:in a simplex fa:shion.  The user who CLOSEs may continue to RECEIVE
put:until he is tol:d that the other side has CLOSED also.  Thus, a program
put:could initiate :several SENDs followed by a CLOSE, and then continue to
put:RECEIVE until s:ignaled that a RECEIVE failed because the other side
put:has CLOSED.  We: assume that the TCP will signal a user, even if no
put:RECEIVEs are ou:tstanding, that the other side has closed, so the user
put:can terminate h:is side gracefully.  A TCP will reliably deliver all
put:buffers SENT be:fore the connection was CLOSED so a user who expects no
put:data in return :need only wait to hear the connection was CLOSED
put:successfully to: know that all his data was received at the destination
put:TCP.  Users mus:t keep reading connections they close for sending until
put:the TCP says no: more data.
put:Transmission Cont:rol Protocol
put:Functional Specif:ication
put:There are essen:tially three cases:
put:1) The user i:nitiates by telling the TCP to CLOSE the connection
put:2) The remote: TCP initiates by sending a FIN control signal
put:3) Both users: CLOSE simultaneously
put:Case 1:  Local :user initiates the close
put:In this case,: a FIN segment can be constructed and placed on the
put:outgoing segm:ent queue.  No further SENDs from the user will be
put:accepted by t:he TCP, and it enters the FIN-WAIT-1 state.  RECEIVEs
put:are allowed i:n this state.  All segments preceding and including FIN
put:will be retra:nsmitted until acknowledged.  When the other TCP has
put:both acknowle:dged the FIN and sent a FIN of its own, the first TCP
put:can ACK this :FIN.  Note that a TCP receiving a FIN will ACK but not
put:send its own :FIN until its user has CLOSED the connection also.
put:Case 2:  TCP re:ceives a FIN from the network
put:If an unsolic:ited FIN arrives from the network, the receiving TCP
put:can ACK it an:d tell the user that the connection is closing.  The
put:user will res:pond with a CLOSE, upon which the TCP can send a FIN to
put:the other TCP: after sending any remaining data.  The TCP then waits
put:until its own: FIN is acknowledged whereupon it deletes the
put:connection.  :If an ACK is not forthcoming, after the user timeout
put:the connectio:n is aborted and the user is told.
put:Case 3:  both u:sers close simultaneously
put:A simultaneou:s CLOSE by users at both ends of a connection causes
put:FIN segments :to be exchanged.  When all segments preceding the FINs
put:have been pro:cessed and acknowledged, each TCP can ACK the FIN it
put:has received.:  Both will, upon receiving these ACKs, delete the
put:[Page 38]        :                                                       
put:September 1981   :                                                       
put:TCP A      :                                          TCP B
put:1.  ESTABLISHED:                                          ESTABLISHED
put:FIN-WAIT-1 : --> <SEQ=100><ACK=300><CTL=FIN,ACK>  --> CLOSE-WAIT
put:3.  FIN-WAIT-2 : <-- <SEQ=300><ACK=101><CTL=ACK>      <-- CLOSE-WAIT
put:4.             :                                          (Close)
put:TIME-WAIT  : <-- <SEQ=300><ACK=101><CTL=FIN,ACK>  <-- LAST-ACK
put:5.  TIME-WAIT  : --> <SEQ=101><ACK=301><CTL=ACK>      --> CLOSED
put:CLOSED     :                                                 
put:TCP A      :                                          TCP B
put:1.  ESTABLISHED:                                          ESTABLISHED
put:2.  (Close)    :                                          (Close)
put:FIN-WAIT-1 : --> <SEQ=100><ACK=300><CTL=FIN,ACK>  ... FIN-WAIT-1
put:3.  CLOSING    : --> <SEQ=101><ACK=301><CTL=ACK>      ... CLOSING
put:4.  TIME-WAIT  :                                          TIME-WAIT
put:(2 MSL)    :                                          (2 MSL)
put:CLOSED     :                                          CLOSED
put:Transmission Cont:rol Protocol
put:Functional Specif:ication
put:3.6.  Precedence :and Security
put:The intent is t:hat connection be allowed only between ports operating
put:with exactly th:e same security and compartment values and at the
put:higher of the p:recedence level requested by the two ports.
put:The precedence :and security parameters used in TCP are exactly those
put:defined in the :Internet Protocol (IP) [2].  Throughout this TCP
put:specification t:he term "security/compartment" is intended to indicate
put:the security pa:rameters used in IP including security, compartment,
put:user group, and: handling restriction.
put:A connection at:tempt with mismatched security/compartment values or a
put:lower precedenc:e value must be rejected by sending a reset.  Rejecting
put:a connection du:e to too low a precedence only occurs after an
put:acknowledgment :of the SYN has been received.
put:Note that TCP m:odules which operate only at the default value of
put:precedence will: still have to check the precedence of incoming
put:segments and po:ssibly raise the precedence level they use on the
put:The security pa:ramaters may be used even in a non-secure environment
put:(the values wou:ld indicate unclassified data), thus hosts in
put:non-secure envi:ronments must be prepared to receive the security
put:parameters, tho:ugh they need not send them.
put:3.7.  Data Commun:ication
put:Once the connec:tion is established data is communicated by the
put:exchange of seg:ments.  Because segments may be lost due to errors
put:(checksum test :failure), or network congestion, TCP uses
put:retransmission :(after a timeout) to ensure delivery of every segment.
put:Duplicate segme:nts may arrive due to network or TCP retransmission.
put:As discussed in: the section on sequence numbers the TCP performs
put:certain tests o:n the sequence and acknowledgment numbers in the
put:segments to ver:ify their acceptability.
put:The sender of d:ata keeps track of the next sequence number to use in
put:the variable SN:D.NXT.  The receiver of data keeps track of the next
put:sequence number: to expect in the variable RCV.NXT.  The sender of data
put:keeps track of :the oldest unacknowledged sequence number in the
put:variable SND.UN:A.  If the data flow is momentarily idle and all data
put:sent has been a:cknowledged then the three variables will be equal.
put:When the sender: creates a segment and transmits it the sender advances
put:SND.NXT.  When :the receiver accepts a segment it advances RCV.NXT and
put:sends an acknow:ledgment.  When the data sender receives an
put:[Page 40]        :                                                       
put:September 1981   :                                                       
put:acknowledgment :it advances SND.UNA.  The extent to which the values of
put:these variables: differ is a measure of the delay in the communication.
put:The amount by w:hich the variables are advanced is the length of the
put:data in the seg:ment.  Note that once in the ESTABLISHED state all
put:segments must c:arry current acknowledgment information.
put:The CLOSE user :call implies a push function, as does the FIN control
put:flag in an inco:ming segment.
put:Retransmission :Timeout
put:Because of the :variability of the networks that compose an
put:internetwork sy:stem and the wide range of uses of TCP connections the
put:retransmission :timeout must be dynamically determined.  One procedure
put:for determining: a retransmission time out is given here as an
put:An Example Re:transmission Timeout Procedure
put:Measure the: elapsed time between sending a data octet with a
put:particular :sequence number and receiving an acknowledgment that
put:covers that: sequence number (segments sent do not have to match
put:segments re:ceived).  This measured elapsed time is the Round Trip
put:Time (RTT).:  Next compute a Smoothed Round Trip Time (SRTT) as:
put:SRTT = ( :ALPHA * SRTT ) + ((1-ALPHA) * RTT)
put:and based o:n this, compute the retransmission timeout (RTO) as:
put:RTO = min:[UBOUND,max[LBOUND,(BETA*SRTT)]]
put:where UBOUN:D is an upper bound on the timeout (e.g., 1 minute),
put:LBOUND is a: lower bound on the timeout (e.g., 1 second), ALPHA is
put:a smoothing: factor (e.g., .8 to .9), and BETA is a delay variance
put:factor (e.g:., 1.3 to 2.0).
put:The Communicati:on of Urgent Information
put:The objective o:f the TCP urgent mechanism is to allow the sending user
put:to stimulate th:e receiving user to accept some urgent data and to
put:permit the rece:iving TCP to indicate to the receiving user when all
put:the currently k:nown urgent data has been received by the user.
put:This mechanism :permits a point in the data stream to be designated as
put:the end of urge:nt information.  Whenever this point is in advance of
put:the receive seq:uence number (RCV.NXT) at the receiving TCP, that TCP
put:must tell the u:ser to go into "urgent mode"; when the receive sequence
put:number catches :up to the urgent pointer, the TCP must tell user to go
put:Transmission Cont:rol Protocol
put:Functional Specif:ication
put:into "normal mo:de".  If the urgent pointer is updated while the user
put:is in "urgent m:ode", the update will be invisible to the user.
put:The method empl:oys a urgent field which is carried in all segments
put:transmitted.  T:he URG control flag indicates that the urgent field is
put:meaningful and :must be added to the segment sequence number to yield
put:the urgent poin:ter.  The absence of this flag indicates that there is
put:no urgent data :outstanding.
put:To send an urge:nt indication the user must also send at least one data
put:octet.  If the :sending user also indicates a push, timely delivery of
put:the urgent info:rmation to the destination process is enhanced.
put:Managing the Wi:ndow
put:The window sent: in each segment indicates the range of sequence
put:numbers the sen:der of the window (the data receiver) is currently
put:prepared to acc:ept.  There is an assumption that this is related to
put:the currently a:vailable data buffer space available for this
put:Indicating a la:rge window encourages transmissions.  If more data
put:arrives than ca:n be accepted, it will be discarded.  This will result
put:in excessive re:transmissions, adding unnecessarily to the load on the
put:network and the: TCPs.  Indicating a small window may restrict the
put:transmission of: data to the point of introducing a round trip delay
put:between each ne:w segment transmitted.
put:The mechanisms :provided allow a TCP to advertise a large window and to
put:subsequently ad:vertise a much smaller window without having accepted
put:that much data.:  This, so called "shrinking the window," is strongly
put:discouraged.  T:he robustness principle dictates that TCPs will not
put:shrink the wind:ow themselves, but will be prepared for such behavior
put:on the part of :other TCPs.
put:The sending TCP: must be prepared to accept from the user and send at
put:least one octet: of new data even if the send window is zero.  The
put:sending TCP mus:t regularly retransmit to the receiving TCP even when
put:the window is z:ero.  Two minutes is recommended for the retransmission
put:interval when t:he window is zero.  This retransmission is essential to
put:guarantee that :when either TCP has a zero window the re-opening of the
put:window will be :reliably reported to the other.
put:When the receiv:ing TCP has a zero window and a segment arrives it must
put:still send an a:cknowledgment showing its next expected sequence number
put:and current win:dow (zero).
put:The sending TCP: packages the data to be transmitted into segments
put:[Page 42]        :                                                       
put:September 1981   :                                                       
put:which fit the c:urrent window, and may repackage segments on the
put:retransmission :queue.  Such repackaging is not required, but may be
put:In a connection: with a one-way data flow, the window information will
put:be carried in a:cknowledgment segments that all have the same sequence
put:number so there: will be no way to reorder them if they arrive out of
put:order.  This is: not a serious problem, but it will allow the window
put:information to :be on occasion temporarily based on old reports from
put:the data receiv:er.  A refinement to avoid this problem is to act on
put:the window info:rmation from segments that carry the highest
put:acknowledgment :number (that is segments with acknowledgment number
put:equal or greate:r than the highest previously received).
put:The window mana:gement procedure has significant influence on the
put:communication p:erformance.  The following comments are suggestions to
put:Window Manage:ment Suggestions
put:Allocating :a very small window causes data to be transmitted in
put:many small :segments when better performance is achieved using
put:fewer large: segments.
put:One suggest:ion for avoiding small windows is for the receiver to
put:defer updat:ing a window until the additional allocation is at
put:least X per:cent of the maximum allocation possible for the
put:connection :(where X might be 20 to 40).
put:Another sug:gestion is for the sender to avoid sending small
put:segments by: waiting until the window is large enough before
put:sending dat:a.  If the the user signals a push function then the
put:data must b:e sent even if it is a small segment.
put:Note that t:he acknowledgments should not be delayed or unnecessary
put:retransmiss:ions will result.  One strategy would be to send an
put:acknowledgm:ent when a small segment arrives (with out updating the
put:window info:rmation), and then to send another acknowledgment with
put:new window :information when the window is larger.
put:The segment: sent to probe a zero window may also begin a break up
put:of transmit:ted data into smaller and smaller segments.  If a
put:segment con:taining a single data octet sent to probe a zero window
put:is accepted:, it consumes one octet of the window now available.
put:If the send:ing TCP simply sends as much as it can whenever the
put:window is n:on zero, the transmitted data will be broken into
put:alternating: big and small segments.  As time goes on, occasional
put:pauses in t:he receiver making window allocation available will
put:Transmission Cont:rol Protocol
put:Functional Specif:ication
put:result in b:reaking the big segments into a small and not quite so
put:big pair. A:nd after a while the data transmission will be in
put:mostly smal:l segments.
put:The suggest:ion here is that the TCP implementations need to
put:actively at:tempt to combine small window allocations into larger
put:windows, si:nce the mechanisms for managing the window tend to lead
put:to many sma:ll windows in the simplest minded implementations.
put:There are of co:urse two interfaces of concern:  the user/TCP interface
put:and the TCP/low:er-level interface.  We have a fairly elaborate model
put:of the user/TCP: interface, but the interface to the lower level
put:protocol module: is left unspecified here, since it will be specified
put:in detail by th:e specification of the lowel level protocol.  For the
put:case that the l:ower level is IP we note some of the parameter values
put:that TCPs might: use.
put:User/TCP Interf:ace
put:The following: functional description of user commands to the TCP is,
put:at best, fict:ional, since every operating system will have different
put:facilities.  :Consequently, we must warn readers that different TCP
put:implementatio:ns may have different user interfaces.  However, all
put:TCPs must pro:vide a certain minimum set of services to guarantee
put:that all TCP :implementations can support the same protocol
put:hierarchy.  T:his section specifies the functional interfaces
put:required of a:ll TCP implementations.
put:TCP User Comm:ands
put:The followi:ng sections functionally characterize a USER/TCP
put:interface. : The notation used is similar to most procedure or
put:function ca:lls in high level languages, but this usage is not
put:meant to ru:le out trap type service calls (e.g., SVCs, UUOs,
put:The user co:mmands described below specify the basic functions the
put:TCP must pe:rform to support interprocess communication.
put:Individual :implementations must define their own exact format, and
put:may provide: combinations or subsets of the basic functions in
put:single call:s.  In particular, some implementations may wish to
put:automatical:ly OPEN a connection on the first SEND or RECEIVE
put:issued by t:he user for a given connection.
put:[Page 44]        :                                                       
put:September 1981   :                                                       
put:In providin:g interprocess communication facilities, the TCP must
put:not only ac:cept commands, but must also return information to the
put:processes i:t serves.  The latter consists of:
put:(a) gener:al information about a connection (e.g., interrupts,
put:remote cl:ose, binding of unspecified foreign socket).
put:(b) repli:es to specific user commands indicating success or
put:various t:ypes of failure.
put:Format:  :OPEN (local port, foreign socket, active/passive
put:[, timeou:t] [, precedence] [, security/compartment] [, options])
put:-> local :connection name
put:We assume: that the local TCP is aware of the identity of the
put:processes: it serves and will check the authority of the process
put:to use th:e connection specified.  Depending upon the
put:implement:ation of the TCP, the local network and TCP identifiers
put:for the s:ource address will either be supplied by the TCP or the
put:lower lev:el protocol (e.g., IP).  These considerations are the
put:result of: concern about security, to the extent that no TCP be
put:able to m:asquerade as another one, and so on.  Similarly, no
put:process c:an masquerade as another without the collusion of the
put:If the ac:tive/passive flag is set to passive, then this is a
put:call to L:ISTEN for an incoming connection.  A passive open may
put:have eith:er a fully specified foreign socket to wait for a
put:particula:r connection or an unspecified foreign socket to wait
put:for any c:all.  A fully specified passive call can be made active
put:by the su:bsequent execution of a SEND.
put:A transmi:ssion control block (TCB) is created and partially
put:filled in: with data from the OPEN command parameters.
put:On an act:ive OPEN command, the TCP will begin the procedure to
put:synchroni:ze (i.e., establish) the connection at once.
put:The timeo:ut, if present, permits the caller to set up a timeout
put:for all d:ata submitted to TCP.  If data is not successfully
put:delivered: to the destination within the timeout period, the TCP
put:will abor:t the connection.  The present global default is five
put:The TCP o:r some component of the operating system will verify
put:the users: authority to open a connection with the specified
put:Transmission Cont:rol Protocol
put:Functional Specif:ication
put:precedenc:e or security/compartment.  The absence of precedence
put:or securi:ty/compartment specification in the OPEN call indicates
put:the defau:lt values must be used.
put:TCP will :accept incoming requests as matching only if the
put:security/:compartment information is exactly the same and only if
put:the prece:dence is equal to or higher than the precedence
put:requested: in the OPEN call.
put:The prece:dence for the connection is the higher of the values
put:requested: in the OPEN call and received from the incoming
put:request, :and fixed at that value for the life of the
put:connectio:n.Implementers may want to give the user control of
put:this prec:edence negotiation.  For example, the user might be
put:allowed t:o specify that the precedence must be exactly matched,
put:or that a:ny attempt to raise the precedence be confirmed by the
put:A local c:onnection name will be returned to the user by the TCP.
put:The local: connection name can then be used as a short hand term
put:for the c:onnection defined by the <local socket, foreign socket>
put:Format:  :SEND (local connection name, buffer address, byte
put:count, PU:SH flag, URGENT flag [,timeout])
put:This call: causes the data contained in the indicated user buffer
put:to be sen:t on the indicated connection.  If the connection has
put:not been :opened, the SEND is considered an error.  Some
put:implement:ations may allow users to SEND first; in which case, an
put:automatic: OPEN would be done.  If the calling process is not
put:authorize:d to use this connection, an error is returned.
put:If the PU:SH flag is set, the data must be transmitted promptly
put:to the re:ceiver, and the PUSH bit will be set in the last TCP
put:segment c:reated from the buffer.  If the PUSH flag is not set,
put:the data :may be combined with data from subsequent SENDs for
put:transmiss:ion efficiency.
put:If the UR:GENT flag is set, segments sent to the destination TCP
put:will have: the urgent pointer set.  The receiving TCP will signal
put:the urgen:t condition to the receiving process if the urgent
put:pointer i:ndicates that data preceding the urgent pointer has not
put:been cons:umed by the receiving process.  The purpose of urgent
put:is to sti:mulate the receiver to process the urgent data and to
put:indicate :to the receiver when all the currently known urgent
put:[Page 46]        :                                                       
put:September 1981   :                                                       
put:data has :been received.  The number of times the sending user's
put:TCP signa:ls urgent will not necessarily be equal to the number
put:of times :the receiving user will be notified of the presence of
put:urgent da:ta.
put:If no for:eign socket was specified in the OPEN, but the
put:connectio:n is established (e.g., because a LISTENing connection
put:has becom:e specific due to a foreign segment arriving for the
put:local soc:ket), then the designated buffer is sent to the implied
put:foreign s:ocket.  Users who make use of OPEN with an unspecified
put:foreign s:ocket can make use of SEND without ever explicitly
put:knowing t:he foreign socket address.
put:However, :if a SEND is attempted before the foreign socket
put:becomes s:pecified, an error will be returned.  Users can use the
put:STATUS ca:ll to determine the status of the connection.  In some
put:implement:ations the TCP may notify the user when an unspecified
put:socket is: bound.
put:If a time:out is specified, the current user timeout for this
put:connectio:n is changed to the new one.
put:In the si:mplest implementation, SEND would not return control to
put:the sendi:ng process until either the transmission was complete
put:or the ti:meout had been exceeded.  However, this simple method
put:is both s:ubject to deadlocks (for example, both sides of the
put:connectio:n might try to do SENDs before doing any RECEIVEs) and
put:offers po:or performance, so it is not recommended.  A more
put:sophistic:ated implementation would return immediately to allow
put:the proce:ss to run concurrently with network I/O, and,
put:furthermo:re, to allow multiple SENDs to be in progress.
put:Multiple :SENDs are served in first come, first served order, so
put:the TCP w:ill queue those it cannot service immediately.
put:We have i:mplicitly assumed an asynchronous user interface in
put:which a S:END later elicits some kind of SIGNAL or
put:pseudo-in:terrupt from the serving TCP.  An alternative is to
put:return a :response immediately.  For instance, SENDs might return
put:immediate: local acknowledgment, even if the segment sent had not
put:been ackn:owledged by the distant TCP.  We could optimistically
put:assume ev:entual success.  If we are wrong, the connection will
put:close any:way due to the timeout.  In implementations of this
put:kind (syn:chronous), there will still be some asynchronous
put:signals, :but these will deal with the connection itself, and not
put:with spec:ific segments or buffers.
put:In order :for the process to distinguish among error or success
put:indicatio:ns for different SENDs, it might be appropriate for the
put:Transmission Cont:rol Protocol
put:Functional Specif:ication
put:buffer ad:dress to be returned along with the coded response to
put:the SEND :request.  TCP-to-user signals are discussed below,
put:indicatin:g the information which should be returned to the
put:calling p:rocess.
put:Format:  :RECEIVE (local connection name, buffer address, byte
put:count) ->: byte count, urgent flag, push flag
put:This comm:and allocates a receiving buffer associated with the
put:specified: connection.  If no OPEN precedes this command or the
put:calling p:rocess is not authorized to use this connection, an
put:error is :returned.
put:In the si:mplest implementation, control would not return to the
put:calling p:rogram until either the buffer was filled, or some
put:error occ:urred, but this scheme is highly subject to deadlocks.
put:A more so:phisticated implementation would permit several
put:RECEIVEs :to be outstanding at once.  These would be filled as
put:segments :arrive.  This strategy permits increased throughput at
put:the cost :of a more elaborate scheme (possibly asynchronous) to
put:notify th:e calling program that a PUSH has been seen or a buffer
put:If enough: data arrive to fill the buffer before a PUSH is seen,
put:the PUSH :flag will not be set in the response to the RECEIVE.
put:The buffe:r will be filled with as much data as it can hold.  If
put:a PUSH is: seen before the buffer is filled the buffer will be
put:returned :partially filled and PUSH indicated.
put:If there :is urgent data the user will have been informed as soon
put:as it arr:ived via a TCP-to-user signal.  The receiving user
put:should th:us be in "urgent mode".  If the URGENT flag is on,
put:additiona:l urgent data remains.  If the URGENT flag is off, this
put:call to R:ECEIVE has returned all the urgent data, and the user
put:may now l:eave "urgent mode".  Note that data following the
put:urgent po:inter (non-urgent data) cannot be delivered to the user
put:in the sa:me buffer with preceeding urgent data unless the
put:boundary :is clearly marked for the user.
put:To distin:guish among several outstanding RECEIVEs and to take
put:care of t:he case that a buffer is not completely filled, the
put:return co:de is accompanied by both a buffer pointer and a byte
put:count ind:icating the actual length of the data received.
put:Alternati:ve implementations of RECEIVE might have the TCP
put:[Page 48]        :                                                       
put:September 1981   :                                                       
put:allocate :buffer storage, or the TCP might share a ring buffer
put:with the :user.
put:Format:  :CLOSE (local connection name)
put:This comm:and causes the connection specified to be closed.  If
put:the conne:ction is not open or the calling process is not
put:authorize:d to use this connection, an error is returned.
put:Closing c:onnections is intended to be a graceful operation in
put:the sense: that outstanding SENDs will be transmitted (and
put:retransmi:tted), as flow control permits, until all have been
put:serviced.:  Thus, it should be acceptable to make several SEND
put:calls, fo:llowed by a CLOSE, and expect all the data to be sent
put:to the de:stination.  It should also be clear that users should
put:continue :to RECEIVE on CLOSING connections, since the other side
put:may be tr:ying to transmit the last of its data.  Thus, CLOSE
put:means "I :have no more to send" but does not mean "I will not
put:receive a:ny more."  It may happen (if the user level protocol is
put:not well :thought out) that the closing side is unable to get rid
put:of all it:s data before timing out.  In this event, CLOSE turns
put:into ABOR:T, and the closing TCP gives up.
put:The user :may CLOSE the connection at any time on his own
put:initiativ:e, or in response to various prompts from the TCP
put:(e.g., re:mote close executed, transmission timeout exceeded,
put:destinati:on inaccessible).
put:Because c:losing a connection requires communication with the
put:foreign T:CP, connections may remain in the closing state for a
put:short tim:e.  Attempts to reopen the connection before the TCP
put:replies t:o the CLOSE command will result in error responses.
put:Close als:o implies push function.
put:Format:  :STATUS (local connection name) -> status data
put:This is a:n implementation dependent user command and could be
put:excluded :without adverse effect.  Information returned would
put:typically: come from the TCB associated with the connection.
put:This comm:and returns a data block containing the following
put:informati:on:
put:local s:ocket,
put:Transmission Cont:rol Protocol
put:Functional Specif:ication
put:foreign: socket,
put:local c:onnection name,
put:receive: window,
put:send wi:ndow,
put:connect:ion state,
put:number :of buffers awaiting acknowledgment,
put:number :of buffers pending receipt,
put:urgent :state,
put:precede:nce,
put:securit:y/compartment,
put:and tra:nsmission timeout.
put:Depending: on the state of the connection, or on the
put:implement:ation itself, some of this information may not be
put:available: or meaningful.  If the calling process is not
put:authorize:d to use this connection, an error is returned.  This
put:prevents :unauthorized processes from gaining information about a
put:connectio:n.
put:Format:  :ABORT (local connection name)
put:This comm:and causes all pending SENDs and RECEIVES to be
put:aborted, :the TCB to be removed, and a special RESET message to
put:be sent t:o the TCP on the other side of the connection.
put:Depending: on the implementation, users may receive abort
put:indicatio:ns for each outstanding SEND or RECEIVE, or may simply
put:receive a:n ABORT-acknowledgment.
put:TCP-to-User M:essages
put:It is assum:ed that the operating system environment provides a
put:means for t:he TCP to asynchronously signal the user program.  When
put:the TCP doe:s signal a user program, certain information is passed
put:to the user:.  Often in the specification the information will be
put:an error me:ssage.  In other cases there will be information
put:relating to: the completion of processing a SEND or RECEIVE or
put:other user :call.
put:The followi:ng information is provided:
put:Local Con:nection Name                    Always
put:Response :String                          Always
put:Buffer Ad:dress                           Send & Receive
put:Byte coun:t (counts bytes received)       Receive
put:Push flag:                                Receive
put:Urgent fl:ag                              Receive
put:[Page 50]        :                                                       
put:September 1981   :                                                       
put:TCP/Lower-Level: Interface
put:The TCP calls: on a lower level protocol module to actually send and
put:receive infor:mation over a network.  One case is that of the ARPA
put:internetwork :system where the lower level module is the Internet
put:Protocol (IP): [2].
put:If the lower :level protocol is IP it provides arguments for a type
put:of service an:d for a time to live.  TCP uses the following settings
put:for these par:ameters:
put:Type of Ser:vice = Precedence: routine, Delay: normal, Throughput:
put:normal, Rel:iability: normal; or 00000000.
put:Time to Liv:e    = one minute, or 00111100.
put:Note that: the assumed maximum segment lifetime is two minutes.
put:Here we e:xplicitly ask that a segment be destroyed if it cannot
put:be delive:red by the internet system within one minute.
put:If the lower :level is IP (or other protocol that provides this
put:feature) and :source routing is used, the interface must allow the
put:route informa:tion to be communicated.  This is especially important
put:so that the s:ource and destination addresses used in the TCP
put:checksum be t:he originating source and ultimate destination. It is
put:also importan:t to preserve the return route to answer connection
put:Any lower lev:el protocol will have to provide the source address,
put:destination a:ddress, and protocol fields, and some way to determine
put:the "TCP leng:th", both to provide the functional equivlent service
put:of IP and to :be used in the TCP checksum.
put:Transmission Cont:rol Protocol
put:Functional Specif:ication
put:3.9.  Event Proce:ssing
put:The processing :depicted in this section is an example of one possible
put:implementation.:  Other implementations may have slightly different
put:processing sequ:ences, but they should differ from those in this
put:section only in: detail, not in substance.
put:The activity of: the TCP can be characterized as responding to events.
put:The events that: occur can be cast into three categories:  user calls,
put:arriving segmen:ts, and timeouts.  This section describes the
put:processing the :TCP does in response to each of the events.  In many
put:cases the proce:ssing required depends on the state of the connection.
put:Events that o:ccur:
put:Arriving Se:gments
put:SEGMENT A:RRIVES
put:USER TIME:OUT
put:RETRANSMI:SSION TIMEOUT
put:TIME-WAIT: TIMEOUT
put:The model of th:e TCP/user interface is that user commands receive an
put:immediate retur:n and possibly a delayed response via an event or
put:pseudo interrup:t.  In the following descriptions, the term "signal"
put:means cause a d:elayed response.
put:Error responses: are given as character strings.  For example, user
put:commands refere:ncing connections that do not exist receive "error:
put:connection not :open".
put:Please note in :the following that all arithmetic on sequence numbers,
put:acknowledgment :numbers, windows, et cetera, is modulo 2**32 the size
put:of the sequence: number space.  Also note that "=<" means less than or
put:equal to (modul:o 2**32).
put:[Page 52]        :                                                       
put:September 1981   :                                                       
put:A natural way t:o think about processing incoming segments is to
put:imagine that th:ey are first tested for proper sequence number (i.e.,
put:that their cont:ents lie in the range of the expected "receive window"
put:in the sequence: number space) and then that they are generally queued
put:and processed i:n sequence number order.
put:When a segment :overlaps other already received segments we reconstruct
put:the segment to :contain just the new data, and adjust the header fields
put:to be consisten:t.
put:Note that if no: state change is mentioned the TCP stays in the same
put:Transmission Cont:rol Protocol
put:Functional Specif:ication
put:CLOSED STATE :(i.e., TCB does not exist)
put:Create a ne:w transmission control block (TCB) to hold connection
put:state infor:mation.  Fill in local socket identifier, foreign
put:socket, pre:cedence, security/compartment, and user timeout
put:information:.  Note that some parts of the foreign socket may be
put:unspecified: in a passive OPEN and are to be filled in by the
put:parameters :of the incoming SYN segment.  Verify the security and
put:precedence :requested are allowed for this user, if not return
put:"error:  pr:ecedence not allowed" or "error:  security/compartment
put:not allowed:."  If passive enter the LISTEN state and return.  If
put:active and :the foreign socket is unspecified, return "error:
put:foreign soc:ket unspecified"; if active and the foreign socket is
put:specified, :issue a SYN segment.  An initial send sequence number
put:(ISS) is se:lected.  A SYN segment of the form <SEQ=ISS><CTL=SYN>
put:is sent.  S:et SND.UNA to ISS, SND.NXT to ISS+1, enter SYN-SENT
put:state, and :return.
put:If the call:er does not have access to the local socket specified,
put:return "err:or:  connection illegal for this process".  If there is
put:no room to :create a new connection, return "error:  insufficient
put:resources".:
put:If active a:nd the foreign socket is specified, then change the
put:connection :from passive to active, select an ISS.  Send a SYN
put:segment, se:t SND.UNA to ISS, SND.NXT to ISS+1.  Enter SYN-SENT
put:state.  Dat:a associated with SEND may be sent with SYN segment or
put:queued for :transmission after entering ESTABLISHED state.  The
put:urgent bit :if requested in the command must be sent with the data
put:segments se:nt as a result of this command.  If there is no room to
put:queue the r:equest, respond with "error:  insufficient resources".
put:If Foreign :socket was not specified, then return "error:  foreign
put:socket unsp:ecified".
put:[Page 54]        :                                                       
put:September 1981   :                                                       
put:SYN-SENT STAT:E
put:SYN-RECEIVED :STATE
put:ESTABLISHED S:TATE
put:FIN-WAIT-1 ST:ATE
put:FIN-WAIT-2 ST:ATE
put:CLOSE-WAIT ST:ATE
put:CLOSING STATE:
put:LAST-ACK STAT:E
put:TIME-WAIT STA:TE
put:Return "err:or:  connection already exists".
put:Transmission Cont:rol Protocol
put:Functional Specif:ication
put:CLOSED STATE :(i.e., TCB does not exist)
put:If the user: does not have access to such a connection, then return
put:"error:  co:nnection illegal for this process".
put:Otherwise, :return "error:  connection does not exist".
put:If the fore:ign socket is specified, then change the connection
put:from passiv:e to active, select an ISS.  Send a SYN segment, set
put:SND.UNA to :ISS, SND.NXT to ISS+1.  Enter SYN-SENT state.  Data
put:associated :with SEND may be sent with SYN segment or queued for
put:transmissio:n after entering ESTABLISHED state.  The urgent bit if
put:requested i:n the command must be sent with the data segments sent
put:as a result: of this command.  If there is no room to queue the
put:request, re:spond with "error:  insufficient resources".  If
put:Foreign soc:ket was not specified, then return "error:  foreign
put:socket unsp:ecified".
put:SYN-SENT STAT:E
put:SYN-RECEIVED :STATE
put:Queue the d:ata for transmission after entering ESTABLISHED state.
put:If no space: to queue, respond with "error:  insufficient
put:resources".:
put:ESTABLISHED S:TATE
put:CLOSE-WAIT ST:ATE
put:Segmentize :the buffer and send it with a piggybacked
put:acknowledgm:ent (acknowledgment value = RCV.NXT).  If there is
put:insufficien:t space to remember this buffer, simply return "error:
put:insufficien:t resources".
put:If the urge:nt flag is set, then SND.UP <- SND.NXT-1 and set the
put:urgent poin:ter in the outgoing segments.
put:[Page 56]        :                                                       
put:September 1981   :                                                       
put:FIN-WAIT-1 ST:ATE
put:FIN-WAIT-2 ST:ATE
put:CLOSING STATE:
put:LAST-ACK STAT:E
put:TIME-WAIT STA:TE
put:Return "err:or:  connection closing" and do not service request.
put:Transmission Cont:rol Protocol
put:Functional Specif:ication
put:CLOSED STATE :(i.e., TCB does not exist)
put:If the user: does not have access to such a connection, return
put:"error:  co:nnection illegal for this process".
put:Otherwise r:eturn "error:  connection does not exist".
put:SYN-SENT STAT:E
put:SYN-RECEIVED :STATE
put:Queue for p:rocessing after entering ESTABLISHED state.  If there
put:is no room :to queue this request, respond with "error:
put:insufficien:t resources".
put:ESTABLISHED S:TATE
put:FIN-WAIT-1 ST:ATE
put:FIN-WAIT-2 ST:ATE
put:If insuffic:ient incoming segments are queued to satisfy the
put:request, qu:eue the request.  If there is no queue space to
put:remember th:e RECEIVE, respond with "error:  insufficient
put:resources".:
put:Reassemble :queued incoming segments into receive buffer and return
put:to user.  M:ark "push seen" (PUSH) if this is the case.
put:If RCV.UP i:s in advance of the data currently being passed to the
put:user notify: the user of the presence of urgent data.
put:When the TC:P takes responsibility for delivering data to the user
put:that fact m:ust be communicated to the sender via an
put:acknowledgm:ent.  The formation of such an acknowledgment is
put:described b:elow in the discussion of processing an incoming
put:[Page 58]        :                                                       
put:September 1981   :                                                       
put:CLOSE-WAIT ST:ATE
put:Since the r:emote side has already sent FIN, RECEIVEs must be
put:satisfied b:y text already on hand, but not yet delivered to the
put:user.  If n:o text is awaiting delivery, the RECEIVE will get a
put:"error:  co:nnection closing" response.  Otherwise, any remaining
put:text can be: used to satisfy the RECEIVE.
put:CLOSING STATE:
put:LAST-ACK STAT:E
put:TIME-WAIT STA:TE
put:Return "err:or:  connection closing".
put:Transmission Cont:rol Protocol
put:Functional Specif:ication
put:CLOSED STATE :(i.e., TCB does not exist)
put:If the user: does not have access to such a connection, return
put:"error:  co:nnection illegal for this process".
put:Otherwise, :return "error:  connection does not exist".
put:Any outstan:ding RECEIVEs are returned with "error:  closing"
put:responses. : Delete TCB, enter CLOSED state, and return.
put:SYN-SENT STAT:E
put:Delete the :TCB and return "error:  closing" responses to any
put:queued SEND:s, or RECEIVEs.
put:SYN-RECEIVED :STATE
put:If no SENDs: have been issued and there is no pending data to send,
put:then form a: FIN segment and send it, and enter FIN-WAIT-1 state;
put:otherwise q:ueue for processing after entering ESTABLISHED state.
put:ESTABLISHED S:TATE
put:Queue this :until all preceding SENDs have been segmentized, then
put:form a FIN :segment and send it.  In any case, enter FIN-WAIT-1
put:FIN-WAIT-1 ST:ATE
put:FIN-WAIT-2 ST:ATE
put:Strictly sp:eaking, this is an error and should receive a "error:
put:connection :closing" response.  An "ok" response would be
put:acceptable,: too, as long as a second FIN is not emitted (the first
put:FIN may be :retransmitted though).
put:[Page 60]        :                                                       
put:September 1981   :                                                       
put:CLOSE-WAIT ST:ATE
put:Queue this :request until all preceding SENDs have been
put:segmentized:; then send a FIN segment, enter CLOSING state.
put:CLOSING STATE:
put:LAST-ACK STAT:E
put:TIME-WAIT STA:TE
put:Respond wit:h "error:  connection closing".
put:Transmission Cont:rol Protocol
put:Functional Specif:ication
put:CLOSED STATE :(i.e., TCB does not exist)
put:If the user: should not have access to such a connection, return
put:"error:  co:nnection illegal for this process".
put:Otherwise r:eturn "error:  connection does not exist".
put:Any outstan:ding RECEIVEs should be returned with "error:
put:connection :reset" responses.  Delete TCB, enter CLOSED state, and
put:SYN-SENT STAT:E
put:All queued :SENDs and RECEIVEs should be given "connection reset"
put:notificatio:n, delete the TCB, enter CLOSED state, and return.
put:SYN-RECEIVED :STATE
put:ESTABLISHED S:TATE
put:FIN-WAIT-1 ST:ATE
put:FIN-WAIT-2 ST:ATE
put:CLOSE-WAIT ST:ATE
put:Send a rese:t segment:
put:<SEQ=SND.:NXT><CTL=RST>
put:All queued :SENDs and RECEIVEs should be given "connection reset"
put:notificatio:n; all segments queued for transmission (except for the
put:RST formed :above) or retransmission should be flushed, delete the
put:TCB, enter :CLOSED state, and return.
put:CLOSING STATE:
put:LAST-ACK STAT:E
put:TIME-WAIT STA:TE
put:Respond wit:h "ok" and delete the TCB, enter CLOSED state, and
put:[Page 62]        :                                                       
put:September 1981   :                                                       
put:CLOSED STATE :(i.e., TCB does not exist)
put:If the user: should not have access to such a connection, return
put:"error:  co:nnection illegal for this process".
put:Otherwise r:eturn "error:  connection does not exist".
put:Return "sta:te = LISTEN", and the TCB pointer.
put:SYN-SENT STAT:E
put:Return "sta:te = SYN-SENT", and the TCB pointer.
put:SYN-RECEIVED :STATE
put:Return "sta:te = SYN-RECEIVED", and the TCB pointer.
put:ESTABLISHED S:TATE
put:Return "sta:te = ESTABLISHED", and the TCB pointer.
put:FIN-WAIT-1 ST:ATE
put:Return "sta:te = FIN-WAIT-1", and the TCB pointer.
put:FIN-WAIT-2 ST:ATE
put:Return "sta:te = FIN-WAIT-2", and the TCB pointer.
put:CLOSE-WAIT ST:ATE
put:Return "sta:te = CLOSE-WAIT", and the TCB pointer.
put:CLOSING STATE:
put:Return "sta:te = CLOSING", and the TCB pointer.
put:LAST-ACK STAT:E
put:Return "sta:te = LAST-ACK", and the TCB pointer.
put:Transmission Cont:rol Protocol
put:Functional Specif:ication
put:TIME-WAIT STA:TE
put:Return "sta:te = TIME-WAIT", and the TCB pointer.
put:[Page 64]        :                                                       
put:September 1981   :                                                       
put:SEGMENT ARRIVES:
put:If the state :is CLOSED (i.e., TCB does not exist) then
put:all data in: the incoming segment is discarded.  An incoming
put:segment con:taining a RST is discarded.  An incoming segment not
put:containing :a RST causes a RST to be sent in response.  The
put:acknowledgm:ent and sequence field values are selected to make the
put:reset seque:nce acceptable to the TCP that sent the offending
put:If the ACK :bit is off, sequence number zero is used,
put:<SEQ=0><A:CK=SEG.SEQ+SEG.LEN><CTL=RST,ACK>
put:If the ACK :bit is on,
put:<SEQ=SEG.:ACK><CTL=RST>
put:If the state :is LISTEN then
put:first check: for an RST
put:An incomi:ng RST should be ignored.  Return.
put:second chec:k for an ACK
put:Any ackno:wledgment is bad if it arrives on a connection still in
put:the LISTE:N state.  An acceptable reset segment should be formed
put:for any a:rriving ACK-bearing segment.  The RST should be
put:formatted: as follows:
put:<SEQ=SE:G.ACK><CTL=RST>
put:third check: for a SYN
put:If the SY:N bit is set, check the security.  If the
put:security/:compartment on the incoming segment does not exactly
put:match the: security/compartment in the TCB then send a reset and
put:<SEQ=SE:G.ACK><CTL=RST>
put:Transmission Cont:rol Protocol
put:Functional Specif:ication
put:If the SE:G.PRC is greater than the TCB.PRC then if allowed by
put:the user :and the system set TCB.PRC<-SEG.PRC, if not allowed
put:send a re:set and return.
put:<SEQ=SE:G.ACK><CTL=RST>
put:If the SE:G.PRC is less than the TCB.PRC then continue.
put:Set RCV.N:XT to SEG.SEQ+1, IRS is set to SEG.SEQ and any other
put:control o:r text should be queued for processing later.  ISS
put:should be: selected and a SYN segment sent of the form:
put:<SEQ=IS:S><ACK=RCV.NXT><CTL=SYN,ACK>
put:SND.NXT i:s set to ISS+1 and SND.UNA to ISS.  The connection
put:state sho:uld be changed to SYN-RECEIVED.  Note that any other
put:incoming :control or data (combined with SYN) will be processed
put:in the SY:N-RECEIVED state, but processing of SYN and ACK should
put:not be re:peated.  If the listen was not fully specified (i.e.,
put:the forei:gn socket was not fully specified), then the
put:unspecifi:ed fields should be filled in now.
put:fourth othe:r text or control
put:Any other: control or text-bearing segment (not containing SYN)
put:must have: an ACK and thus would be discarded by the ACK
put:processin:g.  An incoming RST segment could not be valid, since
put:it could :not have been sent in response to anything sent by this
put:incarnati:on of the connection.  So you are unlikely to get here,
put:but if yo:u do, drop the segment, and return.
put:If the state :is SYN-SENT then
put:first check: the ACK bit
put:If the AC:K bit is set
put:If SEG.:ACK =< ISS, or SEG.ACK > SND.NXT, send a reset (unless
put:the RST: bit is set, if so drop the segment and return)
put:<SEQ=:SEG.ACK><CTL=RST>
put:and dis:card the segment.  Return.
put:If SND.:UNA =< SEG.ACK =< SND.NXT then the ACK is acceptable.
put:second chec:k the RST bit
put:[Page 66]        :                                                       
put:September 1981   :                                                       
put:If the RS:T bit is set
put:If the :ACK was acceptable then signal the user "error:
put:connect:ion reset", drop the segment, enter CLOSED state,
put:delete :TCB, and return.  Otherwise (no ACK) drop the segment
put:and ret:urn.
put:third check: the security and precedence
put:If the se:curity/compartment in the segment does not exactly
put:match the: security/compartment in the TCB, send a reset
put:If ther:e is an ACK
put:<SEQ=:SEG.ACK><CTL=RST>
put:Otherwi:se
put:<SEQ=:0><ACK=SEG.SEQ+SEG.LEN><CTL=RST,ACK>
put:If there :is an ACK
put:The pre:cedence in the segment must match the precedence in the
put:TCB, if: not, send a reset
put:<SEQ=:SEG.ACK><CTL=RST>
put:If there :is no ACK
put:If the :precedence in the segment is higher than the precedence
put:in the :TCB then if allowed by the user and the system raise
put:the pre:cedence in the TCB to that in the segment, if not
put:allowed: to raise the prec then send a reset.
put:<SEQ=:0><ACK=SEG.SEQ+SEG.LEN><CTL=RST,ACK>
put:If the :precedence in the segment is lower than the precedence
put:in the :TCB continue.
put:If a rese:t was sent, discard the segment and return.
put:fourth chec:k the SYN bit
put:This step: should be reached only if the ACK is ok, or there is
put:no ACK, a:nd it the segment did not contain a RST.
put:If the SY:N bit is on and the security/compartment and precedence
put:Transmission Cont:rol Protocol
put:Functional Specif:ication
put:are accep:table then, RCV.NXT is set to SEG.SEQ+1, IRS is set to
put:SEG.SEQ. : SND.UNA should be advanced to equal SEG.ACK (if there
put:is an ACK:), and any segments on the retransmission queue which
put:are there:by acknowledged should be removed.
put:If SND.UN:A > ISS (our SYN has been ACKed), change the connection
put:state to :ESTABLISHED, form an ACK segment
put:<SEQ=SN:D.NXT><ACK=RCV.NXT><CTL=ACK>
put:and send :it.  Data or controls which were queued for
put:transmiss:ion may be included.  If there are other controls or
put:text in t:he segment then continue processing at the sixth step
put:below whe:re the URG bit is checked, otherwise return.
put:Otherwise: enter SYN-RECEIVED, form a SYN,ACK segment
put:<SEQ=IS:S><ACK=RCV.NXT><CTL=SYN,ACK>
put:and send :it.  If there are other controls or text in the
put:segment, :queue them for processing after the ESTABLISHED state
put:has been :reached, return.
put:fifth, if n:either of the SYN or RST bits is set then drop the
put:segment and: return.
put:[Page 68]        :                                                       
put:September 1981   :                                                       
put:first check s:equence number
put:SYN-RECEIVE:D STATE
put:ESTABLISHED: STATE
put:FIN-WAIT-1 :STATE
put:FIN-WAIT-2 :STATE
put:CLOSE-WAIT :STATE
put:CLOSING STA:TE
put:LAST-ACK ST:ATE
put:TIME-WAIT S:TATE
put:Segments :are processed in sequence.  Initial tests on arrival
put:are used :to discard old duplicates, but further processing is
put:done in S:EG.SEQ order.  If a segment's contents straddle the
put:boundary :between old and new, only the new parts should be
put:processed:.
put:There are: four cases for the acceptability test for an incoming
put:segment:
put:Segment R:eceive  Test
put:Length  W:indow
put:------- -:------  -------------------------------------------
put:0     :  0     SEG.SEQ = RCV.NXT
put:0     : >0     RCV.NXT =< SEG.SEQ < RCV.NXT+RCV.WND
put:>0     :  0     not acceptable
put:>0     : >0     RCV.NXT =< SEG.SEQ < RCV.NXT+RCV.WND
put:If the RC:V.WND is zero, no segments will be acceptable, but
put:special a:llowance should be made to accept valid ACKs, URGs and
put:If an inc:oming segment is not acceptable, an acknowledgment
put:should be: sent in reply (unless the RST bit is set, if so drop
put:the segme:nt and return):
put:<SEQ=SN:D.NXT><ACK=RCV.NXT><CTL=ACK>
put:After sen:ding the acknowledgment, drop the unacceptable segment
put:and retur:n.
put:Transmission Cont:rol Protocol
put:Functional Specif:ication
put:In the fo:llowing it is assumed that the segment is the idealized
put:segment t:hat begins at RCV.NXT and does not exceed the window.
put:One could: tailor actual segments to fit this assumption by
put:trimming :off any portions that lie outside the window (including
put:SYN and F:IN), and only processing further if the segment then
put:begins at: RCV.NXT.  Segments with higher begining sequence
put:numbers m:ay be held for later processing.
put:second check :the RST bit,
put:SYN-RECEIVE:D STATE
put:If the RS:T bit is set
put:If this: connection was initiated with a passive OPEN (i.e.,
put:came fr:om the LISTEN state), then return this connection to
put:LISTEN :state and return.  The user need not be informed.  If
put:this co:nnection was initiated with an active OPEN (i.e., came
put:from SY:N-SENT state) then the connection was refused, signal
put:the use:r "connection refused".  In either case, all segments
put:on the :retransmission queue should be removed.  And in the
put:active :OPEN case, enter the CLOSED state and delete the TCB,
put:and ret:urn.
put:ESTABLISHED:
put:If the RS:T bit is set then, any outstanding RECEIVEs and SEND
put:should re:ceive "reset" responses.  All segment queues should be
put:flushed. : Users should also receive an unsolicited general
put:"connecti:on reset" signal.  Enter the CLOSED state, delete the
put:TCB, and :return.
put:CLOSING STA:TE
put:LAST-ACK ST:ATE
put:If the RS:T bit is set then, enter the CLOSED state, delete the
put:TCB, and :return.
put:[Page 70]        :                                                       
put:September 1981   :                                                       
put:third check s:ecurity and precedence
put:SYN-RECEIVE:D
put:If the se:curity/compartment and precedence in the segment do not
put:exactly m:atch the security/compartment and precedence in the TCB
put:then send: a reset, and return.
put:ESTABLISHED: STATE
put:If the se:curity/compartment and precedence in the segment do not
put:exactly m:atch the security/compartment and precedence in the TCB
put:then send: a reset, any outstanding RECEIVEs and SEND should
put:receive ":reset" responses.  All segment queues should be
put:flushed. : Users should also receive an unsolicited general
put:"connecti:on reset" signal.  Enter the CLOSED state, delete the
put:TCB, and :return.
put:Note this c:heck is placed following the sequence check to prevent
put:a segment f:rom an old connection between these ports with a
put:different s:ecurity or precedence from causing an abort of the
put:current con:nection.
put:fourth, check: the SYN bit,
put:SYN-RECEIVE:D
put:ESTABLISHED: STATE
put:FIN-WAIT ST:ATE-1
put:FIN-WAIT ST:ATE-2
put:CLOSE-WAIT :STATE
put:CLOSING STA:TE
put:LAST-ACK ST:ATE
put:TIME-WAIT S:TATE
put:If the SY:N is in the window it is an error, send a reset, any
put:outstandi:ng RECEIVEs and SEND should receive "reset" responses,
put:all segme:nt queues should be flushed, the user should also
put:receive a:n unsolicited general "connection reset" signal, enter
put:the CLOSE:D state, delete the TCB, and return.
put:If the SY:N is not in the window this step would not be reached
put:and an ac:k would have been sent in the first step (sequence
put:number ch:eck).
put:Transmission Cont:rol Protocol
put:Functional Specif:ication
put:fifth check t:he ACK field,
put:if the ACK :bit is off drop the segment and return
put:if the ACK :bit is on
put:SYN-RECEI:VED STATE
put:If SND.:UNA =< SEG.ACK =< SND.NXT then enter ESTABLISHED state
put:and con:tinue processing.
put:If th:e segment acknowledgment is not acceptable, form a
put:reset: segment,
put:<SE:Q=SEG.ACK><CTL=RST>
put:and s:end it.
put:ESTABLISH:ED STATE
put:If SND.:UNA < SEG.ACK =< SND.NXT then, set SND.UNA <- SEG.ACK.
put:Any seg:ments on the retransmission queue which are thereby
put:entirel:y acknowledged are removed.  Users should receive
put:positiv:e acknowledgments for buffers which have been SENT and
put:fully a:cknowledged (i.e., SEND buffer should be returned with
put:"ok" re:sponse).  If the ACK is a duplicate
put:(SEG.AC:K < SND.UNA), it can be ignored.  If the ACK acks
put:somethi:ng not yet sent (SEG.ACK > SND.NXT) then send an ACK,
put:drop th:e segment, and return.
put:If SND.:UNA < SEG.ACK =< SND.NXT, the send window should be
put:updated:.  If (SND.WL1 < SEG.SEQ or (SND.WL1 = SEG.SEQ and
put:SND.WL2: =< SEG.ACK)), set SND.WND <- SEG.WND, set
put:SND.WL1: <- SEG.SEQ, and set SND.WL2 <- SEG.ACK.
put:Note th:at SND.WND is an offset from SND.UNA, that SND.WL1
put:records: the sequence number of the last segment used to update
put:SND.WND:, and that SND.WL2 records the acknowledgment number of
put:the las:t segment used to update SND.WND.  The check here
put:prevent:s using old segments to update the window.
put:[Page 72]        :                                                       
put:September 1981   :                                                       
put:FIN-WAIT-:1 STATE
put:In addi:tion to the processing for the ESTABLISHED state, if
put:our FIN: is now acknowledged then enter FIN-WAIT-2 and continue
put:process:ing in that state.
put:FIN-WAIT-:2 STATE
put:In addi:tion to the processing for the ESTABLISHED state, if
put:the ret:ransmission queue is empty, the user's CLOSE can be
put:acknowl:edged ("ok") but do not delete the TCB.
put:CLOSE-WAI:T STATE
put:Do the :same processing as for the ESTABLISHED state.
put:CLOSING S:TATE
put:In addi:tion to the processing for the ESTABLISHED state, if
put:the ACK: acknowledges our FIN then enter the TIME-WAIT state,
put:otherwi:se ignore the segment.
put:LAST-ACK :STATE
put:The onl:y thing that can arrive in this state is an
put:acknowl:edgment of our FIN.  If our FIN is now acknowledged,
put:delete :the TCB, enter the CLOSED state, and return.
put:TIME-WAIT: STATE
put:The onl:y thing that can arrive in this state is a
put:retrans:mission of the remote FIN.  Acknowledge it, and restart
put:the 2 M:SL timeout.
put:sixth, check :the URG bit,
put:ESTABLISHED: STATE
put:FIN-WAIT-1 :STATE
put:FIN-WAIT-2 :STATE
put:If the UR:G bit is set, RCV.UP <- max(RCV.UP,SEG.UP), and signal
put:the user :that the remote side has urgent data if the urgent
put:pointer (:RCV.UP) is in advance of the data consumed.  If the
put:user has :already been signaled (or is still in the "urgent
put:mode") fo:r this continuous sequence of urgent data, do not
put:signal th:e user again.
put:Transmission Cont:rol Protocol
put:Functional Specif:ication
put:CLOSE-WAIT :STATE
put:CLOSING STA:TE
put:LAST-ACK ST:ATE
put:This shou:ld not occur, since a FIN has been received from the
put:remote si:de.  Ignore the URG.
put:seventh, proc:ess the segment text,
put:ESTABLISHED: STATE
put:FIN-WAIT-1 :STATE
put:FIN-WAIT-2 :STATE
put:Once in t:he ESTABLISHED state, it is possible to deliver segment
put:text to u:ser RECEIVE buffers.  Text from segments can be moved
put:into buff:ers until either the buffer is full or the segment is
put:empty.  I:f the segment empties and carries an PUSH flag, then
put:the user :is informed, when the buffer is returned, that a PUSH
put:has been :received.
put:When the :TCP takes responsibility for delivering the data to the
put:user it m:ust also acknowledge the receipt of the data.
put:Once the :TCP takes responsibility for the data it advances
put:RCV.NXT o:ver the data accepted, and adjusts RCV.WND as
put:apporopri:ate to the current buffer availability.  The total of
put:RCV.NXT a:nd RCV.WND should not be reduced.
put:Please no:te the window management suggestions in section 3.7.
put:Send an a:cknowledgment of the form:
put:<SEQ=SN:D.NXT><ACK=RCV.NXT><CTL=ACK>
put:This ackn:owledgment should be piggybacked on a segment being
put:transmitt:ed if possible without incurring undue delay.
put:[Page 74]        :                                                       
put:September 1981   :                                                       
put:CLOSE-WAIT :STATE
put:CLOSING STA:TE
put:LAST-ACK ST:ATE
put:TIME-WAIT S:TATE
put:This shou:ld not occur, since a FIN has been received from the
put:remote si:de.  Ignore the segment text.
put:eighth, check: the FIN bit,
put:Do not proc:ess the FIN if the state is CLOSED, LISTEN or SYN-SENT
put:since the S:EG.SEQ cannot be validated; drop the segment and
put:If the FIN :bit is set, signal the user "connection closing" and
put:return any :pending RECEIVEs with same message, advance RCV.NXT
put:over the FI:N, and send an acknowledgment for the FIN.  Note that
put:FIN implies: PUSH for any segment text not yet delivered to the
put:SYN-RECEI:VED STATE
put:ESTABLISH:ED STATE
put:Enter t:he CLOSE-WAIT state.
put:FIN-WAIT-:1 STATE
put:If our :FIN has been ACKed (perhaps in this segment), then
put:enter T:IME-WAIT, start the time-wait timer, turn off the other
put:timers;: otherwise enter the CLOSING state.
put:FIN-WAIT-:2 STATE
put:Enter t:he TIME-WAIT state.  Start the time-wait timer, turn
put:off the: other timers.
put:CLOSE-WAI:T STATE
put:Remain :in the CLOSE-WAIT state.
put:CLOSING S:TATE
put:Remain :in the CLOSING state.
put:LAST-ACK :STATE
put:Remain :in the LAST-ACK state.
put:Transmission Cont:rol Protocol
put:Functional Specif:ication
put:TIME-WAIT: STATE
put:Remain :in the TIME-WAIT state.  Restart the 2 MSL time-wait
put:timeout:.
put:[Page 76]        :                                                       
put:September 1981   :                                                       
put:For any state: if the user timeout expires, flush all queues, signal
put:the user "err:or:  connection aborted due to user timeout" in general
put:and for any o:utstanding calls, delete the TCB, enter the CLOSED
put:state and ret:urn.
put:RETRANSMISSION :TIMEOUT
put:For any state: if the retransmission timeout expires on a segment in
put:the retransmi:ssion queue, send the segment at the front of the
put:retransmissio:n queue again, reinitialize the retransmission timer,
put:TIME-WAIT TIMEO:UT
put:If the time-w:ait timeout expires on a connection delete the TCB,
put:enter the CLO:SED state and return.
put:Transmission Cont:rol Protocol
put:[Page 78]        :                                                       
put:September 1981   :                                                       
put:BBN Rep:ort 1822, "The Specification of the Interconnection of
put:a Host :and an IMP".  The specification of interface between a
put:host an:d the ARPANET.
put:A contr:ol bit (acknowledge) occupying no sequence space, which
put:indicat:es that the acknowledgment field of this segment
put:specifi:es the next sequence number the sender of this segment
put:is expe:cting to receive, hence acknowledging receipt of all
put:previou:s sequence numbers.
put:The uni:t of transmission between a host and an IMP in the
put:ARPANET:.  The maximum size is about 1012 octets (8096 bits).
put:A unit :of transmission used internally in the ARPANET between
put:IMPs.  :The maximum size is about 126 octets (1008 bits).
put:A logic:al communication path identified by a pair of sockets.
put:A messa:ge sent in a packet switched computer communications
put:network:.
put:Destination Addre:ss
put:The des:tination address, usually the network and host
put:identif:iers.
put:A contr:ol bit (finis) occupying one sequence number, which
put:indicat:es that the sender will send no more data or control
put:occupyi:ng sequence space.
put:A porti:on of a logical unit of data, in particular an internet
put:fragmen:t is a portion of an internet datagram.
put:A file :transfer protocol.
put:Transmission Cont:rol Protocol
put:Control: information at the beginning of a message, segment,
put:fragmen:t, packet or block of data.
put:A compu:ter.  In particular a source or destination of messages
put:from th:e point of view of the communication network.
put:An Inte:rnet Protocol field.  This identifying value assigned
put:by the :sender aids in assembling the fragments of a datagram.
put:The Int:erface Message Processor, the packet switch of the
put:ARPANET:.
put:A sourc:e or destination address specific to the host level.
put:internet datagram:
put:The uni:t of data exchanged between an internet module and the
put:higher :level protocol together with the internet header.
put:internet fragment:
put:A porti:on of the data of an internet datagram with an internet
put:header.:
put:Interne:t Protocol.
put:The Ini:tial Receive Sequence number.  The first sequence
put:number :used by the sender on a connection.
put:The Ini:tial Sequence Number.  The first sequence number used
put:on a co:nnection, (either ISS or IRS).  Selected on a clock
put:based p:rocedure.
put:The Ini:tial Send Sequence number.  The first sequence number
put:used by: the sender on a connection.
put:Control: information at the beginning of a message or block of
put:data.  :In particular, in the ARPANET, the control information
put:on an A:RPANET message at the host-IMP interface.
put:[Page 80]        :                                                       
put:September 1981   :                                                       
put:This is: the next sequence number to be acknowledged by the
put:data re:ceiving TCP (or the lowest currently unacknowledged
put:sequenc:e number) and is sometimes referred to as the left edge
put:of the :send window.
put:The uni:t of transmission within a local network.
put:An impl:ementation, usually in software, of a protocol or other
put:procedu:re.
put:Maximum: Segment Lifetime, the time a TCP segment can exist in
put:the int:ernetwork system.  Arbitrarily defined to be 2 minutes.
put:An eigh:t bit byte.
put:An Opti:on field may contain several options, and each option
put:may be :several octets in length.  The options are used
put:primari:ly in testing situations; for example, to carry
put:timesta:mps.  Both the Internet Protocol and TCP provide for
put:options: fields.
put:A packa:ge of data with a header which may or may not be
put:logical:ly complete.  More often a physical packaging than a
put:logical: packaging of data.
put:The por:tion of a socket that specifies which logical input or
put:output :channel of a process is associated with the data.
put:A progr:am in execution.  A source or destination of data from
put:the poi:nt of view of the TCP or other host-to-host protocol.
put:A contr:ol bit occupying no sequence space, indicating that
put:this se:gment contains data that must be pushed through to the
put:receivi:ng user.
put:receive: next sequence number
put:Transmission Cont:rol Protocol
put:receive: urgent pointer
put:receive: window
put:receive next sequ:ence number
put:This is: the next sequence number the local TCP is expecting to
put:receive:.
put:This re:presents the sequence numbers the local (receiving) TCP
put:is will:ing to receive.  Thus, the local TCP considers that
put:segment:s overlapping the range RCV.NXT to
put:RCV.NXT: + RCV.WND - 1 carry acceptable data or control.
put:Segment:s containing sequence numbers entirely outside of this
put:range a:re considered duplicates and discarded.
put:A contr:ol bit (reset), occupying no sequence space, indicating
put:that th:e receiver should delete the connection without further
put:interac:tion.  The receiver can determine, based on the
put:sequenc:e number and acknowledgment fields of the incoming
put:segment:, whether it should honor the reset command or ignore
put:it.  In: no case does receipt of a segment containing RST give
put:rise to: a RST in response.
put:Real Ti:me Protocol:  A host-to-host protocol for communication
put:of time: critical information.
put:segment: acknowledgment
put:segment: length
put:segment: precedence value
put:segment: sequence
put:segment: urgent pointer field
put:[Page 82]        :                                                       
put:September 1981   :                                                       
put:segment: window field
put:A logic:al unit of data, in particular a TCP segment is the
put:unit of: data transfered between a pair of TCP modules.
put:segment acknowled:gment
put:The seq:uence number in the acknowledgment field of the
put:arrivin:g segment.
put:The amo:unt of sequence number space occupied by a segment,
put:includi:ng any controls which occupy sequence space.
put:The num:ber in the sequence field of the arriving segment.
put:This is: the next sequence number the local (sending) TCP will
put:use on :the connection.  It is initially selected from an
put:initial: sequence number curve (ISN) and is incremented for
put:each oc:tet of data or sequenced control transmitted.
put:This re:presents the sequence numbers which the remote
put:(receiv:ing) TCP is willing to receive.  It is the value of the
put:window :field specified in segments from the remote (data
put:receivi:ng) TCP.  The range of new sequence numbers which may
put:be emit:ted by a TCP lies between SND.NXT and
put:SND.UNA: + SND.WND - 1. (Retransmissions of sequence numbers
put:between: SND.UNA and SND.NXT are expected, of course.)
put:send se:quence
put:left se:quence
put:send ur:gent pointer
put:segment: sequence number at last window update
put:segment: acknowledgment number at last window update
put:Transmission Cont:rol Protocol
put:send wi:ndow
put:An addr:ess which specifically includes a port identifier, that
put:is, the: concatenation of an Internet Address with a TCP port.
put:The sou:rce address, usually the network and host identifiers.
put:A contr:ol bit in the incoming segment, occupying one sequence
put:number,: used at the initiation of a connection, to indicate
put:where t:he sequence numbering will start.
put:Transmi:ssion control block, the data structure that records
put:the sta:te of a connection.
put:The pre:cedence of the connection.
put:Transmi:ssion Control Protocol:  A host-to-host protocol for
put:reliabl:e communication in internetwork environments.
put:Type of: Service, an Internet Protocol field.
put:An Inte:rnet Protocol field which indicates the type of service
put:for thi:s internet fragment.
put:A contr:ol bit (urgent), occupying no sequence space, used to
put:indicat:e that the receiving user should be notified to do
put:urgent :processing as long as there is data to be consumed with
put:sequenc:e numbers less than the value indicated in the urgent
put:pointer:.
put:A contr:ol field meaningful only when the URG bit is on.  This
put:field c:ommunicates the value of the urgent pointer which
put:indicat:es the data octet associated with the sending user's
put:urgent :call.
put:[Page 84]        :                                                       
put:September 1981   :                                                       
put:[1]  Cerf, V., an:d R. Kahn, "A Protocol for Packet Network
put:Intercommuni:cation", IEEE Transactions on Communications,
put:Vol. COM-22,: No. 5, pp 637-648, May 1974.
put:[2]  Postel, J. (:ed.), "Internet Protocol - DARPA Internet Program
put:Protocol Spe:cification", RFC 791, USC/Information Sciences
put:Institute, S:eptember 1981.
put:[3]  Dalal, Y. an:d C. Sunshine, "Connection Management in Transport
put:Protocols", :Computer Networks, Vol. 2, No. 6, pp. 454-473,
put:December 197:8.
put:[4]  Postel, J., :"Assigned Numbers", RFC 790, USC/Information Sciences
put:Institute, S:eptember 1981.
put:aRFC: 793
put:aDe:fense Advanced Research Projects Agency
put:aI:nformation Processing Techniques Office
put:aSeptember 1981   :                                                       
put:aPREFACE .....:................................................... iii
put:a1.  INTRODUCTION :..................................................... 1
put:a1.1  Motivation: .................................................... 1
put:a1.2  Scope ....:..................................................... 2
put:a1.3  About This: Document ........................................... 2
put:a1.4  Interfaces: .................................................... 3
put:a1.5  Operation :..................................................... 3
put:a2.  PHILOSOPHY ..:..................................................... 7
put:a2.1  Elements o:f the Internetwork System ........................... 7
put:a2.2  Model of O:peration ............................................ 7
put:a2.3  The Host E:nvironment .......................................... 8
put:a2.4  Interfaces: .................................................... 9
put:a2.5  Relation t:o Other Protocols ................................... 9
put:a2.6  Reliable C:ommunication ........................................ 9
put:a2.7  Connection: Establishment and Clearing ........................ 10
put:a2.8  Data Commu:nication ........................................... 12
put:a2.9  Precedence: and Security ...................................... 13
put:a2.10 Robustness: Principle ......................................... 13
put:a3.  FUNCTIONAL SP:ECIFICATION ........................................ 15
put:a3.1  Header For:mat ................................................ 15
put:a3.2  Terminolog:y .................................................. 19
put:a3.3  Sequence N:umbers ............................................. 24
put:a3.4  Establishi:ng a connection .................................... 30
put:a3.5  Closing a :Connection ......................................... 37
put:a3.6  Precedence: and Security ...................................... 40
put:a3.7  Data Commu:nication ........................................... 40
put:a3.8  Interfaces: ................................................... 44
put:a3.9  Event Proc:essing ............................................. 52
put:aGLOSSARY ........:.................................................... 79
put:aREFERENCES ......:.................................................... 85
put:aTransmission Cont:rol Protocol
put:a[Page ii]        :                                                       
put:aSeptember 1981   :                                                       
put:aThis document des:cribes the DoD Standard Transmission Control Protocol
put:a(TCP).  There hav:e been nine earlier editions of the ARPA TCP
put:aspecification on :which this standard is based, and the present text
put:adraws heavily fro:m them.  There have been many contributors to this work
put:aboth in terms of :concepts and in terms of text.  This edition clarifies
put:aseveral details a:nd removes the end-of-letter buffer-size adjustments,
put:aand redescribes t:he letter mechanism as a push function.
put:aRFC:  793
put:aReplaces: RFC 761:
put:aIENs:  129, 124, :112, 81,
put:a55, 44, 40, 27, 2:1, 5
put:aThe Transmission :Control Protocol (TCP) is intended for use as a highly
put:areliable host-to-:host protocol between hosts in packet-switched computer
put:acommunication net:works, and in interconnected systems of such networks.
put:aThis document des:cribes the functions to be performed by the
put:aTransmission Cont:rol Protocol, the program that implements it, and its
put:ainterface to prog:rams or users that require its services.
put:aComputer commun:ication systems are playing an increasingly important
put:arole in militar:y, government, and civilian environments.  This
put:adocument focuse:s its attention primarily on military computer
put:acommunication r:equirements, especially robustness in the presence of
put:acommunication u:nreliability and availability in the presence of
put:acongestion, but: many of these problems are found in the civilian and
put:agovernment sect:or as well.
put:aAs strategic an:d tactical computer communication networks are
put:adeveloped and d:eployed, it is essential to provide means of
put:ainterconnecting: them and to provide standard interprocess
put:acommunication p:rotocols which can support a broad range of
put:aapplications.  :In anticipation of the need for such standards, the
put:aDeputy Undersec:retary of Defense for Research and Engineering has
put:adeclared the Tr:ansmission Control Protocol (TCP) described herein to
put:abe a basis for :DoD-wide inter-process communication protocol
put:astandardization:.
put:aTCP is a connec:tion-oriented, end-to-end reliable protocol designed to
put:afit into a laye:red hierarchy of protocols which support multi-network
put:aapplications.  :The TCP provides for reliable inter-process
put:acommunication b:etween pairs of processes in host computers attached to
put:adistinct but in:terconnected computer communication networks.  Very few
put:aassumptions are: made as to the reliability of the communication
put:aprotocols below: the TCP layer.  TCP assumes it can obtain a simple,
put:apotentially unr:eliable datagram service from the lower level
put:aprotocols.  In :principle, the TCP should be able to operate above a
put:awide spectrum o:f communication systems ranging from hard-wired
put:aconnections to :packet-switched or circuit-switched networks.
put:aTransmission Cont:rol Protocol
put:aTCP is based on: concepts first described by Cerf and Kahn in [1].  The
put:aTCP fits into a: layered protocol architecture just above a basic
put:aInternet Protoc:ol [2] which provides a way for the TCP to send and
put:areceive variabl:e-length segments of information enclosed in internet
put:adatagram "envel:opes".  The internet datagram provides a means for
put:aaddressing sour:ce and destination TCPs in different networks.  The
put:ainternet protoc:ol also deals with any fragmentation or reassembly of
put:athe TCP segment:s required to achieve transport and delivery through
put:amultiple networ:ks and interconnecting gateways.  The internet protocol
put:aalso carries in:formation on the precedence, security classification
put:aand compartment:ation of the TCP segments, so this information can be
put:acommunicated en:d-to-end across multiple networks.
put:aMuch of this do:cument is written in the context of TCP implementations
put:awhich are co-re:sident with higher level protocols in the host
put:acomputer.  Some: computer systems will be connected to networks via
put:afront-end compu:ters which house the TCP and internet protocol layers,
put:aas well as netw:ork specific software.  The TCP specification describes
put:aan interface to: the higher level protocols which appears to be
put:aimplementable e:ven for the front-end case, as long as a suitable
put:ahost-to-front e:nd protocol is implemented.
put:aThe TCP is inte:nded to provide a reliable process-to-process
put:acommunication s:ervice in a multinetwork environment.  The TCP is
put:aintended to be :a host-to-host protocol in common use in multiple
put:a1.3.  About this :Document
put:aThis document r:epresents a specification of the behavior required of
put:aany TCP impleme:ntation, both in its interactions with higher level
put:aprotocols and i:n its interactions with other TCPs.  The rest of this
put:a[Page 2]         :                                                       
put:aSeptember 1981   :                                                       
put:asection offers :a very brief view of the protocol interfaces and
put:aoperation.  Sec:tion 2 summarizes the philosophical basis for the TCP
put:adesign.  Sectio:n 3 offers both a detailed description of the actions
put:arequired of TCP: when various events occur (arrival of new segments,
put:auser calls, err:ors, etc.) and the details of the formats of TCP
put:aThe TCP interfa:ces on one side to user or application processes and on
put:athe other side :to a lower level protocol such as Internet Protocol.
put:aThe interface b:etween an application process and the TCP is
put:aillustrated in :reasonable detail.  This interface consists of a set of
put:acalls much like: the calls an operating system provides to an
put:aapplication pro:cess for manipulating files.  For example, there are
put:acalls to open a:nd close connections and to send and receive data on
put:aestablished con:nections.  It is also expected that the TCP can
put:aasynchronously :communicate with application programs.  Although
put:aconsiderable fr:eedom is permitted to TCP implementors to design
put:ainterfaces whic:h are appropriate to a particular operating system
put:aenvironment, a :minimum functionality is required at the TCP/user
put:ainterface for a:ny valid implementation.
put:aThe interface b:etween TCP and lower level protocol is essentially
put:aunspecified exc:ept that it is assumed there is a mechanism whereby the
put:atwo levels can :asynchronously pass information to each other.
put:aTypically, one :expects the lower level protocol to specify this
put:ainterface.  TCP: is designed to work in a very general environment of
put:ainterconnected :networks.  The lower level protocol which is assumed
put:athroughout this: document is the Internet Protocol [2].
put:aAs noted above,: the primary purpose of the TCP is to provide reliable,
put:asecurable logic:al circuit or connection service between pairs of
put:aprocesses.  To :provide this service on top of a less reliable internet
put:acommunication s:ystem requires facilities in the following areas:
put:aBasic Data Tr:ansfer
put:aPrecedence an:d Security
put:aThe basic opera:tion of the TCP in each of these areas is described in
put:athe following p:aragraphs.
put:aTransmission Cont:rol Protocol
put:aBasic Data Tran:sfer:
put:aThe TCP is ab:le to transfer a continuous stream of octets in each
put:adirection bet:ween its users by packaging some number of octets into
put:asegments for :transmission through the internet system.  In general,
put:athe TCPs deci:de when to block and forward data at their own
put:aSometimes use:rs need to be sure that all the data they have
put:asubmitted to :the TCP has been transmitted.  For this purpose a push
put:afunction is d:efined.  To assure that data submitted to a TCP is
put:aactually tran:smitted the sending user indicates that it should be
put:apushed throug:h to the receiving user.  A push causes the TCPs to
put:apromptly forw:ard and deliver data up to that point to the receiver.
put:aThe exact pus:h point might not be visible to the receiving user and
put:athe push func:tion does not supply a record boundary marker.
put:aReliability:
put:aThe TCP must :recover from data that is damaged, lost, duplicated, or
put:adelivered out: of order by the internet communication system.  This
put:ais achieved b:y assigning a sequence number to each octet
put:atransmitted, :and requiring a positive acknowledgment (ACK) from the
put:areceiving TCP:.  If the ACK is not received within a timeout
put:ainterval, the: data is retransmitted.  At the receiver, the sequence
put:anumbers are u:sed to correctly order segments that may be received
put:aout of order :and to eliminate duplicates.  Damage is handled by
put:aadding a chec:ksum to each segment transmitted, checking it at the
put:areceiver, and: discarding damaged segments.
put:aAs long as th:e TCPs continue to function properly and the internet
put:asystem does n:ot become completely partitioned, no transmission
put:aerrors will a:ffect the correct delivery of data.  TCP recovers from
put:ainternet comm:unication system errors.
put:aFlow Control:
put:aTCP provides :a means for the receiver to govern the amount of data
put:asent by the s:ender.  This is achieved by returning a "window" with
put:aevery ACK ind:icating a range of acceptable sequence numbers beyond
put:athe last segm:ent successfully received.  The window indicates an
put:aallowed numbe:r of octets that the sender may transmit before
put:areceiving fur:ther permission.
put:a[Page 4]         :                                                       
put:aSeptember 1981   :                                                       
put:aMultiplexing:
put:aTo allow for :many processes within a single Host to use TCP
put:acommunication: facilities simultaneously, the TCP provides a set of
put:aaddresses or :ports within each host.  Concatenated with the network
put:aand host addr:esses from the internet communication layer, this forms
put:aa socket.  A :pair of sockets uniquely identifies each connection.
put:aThat is, a so:cket may be simultaneously used in multiple
put:aThe binding o:f ports to processes is handled independently by each
put:aHost.  Howeve:r, it proves useful to attach frequently used processes
put:a(e.g., a "log:ger" or timesharing service) to fixed sockets which are
put:amade known to: the public.  These services can then be accessed
put:athrough the k:nown addresses.  Establishing and learning the port
put:aaddresses of :other processes may involve more dynamic mechanisms.
put:aConnections:
put:aThe reliabili:ty and flow control mechanisms described above require
put:athat TCPs ini:tialize and maintain certain status information for
put:aeach data str:eam.  The combination of this information, including
put:asockets, sequ:ence numbers, and window sizes, is called a connection.
put:aEach connecti:on is uniquely specified by a pair of sockets
put:aidentifying i:ts two sides.
put:aWhen two proc:esses wish to communicate, their TCP's must first
put:aestablish a c:onnection (initialize the status information on each
put:aside).  When :their communication is complete, the connection is
put:aterminated or: closed to free the resources for other uses.
put:aSince connect:ions must be established between unreliable hosts and
put:aover the unre:liable internet communication system, a handshake
put:amechanism wit:h clock-based sequence numbers is used to avoid
put:aerroneous ini:tialization of connections.
put:aPrecedence and :Security:
put:aThe users of :TCP may indicate the security and precedence of their
put:acommunication:.  Provision is made for default values to be used when
put:athese feature:s are not needed.
put:aTransmission Cont:rol Protocol
put:a[Page 6]         :                                                       
put:aSeptember 1981   :                                                       
put:a2.1.  Elements of: the Internetwork System
put:aThe internetwor:k environment consists of hosts connected to networks
put:awhich are in tu:rn interconnected via gateways.  It is assumed here
put:athat the networ:ks may be either local networks (e.g., the ETHERNET) or
put:alarge networks :(e.g., the ARPANET), but in any case are based on
put:apacket switchin:g technology.  The active agents that produce and
put:aconsume message:s are processes.  Various levels of protocols in the
put:anetworks, the g:ateways, and the hosts support an interprocess
put:acommunication s:ystem that provides two-way data flow on logical
put:aconnections bet:ween process ports.
put:aThe term packet: is used generically here to mean the data of one
put:atransaction bet:ween a host and its network.  The format of data blocks
put:aexchanged withi:n the a network will generally not be of concern to us.
put:aHosts are compu:ters attached to a network, and from the communication
put:anetwork's point: of view, are the sources and destinations of packets.
put:aProcesses are v:iewed as the active elements in host computers (in
put:aaccordance with: the fairly common definition of a process as a program
put:ain execution). : Even terminals and files or other I/O devices are
put:aviewed as commu:nicating with each other through the use of processes.
put:aThus, all commu:nication is viewed as inter-process communication.
put:aSince a process: may need to distinguish among several communication
put:astreams between: itself and another process (or processes), we imagine
put:athat each proce:ss may have a number of ports through which it
put:acommunicates wi:th the ports of other processes.
put:a2.2.  Model of Op:eration
put:aProcesses trans:mit data by calling on the TCP and passing buffers of
put:adata as argumen:ts.  The TCP packages the data from these buffers into
put:asegments and ca:lls on the internet module to transmit each segment to
put:athe destination: TCP.  The receiving TCP places the data from a segment
put:ainto the receiv:ing user's buffer and notifies the receiving user.  The
put:aTCPs include co:ntrol information in the segments which they use to
put:aensure reliable: ordered data transmission.
put:aThe model of in:ternet communication is that there is an internet
put:aprotocol module: associated with each TCP which provides an interface
put:ato the local ne:twork.  This internet module packages TCP segments
put:ainside internet: datagrams and routes these datagrams to a destination
put:ainternet module: or intermediate gateway.  To transmit the datagram
put:athrough the loc:al network, it is embedded in a local network packet.
put:aThe packet swit:ches may perform further packaging, fragmentation, or
put:aTransmission Cont:rol Protocol
put:aother operation:s to achieve the delivery of the local packet to the
put:adestination int:ernet module.
put:aAt a gateway be:tween networks, the internet datagram is "unwrapped"
put:afrom its local :packet and examined to determine through which network
put:athe internet da:tagram should travel next.  The internet datagram is
put:athen "wrapped" :in a local packet suitable to the next network and
put:arouted to the n:ext gateway, or to the final destination.
put:aA gateway is pe:rmitted to break up an internet datagram into smaller
put:ainternet datagr:am fragments if this is necessary for transmission
put:athrough the nex:t network.  To do this, the gateway produces a set of
put:ainternet datagr:ams; each carrying a fragment.  Fragments may be
put:afurther broken :into smaller fragments at subsequent gateways.  The
put:ainternet datagr:am fragment format is designed so that the destination
put:ainternet module: can reassemble fragments into internet datagrams.
put:aA destination i:nternet module unwraps the segment from the datagram
put:a(after reassemb:ling the datagram, if necessary) and passes it to the
put:adestination TCP:.
put:aThis simple mod:el of the operation glosses over many details.  One
put:aimportant featu:re is the type of service.  This provides information
put:ato the gateway :(or internet module) to guide it in selecting the
put:aservice paramet:ers to be used in traversing the next network.
put:aIncluded in the: type of service information is the precedence of the
put:adatagram.  Data:grams may also carry security information to permit
put:ahost and gatewa:ys that operate in multilevel secure environments to
put:aproperly segreg:ate datagrams for security considerations.
put:a2.3.  The Host En:vironment
put:aThe TCP is assu:med to be a module in an operating system.  The users
put:aaccess the TCP :much like they would access the file system.  The TCP
put:amay call on oth:er operating system functions, for example, to manage
put:adata structures:.  The actual interface to the network is assumed to be
put:acontrolled by a: device driver module.  The TCP does not call on the
put:anetwork device :driver directly, but rather calls on the internet
put:adatagram protoc:ol module which may in turn call on the device driver.
put:aThe mechanisms :of TCP do not preclude implementation of the TCP in a
put:afront-end proce:ssor.  However, in such an implementation, a
put:ahost-to-front-e:nd protocol must provide the functionality to support
put:athe type of TCP:-user interface described in this document.
put:a[Page 8]         :                                                       
put:aSeptember 1981   :                                                       
put:aThe TCP/user in:terface provides for calls made by the user on the TCP
put:ato OPEN or CLOS:E a connection, to SEND or RECEIVE data, or to obtain
put:aSTATUS about a :connection.  These calls are like other calls from user
put:aprograms on the: operating system, for example, the calls to open, read
put:afrom, and close: a file.
put:aThe TCP/interne:t interface provides calls to send and receive
put:adatagrams addre:ssed to TCP modules in hosts anywhere in the internet
put:asystem.  These :calls have parameters for passing the address, type of
put:aservice, preced:ence, security, and other control information.
put:a2.5.  Relation to: Other Protocols
put:aThe following d:iagram illustrates the place of the TCP in the protocol
put:ahierarchy:
put:a+------+ +:-----+ +-----+       +-----+                    
put:a|Telnet| |: FTP | |Voice|  ...  |     |  Application Level 
put:a+------+ +:-----+ +-----+       +-----+                    
put:a|   :|         |             |                       
put:a+----:-+     +-----+       +-----+                    
put:a| TCP: |     | RTP |  ...  |     |  Host Level        
put:a+----:-+     +-----+       +-----+                    
put:a| :          |             |                       
put:a+----:---------------------------+                    
put:a|    :Internet Protocol & ICMP   |  Gateway Level     
put:a+----:---------------------------+                    
put:a+--:-------------------------+                      
put:a|  : Local Network Protocol  |    Network Level     
put:a+--:-------------------------+                      
put:aIt is expected :that the TCP will be able to support higher level
put:aprotocols effic:iently.  It should be easy to interface higher level
put:aprotocols like :the ARPANET Telnet or AUTODIN II THP to the TCP.
put:a2.6.  Reliable Co:mmunication
put:aA stream of dat:a sent on a TCP connection is delivered reliably and in
put:aorder at the de:stination.
put:aTransmission Cont:rol Protocol
put:aTransmission is: made reliable via the use of sequence numbers and
put:aacknowledgments:.  Conceptually, each octet of data is assigned a
put:asequence number:.  The sequence number of the first octet of data in a
put:asegment is tran:smitted with that segment and is called the segment
put:asequence number:.  Segments also carry an acknowledgment number which
put:ais the sequence: number of the next expected data octet of
put:atransmissions i:n the reverse direction.  When the TCP transmits a
put:asegment contain:ing data, it puts a copy on a retransmission queue and
put:astarts a timer;: when the acknowledgment for that data is received, the
put:asegment is dele:ted from the queue.  If the acknowledgment is not
put:areceived before: the timer runs out, the segment is retransmitted.
put:aAn acknowledgme:nt by TCP does not guarantee that the data has been
put:adelivered to th:e end user, but only that the receiving TCP has taken
put:athe responsibil:ity to do so.
put:aTo govern the f:low of data between TCPs, a flow control mechanism is
put:aemployed.  The :receiving TCP reports a "window" to the sending TCP.
put:aThis window spe:cifies the number of octets, starting with the
put:aacknowledgment :number, that the receiving TCP is currently prepared to
put:a2.7.  Connection :Establishment and Clearing
put:aTo identify the: separate data streams that a TCP may handle, the TCP
put:aprovides a port: identifier.  Since port identifiers are selected
put:aindependently b:y each TCP they might not be unique.  To provide for
put:aunique addresse:s within each TCP, we concatenate an internet address
put:aidentifying the: TCP with a port identifier to create a socket which
put:awill be unique :throughout all networks connected together.
put:aA connection is: fully specified by the pair of sockets at the ends.  A
put:alocal socket ma:y participate in many connections to different foreign
put:asockets.  A con:nection can be used to carry data in both directions,
put:athat is, it is :"full duplex".
put:aTCPs are free t:o associate ports with processes however they choose.
put:aHowever, severa:l basic concepts are necessary in any implementation.
put:aThere must be w:ell-known sockets which the TCP associates only with
put:athe "appropriat:e" processes by some means.  We envision that processes
put:amay "own" ports:, and that processes can initiate connections only on
put:athe ports they :own.  (Means for implementing ownership is a local
put:aissue, but we e:nvision a Request Port user command, or a method of
put:auniquely alloca:ting a group of ports to a given process, e.g., by
put:aassociating the: high order bits of a port name with a given process.)
put:aA connection is: specified in the OPEN call by the local port and
put:aforeign socket :arguments.  In return, the TCP supplies a (short) local
put:a[Page 10]        :                                                       
put:aSeptember 1981   :                                                       
put:aconnection name: by which the user refers to the connection in
put:asubsequent call:s.  There are several things that must be remembered
put:aabout a connect:ion.  To store this information we imagine that there
put:ais a data struc:ture called a Transmission Control Block (TCB).  One
put:aimplementation :strategy would have the local connection name be a
put:apointer to the :TCB for this connection.  The OPEN call also specifies
put:awhether the con:nection establishment is to be actively pursued, or to
put:abe passively wa:ited for.
put:aA passive OPEN :request means that the process wants to accept incoming
put:aconnection requ:ests rather than attempting to initiate a connection.
put:aOften the proce:ss requesting a passive OPEN will accept a connection
put:arequest from an:y caller.  In this case a foreign socket of all zeros
put:ais used to deno:te an unspecified socket.  Unspecified foreign sockets
put:aare allowed onl:y on passive OPENs.
put:aA service proce:ss that wished to provide services for unknown other
put:aprocesses would: issue a passive OPEN request with an unspecified
put:aforeign socket.:  Then a connection could be made with any process that
put:arequested a con:nection to this local socket.  It would help if this
put:alocal socket we:re known to be associated with this service.
put:aWell-known sock:ets are a convenient mechanism for a priori associating
put:aa socket addres:s with a standard service.  For instance, the
put:a"Telnet-Server": process is permanently assigned to a particular
put:asocket, and oth:er sockets are reserved for File Transfer, Remote Job
put:aEntry, Text Gen:erator, Echoer, and Sink processes (the last three
put:abeing for test :purposes).  A socket address might be reserved for
put:aaccess to a "Lo:ok-Up" service which would return the specific socket
put:aat which a newl:y created service would be provided.  The concept of a
put:awell-known sock:et is part of the TCP specification, but the assignment
put:aof sockets to s:ervices is outside this specification.  (See [4].)
put:aProcesses can i:ssue passive OPENs and wait for matching active OPENs
put:afrom other proc:esses and be informed by the TCP when connections have
put:abeen establishe:d.  Two processes which issue active OPENs to each
put:aother at the sa:me time will be correctly connected.  This flexibility
put:ais critical for: the support of distributed computing in which
put:acomponents act :asynchronously with respect to each other.
put:aThere are two p:rincipal cases for matching the sockets in the local
put:apassive OPENs a:nd an foreign active OPENs.  In the first case, the
put:alocal passive O:PENs has fully specified the foreign socket.  In this
put:acase, the match: must be exact.  In the second case, the local passive
put:aOPENs has left :the foreign socket unspecified.  In this case, any
put:aforeign socket :is acceptable as long as the local sockets match.
put:aOther possibili:ties include partially restricted matches.
put:aTransmission Cont:rol Protocol
put:aIf there are se:veral pending passive OPENs (recorded in TCBs) with the
put:asame local sock:et, an foreign active OPEN will be matched to a TCB
put:awith the specif:ic foreign socket in the foreign active OPEN, if such a
put:aTCB exists, bef:ore selecting a TCB with an unspecified foreign socket.
put:aThe procedures :to establish connections utilize the synchronize (SYN)
put:acontrol flag an:d involves an exchange of three messages.  This
put:aexchange has be:en termed a three-way hand shake [3].
put:aA connection is: initiated by the rendezvous of an arriving segment
put:acontaining a SY:N and a waiting TCB entry each created by a user OPEN
put:acommand.  The m:atching of local and foreign sockets determines when a
put:aconnection has :been initiated.  The connection becomes "established"
put:awhen sequence n:umbers have been synchronized in both directions.
put:aThe clearing of: a connection also involves the exchange of segments,
put:ain this case ca:rrying the FIN control flag.
put:a2.8.  Data Commun:ication
put:aThe data that f:lows on a connection may be thought of as a stream of
put:aoctets.  The se:nding user indicates in each SEND call whether the data
put:ain that call (a:nd any preceeding calls) should be immediately pushed
put:athrough to the :receiving user by the setting of the PUSH flag.
put:aA sending TCP i:s allowed to collect data from the sending user and to
put:asend that data :in segments at its own convenience, until the push
put:afunction is sig:naled, then it must send all unsent data.  When a
put:areceiving TCP s:ees the PUSH flag, it must not wait for more data from
put:athe sending TCP: before passing the data to the receiving process.
put:aThere is no nec:essary relationship between push functions and segment
put:aboundaries.  Th:e data in any particular segment may be the result of a
put:asingle SEND cal:l, in whole or part, or of multiple SEND calls.
put:aThe purpose of :push function and the PUSH flag is to push data through
put:afrom the sendin:g user to the receiving user.  It does not provide a
put:arecord service.:
put:aThere is a coup:ling between the push function and the use of buffers
put:aof data that cr:oss the TCP/user interface.  Each time a PUSH flag is
put:aassociated with: data placed into the receiving user's buffer, the
put:abuffer is retur:ned to the user for processing even if the buffer is
put:anot filled.  If: data arrives that fills the user's buffer before a
put:aPUSH is seen, t:he data is passed to the user in buffer size units.
put:aTCP also provid:es a means to communicate to the receiver of data that
put:aat some point f:urther along in the data stream than the receiver is
put:a[Page 12]        :                                                       
put:aSeptember 1981   :                                                       
put:acurrently readi:ng there is urgent data.  TCP does not attempt to
put:adefine what the: user specifically does upon being notified of pending
put:aurgent data, bu:t the general notion is that the receiving process will
put:atake action to :process the urgent data quickly.
put:a2.9.  Precedence :and Security
put:aThe TCP makes u:se of the internet protocol type of service field and
put:asecurity option: to provide precedence and security on a per connection
put:abasis to TCP us:ers.  Not all TCP modules will necessarily function in
put:aa multilevel se:cure environment; some may be limited to unclassified
put:ause only, and o:thers may operate at only one security level and
put:acompartment.  C:onsequently, some TCP implementations and services to
put:ausers may be li:mited to a subset of the multilevel secure case.
put:aTCP modules whi:ch operate in a multilevel secure environment must
put:aproperly mark o:utgoing segments with the security, compartment, and
put:aprecedence.  Su:ch TCP modules must also provide to their users or
put:ahigher level pr:otocols such as Telnet or THP an interface to allow
put:athem to specify: the desired security level, compartment, and
put:aprecedence of c:onnections.
put:a2.10.  Robustness: Principle
put:aTCP implementat:ions will follow a general principle of robustness:  be
put:aconservative in: what you do, be liberal in what you accept from
put:aTransmission Cont:rol Protocol
put:a[Page 14]        :                                                       
put:aSeptember 1981   :                                                       
put:a3.1.  Header Form:at
put:aTCP segments ar:e sent as internet datagrams.  The Internet Protocol
put:aheader carries :several information fields, including the source and
put:adestination hos:t addresses [2].  A TCP header follows the internet
put:aheader, supplyi:ng information specific to the TCP protocol.  This
put:adivision allows: for the existence of host level protocols other than
put:aTCP Header Form:at
put:a0            :       1                   2                   3   
put:a0 1 2 3 4 5 6: 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 
put:a+-+-+-+-+-+-+-:+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
put:a|          Sou:rce Port          |       Destination Port        |
put:a+-+-+-+-+-+-+-:+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
put:a|             :           Sequence Number                        |
put:a+-+-+-+-+-+-+-:+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
put:a|             :       Acknowledgment Number                      |
put:a+-+-+-+-+-+-+-:+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
put:a|  Data |     :      |U|A|P|R|S|F|                               |
put:a| Offset| Rese:rved  |R|C|S|S|Y|I|            Window             |
put:a|       |     :      |G|K|H|T|N|N|                               |
put:a+-+-+-+-+-+-+-:+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
put:a|           Ch:ecksum            |         Urgent Pointer        |
put:a+-+-+-+-+-+-+-:+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
put:a|             :       Options                    |    Padding    |
put:a+-+-+-+-+-+-+-:+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
put:a|             :                data                              |
put:a+-+-+-+-+-+-+-:+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
put:aNote th:at one tick mark represents one bit position.
put:aSource Port:  1:6 bits
put:aThe source po:rt number.
put:aDestination Por:t:  16 bits
put:aThe destinati:on port number.
put:aTransmission Cont:rol Protocol
put:aFunctional Specif:ication
put:aSequence Number::  32 bits
put:aThe sequence :number of the first data octet in this segment (except
put:awhen SYN is p:resent). If SYN is present the sequence number is the
put:ainitial seque:nce number (ISN) and the first data octet is ISN+1.
put:aAcknowledgment :Number:  32 bits
put:aIf the ACK co:ntrol bit is set this field contains the value of the
put:anext sequence: number the sender of the segment is expecting to
put:areceive.  Onc:e a connection is established this is always sent.
put:aData Offset:  4: bits
put:aThe number of: 32 bit words in the TCP Header.  This indicates where
put:athe data begi:ns.  The TCP header (even one including options) is an
put:aintegral numb:er of 32 bits long.
put:aReserved:  6 bi:ts
put:aReserved for :future use.  Must be zero.
put:aControl Bits:  :6 bits (from left to right):
put:aURG:  Urgent :Pointer field significant
put:aACK:  Acknowl:edgment field significant
put:aPSH:  Push Fu:nction
put:aRST:  Reset t:he connection
put:aSYN:  Synchro:nize sequence numbers
put:aFIN:  No more: data from sender
put:aWindow:  16 bit:s
put:aThe number of: data octets beginning with the one indicated in the
put:aacknowledgmen:t field which the sender of this segment is willing to
put:aChecksum:  16 b:its
put:aThe checksum :field is the 16 bit one's complement of the one's
put:acomplement su:m of all 16 bit words in the header and text.  If a
put:asegment conta:ins an odd number of header and text octets to be
put:achecksummed, :the last octet is padded on the right with zeros to
put:aform a 16 bit: word for checksum purposes.  The pad is not
put:atransmitted a:s part of the segment.  While computing the checksum,
put:athe checksum :field itself is replaced with zeros.
put:aThe checksum :also covers a 96 bit pseudo header conceptually
put:a[Page 16]        :                                                       
put:aSeptember 1981   :                                                       
put:aprefixed to t:he TCP header.  This pseudo header contains the Source
put:aAddress, the :Destination Address, the Protocol, and TCP length.
put:aThis gives th:e TCP protection against misrouted segments.  This
put:ainformation i:s carried in the Internet Protocol and is transferred
put:aacross the TC:P/Network interface in the arguments or results of
put:acalls by the :TCP on the IP.
put:aThe TCP Len:gth is the TCP header length plus the data length in
put:aoctets (thi:s is not an explicitly transmitted quantity, but is
put:acomputed), :and it does not count the 12 octets of the pseudo
put:aUrgent Pointer::  16 bits
put:aThis field co:mmunicates the current value of the urgent pointer as a
put:apositive offs:et from the sequence number in this segment.  The
put:aurgent pointe:r points to the sequence number of the octet following
put:athe urgent da:ta.  This field is only be interpreted in segments with
put:athe URG contr:ol bit set.
put:aOptions:  varia:ble
put:aOptions may o:ccupy space at the end of the TCP header and are a
put:amultiple of 8: bits in length.  All options are included in the
put:achecksum.  An: option may begin on any octet boundary.  There are two
put:acases for the: format of an option:
put:aCase 1:  A :single octet of option-kind.
put:aCase 2:  An: octet of option-kind, an octet of option-length, and
put:ath:e actual option-data octets.
put:aThe option-le:ngth counts the two octets of option-kind and
put:aoption-length: as well as the option-data octets.
put:aNote that the: list of options may be shorter than the data offset
put:afield might i:mply.  The content of the header beyond the
put:aEnd-of-Option: option must be header padding (i.e., zero).
put:aA TCP must im:plement all options.
put:aTransmission Cont:rol Protocol
put:aFunctional Specif:ication
put:aCurrently def:ined options include (kind indicated in octal):
put:aKind     Le:ngth    Meaning
put:a----     --:----    -------
put:a0         :-       End of option list.
put:a1         :-       No-Operation.
put:a2         :4       Maximum Segment Size.
put:aSpecific Opti:on Definitions
put:aEnd of Opti:on List
put:a+--------:+
put:a|00000000:|
put:a+--------:+
put:aThis opti:on code indicates the end of the option list.  This
put:amight not: coincide with the end of the TCP header according to
put:athe Data :Offset field.  This is used at the end of all options,
put:anot the e:nd of each option, and need only be used if the end of
put:athe optio:ns would not otherwise coincide with the end of the TCP
put:aNo-Operatio:n
put:a+--------:+
put:a|00000001:|
put:a+--------:+
put:aThis opti:on code may be used between options, for example, to
put:aalign the: beginning of a subsequent option on a word boundary.
put:aThere is :no guarantee that senders will use this option, so
put:areceivers: must be prepared to process options even if they do
put:anot begin: on a word boundary.
put:aMaximum Seg:ment Size
put:a+--------:+--------+---------+--------+
put:a|00000010:|00000100|   max seg size   |
put:a+--------:+--------+---------+--------+
put:aKind=2  : Length=4
put:a[Page 18]        :                                                       
put:aSeptember 1981   :                                                       
put:aMaximum S:egment Size Option Data:  16 bits
put:aIf this: option is present, then it communicates the maximum
put:areceive: segment size at the TCP which sends this segment.
put:aThis fi:eld must only be sent in the initial connection request
put:a(i.e., :in segments with the SYN control bit set).  If this
put:aoption :is not used, any segment size is allowed.
put:aPadding:  varia:ble
put:aThe TCP heade:r padding is used to ensure that the TCP header ends
put:aand data begi:ns on a 32 bit boundary.  The padding is composed of
put:a3.2.  Terminology:
put:aBefore we can d:iscuss very much about the operation of the TCP we need
put:ato introduce so:me detailed terminology.  The maintenance of a TCP
put:aconnection requ:ires the remembering of several variables.  We conceive
put:aof these variab:les being stored in a connection record called a
put:aTransmission Co:ntrol Block or TCB.  Among the variables stored in the
put:aTCB are the loc:al and remote socket numbers, the security and
put:aprecedence of t:he connection, pointers to the user's send and receive
put:abuffers, pointe:rs to the retransmit queue and to the current segment.
put:aIn addition sev:eral variables relating to the send and receive
put:asequence number:s are stored in the TCB.
put:aSend Sequence: Variables
put:aSND.UNA - s:end unacknowledged
put:aSND.NXT - s:end next
put:aSND.WND - s:end window
put:aSND.UP  - s:end urgent pointer
put:aSND.WL1 - s:egment sequence number used for last window update
put:aSND.WL2 - s:egment acknowledgment number used for last window
put:au:pdate
put:aISS     - i:nitial send sequence number
put:aReceive Seque:nce Variables
put:aRCV.NXT - r:eceive next
put:aRCV.WND - r:eceive window
put:aRCV.UP  - r:eceive urgent pointer
put:aIRS     - i:nitial receive sequence number
put:aTransmission Cont:rol Protocol
put:aFunctional Specif:ication
put:aThe following d:iagrams may help to relate some of these variables to
put:athe sequence sp:ace.
put:aSend Sequence S:pace
put:a---:-------|----------|----------|---------- 
put:a1 - old s:equence numbers which have been acknowledged  
put:a2 - seque:nce numbers of unacknowledged data            
put:a3 - seque:nce numbers allowed for new data transmission 
put:a4 - futur:e sequence numbers which are not yet allowed  
put:aThe send window: is the portion of the sequence space labeled 3 in
put:aReceive Sequenc:e Space
put:a1 - old s:equence numbers which have been acknowledged  
put:a2 - seque:nce numbers allowed for new reception         
put:a3 - futur:e sequence numbers which are not yet allowed  
put:aThe receive win:dow is the portion of the sequence space labeled 2 in
put:aThere are also :some variables used frequently in the discussion that
put:atake their valu:es from the fields of the current segment.
put:a[Page 20]        :                                                       
put:aSeptember 1981   :                                                       
put:aCurrent Segme:nt Variables
put:aSEG.SEQ - s:egment sequence number
put:aSEG.ACK - s:egment acknowledgment number
put:aSEG.LEN - s:egment length
put:aSEG.WND - s:egment window
put:aSEG.UP  - s:egment urgent pointer
put:aSEG.PRC - s:egment precedence value
put:aA connection pr:ogresses through a series of states during its
put:alifetime.  The :states are:  LISTEN, SYN-SENT, SYN-RECEIVED,
put:aESTABLISHED, FI:N-WAIT-1, FIN-WAIT-2, CLOSE-WAIT, CLOSING, LAST-ACK,
put:aTIME-WAIT, and :the fictional state CLOSED.  CLOSED is fictional
put:abecause it repr:esents the state when there is no TCB, and therefore,
put:ano connection. : Briefly the meanings of the states are:
put:aLISTEN - repr:esents waiting for a connection request from any remote
put:aTCP and port.:
put:aSYN-SENT - re:presents waiting for a matching connection request
put:aafter having :sent a connection request.
put:aSYN-RECEIVED :- represents waiting for a confirming connection
put:arequest ackno:wledgment after having both received and sent a
put:aconnection re:quest.
put:aESTABLISHED -: represents an open connection, data received can be
put:adelivered to :the user.  The normal state for the data transfer phase
put:aof the connec:tion.
put:aFIN-WAIT-1 - :represents waiting for a connection termination request
put:afrom the remo:te TCP, or an acknowledgment of the connection
put:atermination r:equest previously sent.
put:aFIN-WAIT-2 - :represents waiting for a connection termination request
put:afrom the remo:te TCP.
put:aCLOSE-WAIT - :represents waiting for a connection termination request
put:afrom the loca:l user.
put:aCLOSING - rep:resents waiting for a connection termination request
put:aacknowledgmen:t from the remote TCP.
put:aLAST-ACK - re:presents waiting for an acknowledgment of the
put:aconnection te:rmination request previously sent to the remote TCP
put:a(which includ:es an acknowledgment of its connection termination
put:aTransmission Cont:rol Protocol
put:aFunctional Specif:ication
put:aTIME-WAIT - r:epresents waiting for enough time to pass to be sure
put:athe remote TC:P received the acknowledgment of its connection
put:atermination r:equest.
put:aCLOSED - repr:esents no connection state at all.
put:aA TCP connectio:n progresses from one state to another in response to
put:aevents.  The ev:ents are the user calls, OPEN, SEND, RECEIVE, CLOSE,
put:aABORT, and STAT:US; the incoming segments, particularly those
put:acontaining the :SYN, ACK, RST and FIN flags; and timeouts.
put:aThe state diagr:am in figure 6 illustrates only state changes, together
put:awith the causin:g events and resulting actions, but addresses neither
put:aerror condition:s nor actions which are not connected with state
put:achanges.  In a :later section, more detail is offered with respect to
put:athe reaction of: the TCP to events.
put:aNOTE BENE:  thi:s diagram is only a summary and must not be taken as
put:athe total speci:fication.
put:a[Page 22]        :                                                       
put:aSeptember 1981   :                                                       
put:a+---------+     : snd SYN,ACK  /       \   snd SYN          +---------+
put:a|         |<----:-------------           ------------------>|         |
put:a|   SYN   |     :               rcv SYN                     |   SYN   |
put:a|   RCVD  |<----:-------------------------------------------|   SENT  |
put:a|         |     :               snd ACK                     |         |
put:a|         |-----:-------------           -------------------|         |
put:a+---------+   rc:v ACK of SYN  \       /  rcv SYN,ACK       +---------+
put:a|           --:------------   |     |   -----------                  
put:a|             :     x         |     |     snd ACK                    
put:a|             :               V     V                                
put:a|  CLOSE      :             +---------+                              
put:a| -------     :             |  ESTAB  |                              
put:a| snd FIN     :             +---------+                              
put:a|             :      CLOSE    |     |    rcv FIN                     
put:aV             :     -------   |     |    -------                     
put:a+---------+     :     snd FIN  /       \   snd ACK          +---------+
put:a|  FIN    |<----:-------------           ------------------>|  CLOSE  |
put:a| WAIT-1  |-----:-------------                              |   WAIT  |
put:a+---------+     :     rcv FIN  \                            +---------+
put:a| rcv ACK of F:IN   -------   |                            CLOSE  |  
put:a| ------------:--   snd ACK   |                           ------- |  
put:aV        x    :               V                           snd FIN V  
put:a+---------+     :             +---------+                   +---------+
put:a|FINWAIT-2|     :             | CLOSING |                   | LAST-ACK|
put:a+---------+     :             +---------+                   +---------+
put:a|             :   rcv ACK of FIN |                 rcv ACK of FIN |  
put:a|  rcv FIN    :   -------------- |    Timeout=2MSL -------------- |  
put:a|  -------    :          x       V    ------------        x       V  
put:a\ snd ACK    :             +---------+delete TCB         +---------+
put:a------------:------------>|TIME WAIT|------------------>| CLOSED  |
put:aTransmission Cont:rol Protocol
put:aFunctional Specif:ication
put:a3.3.  Sequence Nu:mbers
put:aA fundamental n:otion in the design is that every octet of data sent
put:aover a TCP conn:ection has a sequence number.  Since every octet is
put:asequenced, each: of them can be acknowledged.  The acknowledgment
put:amechanism emplo:yed is cumulative so that an acknowledgment of sequence
put:anumber X indica:tes that all octets up to but not including X have been
put:areceived.  This: mechanism allows for straight-forward duplicate
put:adetection in th:e presence of retransmission.  Numbering of octets
put:awithin a segmen:t is that the first data octet immediately following
put:athe header is t:he lowest numbered, and the following octets are
put:anumbered consec:utively.
put:aIt is essential: to remember that the actual sequence number space is
put:afinite, though :very large.  This space ranges from 0 to 2**32 - 1.
put:aSince the space: is finite, all arithmetic dealing with sequence
put:anumbers must be: performed modulo 2**32.  This unsigned arithmetic
put:apreserves the r:elationship of sequence numbers as they cycle from
put:a2**32 - 1 to 0 :again.  There are some subtleties to computer modulo
put:aarithmetic, so :great care should be taken in programming the
put:acomparison of s:uch values.  The symbol "=<" means "less than or equal"
put:a(modulo 2**32).:
put:aThe typical kin:ds of sequence number comparisons which the TCP must
put:aperform include::
put:a(a)  Determin:ing that an acknowledgment refers to some sequence
put:anumber s:ent but not yet acknowledged.
put:a(b)  Determin:ing that all sequence numbers occupied by a segment
put:ahave bee:n acknowledged (e.g., to remove the segment from a
put:aretransm:ission queue).
put:a(c)  Determin:ing that an incoming segment contains sequence numbers
put:awhich ar:e expected (i.e., that the segment "overlaps" the
put:areceive :window).
put:a[Page 24]        :                                                       
put:aSeptember 1981   :                                                       
put:aIn response to :sending data the TCP will receive acknowledgments.  The
put:afollowing compa:risons are needed to process the acknowledgments.
put:aSND.UNA = old:est unacknowledged sequence number
put:aSND.NXT = nex:t sequence number to be sent
put:aSEG.ACK = ack:nowledgment from the receiving TCP (next sequence
put:anum:ber expected by the receiving TCP)
put:aSEG.SEQ = fir:st sequence number of a segment
put:aSEG.LEN = the: number of octets occupied by the data in the segment
put:a(co:unting SYN and FIN)
put:aSEG.SEQ+SEG.L:EN-1 = last sequence number of a segment
put:aA new acknowled:gment (called an "acceptable ack"), is one for which
put:athe inequality :below holds:
put:aSND.UNA < SEG:.ACK =< SND.NXT
put:aA segment on th:e retransmission queue is fully acknowledged if the sum
put:aof its sequence: number and length is less or equal than the
put:aacknowledgment :value in the incoming segment.
put:aWhen data is re:ceived the following comparisons are needed:
put:aRCV.NXT = nex:t sequence number expected on an incoming segments, and
put:ais the le:ft or lower edge of the receive window
put:aRCV.NXT+RCV.W:ND-1 = last sequence number expected on an incoming
put:asegment, :and is the right or upper edge of the receive window
put:aSEG.SEQ = fir:st sequence number occupied by the incoming segment
put:aSEG.SEQ+SEG.L:EN-1 = last sequence number occupied by the incoming
put:aA segment is ju:dged to occupy a portion of valid receive sequence
put:aRCV.NXT =< SE:G.SEQ < RCV.NXT+RCV.WND
put:aRCV.NXT =< SE:G.SEQ+SEG.LEN-1 < RCV.NXT+RCV.WND
put:aTransmission Cont:rol Protocol
put:aFunctional Specif:ication
put:aThe first part :of this test checks to see if the beginning of the
put:asegment falls i:n the window, the second part of the test checks to see
put:aif the end of t:he segment falls in the window; if the segment passes
put:aeither part of :the test it contains data in the window.
put:aActually, it is: a little more complicated than this.  Due to zero
put:awindows and zer:o length segments, we have four cases for the
put:aacceptability o:f an incoming segment:
put:aSegment Recei:ve  Test
put:aLength  Windo:w
put:a------- -----:--  -------------------------------------------
put:a0       0 :    SEG.SEQ = RCV.NXT
put:a0      >0 :    RCV.NXT =< SEG.SEQ < RCV.NXT+RCV.WND
put:a>0       0 :    not acceptable
put:a>0      >0 :    RCV.NXT =< SEG.SEQ < RCV.NXT+RCV.WND
put:aNote that when :the receive window is zero no segments should be
put:aacceptable exce:pt ACK segments.  Thus, it is be possible for a TCP to
put:amaintain a zero: receive window while transmitting data and receiving
put:aACKs.  However,: even when the receive window is zero, a TCP must
put:aprocess the RST: and URG fields of all incoming segments.
put:aWe have taken a:dvantage of the numbering scheme to protect certain
put:acontrol informa:tion as well.  This is achieved by implicitly including
put:asome control fl:ags in the sequence space so they can be retransmitted
put:aand acknowledge:d without confusion (i.e., one and only one copy of the
put:acontrol will be: acted upon).  Control information is not physically
put:acarried in the :segment data space.  Consequently, we must adopt rules
put:afor implicitly :assigning sequence numbers to control.  The SYN and FIN
put:aare the only co:ntrols requiring this protection, and these controls
put:aare used only a:t connection opening and closing.  For sequence number
put:apurposes, the S:YN is considered to occur before the first actual data
put:aoctet of the se:gment in which it occurs, while the FIN is considered
put:ato occur after :the last actual data octet in a segment in which it
put:aoccurs.  The se:gment length (SEG.LEN) includes both data and sequence
put:aspace occupying: controls.  When a SYN is present then SEG.SEQ is the
put:asequence number: of the SYN.
put:a[Page 26]        :                                                       
put:aSeptember 1981   :                                                       
put:aInitial Sequenc:e Number Selection
put:aThe protocol pl:aces no restriction on a particular connection being
put:aused over and o:ver again.  A connection is defined by a pair of
put:asockets.  New i:nstances of a connection will be referred to as
put:aincarnations of: the connection.  The problem that arises from this is
put:a-- "how does th:e TCP identify duplicate segments from previous
put:aincarnations of: the connection?"  This problem becomes apparent if the
put:aconnection is b:eing opened and closed in quick succession, or if the
put:aconnection brea:ks with loss of memory and is then reestablished.
put:aTo avoid confus:ion we must prevent segments from one incarnation of a
put:aconnection from: being used while the same sequence numbers may still
put:abe present in t:he network from an earlier incarnation.  We want to
put:aassure this, ev:en if a TCP crashes and loses all knowledge of the
put:asequence number:s it has been using.  When new connections are created,
put:aan initial sequ:ence number (ISN) generator is employed which selects a
put:anew 32 bit ISN.:  The generator is bound to a (possibly fictitious) 32
put:abit clock whose: low order bit is incremented roughly every 4
put:amicroseconds.  :Thus, the ISN cycles approximately every 4.55 hours.
put:aSince we assume: that segments will stay in the network no more than
put:athe Maximum Seg:ment Lifetime (MSL) and that the MSL is less than 4.55
put:ahours we can re:asonably assume that ISN's will be unique.
put:aFor each connec:tion there is a send sequence number and a receive
put:asequence number:.  The initial send sequence number (ISS) is chosen by
put:athe data sendin:g TCP, and the initial receive sequence number (IRS) is
put:alearned during :the connection establishing procedure.
put:aFor a connectio:n to be established or initialized, the two TCPs must
put:asynchronize on :each other's initial sequence numbers.  This is done in
put:aan exchange of :connection establishing segments carrying a control bit
put:acalled "SYN" (f:or synchronize) and the initial sequence numbers.  As a
put:ashorthand, segm:ents carrying the SYN bit are also called "SYNs".
put:aHence, the solu:tion requires a suitable mechanism for picking an
put:ainitial sequenc:e number and a slightly involved handshake to exchange
put:aThe synchroniza:tion requires each side to send it's own initial
put:asequence number: and to receive a confirmation of it in acknowledgment
put:afrom the other :side.  Each side must also receive the other side's
put:ainitial sequenc:e number and send a confirming acknowledgment.
put:a1) A --> B  S:YN my sequence number is X
put:a2) A <-- B  A:CK your sequence number is X
put:a3) A <-- B  S:YN my sequence number is Y
put:a4) A --> B  A:CK your sequence number is Y
put:aTransmission Cont:rol Protocol
put:aFunctional Specif:ication
put:aBecause steps 2: and 3 can be combined in a single message this is
put:acalled the thre:e way (or three message) handshake.
put:aA three way han:dshake is necessary because sequence numbers are not
put:atied to a globa:l clock in the network, and TCPs may have different
put:amechanisms for :picking the ISN's.  The receiver of the first SYN has
put:ano way of knowi:ng whether the segment was an old delayed one or not,
put:aunless it remem:bers the last sequence number used on the connection
put:a(which is not a:lways possible), and so it must ask the sender to
put:averify this SYN:.  The three way handshake and the advantages of a
put:aclock-driven sc:heme are discussed in [3].
put:aKnowing When to: Keep Quiet
put:aTo be sure that: a TCP does not create a segment that carries a
put:asequence number: which may be duplicated by an old segment remaining in
put:athe network, th:e TCP must keep quiet for a maximum segment lifetime
put:a(MSL) before as:signing any sequence numbers upon starting up or
put:arecovering from: a crash in which memory of sequence numbers in use was
put:alost.  For this: specification the MSL is taken to be 2 minutes.  This
put:ais an engineeri:ng choice, and may be changed if experience indicates
put:ait is desirable: to do so.  Note that if a TCP is reinitialized in some
put:asense, yet reta:ins its memory of sequence numbers in use, then it need
put:anot wait at all:; it must only be sure to use sequence numbers larger
put:athan those rece:ntly used.
put:aThe TCP Quiet T:ime Concept
put:aThis specific:ation provides that hosts which "crash" without
put:aretaining any: knowledge of the last sequence numbers transmitted on
put:aeach active (:i.e., not closed) connection shall delay emitting any
put:aTCP segments :for at least the agreed Maximum Segment Lifetime (MSL)
put:ain the intern:et system of which the host is a part.  In the
put:aparagraphs be:low, an explanation for this specification is given.
put:aTCP implement:ors may violate the "quiet time" restriction, but only
put:aat the risk o:f causing some old data to be accepted as new or new
put:adata rejected: as old duplicated by some receivers in the internet
put:aTCPs consume :sequence number space each time a segment is formed and
put:aentered into :the network output queue at a source host. The
put:aduplicate det:ection and sequencing algorithm in the TCP protocol
put:arelies on the: unique binding of segment data to sequence space to
put:athe extent th:at sequence numbers will not cycle through all 2**32
put:avalues before: the segment data bound to those sequence numbers has
put:abeen delivere:d and acknowledged by the receiver and all duplicate
put:acopies of the: segments have "drained" from the internet.  Without
put:asuch an assum:ption, two distinct TCP segments could conceivably be
put:a[Page 28]        :                                                       
put:aSeptember 1981   :                                                       
put:aassigned the :same or overlapping sequence numbers, causing confusion
put:aat the receiv:er as to which data is new and which is old.  Remember
put:athat each seg:ment is bound to as many consecutive sequence numbers
put:aas there are :octets of data in the segment.
put:aUnder normal :conditions, TCPs keep track of the next sequence number
put:ato emit and t:he oldest awaiting acknowledgment so as to avoid
put:amistakenly us:ing a sequence number over before its first use has
put:abeen acknowle:dged.  This alone does not guarantee that old duplicate
put:adata is drain:ed from the net, so the sequence space has been made
put:avery large to: reduce the probability that a wandering duplicate will
put:acause trouble: upon arrival.  At 2 megabits/sec. it takes 4.5 hours
put:ato use up 2**:32 octets of sequence space.  Since the maximum segment
put:alifetime in t:he net is not likely to exceed a few tens of seconds,
put:athis is deeme:d ample protection for foreseeable nets, even if data
put:arates escalat:e to l0's of megabits/sec.  At 100 megabits/sec, the
put:acycle time is: 5.4 minutes which may be a little short, but still
put:awithin reason:.
put:aThe basic dup:licate detection and sequencing algorithm in TCP can be
put:adefeated, how:ever, if a source TCP does not have any memory of the
put:asequence numb:ers it last used on a given connection. For example, if
put:athe TCP were :to start all connections with sequence number 0, then
put:aupon crashing: and restarting, a TCP might re-form an earlier
put:aconnection (p:ossibly after half-open connection resolution) and emit
put:apackets with :sequence numbers identical to or overlapping with
put:apackets still: in the network which were emitted on an earlier
put:aincarnation o:f the same connection.  In the absence of knowledge
put:aabout the seq:uence numbers used on a particular connection, the TCP
put:aspecification: recommends that the source delay for MSL seconds
put:abefore emitti:ng segments on the connection, to allow time for
put:asegments from: the earlier connection incarnation to drain from the
put:aEven hosts wh:ich can remember the time of day and used it to select
put:ainitial seque:nce number values are not immune from this problem
put:a(i.e., even i:f time of day is used to select an initial sequence
put:anumber for ea:ch new connection incarnation).
put:aSuppose, for :example, that a connection is opened starting with
put:asequence numb:er S.  Suppose that this connection is not used much
put:aand that even:tually the initial sequence number function (ISN(t))
put:atakes on a va:lue equal to the sequence number, say S1, of the last
put:asegment sent :by this TCP on a particular connection.  Now suppose,
put:aat this insta:nt, the host crashes, recovers, and establishes a new
put:aincarnation o:f the connection. The initial sequence number chosen is
put:aS1 = ISN(t) -:- last used sequence number on old incarnation of
put:aconnection!  :If the recovery occurs quickly enough, any old
put:aTransmission Cont:rol Protocol
put:aFunctional Specif:ication
put:aduplicates in: the net bearing sequence numbers in the neighborhood
put:aof S1 may arr:ive and be treated as new packets by the receiver of
put:athe new incar:nation of the connection.
put:aThe problem i:s that the recovering host may not know for how long it
put:acrashed nor d:oes it know whether there are still old duplicates in
put:athe system fr:om earlier connection incarnations.
put:aOne way to de:al with this problem is to deliberately delay emitting
put:asegments for :one MSL after recovery from a crash- this is the "quite
put:atime" specifi:cation.  Hosts which prefer to avoid waiting are
put:awilling to ri:sk possible confusion of old and new packets at a given
put:adestination m:ay choose not to wait for the "quite time".
put:aImplementors :may provide TCP users with the ability to select on a
put:aconnection by: connection basis whether to wait after a crash, or may
put:ainformally im:plement the "quite time" for all connections.
put:aObviously, ev:en where a user selects to "wait," this is not
put:anecessary aft:er the host has been "up" for at least MSL seconds.
put:aTo summarize:: every segment emitted occupies one or more sequence
put:anumbers in th:e sequence space, the numbers occupied by a segment are
put:a"busy" or "in: use" until MSL seconds have passed, upon crashing a
put:ablock of spac:e-time is occupied by the octets of the last emitted
put:asegment, if a: new connection is started too soon and uses any of the
put:asequence numb:ers in the space-time footprint of the last segment of
put:athe previous :connection incarnation, there is a potential sequence
put:anumber overla:p area which could cause confusion at the receiver.
put:a3.4.  Establishin:g a connection
put:aThe "three-way :handshake" is the procedure used to establish a
put:aconnection.  Th:is procedure normally is initiated by one TCP and
put:aresponded to by: another TCP.  The procedure also works if two TCP
put:asimultaneously :initiate the procedure.  When simultaneous attempt
put:aoccurs, each TC:P receives a "SYN" segment which carries no
put:aacknowledgment :after it has sent a "SYN".  Of course, the arrival of
put:aan old duplicat:e "SYN" segment can potentially make it appear, to the
put:arecipient, that: a simultaneous connection initiation is in progress.
put:aProper use of ":reset" segments can disambiguate these cases.
put:aSeveral example:s of connection initiation follow.  Although these
put:aexamples do not: show connection synchronization using data-carrying
put:asegments, this :is perfectly legitimate, so long as the receiving TCP
put:adoesn't deliver: the data to the user until it is clear the data is
put:avalid (i.e., th:e data must be buffered at the receiver until the
put:aconnection reac:hes the ESTABLISHED state).  The three-way handshake
put:areduces the pos:sibility of false connections.  It is the
put:a[Page 30]        :                                                       
put:aSeptember 1981   :                                                       
put:aimplementation :of a trade-off between memory and messages to provide
put:ainformation for: this checking.
put:aThe simplest th:ree-way handshake is shown in figure 7 below.  The
put:afigures should :be interpreted in the following way.  Each line is
put:anumbered for re:ference purposes.  Right arrows (-->) indicate
put:adeparture of a :TCP segment from TCP A to TCP B, or arrival of a
put:asegment at B fr:om A.  Left arrows (<--), indicate the reverse.
put:aEllipsis (...) :indicates a segment which is still in the network
put:a(delayed).  An :"XXX" indicates a segment which is lost or rejected.
put:aComments appear: in parentheses.  TCP states represent the state AFTER
put:athe departure o:r arrival of the segment (whose contents are shown in
put:athe center of e:ach line).  Segment contents are shown in abbreviated
put:aform, with sequ:ence number, control flags, and ACK field.  Other
put:afields such as :window, addresses, lengths, and text have been left out
put:ain the interest: of clarity.
put:aTCP A      :                                          TCP B
put:a1.  CLOSED     :                                          LISTEN
put:a2.  SYN-SENT   : --> <SEQ=100><CTL=SYN>               --> SYN-RECEIVED
put:a3.  ESTABLISHED: <-- <SEQ=300><ACK=101><CTL=SYN,ACK>  <-- SYN-RECEIVED
put:a4.  ESTABLISHED: --> <SEQ=101><ACK=301><CTL=ACK>       --> ESTABLISHED
put:a5.  ESTABLISHED: --> <SEQ=101><ACK=301><CTL=ACK><DATA> --> ESTABLISHED
put:aBasic 3:-Way Handshake for Connection Synchronization
put:aIn line 2 of fi:gure 7, TCP A begins by sending a SYN segment
put:aindicating that: it will use sequence numbers starting with sequence
put:anumber 100.  In: line 3, TCP B sends a SYN and acknowledges the SYN it
put:areceived from T:CP A.  Note that the acknowledgment field indicates TCP
put:aB is now expect:ing to hear sequence 101, acknowledging the SYN which
put:aoccupied sequen:ce 100.
put:aAt line 4, TCP :A responds with an empty segment containing an ACK for
put:aTCP B's SYN; an:d in line 5, TCP A sends some data.  Note that the
put:asequence number: of the segment in line 5 is the same as in line 4
put:abecause the ACK: does not occupy sequence number space (if it did, we
put:awould wind up A:CKing ACK's!).
put:aTransmission Cont:rol Protocol
put:aFunctional Specif:ication
put:aSimultaneous in:itiation is only slightly more complex, as is shown in
put:afigure 8.  Each: TCP cycles from CLOSED to SYN-SENT to SYN-RECEIVED to
put:aTCP A      :                                      TCP B
put:a1.  CLOSED     :                                      CLOSED
put:a2.  SYN-SENT   :  --> <SEQ=100><CTL=SYN>              ...
put:a3.  SYN-RECEIVE:D <-- <SEQ=300><CTL=SYN>              <-- SYN-SENT
put:a4.             :  ... <SEQ=100><CTL=SYN>              --> SYN-RECEIVED
put:a5.  SYN-RECEIVE:D --> <SEQ=100><ACK=301><CTL=SYN,ACK> ...
put:a6.  ESTABLISHED:  <-- <SEQ=300><ACK=101><CTL=SYN,ACK> <-- SYN-RECEIVED
put:a7.             :  ... <SEQ=101><ACK=301><CTL=ACK>     --> ESTABLISHED
put:aS:imultaneous Connection Synchronization
put:aThe principle r:eason for the three-way handshake is to prevent old
put:aduplicate conne:ction initiations from causing confusion.  To deal with
put:athis, a special: control message, reset, has been devised.  If the
put:areceiving TCP i:s in a  non-synchronized state (i.e., SYN-SENT,
put:aSYN-RECEIVED), :it returns to LISTEN on receiving an acceptable reset.
put:aIf the TCP is i:n one of the synchronized states (ESTABLISHED,
put:aFIN-WAIT-1, FIN:-WAIT-2, CLOSE-WAIT, CLOSING, LAST-ACK, TIME-WAIT), it
put:aaborts the conn:ection and informs its user.  We discuss this latter
put:acase under "hal:f-open" connections below.
put:a[Page 32]        :                                                       
put:aSeptember 1981   :                                                       
put:aTCP A      :                                          TCP B
put:a1.  CLOSED     :                                          LISTEN
put:a2.  SYN-SENT   : --> <SEQ=100><CTL=SYN>               ...
put:a3.  (duplicate): ... <SEQ=90><CTL=SYN>               --> SYN-RECEIVED
put:a4.  SYN-SENT   : <-- <SEQ=300><ACK=91><CTL=SYN,ACK>  <-- SYN-RECEIVED
put:a5.  SYN-SENT   : --> <SEQ=91><CTL=RST>               --> LISTEN
put:a6.             : ... <SEQ=100><CTL=SYN>               --> SYN-RECEIVED
put:a7.  SYN-SENT   : <-- <SEQ=400><ACK=101><CTL=SYN,ACK>  <-- SYN-RECEIVED
put:a8.  ESTABLISHED: --> <SEQ=101><ACK=401><CTL=ACK>      --> ESTABLISHED
put:aAs a simple exa:mple of recovery from old duplicates, consider
put:afigure 9.  At l:ine 3, an old duplicate SYN arrives at TCP B.  TCP B
put:acannot tell tha:t this is an old duplicate, so it responds normally
put:a(line 4).  TCP :A detects that the ACK field is incorrect and returns a
put:aRST (reset) wit:h its SEQ field selected to make the segment
put:abelievable.  TC:P B, on receiving the RST, returns to the LISTEN state.
put:aWhen the origin:al SYN (pun intended) finally arrives at line 6, the
put:asynchronization: proceeds normally.  If the SYN at line 6 had arrived
put:abefore the RST,: a more complex exchange might have occurred with RST's
put:asent in both di:rections.
put:aHalf-Open Conne:ctions and Other Anomalies
put:aAn established :connection is said to be  "half-open" if one of the
put:aTCPs has closed: or aborted the connection at its end without the
put:aknowledge of th:e other, or if the two ends of the connection have
put:abecome desynchr:onized owing to a crash that resulted in loss of
put:amemory.  Such c:onnections will automatically become reset if an
put:aattempt is made: to send data in either direction.  However, half-open
put:aconnections are: expected to be unusual, and the recovery procedure is
put:amildly involved:.
put:aIf at site A th:e connection no longer exists, then an attempt by the
put:aTransmission Cont:rol Protocol
put:aFunctional Specif:ication
put:auser at site B :to send any data on it will result in the site B TCP
put:areceiving a res:et control message.  Such a message indicates to the
put:asite B TCP that: something is wrong, and it is expected to abort the
put:aAssume that two: user processes A and B are communicating with one
put:aanother when a :crash occurs causing loss of memory to A's TCP.
put:aDepending on th:e operating system supporting A's TCP, it is likely
put:athat some error: recovery mechanism exists.  When the TCP is up again,
put:aA is likely to :start again from the beginning or from a recovery
put:apoint.  As a re:sult, A will probably try to OPEN the connection again
put:aor try to SEND :on the connection it believes open.  In the latter
put:acase, it receiv:es the error message "connection not open" from the
put:alocal (A's) TCP:.  In an attempt to establish the connection, A's TCP
put:awill send a seg:ment containing SYN.  This scenario leads to the
put:aexample shown i:n figure 10.  After TCP A crashes, the user attempts to
put:are-open the con:nection.  TCP B, in the meantime, thinks the connection
put:aTCP A      :                                     TCP B
put:a1.  (CRASH)    :                           (send 300,receive 100)
put:a2.  CLOSED     :                                      ESTABLISHED
put:a3.  SYN-SENT --:> <SEQ=400><CTL=SYN>              --> (??)
put:a4.  (!!)     <-:- <SEQ=300><ACK=100><CTL=ACK>     <-- ESTABLISHED
put:a5.  SYN-SENT --:> <SEQ=100><CTL=RST>              --> (Abort!!)
put:a6.  SYN-SENT   :                                      CLOSED
put:a7.  SYN-SENT --:> <SEQ=400><CTL=SYN>              -->
put:aWhen the SYN ar:rives at line 3, TCP B, being in a synchronized state,
put:aand the incomin:g segment outside the window, responds with an
put:aacknowledgment :indicating what sequence it next expects to hear (ACK
put:a100).  TCP A se:es that this segment does not acknowledge anything it
put:asent and, being: unsynchronized, sends a reset (RST) because it has
put:adetected a half:-open connection.  TCP B aborts at line 5.  TCP A will
put:a[Page 34]        :                                                       
put:aSeptember 1981   :                                                       
put:acontinue to try: to establish the connection; the problem is now
put:areduced to the :basic 3-way handshake of figure 7.
put:aAn interesting :alternative case occurs when TCP A crashes and TCP B
put:atries to send d:ata on what it thinks is a synchronized connection.
put:aThis is illustr:ated in figure 11.  In this case, the data arriving at
put:aTCP A from TCP :B (line 2) is unacceptable because no such connection
put:aexists, so TCP :A sends a RST.  The RST is acceptable so TCP B
put:aprocesses it an:d aborts the connection.
put:aTCP A    :                                          TCP B
put:a1.  (CRASH)    :                               (send 300,receive 100)
put:a2.  (??)    <--: <SEQ=300><ACK=100><DATA=10><CTL=ACK> <-- ESTABLISHED
put:a3.          -->: <SEQ=100><CTL=RST>                   --> (ABORT!!)
put:aActive: Side Causes Half-Open Connection Discovery
put:aIn figure 12, w:e find the two TCPs A and B with passive connections
put:awaiting for SYN:.  An old duplicate arriving at TCP B (line 2) stirs B
put:ainto action.  A: SYN-ACK is returned (line 3) and causes TCP A to
put:agenerate a RST :(the ACK in line 3 is not acceptable).  TCP B accepts
put:athe reset and r:eturns to its passive LISTEN state.
put:aTCP A      :                                   TCP B
put:a1.  LISTEN     :                                   LISTEN
put:a2.       ... <S:EQ=Z><CTL=SYN>                -->  SYN-RECEIVED
put:a3.  (??) <-- <S:EQ=X><ACK=Z+1><CTL=SYN,ACK>   <--  SYN-RECEIVED
put:a4.       --> <S:EQ=Z+1><CTL=RST>              -->  (return to LISTEN!)
put:a5.  LISTEN     :                                   LISTEN
put:aOld Duplic:ate SYN Initiates a Reset on two Passive Sockets
put:aTransmission Cont:rol Protocol
put:aFunctional Specif:ication
put:aA variety of ot:her cases are possible, all of which are accounted for
put:aby the followin:g rules for RST generation and processing.
put:aReset Generatio:n
put:aAs a general ru:le, reset (RST) must be sent whenever a segment arrives
put:awhich apparentl:y is not intended for the current connection.  A reset
put:amust not be sen:t if it is not clear that this is the case.
put:aThere are three: groups of states:
put:a1.  If the co:nnection does not exist (CLOSED) then a reset is sent
put:ain response t:o any incoming segment except another reset.  In
put:aparticular, S:YNs addressed to a non-existent connection are rejected
put:aby this means:.
put:aIf the incomi:ng segment has an ACK field, the reset takes its
put:asequence numb:er from the ACK field of the segment, otherwise the
put:areset has seq:uence number zero and the ACK field is set to the sum
put:aof the sequen:ce number and segment length of the incoming segment.
put:aThe connectio:n remains in the CLOSED state.
put:a2.  If the co:nnection is in any non-synchronized state (LISTEN,
put:aSYN-SENT, SYN:-RECEIVED), and the incoming segment acknowledges
put:asomething not: yet sent (the segment carries an unacceptable ACK), or
put:aif an incomin:g segment has a security level or compartment which
put:adoes not exac:tly match the level and compartment requested for the
put:aconnection, a: reset is sent.
put:aIf our SYN ha:s not been acknowledged and the precedence level of the
put:aincoming segm:ent is higher than the precedence level requested then
put:aeither raise :the local precedence level (if allowed by the user and
put:athe system) o:r send a reset; or if the precedence level of the
put:aincoming segm:ent is lower than the precedence level requested then
put:acontinue as i:f the precedence matched exactly (if the remote TCP
put:acannot raise :the precedence level to match ours this will be
put:adetected in t:he next segment it sends, and the connection will be
put:aterminated th:en).  If our SYN has been acknowledged (perhaps in this
put:aincoming segm:ent) the precedence level of the incoming segment must
put:amatch the loc:al precedence level exactly, if it does not a reset
put:amust be sent.:
put:aIf the incomi:ng segment has an ACK field, the reset takes its
put:asequence numb:er from the ACK field of the segment, otherwise the
put:areset has seq:uence number zero and the ACK field is set to the sum
put:aof the sequen:ce number and segment length of the incoming segment.
put:aThe connectio:n remains in the same state.
put:a[Page 36]        :                                                       
put:aSeptember 1981   :                                                       
put:a3.  If the co:nnection is in a synchronized state (ESTABLISHED,
put:aFIN-WAIT-1, F:IN-WAIT-2, CLOSE-WAIT, CLOSING, LAST-ACK, TIME-WAIT),
put:aany unaccepta:ble segment (out of window sequence number or
put:aunacceptible :acknowledgment number) must elicit only an empty
put:aacknowledgmen:t segment containing the current send-sequence number
put:aand an acknow:ledgment indicating the next sequence number expected
put:ato be receive:d, and the connection remains in the same state.
put:aIf an incomin:g segment has a security level, or compartment, or
put:aprecedence wh:ich does not exactly match the level, and compartment,
put:aand precedenc:e requested for the connection,a reset is sent and
put:aconnection go:es to the CLOSED state.  The reset takes its sequence
put:anumber from t:he ACK field of the incoming segment.
put:aReset Processin:g
put:aIn all states e:xcept SYN-SENT, all reset (RST) segments are validated
put:aby checking the:ir SEQ-fields.  A reset is valid if its sequence number
put:ais in the windo:w.  In the SYN-SENT state (a RST received in response
put:ato an initial S:YN), the RST is acceptable if the ACK field
put:aacknowledges th:e SYN.
put:aThe receiver of: a RST first validates it, then changes state.  If the
put:areceiver was in: the LISTEN state, it ignores it.  If the receiver was
put:ain SYN-RECEIVED: state and had previously been in the LISTEN state,
put:athen the receiv:er returns to the LISTEN state, otherwise the receiver
put:aaborts the conn:ection and goes to the CLOSED state.  If the receiver
put:awas in any othe:r state, it aborts the connection and advises the user
put:aand goes to the: CLOSED state.
put:a3.5.  Closing a C:onnection
put:aCLOSE is an ope:ration meaning "I have no more data to send."  The
put:anotion of closi:ng a full-duplex connection is subject to ambiguous
put:ainterpretation,: of course, since it may not be obvious how to treat
put:athe receiving s:ide of the connection.  We have chosen to treat CLOSE
put:ain a simplex fa:shion.  The user who CLOSEs may continue to RECEIVE
put:auntil he is tol:d that the other side has CLOSED also.  Thus, a program
put:acould initiate :several SENDs followed by a CLOSE, and then continue to
put:aRECEIVE until s:ignaled that a RECEIVE failed because the other side
put:ahas CLOSED.  We: assume that the TCP will signal a user, even if no
put:aRECEIVEs are ou:tstanding, that the other side has closed, so the user
put:acan terminate h:is side gracefully.  A TCP will reliably deliver all
put:abuffers SENT be:fore the connection was CLOSED so a user who expects no
put:adata in return :need only wait to hear the connection was CLOSED
put:asuccessfully to: know that all his data was received at the destination
put:aTCP.  Users mus:t keep reading connections they close for sending until
put:athe TCP says no: more data.
put:aTransmission Cont:rol Protocol
put:aFunctional Specif:ication
put:aThere are essen:tially three cases:
put:a1) The user i:nitiates by telling the TCP to CLOSE the connection
put:a2) The remote: TCP initiates by sending a FIN control signal
put:a3) Both users: CLOSE simultaneously
put:aCase 1:  Local :user initiates the close
put:aIn this case,: a FIN segment can be constructed and placed on the
put:aoutgoing segm:ent queue.  No further SENDs from the user will be
put:aaccepted by t:he TCP, and it enters the FIN-WAIT-1 state.  RECEIVEs
put:aare allowed i:n this state.  All segments preceding and including FIN
put:awill be retra:nsmitted until acknowledged.  When the other TCP has
put:aboth acknowle:dged the FIN and sent a FIN of its own, the first TCP
put:acan ACK this :FIN.  Note that a TCP receiving a FIN will ACK but not
put:asend its own :FIN until its user has CLOSED the connection also.
put:aCase 2:  TCP re:ceives a FIN from the network
put:aIf an unsolic:ited FIN arrives from the network, the receiving TCP
put:acan ACK it an:d tell the user that the connection is closing.  The
put:auser will res:pond with a CLOSE, upon which the TCP can send a FIN to
put:athe other TCP: after sending any remaining data.  The TCP then waits
put:auntil its own: FIN is acknowledged whereupon it deletes the
put:aconnection.  :If an ACK is not forthcoming, after the user timeout
put:athe connectio:n is aborted and the user is told.
put:aCase 3:  both u:sers close simultaneously
put:aA simultaneou:s CLOSE by users at both ends of a connection causes
put:aFIN segments :to be exchanged.  When all segments preceding the FINs
put:ahave been pro:cessed and acknowledged, each TCP can ACK the FIN it
put:ahas received.:  Both will, upon receiving these ACKs, delete the
put:a[Page 38]        :                                                       
put:aSeptember 1981   :                                                       
put:aTCP A      :                                          TCP B
put:a1.  ESTABLISHED:                                          ESTABLISHED
put:aFIN-WAIT-1 : --> <SEQ=100><ACK=300><CTL=FIN,ACK>  --> CLOSE-WAIT
put:a3.  FIN-WAIT-2 : <-- <SEQ=300><ACK=101><CTL=ACK>      <-- CLOSE-WAIT
put:a4.             :                                          (Close)
put:aTIME-WAIT  : <-- <SEQ=300><ACK=101><CTL=FIN,ACK>  <-- LAST-ACK
put:a5.  TIME-WAIT  : --> <SEQ=101><ACK=301><CTL=ACK>      --> CLOSED
put:aCLOSED     :                                                 
put:aTCP A      :                                          TCP B
put:a1.  ESTABLISHED:                                          ESTABLISHED
put:a2.  (Close)    :                                          (Close)
put:aFIN-WAIT-1 : --> <SEQ=100><ACK=300><CTL=FIN,ACK>  ... FIN-WAIT-1
put:a3.  CLOSING    : --> <SEQ=101><ACK=301><CTL=ACK>      ... CLOSING
put:a4.  TIME-WAIT  :                                          TIME-WAIT
put:a(2 MSL)    :                                          (2 MSL)
put:aCLOSED     :                                          CLOSED
put:aTransmission Cont:rol Protocol
put:aFunctional Specif:ication
put:a3.6.  Precedence :and Security
put:aThe intent is t:hat connection be allowed only between ports operating
put:awith exactly th:e same security and compartment values and at the
put:ahigher of the p:recedence level requested by the two ports.
put:aThe precedence :and security parameters used in TCP are exactly those
put:adefined in the :Internet Protocol (IP) [2].  Throughout this TCP
put:aspecification t:he term "security/compartment" is intended to indicate
put:athe security pa:rameters used in IP including security, compartment,
put:auser group, and: handling restriction.
put:aA connection at:tempt with mismatched security/compartment values or a
put:alower precedenc:e value must be rejected by sending a reset.  Rejecting
put:aa connection du:e to too low a precedence only occurs after an
put:aacknowledgment :of the SYN has been received.
put:aNote that TCP m:odules which operate only at the default value of
put:aprecedence will: still have to check the precedence of incoming
put:asegments and po:ssibly raise the precedence level they use on the
put:aThe security pa:ramaters may be used even in a non-secure environment
put:a(the values wou:ld indicate unclassified data), thus hosts in
put:anon-secure envi:ronments must be prepared to receive the security
put:aparameters, tho:ugh they need not send them.
put:a3.7.  Data Commun:ication
put:aOnce the connec:tion is established data is communicated by the
put:aexchange of seg:ments.  Because segments may be lost due to errors
put:a(checksum test :failure), or network congestion, TCP uses
put:aretransmission :(after a timeout) to ensure delivery of every segment.
put:aDuplicate segme:nts may arrive due to network or TCP retransmission.
put:aAs discussed in: the section on sequence numbers the TCP performs
put:acertain tests o:n the sequence and acknowledgment numbers in the
put:asegments to ver:ify their acceptability.
put:aThe sender of d:ata keeps track of the next sequence number to use in
put:athe variable SN:D.NXT.  The receiver of data keeps track of the next
put:asequence number: to expect in the variable RCV.NXT.  The sender of data
put:akeeps track of :the oldest unacknowledged sequence number in the
put:avariable SND.UN:A.  If the data flow is momentarily idle and all data
put:asent has been a:cknowledged then the three variables will be equal.
put:aWhen the sender: creates a segment and transmits it the sender advances
put:aSND.NXT.  When :the receiver accepts a segment it advances RCV.NXT and
put:asends an acknow:ledgment.  When the data sender receives an
put:a[Page 40]        :                                                       
put:aSeptember 1981   :                                                       
put:aacknowledgment :it advances SND.UNA.  The extent to which the values of
put:athese variables: differ is a measure of the delay in the communication.
put:aThe amount by w:hich the variables are advanced is the length of the
put:adata in the seg:ment.  Note that once in the ESTABLISHED state all
put:asegments must c:arry current acknowledgment information.
put:aThe CLOSE user :call implies a push function, as does the FIN control
put:aflag in an inco:ming segment.
put:aRetransmission :Timeout
put:aBecause of the :variability of the networks that compose an
put:ainternetwork sy:stem and the wide range of uses of TCP connections the
put:aretransmission :timeout must be dynamically determined.  One procedure
put:afor determining: a retransmission time out is given here as an
put:aAn Example Re:transmission Timeout Procedure
put:aMeasure the: elapsed time between sending a data octet with a
put:aparticular :sequence number and receiving an acknowledgment that
put:acovers that: sequence number (segments sent do not have to match
put:asegments re:ceived).  This measured elapsed time is the Round Trip
put:aTime (RTT).:  Next compute a Smoothed Round Trip Time (SRTT) as:
put:aSRTT = ( :ALPHA * SRTT ) + ((1-ALPHA) * RTT)
put:aand based o:n this, compute the retransmission timeout (RTO) as:
put:aRTO = min:[UBOUND,max[LBOUND,(BETA*SRTT)]]
put:awhere UBOUN:D is an upper bound on the timeout (e.g., 1 minute),
put:aLBOUND is a: lower bound on the timeout (e.g., 1 second), ALPHA is
put:aa smoothing: factor (e.g., .8 to .9), and BETA is a delay variance
put:afactor (e.g:., 1.3 to 2.0).
put:aThe Communicati:on of Urgent Information
put:aThe objective o:f the TCP urgent mechanism is to allow the sending user
put:ato stimulate th:e receiving user to accept some urgent data and to
put:apermit the rece:iving TCP to indicate to the receiving user when all
put:athe currently k:nown urgent data has been received by the user.
put:aThis mechanism :permits a point in the data stream to be designated as
put:athe end of urge:nt information.  Whenever this point is in advance of
put:athe receive seq:uence number (RCV.NXT) at the receiving TCP, that TCP
put:amust tell the u:ser to go into "urgent mode"; when the receive sequence
put:anumber catches :up to the urgent pointer, the TCP must tell user to go
put:aTransmission Cont:rol Protocol
put:aFunctional Specif:ication
put:ainto "normal mo:de".  If the urgent pointer is updated while the user
put:ais in "urgent m:ode", the update will be invisible to the user.
put:aThe method empl:oys a urgent field which is carried in all segments
put:atransmitted.  T:he URG control flag indicates that the urgent field is
put:ameaningful and :must be added to the segment sequence number to yield
put:athe urgent poin:ter.  The absence of this flag indicates that there is
put:ano urgent data :outstanding.
put:aTo send an urge:nt indication the user must also send at least one data
put:aoctet.  If the :sending user also indicates a push, timely delivery of
put:athe urgent info:rmation to the destination process is enhanced.
put:aManaging the Wi:ndow
put:aThe window sent: in each segment indicates the range of sequence
put:anumbers the sen:der of the window (the data receiver) is currently
put:aprepared to acc:ept.  There is an assumption that this is related to
put:athe currently a:vailable data buffer space available for this
put:aIndicating a la:rge window encourages transmissions.  If more data
put:aarrives than ca:n be accepted, it will be discarded.  This will result
put:ain excessive re:transmissions, adding unnecessarily to the load on the
put:anetwork and the: TCPs.  Indicating a small window may restrict the
put:atransmission of: data to the point of introducing a round trip delay
put:abetween each ne:w segment transmitted.
put:aThe mechanisms :provided allow a TCP to advertise a large window and to
put:asubsequently ad:vertise a much smaller window without having accepted
put:athat much data.:  This, so called "shrinking the window," is strongly
put:adiscouraged.  T:he robustness principle dictates that TCPs will not
put:ashrink the wind:ow themselves, but will be prepared for such behavior
put:aon the part of :other TCPs.
put:aThe sending TCP: must be prepared to accept from the user and send at
put:aleast one octet: of new data even if the send window is zero.  The
put:asending TCP mus:t regularly retransmit to the receiving TCP even when
put:athe window is z:ero.  Two minutes is recommended for the retransmission
put:ainterval when t:he window is zero.  This retransmission is essential to
put:aguarantee that :when either TCP has a zero window the re-opening of the
put:awindow will be :reliably reported to the other.
put:aWhen the receiv:ing TCP has a zero window and a segment arrives it must
put:astill send an a:cknowledgment showing its next expected sequence number
put:aand current win:dow (zero).
put:aThe sending TCP: packages the data to be transmitted into segments
put:a[Page 42]        :                                                       
put:aSeptember 1981   :                                                       
put:awhich fit the c:urrent window, and may repackage segments on the
put:aretransmission :queue.  Such repackaging is not required, but may be
put:aIn a connection: with a one-way data flow, the window information will
put:abe carried in a:cknowledgment segments that all have the same sequence
put:anumber so there: will be no way to reorder them if they arrive out of
put:aorder.  This is: not a serious problem, but it will allow the window
put:ainformation to :be on occasion temporarily based on old reports from
put:athe data receiv:er.  A refinement to avoid this problem is to act on
put:athe window info:rmation from segments that carry the highest
put:aacknowledgment :number (that is segments with acknowledgment number
put:aequal or greate:r than the highest previously received).
put:aThe window mana:gement procedure has significant influence on the
put:acommunication p:erformance.  The following comments are suggestions to
put:aWindow Manage:ment Suggestions
put:aAllocating :a very small window causes data to be transmitted in
put:amany small :segments when better performance is achieved using
put:afewer large: segments.
put:aOne suggest:ion for avoiding small windows is for the receiver to
put:adefer updat:ing a window until the additional allocation is at
put:aleast X per:cent of the maximum allocation possible for the
put:aconnection :(where X might be 20 to 40).
put:aAnother sug:gestion is for the sender to avoid sending small
put:asegments by: waiting until the window is large enough before
put:asending dat:a.  If the the user signals a push function then the
put:adata must b:e sent even if it is a small segment.
put:aNote that t:he acknowledgments should not be delayed or unnecessary
put:aretransmiss:ions will result.  One strategy would be to send an
put:aacknowledgm:ent when a small segment arrives (with out updating the
put:awindow info:rmation), and then to send another acknowledgment with
put:anew window :information when the window is larger.
put:aThe segment: sent to probe a zero window may also begin a break up
put:aof transmit:ted data into smaller and smaller segments.  If a
put:asegment con:taining a single data octet sent to probe a zero window
put:ais accepted:, it consumes one octet of the window now available.
put:aIf the send:ing TCP simply sends as much as it can whenever the
put:awindow is n:on zero, the transmitted data will be broken into
put:aalternating: big and small segments.  As time goes on, occasional
put:apauses in t:he receiver making window allocation available will
put:aTransmission Cont:rol Protocol
put:aFunctional Specif:ication
put:aresult in b:reaking the big segments into a small and not quite so
put:abig pair. A:nd after a while the data transmission will be in
put:amostly smal:l segments.
put:aThe suggest:ion here is that the TCP implementations need to
put:aactively at:tempt to combine small window allocations into larger
put:awindows, si:nce the mechanisms for managing the window tend to lead
put:ato many sma:ll windows in the simplest minded implementations.
put:aThere are of co:urse two interfaces of concern:  the user/TCP interface
put:aand the TCP/low:er-level interface.  We have a fairly elaborate model
put:aof the user/TCP: interface, but the interface to the lower level
put:aprotocol module: is left unspecified here, since it will be specified
put:ain detail by th:e specification of the lowel level protocol.  For the
put:acase that the l:ower level is IP we note some of the parameter values
put:athat TCPs might: use.
put:aUser/TCP Interf:ace
put:aThe following: functional description of user commands to the TCP is,
put:aat best, fict:ional, since every operating system will have different
put:afacilities.  :Consequently, we must warn readers that different TCP
put:aimplementatio:ns may have different user interfaces.  However, all
put:aTCPs must pro:vide a certain minimum set of services to guarantee
put:athat all TCP :implementations can support the same protocol
put:ahierarchy.  T:his section specifies the functional interfaces
put:arequired of a:ll TCP implementations.
put:aTCP User Comm:ands
put:aThe followi:ng sections functionally characterize a USER/TCP
put:ainterface. : The notation used is similar to most procedure or
put:afunction ca:lls in high level languages, but this usage is not
put:ameant to ru:le out trap type service calls (e.g., SVCs, UUOs,
put:aThe user co:mmands described below specify the basic functions the
put:aTCP must pe:rform to support interprocess communication.
put:aIndividual :implementations must define their own exact format, and
put:amay provide: combinations or subsets of the basic functions in
put:asingle call:s.  In particular, some implementations may wish to
put:aautomatical:ly OPEN a connection on the first SEND or RECEIVE
put:aissued by t:he user for a given connection.
put:a[Page 44]        :                                                       
put:aSeptember 1981   :                                                       
put:aIn providin:g interprocess communication facilities, the TCP must
put:anot only ac:cept commands, but must also return information to the
put:aprocesses i:t serves.  The latter consists of:
put:a(a) gener:al information about a connection (e.g., interrupts,
put:aremote cl:ose, binding of unspecified foreign socket).
put:a(b) repli:es to specific user commands indicating success or
put:avarious t:ypes of failure.
put:aFormat:  :OPEN (local port, foreign socket, active/passive
put:a[, timeou:t] [, precedence] [, security/compartment] [, options])
put:a-> local :connection name
put:aWe assume: that the local TCP is aware of the identity of the
put:aprocesses: it serves and will check the authority of the process
put:ato use th:e connection specified.  Depending upon the
put:aimplement:ation of the TCP, the local network and TCP identifiers
put:afor the s:ource address will either be supplied by the TCP or the
put:alower lev:el protocol (e.g., IP).  These considerations are the
put:aresult of: concern about security, to the extent that no TCP be
put:aable to m:asquerade as another one, and so on.  Similarly, no
put:aprocess c:an masquerade as another without the collusion of the
put:aIf the ac:tive/passive flag is set to passive, then this is a
put:acall to L:ISTEN for an incoming connection.  A passive open may
put:ahave eith:er a fully specified foreign socket to wait for a
put:aparticula:r connection or an unspecified foreign socket to wait
put:afor any c:all.  A fully specified passive call can be made active
put:aby the su:bsequent execution of a SEND.
put:aA transmi:ssion control block (TCB) is created and partially
put:afilled in: with data from the OPEN command parameters.
put:aOn an act:ive OPEN command, the TCP will begin the procedure to
put:asynchroni:ze (i.e., establish) the connection at once.
put:aThe timeo:ut, if present, permits the caller to set up a timeout
put:afor all d:ata submitted to TCP.  If data is not successfully
put:adelivered: to the destination within the timeout period, the TCP
put:awill abor:t the connection.  The present global default is five
put:aThe TCP o:r some component of the operating system will verify
put:athe users: authority to open a connection with the specified
put:aTransmission Cont:rol Protocol
put:aFunctional Specif:ication
put:aprecedenc:e or security/compartment.  The absence of precedence
put:aor securi:ty/compartment specification in the OPEN call indicates
put:athe defau:lt values must be used.
put:aTCP will :accept incoming requests as matching only if the
put:asecurity/:compartment information is exactly the same and only if
put:athe prece:dence is equal to or higher than the precedence
put:arequested: in the OPEN call.
put:aThe prece:dence for the connection is the higher of the values
put:arequested: in the OPEN call and received from the incoming
put:arequest, :and fixed at that value for the life of the
put:aconnectio:n.Implementers may want to give the user control of
put:athis prec:edence negotiation.  For example, the user might be
put:aallowed t:o specify that the precedence must be exactly matched,
put:aor that a:ny attempt to raise the precedence be confirmed by the
put:aA local c:onnection name will be returned to the user by the TCP.
put:aThe local: connection name can then be used as a short hand term
put:afor the c:onnection defined by the <local socket, foreign socket>
put:aFormat:  :SEND (local connection name, buffer address, byte
put:acount, PU:SH flag, URGENT flag [,timeout])
put:aThis call: causes the data contained in the indicated user buffer
put:ato be sen:t on the indicated connection.  If the connection has
put:anot been :opened, the SEND is considered an error.  Some
put:aimplement:ations may allow users to SEND first; in which case, an
put:aautomatic: OPEN would be done.  If the calling process is not
put:aauthorize:d to use this connection, an error is returned.
put:aIf the PU:SH flag is set, the data must be transmitted promptly
put:ato the re:ceiver, and the PUSH bit will be set in the last TCP
put:asegment c:reated from the buffer.  If the PUSH flag is not set,
put:athe data :may be combined with data from subsequent SENDs for
put:atransmiss:ion efficiency.
put:aIf the UR:GENT flag is set, segments sent to the destination TCP
put:awill have: the urgent pointer set.  The receiving TCP will signal
put:athe urgen:t condition to the receiving process if the urgent
put:apointer i:ndicates that data preceding the urgent pointer has not
put:abeen cons:umed by the receiving process.  The purpose of urgent
put:ais to sti:mulate the receiver to process the urgent data and to
put:aindicate :to the receiver when all the currently known urgent
put:a[Page 46]        :                                                       
put:aSeptember 1981   :                                                       
put:adata has :been received.  The number of times the sending user's
put:aTCP signa:ls urgent will not necessarily be equal to the number
put:aof times :the receiving user will be notified of the presence of
put:aurgent da:ta.
put:aIf no for:eign socket was specified in the OPEN, but the
put:aconnectio:n is established (e.g., because a LISTENing connection
put:ahas becom:e specific due to a foreign segment arriving for the
put:alocal soc:ket), then the designated buffer is sent to the implied
put:aforeign s:ocket.  Users who make use of OPEN with an unspecified
put:aforeign s:ocket can make use of SEND without ever explicitly
put:aknowing t:he foreign socket address.
put:aHowever, :if a SEND is attempted before the foreign socket
put:abecomes s:pecified, an error will be returned.  Users can use the
put:aSTATUS ca:ll to determine the status of the connection.  In some
put:aimplement:ations the TCP may notify the user when an unspecified
put:asocket is: bound.
put:aIf a time:out is specified, the current user timeout for this
put:aconnectio:n is changed to the new one.
put:aIn the si:mplest implementation, SEND would not return control to
put:athe sendi:ng process until either the transmission was complete
put:aor the ti:meout had been exceeded.  However, this simple method
put:ais both s:ubject to deadlocks (for example, both sides of the
put:aconnectio:n might try to do SENDs before doing any RECEIVEs) and
put:aoffers po:or performance, so it is not recommended.  A more
put:asophistic:ated implementation would return immediately to allow
put:athe proce:ss to run concurrently with network I/O, and,
put:afurthermo:re, to allow multiple SENDs to be in progress.
put:aMultiple :SENDs are served in first come, first served order, so
put:athe TCP w:ill queue those it cannot service immediately.
put:aWe have i:mplicitly assumed an asynchronous user interface in
put:awhich a S:END later elicits some kind of SIGNAL or
put:apseudo-in:terrupt from the serving TCP.  An alternative is to
put:areturn a :response immediately.  For instance, SENDs might return
put:aimmediate: local acknowledgment, even if the segment sent had not
put:abeen ackn:owledged by the distant TCP.  We could optimistically
put:aassume ev:entual success.  If we are wrong, the connection will
put:aclose any:way due to the timeout.  In implementations of this
put:akind (syn:chronous), there will still be some asynchronous
put:asignals, :but these will deal with the connection itself, and not
put:awith spec:ific segments or buffers.
put:aIn order :for the process to distinguish among error or success
put:aindicatio:ns for different SENDs, it might be appropriate for the
put:aTransmission Cont:rol Protocol
put:aFunctional Specif:ication
put:abuffer ad:dress to be returned along with the coded response to
put:athe SEND :request.  TCP-to-user signals are discussed below,
put:aindicatin:g the information which should be returned to the
put:acalling p:rocess.
put:aFormat:  :RECEIVE (local connection name, buffer address, byte
put:acount) ->: byte count, urgent flag, push flag
put:aThis comm:and allocates a receiving buffer associated with the
put:aspecified: connection.  If no OPEN precedes this command or the
put:acalling p:rocess is not authorized to use this connection, an
put:aerror is :returned.
put:aIn the si:mplest implementation, control would not return to the
put:acalling p:rogram until either the buffer was filled, or some
put:aerror occ:urred, but this scheme is highly subject to deadlocks.
put:aA more so:phisticated implementation would permit several
put:aRECEIVEs :to be outstanding at once.  These would be filled as
put:asegments :arrive.  This strategy permits increased throughput at
put:athe cost :of a more elaborate scheme (possibly asynchronous) to
put:anotify th:e calling program that a PUSH has been seen or a buffer
put:aIf enough: data arrive to fill the buffer before a PUSH is seen,
put:athe PUSH :flag will not be set in the response to the RECEIVE.
put:aThe buffe:r will be filled with as much data as it can hold.  If
put:aa PUSH is: seen before the buffer is filled the buffer will be
put:areturned :partially filled and PUSH indicated.
put:aIf there :is urgent data the user will have been informed as soon
put:aas it arr:ived via a TCP-to-user signal.  The receiving user
put:ashould th:us be in "urgent mode".  If the URGENT flag is on,
put:aadditiona:l urgent data remains.  If the URGENT flag is off, this
put:acall to R:ECEIVE has returned all the urgent data, and the user
put:amay now l:eave "urgent mode".  Note that data following the
put:aurgent po:inter (non-urgent data) cannot be delivered to the user
put:ain the sa:me buffer with preceeding urgent data unless the
put:aboundary :is clearly marked for the user.
put:aTo distin:guish among several outstanding RECEIVEs and to take
put:acare of t:he case that a buffer is not completely filled, the
put:areturn co:de is accompanied by both a buffer pointer and a byte
put:acount ind:icating the actual length of the data received.
put:aAlternati:ve implementations of RECEIVE might have the TCP
put:a[Page 48]        :                                                       
put:aSeptember 1981   :                                                       
put:aallocate :buffer storage, or the TCP might share a ring buffer
put:awith the :user.
put:aFormat:  :CLOSE (local connection name)
put:aThis comm:and causes the connection specified to be closed.  If
put:athe conne:ction is not open or the calling process is not
put:aauthorize:d to use this connection, an error is returned.
put:aClosing c:onnections is intended to be a graceful operation in
put:athe sense: that outstanding SENDs will be transmitted (and
put:aretransmi:tted), as flow control permits, until all have been
put:aserviced.:  Thus, it should be acceptable to make several SEND
put:acalls, fo:llowed by a CLOSE, and expect all the data to be sent
put:ato the de:stination.  It should also be clear that users should
put:acontinue :to RECEIVE on CLOSING connections, since the other side
put:amay be tr:ying to transmit the last of its data.  Thus, CLOSE
put:ameans "I :have no more to send" but does not mean "I will not
put:areceive a:ny more."  It may happen (if the user level protocol is
put:anot well :thought out) that the closing side is unable to get rid
put:aof all it:s data before timing out.  In this event, CLOSE turns
put:ainto ABOR:T, and the closing TCP gives up.
put:aThe user :may CLOSE the connection at any time on his own
put:ainitiativ:e, or in response to various prompts from the TCP
put:a(e.g., re:mote close executed, transmission timeout exceeded,
put:adestinati:on inaccessible).
put:aBecause c:losing a connection requires communication with the
put:aforeign T:CP, connections may remain in the closing state for a
put:ashort tim:e.  Attempts to reopen the connection before the TCP
put:areplies t:o the CLOSE command will result in error responses.
put:aClose als:o implies push function.
put:aFormat:  :STATUS (local connection name) -> status data
put:aThis is a:n implementation dependent user command and could be
put:aexcluded :without adverse effect.  Information returned would
put:atypically: come from the TCB associated with the connection.
put:aThis comm:and returns a data block containing the following
put:ainformati:on:
put:alocal s:ocket,
put:aTransmission Cont:rol Protocol
put:aFunctional Specif:ication
put:aforeign: socket,
put:alocal c:onnection name,
put:areceive: window,
put:asend wi:ndow,
put:aconnect:ion state,
put:anumber :of buffers awaiting acknowledgment,
put:anumber :of buffers pending receipt,
put:aurgent :state,
put:aprecede:nce,
put:asecurit:y/compartment,
put:aand tra:nsmission timeout.
put:aDepending: on the state of the connection, or on the
put:aimplement:ation itself, some of this information may not be
put:aavailable: or meaningful.  If the calling process is not
put:aauthorize:d to use this connection, an error is returned.  This
put:aprevents :unauthorized processes from gaining information about a
put:aconnectio:n.
put:aFormat:  :ABORT (local connection name)
put:aThis comm:and causes all pending SENDs and RECEIVES to be
put:aaborted, :the TCB to be removed, and a special RESET message to
put:abe sent t:o the TCP on the other side of the connection.
put:aDepending: on the implementation, users may receive abort
put:aindicatio:ns for each outstanding SEND or RECEIVE, or may simply
put:areceive a:n ABORT-acknowledgment.
put:aTCP-to-User M:essages
put:aIt is assum:ed that the operating system environment provides a
put:ameans for t:he TCP to asynchronously signal the user program.  When
put:athe TCP doe:s signal a user program, certain information is passed
put:ato the user:.  Often in the specification the information will be
put:aan error me:ssage.  In other cases there will be information
put:arelating to: the completion of processing a SEND or RECEIVE or
put:aother user :call.
put:aThe followi:ng information is provided:
put:aLocal Con:nection Name                    Always
put:aResponse :String                          Always
put:aBuffer Ad:dress                           Send & Receive
put:aByte coun:t (counts bytes received)       Receive
put:aPush flag:                                Receive
put:aUrgent fl:ag                              Receive
put:a[Page 50]        :                                                       
put:aSeptember 1981   :                                                       
put:aTCP/Lower-Level: Interface
put:aThe TCP calls: on a lower level protocol module to actually send and
put:areceive infor:mation over a network.  One case is that of the ARPA
put:ainternetwork :system where the lower level module is the Internet
put:aProtocol (IP): [2].
put:aIf the lower :level protocol is IP it provides arguments for a type
put:aof service an:d for a time to live.  TCP uses the following settings
put:afor these par:ameters:
put:aType of Ser:vice = Precedence: routine, Delay: normal, Throughput:
put:anormal, Rel:iability: normal; or 00000000.
put:aTime to Liv:e    = one minute, or 00111100.
put:aNote that: the assumed maximum segment lifetime is two minutes.
put:aHere we e:xplicitly ask that a segment be destroyed if it cannot
put:abe delive:red by the internet system within one minute.
put:aIf the lower :level is IP (or other protocol that provides this
put:afeature) and :source routing is used, the interface must allow the
put:aroute informa:tion to be communicated.  This is especially important
put:aso that the s:ource and destination addresses used in the TCP
put:achecksum be t:he originating source and ultimate destination. It is
put:aalso importan:t to preserve the return route to answer connection
put:aAny lower lev:el protocol will have to provide the source address,
put:adestination a:ddress, and protocol fields, and some way to determine
put:athe "TCP leng:th", both to provide the functional equivlent service
put:aof IP and to :be used in the TCP checksum.
put:aTransmission Cont:rol Protocol
put:aFunctional Specif:ication
put:a3.9.  Event Proce:ssing
put:aThe processing :depicted in this section is an example of one possible
put:aimplementation.:  Other implementations may have slightly different
put:aprocessing sequ:ences, but they should differ from those in this
put:asection only in: detail, not in substance.
put:aThe activity of: the TCP can be characterized as responding to events.
put:aThe events that: occur can be cast into three categories:  user calls,
put:aarriving segmen:ts, and timeouts.  This section describes the
put:aprocessing the :TCP does in response to each of the events.  In many
put:acases the proce:ssing required depends on the state of the connection.
put:aEvents that o:ccur:
put:aArriving Se:gments
put:aSEGMENT A:RRIVES
put:aUSER TIME:OUT
put:aRETRANSMI:SSION TIMEOUT
put:aTIME-WAIT: TIMEOUT
put:aThe model of th:e TCP/user interface is that user commands receive an
put:aimmediate retur:n and possibly a delayed response via an event or
put:apseudo interrup:t.  In the following descriptions, the term "signal"
put:ameans cause a d:elayed response.
put:aError responses: are given as character strings.  For example, user
put:acommands refere:ncing connections that do not exist receive "error:
put:aconnection not :open".
put:aPlease note in :the following that all arithmetic on sequence numbers,
put:aacknowledgment :numbers, windows, et cetera, is modulo 2**32 the size
put:aof the sequence: number space.  Also note that "=<" means less than or
put:aequal to (modul:o 2**32).
put:a[Page 52]        :                                                       
put:aSeptember 1981   :                                                       
put:aA natural way t:o think about processing incoming segments is to
put:aimagine that th:ey are first tested for proper sequence number (i.e.,
put:athat their cont:ents lie in the range of the expected "receive window"
put:ain the sequence: number space) and then that they are generally queued
put:aand processed i:n sequence number order.
put:aWhen a segment :overlaps other already received segments we reconstruct
put:athe segment to :contain just the new data, and adjust the header fields
put:ato be consisten:t.
put:aNote that if no: state change is mentioned the TCP stays in the same
put:aTransmission Cont:rol Protocol
put:aFunctional Specif:ication
put:aCLOSED STATE :(i.e., TCB does not exist)
put:aCreate a ne:w transmission control block (TCB) to hold connection
put:astate infor:mation.  Fill in local socket identifier, foreign
put:asocket, pre:cedence, security/compartment, and user timeout
put:ainformation:.  Note that some parts of the foreign socket may be
put:aunspecified: in a passive OPEN and are to be filled in by the
put:aparameters :of the incoming SYN segment.  Verify the security and
put:aprecedence :requested are allowed for this user, if not return
put:a"error:  pr:ecedence not allowed" or "error:  security/compartment
put:anot allowed:."  If passive enter the LISTEN state and return.  If
put:aactive and :the foreign socket is unspecified, return "error:
put:aforeign soc:ket unspecified"; if active and the foreign socket is
put:aspecified, :issue a SYN segment.  An initial send sequence number
put:a(ISS) is se:lected.  A SYN segment of the form <SEQ=ISS><CTL=SYN>
put:ais sent.  S:et SND.UNA to ISS, SND.NXT to ISS+1, enter SYN-SENT
put:astate, and :return.
put:aIf the call:er does not have access to the local socket specified,
put:areturn "err:or:  connection illegal for this process".  If there is
put:ano room to :create a new connection, return "error:  insufficient
put:aresources".:
put:aIf active a:nd the foreign socket is specified, then change the
put:aconnection :from passive to active, select an ISS.  Send a SYN
put:asegment, se:t SND.UNA to ISS, SND.NXT to ISS+1.  Enter SYN-SENT
put:astate.  Dat:a associated with SEND may be sent with SYN segment or
put:aqueued for :transmission after entering ESTABLISHED state.  The
put:aurgent bit :if requested in the command must be sent with the data
put:asegments se:nt as a result of this command.  If there is no room to
put:aqueue the r:equest, respond with "error:  insufficient resources".
put:aIf Foreign :socket was not specified, then return "error:  foreign
put:asocket unsp:ecified".
put:a[Page 54]        :                                                       
put:aSeptember 1981   :                                                       
put:aSYN-SENT STAT:E
put:aSYN-RECEIVED :STATE
put:aESTABLISHED S:TATE
put:aFIN-WAIT-1 ST:ATE
put:aFIN-WAIT-2 ST:ATE
put:aCLOSE-WAIT ST:ATE
put:aCLOSING STATE:
put:aLAST-ACK STAT:E
put:aTIME-WAIT STA:TE
put:aReturn "err:or:  connection already exists".
put:aTransmission Cont:rol Protocol
put:aFunctional Specif:ication
put:aCLOSED STATE :(i.e., TCB does not exist)
put:aIf the user: does not have access to such a connection, then return
put:a"error:  co:nnection illegal for this process".
put:aOtherwise, :return "error:  connection does not exist".
put:aIf the fore:ign socket is specified, then change the connection
put:afrom passiv:e to active, select an ISS.  Send a SYN segment, set
put:aSND.UNA to :ISS, SND.NXT to ISS+1.  Enter SYN-SENT state.  Data
put:aassociated :with SEND may be sent with SYN segment or queued for
put:atransmissio:n after entering ESTABLISHED state.  The urgent bit if
put:arequested i:n the command must be sent with the data segments sent
put:aas a result: of this command.  If there is no room to queue the
put:arequest, re:spond with "error:  insufficient resources".  If
put:aForeign soc:ket was not specified, then return "error:  foreign
put:asocket unsp:ecified".
put:aSYN-SENT STAT:E
put:aSYN-RECEIVED :STATE
put:aQueue the d:ata for transmission after entering ESTABLISHED state.
put:aIf no space: to queue, respond with "error:  insufficient
put:aresources".:
put:aESTABLISHED S:TATE
put:aCLOSE-WAIT ST:ATE
put:aSegmentize :the buffer and send it with a piggybacked
put:aacknowledgm:ent (acknowledgment value = RCV.NXT).  If there is
put:ainsufficien:t space to remember this buffer, simply return "error:
put:ainsufficien:t resources".
put:aIf the urge:nt flag is set, then SND.UP <- SND.NXT-1 and set the
put:aurgent poin:ter in the outgoing segments.
put:a[Page 56]        :                                                       
put:aSeptember 1981   :                                                       
put:aFIN-WAIT-1 ST:ATE
put:aFIN-WAIT-2 ST:ATE
put:aCLOSING STATE:
put:aLAST-ACK STAT:E
put:aTIME-WAIT STA:TE
put:aReturn "err:or:  connection closing" and do not service request.
put:aTransmission Cont:rol Protocol
put:aFunctional Specif:ication
put:aCLOSED STATE :(i.e., TCB does not exist)
put:aIf the user: does not have access to such a connection, return
put:a"error:  co:nnection illegal for this process".
put:aOtherwise r:eturn "error:  connection does not exist".
put:aSYN-SENT STAT:E
put:aSYN-RECEIVED :STATE
put:aQueue for p:rocessing after entering ESTABLISHED state.  If there
put:ais no room :to queue this request, respond with "error:
put:ainsufficien:t resources".
put:aESTABLISHED S:TATE
put:aFIN-WAIT-1 ST:ATE
put:aFIN-WAIT-2 ST:ATE
put:aIf insuffic:ient incoming segments are queued to satisfy the
put:arequest, qu:eue the request.  If there is no queue space to
put:aremember th:e RECEIVE, respond with "error:  insufficient
put:aresources".:
put:aReassemble :queued incoming segments into receive buffer and return
put:ato user.  M:ark "push seen" (PUSH) if this is the case.
put:aIf RCV.UP i:s in advance of the data currently being passed to the
put:auser notify: the user of the presence of urgent data.
put:aWhen the TC:P takes responsibility for delivering data to the user
put:athat fact m:ust be communicated to the sender via an
put:aacknowledgm:ent.  The formation of such an acknowledgment is
put:adescribed b:elow in the discussion of processing an incoming
put:a[Page 58]        :                                                       
put:aSeptember 1981   :                                                       
put:aCLOSE-WAIT ST:ATE
put:aSince the r:emote side has already sent FIN, RECEIVEs must be
put:asatisfied b:y text already on hand, but not yet delivered to the
put:auser.  If n:o text is awaiting delivery, the RECEIVE will get a
put:a"error:  co:nnection closing" response.  Otherwise, any remaining
put:atext can be: used to satisfy the RECEIVE.
put:aCLOSING STATE:
put:aLAST-ACK STAT:E
put:aTIME-WAIT STA:TE
put:aReturn "err:or:  connection closing".
put:aTransmission Cont:rol Protocol
put:aFunctional Specif:ication
put:aCLOSED STATE :(i.e., TCB does not exist)
put:aIf the user: does not have access to such a connection, return
put:a"error:  co:nnection illegal for this process".
put:aOtherwise, :return "error:  connection does not exist".
put:aAny outstan:ding RECEIVEs are returned with "error:  closing"
put:aresponses. : Delete TCB, enter CLOSED state, and return.
put:aSYN-SENT STAT:E
put:aDelete the :TCB and return "error:  closing" responses to any
put:aqueued SEND:s, or RECEIVEs.
put:aSYN-RECEIVED :STATE
put:aIf no SENDs: have been issued and there is no pending data to send,
put:athen form a: FIN segment and send it, and enter FIN-WAIT-1 state;
put:aotherwise q:ueue for processing after entering ESTABLISHED state.
put:aESTABLISHED S:TATE
put:aQueue this :until all preceding SENDs have been segmentized, then
put:aform a FIN :segment and send it.  In any case, enter FIN-WAIT-1
put:aFIN-WAIT-1 ST:ATE
put:aFIN-WAIT-2 ST:ATE
put:aStrictly sp:eaking, this is an error and should receive a "error:
put:aconnection :closing" response.  An "ok" response would be
put:aacceptable,: too, as long as a second FIN is not emitted (the first
put:aFIN may be :retransmitted though).
put:a[Page 60]        :                                                       
put:aSeptember 1981   :                                                       
put:aCLOSE-WAIT ST:ATE
put:aQueue this :request until all preceding SENDs have been
put:asegmentized:; then send a FIN segment, enter CLOSING state.
put:aCLOSING STATE:
put:aLAST-ACK STAT:E
put:aTIME-WAIT STA:TE
put:aRespond wit:h "error:  connection closing".
put:aTransmission Cont:rol Protocol
put:aFunctional Specif:ication
put:aCLOSED STATE :(i.e., TCB does not exist)
put:aIf the user: should not have access to such a connection, return
put:a"error:  co:nnection illegal for this process".
put:aOtherwise r:eturn "error:  connection does not exist".
put:aAny outstan:ding RECEIVEs should be returned with "error:
put:aconnection :reset" responses.  Delete TCB, enter CLOSED state, and
put:aSYN-SENT STAT:E
put:aAll queued :SENDs and RECEIVEs should be given "connection reset"
put:anotificatio:n, delete the TCB, enter CLOSED state, and return.
put:aSYN-RECEIVED :STATE
put:aESTABLISHED S:TATE
put:aFIN-WAIT-1 ST:ATE
put:aFIN-WAIT-2 ST:ATE
put:aCLOSE-WAIT ST:ATE
put:aSend a rese:t segment:
put:a<SEQ=SND.:NXT><CTL=RST>
put:aAll queued :SENDs and RECEIVEs should be given "connection reset"
put:anotificatio:n; all segments queued for transmission (except for the
put:aRST formed :above) or retransmission should be flushed, delete the
put:aTCB, enter :CLOSED state, and return.
put:aCLOSING STATE:
put:aLAST-ACK STAT:E
put:aTIME-WAIT STA:TE
put:aRespond wit:h "ok" and delete the TCB, enter CLOSED state, and
put:a[Page 62]        :                                                       
put:aSeptember 1981   :                                                       
put:aCLOSED STATE :(i.e., TCB does not exist)
put:aIf the user: should not have access to such a connection, return
put:a"error:  co:nnection illegal for this process".
put:aOtherwise r:eturn "error:  connection does not exist".
put:aReturn "sta:te = LISTEN", and the TCB pointer.
put:aSYN-SENT STAT:E
put:aReturn "sta:te = SYN-SENT", and the TCB pointer.
put:aSYN-RECEIVED :STATE
put:aReturn "sta:te = SYN-RECEIVED", and the TCB pointer.
put:aESTABLISHED S:TATE
put:aReturn "sta:te = ESTABLISHED", and the TCB pointer.
put:aFIN-WAIT-1 ST:ATE
put:aReturn "sta:te = FIN-WAIT-1", and the TCB pointer.
put:aFIN-WAIT-2 ST:ATE
put:aReturn "sta:te = FIN-WAIT-2", and the TCB pointer.
put:aCLOSE-WAIT ST:ATE
put:aReturn "sta:te = CLOSE-WAIT", and the TCB pointer.
put:aCLOSING STATE:
put:aReturn "sta:te = CLOSING", and the TCB pointer.
put:aLAST-ACK STAT:E
put:aReturn "sta:te = LAST-ACK", and the TCB pointer.
put:aTransmission Cont:rol Protocol
put:aFunctional Specif:ication
put:aTIME-WAIT STA:TE
put:aReturn "sta:te = TIME-WAIT", and the TCB pointer.
put:a[Page 64]        :                                                       
put:aSeptember 1981   :                                                       
put:aSEGMENT ARRIVES:
put:aIf the state :is CLOSED (i.e., TCB does not exist) then
put:aall data in: the incoming segment is discarded.  An incoming
put:asegment con:taining a RST is discarded.  An incoming segment not
put:acontaining :a RST causes a RST to be sent in response.  The
put:aacknowledgm:ent and sequence field values are selected to make the
put:areset seque:nce acceptable to the TCP that sent the offending
put:aIf the ACK :bit is off, sequence number zero is used,
put:a<SEQ=0><A:CK=SEG.SEQ+SEG.LEN><CTL=RST,ACK>
put:aIf the ACK :bit is on,
put:a<SEQ=SEG.:ACK><CTL=RST>
put:aIf the state :is LISTEN then
put:afirst check: for an RST
put:aAn incomi:ng RST should be ignored.  Return.
put:asecond chec:k for an ACK
put:aAny ackno:wledgment is bad if it arrives on a connection still in
put:athe LISTE:N state.  An acceptable reset segment should be formed
put:afor any a:rriving ACK-bearing segment.  The RST should be
put:aformatted: as follows:
put:a<SEQ=SE:G.ACK><CTL=RST>
put:athird check: for a SYN
put:aIf the SY:N bit is set, check the security.  If the
put:asecurity/:compartment on the incoming segment does not exactly
put:amatch the: security/compartment in the TCB then send a reset and
put:a<SEQ=SE:G.ACK><CTL=RST>
put:aTransmission Cont:rol Protocol
put:aFunctional Specif:ication
put:aIf the SE:G.PRC is greater than the TCB.PRC then if allowed by
put:athe user :and the system set TCB.PRC<-SEG.PRC, if not allowed
put:asend a re:set and return.
put:a<SEQ=SE:G.ACK><CTL=RST>
put:aIf the SE:G.PRC is less than the TCB.PRC then continue.
put:aSet RCV.N:XT to SEG.SEQ+1, IRS is set to SEG.SEQ and any other
put:acontrol o:r text should be queued for processing later.  ISS
put:ashould be: selected and a SYN segment sent of the form:
put:a<SEQ=IS:S><ACK=RCV.NXT><CTL=SYN,ACK>
put:aSND.NXT i:s set to ISS+1 and SND.UNA to ISS.  The connection
put:astate sho:uld be changed to SYN-RECEIVED.  Note that any other
put:aincoming :control or data (combined with SYN) will be processed
put:ain the SY:N-RECEIVED state, but processing of SYN and ACK should
put:anot be re:peated.  If the listen was not fully specified (i.e.,
put:athe forei:gn socket was not fully specified), then the
put:aunspecifi:ed fields should be filled in now.
put:afourth othe:r text or control
put:aAny other: control or text-bearing segment (not containing SYN)
put:amust have: an ACK and thus would be discarded by the ACK
put:aprocessin:g.  An incoming RST segment could not be valid, since
put:ait could :not have been sent in response to anything sent by this
put:aincarnati:on of the connection.  So you are unlikely to get here,
put:abut if yo:u do, drop the segment, and return.
put:aIf the state :is SYN-SENT then
put:afirst check: the ACK bit
put:aIf the AC:K bit is set
put:aIf SEG.:ACK =< ISS, or SEG.ACK > SND.NXT, send a reset (unless
put:athe RST: bit is set, if so drop the segment and return)
put:a<SEQ=:SEG.ACK><CTL=RST>
put:aand dis:card the segment.  Return.
put:aIf SND.:UNA =< SEG.ACK =< SND.NXT then the ACK is acceptable.
put:asecond chec:k the RST bit
put:a[Page 66]        :                                                       
put:aSeptember 1981   :                                                       
put:aIf the RS:T bit is set
put:aIf the :ACK was acceptable then signal the user "error:
put:aconnect:ion reset", drop the segment, enter CLOSED state,
put:adelete :TCB, and return.  Otherwise (no ACK) drop the segment
put:aand ret:urn.
put:athird check: the security and precedence
put:aIf the se:curity/compartment in the segment does not exactly
put:amatch the: security/compartment in the TCB, send a reset
put:aIf ther:e is an ACK
put:a<SEQ=:SEG.ACK><CTL=RST>
put:aOtherwi:se
put:a<SEQ=:0><ACK=SEG.SEQ+SEG.LEN><CTL=RST,ACK>
put:aIf there :is an ACK
put:aThe pre:cedence in the segment must match the precedence in the
put:aTCB, if: not, send a reset
put:a<SEQ=:SEG.ACK><CTL=RST>
put:aIf there :is no ACK
put:aIf the :precedence in the segment is higher than the precedence
put:ain the :TCB then if allowed by the user and the system raise
put:athe pre:cedence in the TCB to that in the segment, if not
put:aallowed: to raise the prec then send a reset.
put:a<SEQ=:0><ACK=SEG.SEQ+SEG.LEN><CTL=RST,ACK>
put:aIf the :precedence in the segment is lower than the precedence
put:ain the :TCB continue.
put:aIf a rese:t was sent, discard the segment and return.
put:afourth chec:k the SYN bit
put:aThis step: should be reached only if the ACK is ok, or there is
put:ano ACK, a:nd it the segment did not contain a RST.
put:aIf the SY:N bit is on and the security/compartment and precedence
put:aTransmission Cont:rol Protocol
put:aFunctional Specif:ication
put:aare accep:table then, RCV.NXT is set to SEG.SEQ+1, IRS is set to
put:aSEG.SEQ. : SND.UNA should be advanced to equal SEG.ACK (if there
put:ais an ACK:), and any segments on the retransmission queue which
put:aare there:by acknowledged should be removed.
put:aIf SND.UN:A > ISS (our SYN has been ACKed), change the connection
put:astate to :ESTABLISHED, form an ACK segment
put:a<SEQ=SN:D.NXT><ACK=RCV.NXT><CTL=ACK>
put:aand send :it.  Data or controls which were queued for
put:atransmiss:ion may be included.  If there are other controls or
put:atext in t:he segment then continue processing at the sixth step
put:abelow whe:re the URG bit is checked, otherwise return.
put:aOtherwise: enter SYN-RECEIVED, form a SYN,ACK segment
put:a<SEQ=IS:S><ACK=RCV.NXT><CTL=SYN,ACK>
put:aand send :it.  If there are other controls or text in the
put:asegment, :queue them for processing after the ESTABLISHED state
put:ahas been :reached, return.
put:afifth, if n:either of the SYN or RST bits is set then drop the
put:asegment and: return.
put:a[Page 68]        :                                                       
put:aSeptember 1981   :                                                       
put:afirst check s:equence number
put:aSYN-RECEIVE:D STATE
put:aESTABLISHED: STATE
put:aFIN-WAIT-1 :STATE
put:aFIN-WAIT-2 :STATE
put:aCLOSE-WAIT :STATE
put:aCLOSING STA:TE
put:aLAST-ACK ST:ATE
put:aTIME-WAIT S:TATE
put:aSegments :are processed in sequence.  Initial tests on arrival
put:aare used :to discard old duplicates, but further processing is
put:adone in S:EG.SEQ order.  If a segment's contents straddle the
put:aboundary :between old and new, only the new parts should be
put:aprocessed:.
put:aThere are: four cases for the acceptability test for an incoming
put:asegment:
put:aSegment R:eceive  Test
put:aLength  W:indow
put:a------- -:------  -------------------------------------------
put:a0     :  0     SEG.SEQ = RCV.NXT
put:a0     : >0     RCV.NXT =< SEG.SEQ < RCV.NXT+RCV.WND
put:a>0     :  0     not acceptable
put:a>0     : >0     RCV.NXT =< SEG.SEQ < RCV.NXT+RCV.WND
put:aIf the RC:V.WND is zero, no segments will be acceptable, but
put:aspecial a:llowance should be made to accept valid ACKs, URGs and
put:aIf an inc:oming segment is not acceptable, an acknowledgment
put:ashould be: sent in reply (unless the RST bit is set, if so drop
put:athe segme:nt and return):
put:a<SEQ=SN:D.NXT><ACK=RCV.NXT><CTL=ACK>
put:aAfter sen:ding the acknowledgment, drop the unacceptable segment
put:aand retur:n.
put:aTransmission Cont:rol Protocol
put:aFunctional Specif:ication
put:aIn the fo:llowing it is assumed that the segment is the idealized
put:asegment t:hat begins at RCV.NXT and does not exceed the window.
put:aOne could: tailor actual segments to fit this assumption by
put:atrimming :off any portions that lie outside the window (including
put:aSYN and F:IN), and only processing further if the segment then
put:abegins at: RCV.NXT.  Segments with higher begining sequence
put:anumbers m:ay be held for later processing.
put:asecond check :the RST bit,
put:aSYN-RECEIVE:D STATE
put:aIf the RS:T bit is set
put:aIf this: connection was initiated with a passive OPEN (i.e.,
put:acame fr:om the LISTEN state), then return this connection to
put:aLISTEN :state and return.  The user need not be informed.  If
put:athis co:nnection was initiated with an active OPEN (i.e., came
put:afrom SY:N-SENT state) then the connection was refused, signal
put:athe use:r "connection refused".  In either case, all segments
put:aon the :retransmission queue should be removed.  And in the
put:aactive :OPEN case, enter the CLOSED state and delete the TCB,
put:aand ret:urn.
put:aESTABLISHED:
put:aIf the RS:T bit is set then, any outstanding RECEIVEs and SEND
put:ashould re:ceive "reset" responses.  All segment queues should be
put:aflushed. : Users should also receive an unsolicited general
put:a"connecti:on reset" signal.  Enter the CLOSED state, delete the
put:aTCB, and :return.
put:aCLOSING STA:TE
put:aLAST-ACK ST:ATE
put:aIf the RS:T bit is set then, enter the CLOSED state, delete the
put:aTCB, and :return.
put:a[Page 70]        :                                                       
put:aSeptember 1981   :                                                       
put:athird check s:ecurity and precedence
put:aSYN-RECEIVE:D
put:aIf the se:curity/compartment and precedence in the segment do not
put:aexactly m:atch the security/compartment and precedence in the TCB
put:athen send: a reset, and return.
put:aESTABLISHED: STATE
put:aIf the se:curity/compartment and precedence in the segment do not
put:aexactly m:atch the security/compartment and precedence in the TCB
put:athen send: a reset, any outstanding RECEIVEs and SEND should
put:areceive ":reset" responses.  All segment queues should be
put:aflushed. : Users should also receive an unsolicited general
put:a"connecti:on reset" signal.  Enter the CLOSED state, delete the
put:aTCB, and :return.
put:aNote this c:heck is placed following the sequence check to prevent
put:aa segment f:rom an old connection between these ports with a
put:adifferent s:ecurity or precedence from causing an abort of the
put:acurrent con:nection.
put:afourth, check: the SYN bit,
put:aSYN-RECEIVE:D
put:aESTABLISHED: STATE
put:aFIN-WAIT ST:ATE-1
put:aFIN-WAIT ST:ATE-2
put:aCLOSE-WAIT :STATE
put:aCLOSING STA:TE
put:aLAST-ACK ST:ATE
put:aTIME-WAIT S:TATE
put:aIf the SY:N is in the window it is an error, send a reset, any
put:aoutstandi:ng RECEIVEs and SEND should receive "reset" responses,
put:aall segme:nt queues should be flushed, the user should also
put:areceive a:n unsolicited general "connection reset" signal, enter
put:athe CLOSE:D state, delete the TCB, and return.
put:aIf the SY:N is not in the window this step would not be reached
put:aand an ac:k would have been sent in the first step (sequence
put:anumber ch:eck).
put:aTransmission Cont:rol Protocol
put:aFunctional Specif:ication
put:afifth check t:he ACK field,
put:aif the ACK :bit is off drop the segment and return
put:aif the ACK :bit is on
put:aSYN-RECEI:VED STATE
put:aIf SND.:UNA =< SEG.ACK =< SND.NXT then enter ESTABLISHED state
put:aand con:tinue processing.
put:aIf th:e segment acknowledgment is not acceptable, form a
put:areset: segment,
put:a<SE:Q=SEG.ACK><CTL=RST>
put:aand s:end it.
put:aESTABLISH:ED STATE
put:aIf SND.:UNA < SEG.ACK =< SND.NXT then, set SND.UNA <- SEG.ACK.
put:aAny seg:ments on the retransmission queue which are thereby
put:aentirel:y acknowledged are removed.  Users should receive
put:apositiv:e acknowledgments for buffers which have been SENT and
put:afully a:cknowledged (i.e., SEND buffer should be returned with
put:a"ok" re:sponse).  If the ACK is a duplicate
put:a(SEG.AC:K < SND.UNA), it can be ignored.  If the ACK acks
put:asomethi:ng not yet sent (SEG.ACK > SND.NXT) then send an ACK,
put:adrop th:e segment, and return.
put:aIf SND.:UNA < SEG.ACK =< SND.NXT, the send window should be
put:aupdated:.  If (SND.WL1 < SEG.SEQ or (SND.WL1 = SEG.SEQ and
put:aSND.WL2: =< SEG.ACK)), set SND.WND <- SEG.WND, set
put:aSND.WL1: <- SEG.SEQ, and set SND.WL2 <- SEG.ACK.
put:aNote th:at SND.WND is an offset from SND.UNA, that SND.WL1
put:arecords: the sequence number of the last segment used to update
put:aSND.WND:, and that SND.WL2 records the acknowledgment number of
put:athe las:t segment used to update SND.WND.  The check here
put:aprevent:s using old segments to update the window.
put:a[Page 72]        :                                                       
put:aSeptember 1981   :                                                       
put:aFIN-WAIT-:1 STATE
put:aIn addi:tion to the processing for the ESTABLISHED state, if
put:aour FIN: is now acknowledged then enter FIN-WAIT-2 and continue
put:aprocess:ing in that state.
put:aFIN-WAIT-:2 STATE
put:aIn addi:tion to the processing for the ESTABLISHED state, if
put:athe ret:ransmission queue is empty, the user's CLOSE can be
put:aacknowl:edged ("ok") but do not delete the TCB.
put:aCLOSE-WAI:T STATE
put:aDo the :same processing as for the ESTABLISHED state.
put:aCLOSING S:TATE
put:aIn addi:tion to the processing for the ESTABLISHED state, if
put:athe ACK: acknowledges our FIN then enter the TIME-WAIT state,
put:aotherwi:se ignore the segment.
put:aLAST-ACK :STATE
put:aThe onl:y thing that can arrive in this state is an
put:aacknowl:edgment of our FIN.  If our FIN is now acknowledged,
put:adelete :the TCB, enter the CLOSED state, and return.
put:aTIME-WAIT: STATE
put:aThe onl:y thing that can arrive in this state is a
put:aretrans:mission of the remote FIN.  Acknowledge it, and restart
put:athe 2 M:SL timeout.
put:asixth, check :the URG bit,
put:aESTABLISHED: STATE
put:aFIN-WAIT-1 :STATE
put:aFIN-WAIT-2 :STATE
put:aIf the UR:G bit is set, RCV.UP <- max(RCV.UP,SEG.UP), and signal
put:athe user :that the remote side has urgent data if the urgent
put:apointer (:RCV.UP) is in advance of the data consumed.  If the
put:auser has :already been signaled (or is still in the "urgent
put:amode") fo:r this continuous sequence of urgent data, do not
put:asignal th:e user again.
put:aTransmission Cont:rol Protocol
put:aFunctional Specif:ication
put:aCLOSE-WAIT :STATE
put:aCLOSING STA:TE
put:aLAST-ACK ST:ATE
put:aThis shou:ld not occur, since a FIN has been received from the
put:aremote si:de.  Ignore the URG.
put:aseventh, proc:ess the segment text,
put:aESTABLISHED: STATE
put:aFIN-WAIT-1 :STATE
put:aFIN-WAIT-2 :STATE
put:aOnce in t:he ESTABLISHED state, it is possible to deliver segment
put:atext to u:ser RECEIVE buffers.  Text from segments can be moved
put:ainto buff:ers until either the buffer is full or the segment is
put:aempty.  I:f the segment empties and carries an PUSH flag, then
put:athe user :is informed, when the buffer is returned, that a PUSH
put:ahas been :received.
put:aWhen the :TCP takes responsibility for delivering the data to the
put:auser it m:ust also acknowledge the receipt of the data.
put:aOnce the :TCP takes responsibility for the data it advances
put:aRCV.NXT o:ver the data accepted, and adjusts RCV.WND as
put:aapporopri:ate to the current buffer availability.  The total of
put:aRCV.NXT a:nd RCV.WND should not be reduced.
put:aPlease no:te the window management suggestions in section 3.7.
put:aSend an a:cknowledgment of the form:
put:a<SEQ=SN:D.NXT><ACK=RCV.NXT><CTL=ACK>
put:aThis ackn:owledgment should be piggybacked on a segment being
put:atransmitt:ed if possible without incurring undue delay.
put:a[Page 74]        :                                                       
put:aSeptember 1981   :                                                       
put:aCLOSE-WAIT :STATE
put:aCLOSING STA:TE
put:aLAST-ACK ST:ATE
put:aTIME-WAIT S:TATE
put:aThis shou:ld not occur, since a FIN has been received from the
put:aremote si:de.  Ignore the segment text.
put:aeighth, check: the FIN bit,
put:aDo not proc:ess the FIN if the state is CLOSED, LISTEN or SYN-SENT
put:asince the S:EG.SEQ cannot be validated; drop the segment and
put:aIf the FIN :bit is set, signal the user "connection closing" and
put:areturn any :pending RECEIVEs with same message, advance RCV.NXT
put:aover the FI:N, and send an acknowledgment for the FIN.  Note that
put:aFIN implies: PUSH for any segment text not yet delivered to the
put:aSYN-RECEI:VED STATE
put:aESTABLISH:ED STATE
put:aEnter t:he CLOSE-WAIT state.
put:aFIN-WAIT-:1 STATE
put:aIf our :FIN has been ACKed (perhaps in this segment), then
put:aenter T:IME-WAIT, start the time-wait timer, turn off the other
put:atimers;: otherwise enter the CLOSING state.
put:aFIN-WAIT-:2 STATE
put:aEnter t:he TIME-WAIT state.  Start the time-wait timer, turn
put:aoff the: other timers.
put:aCLOSE-WAI:T STATE
put:aRemain :in the CLOSE-WAIT state.
put:aCLOSING S:TATE
put:aRemain :in the CLOSING state.
put:aLAST-ACK :STATE
put:aRemain :in the LAST-ACK state.
put:aTransmission Cont:rol Protocol
put:aFunctional Specif:ication
put:aTIME-WAIT: STATE
put:aRemain :in the TIME-WAIT state.  Restart the 2 MSL time-wait
put:atimeout:.
put:a[Page 76]        :                                                       
put:aSeptember 1981   :                                                       
put:aFor any state: if the user timeout expires, flush all queues, signal
put:athe user "err:or:  connection aborted due to user timeout" in general
put:aand for any o:utstanding calls, delete the TCB, enter the CLOSED
put:astate and ret:urn.
put:aRETRANSMISSION :TIMEOUT
put:aFor any state: if the retransmission timeout expires on a segment in
put:athe retransmi:ssion queue, send the segment at the front of the
put:aretransmissio:n queue again, reinitialize the retransmission timer,
put:aTIME-WAIT TIMEO:UT
put:aIf the time-w:ait timeout expires on a connection delete the TCB,
put:aenter the CLO:SED state and return.
put:aTransmission Cont:rol Protocol
put:a[Page 78]        :                                                       
put:aSeptember 1981   :                                                       
put:aBBN Rep:ort 1822, "The Specification of the Interconnection of
put:aa Host :and an IMP".  The specification of interface between a
put:ahost an:d the ARPANET.
put:aA contr:ol bit (acknowledge) occupying no sequence space, which
put:aindicat:es that the acknowledgment field of this segment
put:aspecifi:es the next sequence number the sender of this segment
put:ais expe:cting to receive, hence acknowledging receipt of all
put:apreviou:s sequence numbers.
put:aThe uni:t of transmission between a host and an IMP in the
put:aARPANET:.  The maximum size is about 1012 octets (8096 bits).
put:aA unit :of transmission used internally in the ARPANET between
put:aIMPs.  :The maximum size is about 126 octets (1008 bits).
put:aA logic:al communication path identified by a pair of sockets.
put:aA messa:ge sent in a packet switched computer communications
put:anetwork:.
put:aDestination Addre:ss
put:aThe des:tination address, usually the network and host
put:aidentif:iers.
put:aA contr:ol bit (finis) occupying one sequence number, which
put:aindicat:es that the sender will send no more data or control
put:aoccupyi:ng sequence space.
put:aA porti:on of a logical unit of data, in particular an internet
put:afragmen:t is a portion of an internet datagram.
put:aA file :transfer protocol.
put:aTransmission Cont:rol Protocol
put:aControl: information at the beginning of a message, segment,
put:afragmen:t, packet or block of data.
put:aA compu:ter.  In particular a source or destination of messages
put:afrom th:e point of view of the communication network.
put:aAn Inte:rnet Protocol field.  This identifying value assigned
put:aby the :sender aids in assembling the fragments of a datagram.
put:aThe Int:erface Message Processor, the packet switch of the
put:aARPANET:.
put:aA sourc:e or destination address specific to the host level.
put:ainternet datagram:
put:aThe uni:t of data exchanged between an internet module and the
put:ahigher :level protocol together with the internet header.
put:ainternet fragment:
put:aA porti:on of the data of an internet datagram with an internet
put:aheader.:
put:aInterne:t Protocol.
put:aThe Ini:tial Receive Sequence number.  The first sequence
put:anumber :used by the sender on a connection.
put:aThe Ini:tial Sequence Number.  The first sequence number used
put:aon a co:nnection, (either ISS or IRS).  Selected on a clock
put:abased p:rocedure.
put:aThe Ini:tial Send Sequence number.  The first sequence number
put:aused by: the sender on a connection.
put:aControl: information at the beginning of a message or block of
put:adata.  :In particular, in the ARPANET, the control information
put:aon an A:RPANET message at the host-IMP interface.
put:a[Page 80]        :                                                       
put:aSeptember 1981   :                                                       
put:aThis is: the next sequence number to be acknowledged by the
put:adata re:ceiving TCP (or the lowest currently unacknowledged
put:asequenc:e number) and is sometimes referred to as the left edge
put:aof the :send window.
put:aThe uni:t of transmission within a local network.
put:aAn impl:ementation, usually in software, of a protocol or other
put:aprocedu:re.
put:aMaximum: Segment Lifetime, the time a TCP segment can exist in
put:athe int:ernetwork system.  Arbitrarily defined to be 2 minutes.
put:aAn eigh:t bit byte.
put:aAn Opti:on field may contain several options, and each option
put:amay be :several octets in length.  The options are used
put:aprimari:ly in testing situations; for example, to carry
put:atimesta:mps.  Both the Internet Protocol and TCP provide for
put:aoptions: fields.
put:aA packa:ge of data with a header which may or may not be
put:alogical:ly complete.  More often a physical packaging than a
put:alogical: packaging of data.
put:aThe por:tion of a socket that specifies which logical input or
put:aoutput :channel of a process is associated with the data.
put:aA progr:am in execution.  A source or destination of data from
put:athe poi:nt of view of the TCP or other host-to-host protocol.
put:aA contr:ol bit occupying no sequence space, indicating that
put:athis se:gment contains data that must be pushed through to the
put:areceivi:ng user.
put:areceive: next sequence number
put:aTransmission Cont:rol Protocol
put:areceive: urgent pointer
put:areceive: window
put:areceive next sequ:ence number
put:aThis is: the next sequence number the local TCP is expecting to
put:areceive:.
put:aThis re:presents the sequence numbers the local (receiving) TCP
put:ais will:ing to receive.  Thus, the local TCP considers that
put:asegment:s overlapping the range RCV.NXT to
put:aRCV.NXT: + RCV.WND - 1 carry acceptable data or control.
put:aSegment:s containing sequence numbers entirely outside of this
put:arange a:re considered duplicates and discarded.
put:aA contr:ol bit (reset), occupying no sequence space, indicating
put:athat th:e receiver should delete the connection without further
put:ainterac:tion.  The receiver can determine, based on the
put:asequenc:e number and acknowledgment fields of the incoming
put:asegment:, whether it should honor the reset command or ignore
put:ait.  In: no case does receipt of a segment containing RST give
put:arise to: a RST in response.
put:aReal Ti:me Protocol:  A host-to-host protocol for communication
put:aof time: critical information.
put:asegment: acknowledgment
put:asegment: length
put:asegment: precedence value
put:asegment: sequence
put:asegment: urgent pointer field
put:a[Page 82]        :                                                       
put:aSeptember 1981   :                                                       
put:asegment: window field
put:aA logic:al unit of data, in particular a TCP segment is the
put:aunit of: data transfered between a pair of TCP modules.
put:asegment acknowled:gment
put:aThe seq:uence number in the acknowledgment field of the
put:aarrivin:g segment.
put:aThe amo:unt of sequence number space occupied by a segment,
put:aincludi:ng any controls which occupy sequence space.
put:aThe num:ber in the sequence field of the arriving segment.
put:aThis is: the next sequence number the local (sending) TCP will
put:ause on :the connection.  It is initially selected from an
put:ainitial: sequence number curve (ISN) and is incremented for
put:aeach oc:tet of data or sequenced control transmitted.
put:aThis re:presents the sequence numbers which the remote
put:a(receiv:ing) TCP is willing to receive.  It is the value of the
put:awindow :field specified in segments from the remote (data
put:areceivi:ng) TCP.  The range of new sequence numbers which may
put:abe emit:ted by a TCP lies between SND.NXT and
put:aSND.UNA: + SND.WND - 1. (Retransmissions of sequence numbers
put:abetween: SND.UNA and SND.NXT are expected, of course.)
put:asend se:quence
put:aleft se:quence
put:asend ur:gent pointer
put:asegment: sequence number at last window update
put:asegment: acknowledgment number at last window update
put:aTransmission Cont:rol Protocol
put:asend wi:ndow
put:aAn addr:ess which specifically includes a port identifier, that
put:ais, the: concatenation of an Internet Address with a TCP port.
put:aThe sou:rce address, usually the network and host identifiers.
put:aA contr:ol bit in the incoming segment, occupying one sequence
put:anumber,: used at the initiation of a connection, to indicate
put:awhere t:he sequence numbering will start.
put:aTransmi:ssion control block, the data structure that records
put:athe sta:te of a connection.
put:aThe pre:cedence of the connection.
put:aTransmi:ssion Control Protocol:  A host-to-host protocol for
put:areliabl:e communication in internetwork environments.
put:aType of: Service, an Internet Protocol field.
put:aAn Inte:rnet Protocol field which indicates the type of service
put:afor thi:s internet fragment.
put:aA contr:ol bit (urgent), occupying no sequence space, used to
put:aindicat:e that the receiving user should be notified to do
put:aurgent :processing as long as there is data to be consumed with
put:asequenc:e numbers less than the value indicated in the urgent
put:apointer:.
put:aA contr:ol field meaningful only when the URG bit is on.  This
put:afield c:ommunicates the value of the urgent pointer which
put:aindicat:es the data octet associated with the sending user's
put:aurgent :call.
put:a[Page 84]        :                                                       
put:aSeptember 1981   :                                                       
put:a[1]  Cerf, V., an:d R. Kahn, "A Protocol for Packet Network
put:aIntercommuni:cation", IEEE Transactions on Communications,
put:aVol. COM-22,: No. 5, pp 637-648, May 1974.
put:a[2]  Postel, J. (:ed.), "Internet Protocol - DARPA Internet Program
put:aProtocol Spe:cification", RFC 791, USC/Information Sciences
put:aInstitute, S:eptember 1981.
put:a[3]  Dalal, Y. an:d C. Sunshine, "Connection Management in Transport
put:aProtocols", :Computer Networks, Vol. 2, No. 6, pp. 454-473,
put:aDecember 197:8.
put:a[4]  Postel, J., :"Assigned Numbers", RFC 790, USC/Information Sciences
put:aInstitute, S:eptember 1981.
put:bRFC: 793
put:bDe:fense Advanced Research Projects Agency
put:bI:nformation Processing Techniques Office
put:bSeptember 1981   :                                                       
put:bPREFACE .....:................................................... iii
put:b1.  INTRODUCTION :..................................................... 1
put:b1.1  Motivation: .................................................... 1
put:b1.2  Scope ....:..................................................... 2
put:b1.3  About This: Document ........................................... 2
put:b1.4  Interfaces: .................................................... 3
put:b1.5  Operation :..................................................... 3
put:b2.  PHILOSOPHY ..:..................................................... 7
put:b2.1  Elements o:f the Internetwork System ........................... 7
put:b2.2  Model of O:peration ............................................ 7
put:b2.3  The Host E:nvironment .......................................... 8
put:b2.4  Interfaces: .................................................... 9
put:b2.5  Relation t:o Other Protocols ................................... 9
put:b2.6  Reliable C:ommunication ........................................ 9
put:b2.7  Connection: Establishment and Clearing ........................ 10
put:b2.8  Data Commu:nication ........................................... 12
put:b2.9  Precedence: and Security ...................................... 13
put:b2.10 Robustness: Principle ......................................... 13
put:b3.  FUNCTIONAL SP:ECIFICATION ........................................ 15
put:b3.1  Header For:mat ................................................ 15
put:b3.2  Terminolog:y .................................................. 19
put:b3.3  Sequence N:umbers ............................................. 24
put:b3.4  Establishi:ng a connection .................................... 30
put:b3.5  Closing a :Connection ......................................... 37
put:b3.6  Precedence: and Security ...................................... 40
put:b3.7  Data Commu:nication ........................................... 40
put:b3.8  Interfaces: ................................................... 44
put:b3.9  Event Proc:essing ............................................. 52
put:bGLOSSARY ........:.................................................... 79
put:bREFERENCES ......:.................................................... 85
put:bTransmission Cont:rol Protocol
put:b[Page ii]        :                                                       
put:bSeptember 1981   :                                                       
put:bThis document des:cribes the DoD Standard Transmission Control Protocol
put:b(TCP).  There hav:e been nine earlier editions of the ARPA TCP
put:bspecification on :which this standard is based, and the present text
put:bdraws heavily fro:m them.  There have been many contributors to this work
put:bboth in terms of :concepts and in terms of text.  This edition clarifies
put:bseveral details a:nd removes the end-of-letter buffer-size adjustments,
put:band redescribes t:he letter mechanism as a push function.
put:bRFC:  793
put:bReplaces: RFC 761:
put:bIENs:  129, 124, :112, 81,
put:b55, 44, 40, 27, 2:1, 5
put:bThe Transmission :Control Protocol (TCP) is intended for use as a highly
put:breliable host-to-:host protocol between hosts in packet-switched computer
put:bcommunication net:works, and in interconnected systems of such networks.
put:bThis document des:cribes the functions to be performed by the
put:bTransmission Cont:rol Protocol, the program that implements it, and its
put:binterface to prog:rams or users that require its services.
put:bComputer commun:ication systems are playing an increasingly important
put:brole in militar:y, government, and civilian environments.  This
put:bdocument focuse:s its attention primarily on military computer
put:bcommunication r:equirements, especially robustness in the presence of
put:bcommunication u:nreliability and availability in the presence of
put:bcongestion, but: many of these problems are found in the civilian and
put:bgovernment sect:or as well.
put:bAs strategic an:d tactical computer communication networks are
put:bdeveloped and d:eployed, it is essential to provide means of
put:binterconnecting: them and to provide standard interprocess
put:bcommunication p:rotocols which can support a broad range of
put:bapplications.  :In anticipation of the need for such standards, the
put:bDeputy Undersec:retary of Defense for Research and Engineering has
put:bdeclared the Tr:ansmission Control Protocol (TCP) described herein to
put:bbe a basis for :DoD-wide inter-process communication protocol
put:bstandardization:.
put:bTCP is a connec:tion-oriented, end-to-end reliable protocol designed to
put:bfit into a laye:red hierarchy of protocols which support multi-network
put:bapplications.  :The TCP provides for reliable inter-process
put:bcommunication b:etween pairs of processes in host computers attached to
put:bdistinct but in:terconnected computer communication networks.  Very few
put:bassumptions are: made as to the reliability of the communication
put:bprotocols below: the TCP layer.  TCP assumes it can obtain a simple,
put:bpotentially unr:eliable datagram service from the lower level
put:bprotocols.  In :principle, the TCP should be able to operate above a
put:bwide spectrum o:f communication systems ranging from hard-wired
put:bconnections to :packet-switched or circuit-switched networks.
put:bTransmission Cont:rol Protocol
put:bTCP is based on: concepts first described by Cerf and Kahn in [1].  The
put:bTCP fits into a: layered protocol architecture just above a basic
put:bInternet Protoc:ol [2] which provides a way for the TCP to send and
put:breceive variabl:e-length segments of information enclosed in internet
put:bdatagram "envel:opes".  The internet datagram provides a means for
put:baddressing sour:ce and destination TCPs in different networks.  The
put:binternet protoc:ol also deals with any fragmentation or reassembly of
put:bthe TCP segment:s required to achieve transport and delivery through
put:bmultiple networ:ks and interconnecting gateways.  The internet protocol
put:balso carries in:formation on the precedence, security classification
put:band compartment:ation of the TCP segments, so this information can be
put:bcommunicated en:d-to-end across multiple networks.
put:bMuch of this do:cument is written in the context of TCP implementations
put:bwhich are co-re:sident with higher level protocols in the host
put:bcomputer.  Some: computer systems will be connected to networks via
put:bfront-end compu:ters which house the TCP and internet protocol layers,
put:bas well as netw:ork specific software.  The TCP specification describes
put:ban interface to: the higher level protocols which appears to be
put:bimplementable e:ven for the front-end case, as long as a suitable
put:bhost-to-front e:nd protocol is implemented.
put:bThe TCP is inte:nded to provide a reliable process-to-process
put:bcommunication s:ervice in a multinetwork environment.  The TCP is
put:bintended to be :a host-to-host protocol in common use in multiple
put:b1.3.  About this :Document
put:bThis document r:epresents a specification of the behavior required of
put:bany TCP impleme:ntation, both in its interactions with higher level
put:bprotocols and i:n its interactions with other TCPs.  The rest of this
put:b[Page 2]         :                                                       
put:bSeptember 1981   :                                                       
put:bsection offers :a very brief view of the protocol interfaces and
put:boperation.  Sec:tion 2 summarizes the philosophical basis for the TCP
put:bdesign.  Sectio:n 3 offers both a detailed description of the actions
put:brequired of TCP: when various events occur (arrival of new segments,
put:buser calls, err:ors, etc.) and the details of the formats of TCP
put:bThe TCP interfa:ces on one side to user or application processes and on
put:bthe other side :to a lower level protocol such as Internet Protocol.
put:bThe interface b:etween an application process and the TCP is
put:billustrated in :reasonable detail.  This interface consists of a set of
put:bcalls much like: the calls an operating system provides to an
put:bapplication pro:cess for manipulating files.  For example, there are
put:bcalls to open a:nd close connections and to send and receive data on
put:bestablished con:nections.  It is also expected that the TCP can
put:basynchronously :communicate with application programs.  Although
put:bconsiderable fr:eedom is permitted to TCP implementors to design
put:binterfaces whic:h are appropriate to a particular operating system
put:benvironment, a :minimum functionality is required at the TCP/user
put:binterface for a:ny valid implementation.
put:bThe interface b:etween TCP and lower level protocol is essentially
put:bunspecified exc:ept that it is assumed there is a mechanism whereby the
put:btwo levels can :asynchronously pass information to each other.
put:bTypically, one :expects the lower level protocol to specify this
put:binterface.  TCP: is designed to work in a very general environment of
put:binterconnected :networks.  The lower level protocol which is assumed
put:bthroughout this: document is the Internet Protocol [2].
put:bAs noted above,: the primary purpose of the TCP is to provide reliable,
put:bsecurable logic:al circuit or connection service between pairs of
put:bprocesses.  To :provide this service on top of a less reliable internet
put:bcommunication s:ystem requires facilities in the following areas:
put:bBasic Data Tr:ansfer
put:bPrecedence an:d Security
put:bThe basic opera:tion of the TCP in each of these areas is described in
put:bthe following p:aragraphs.
put:bTransmission Cont:rol Protocol
put:bBasic Data Tran:sfer:
put:bThe TCP is ab:le to transfer a continuous stream of octets in each
put:bdirection bet:ween its users by packaging some number of octets into
put:bsegments for :transmission through the internet system.  In general,
put:bthe TCPs deci:de when to block and forward data at their own
put:bSometimes use:rs need to be sure that all the data they have
put:bsubmitted to :the TCP has been transmitted.  For this purpose a push
put:bfunction is d:efined.  To assure that data submitted to a TCP is
put:bactually tran:smitted the sending user indicates that it should be
put:bpushed throug:h to the receiving user.  A push causes the TCPs to
put:bpromptly forw:ard and deliver data up to that point to the receiver.
put:bThe exact pus:h point might not be visible to the receiving user and
put:bthe push func:tion does not supply a record boundary marker.
put:bReliability:
put:bThe TCP must :recover from data that is damaged, lost, duplicated, or
put:bdelivered out: of order by the internet communication system.  This
put:bis achieved b:y assigning a sequence number to each octet
put:btransmitted, :and requiring a positive acknowledgment (ACK) from the
put:breceiving TCP:.  If the ACK is not received within a timeout
put:binterval, the: data is retransmitted.  At the receiver, the sequence
put:bnumbers are u:sed to correctly order segments that may be received
put:bout of order :and to eliminate duplicates.  Damage is handled by
put:badding a chec:ksum to each segment transmitted, checking it at the
put:breceiver, and: discarding damaged segments.
put:bAs long as th:e TCPs continue to function properly and the internet
put:bsystem does n:ot become completely partitioned, no transmission
put:berrors will a:ffect the correct delivery of data.  TCP recovers from
put:binternet comm:unication system errors.
put:bFlow Control:
put:bTCP provides :a means for the receiver to govern the amount of data
put:bsent by the s:ender.  This is achieved by returning a "window" with
put:bevery ACK ind:icating a range of acceptable sequence numbers beyond
put:bthe last segm:ent successfully received.  The window indicates an
put:ballowed numbe:r of octets that the sender may transmit before
put:breceiving fur:ther permission.
put:b[Page 4]         :                                                       
put:bSeptember 1981   :                                                       
put:bMultiplexing:
put:bTo allow for :many processes within a single Host to use TCP
put:bcommunication: facilities simultaneously, the TCP provides a set of
put:baddresses or :ports within each host.  Concatenated with the network
put:band host addr:esses from the internet communication layer, this forms
put:ba socket.  A :pair of sockets uniquely identifies each connection.
put:bThat is, a so:cket may be simultaneously used in multiple
put:bThe binding o:f ports to processes is handled independently by each
put:bHost.  Howeve:r, it proves useful to attach frequently used processes
put:b(e.g., a "log:ger" or timesharing service) to fixed sockets which are
put:bmade known to: the public.  These services can then be accessed
put:bthrough the k:nown addresses.  Establishing and learning the port
put:baddresses of :other processes may involve more dynamic mechanisms.
put:bConnections:
put:bThe reliabili:ty and flow control mechanisms described above require
put:bthat TCPs ini:tialize and maintain certain status information for
put:beach data str:eam.  The combination of this information, including
put:bsockets, sequ:ence numbers, and window sizes, is called a connection.
put:bEach connecti:on is uniquely specified by a pair of sockets
put:bidentifying i:ts two sides.
put:bWhen two proc:esses wish to communicate, their TCP's must first
put:bestablish a c:onnection (initialize the status information on each
put:bside).  When :their communication is complete, the connection is
put:bterminated or: closed to free the resources for other uses.
put:bSince connect:ions must be established between unreliable hosts and
put:bover the unre:liable internet communication system, a handshake
put:bmechanism wit:h clock-based sequence numbers is used to avoid
put:berroneous ini:tialization of connections.
put:bPrecedence and :Security:
put:bThe users of :TCP may indicate the security and precedence of their
put:bcommunication:.  Provision is made for default values to be used when
put:bthese feature:s are not needed.
put:bTransmission Cont:rol Protocol
put:b[Page 6]         :                                                       
put:bSeptember 1981   :                                                       
put:b2.1.  Elements of: the Internetwork System
put:bThe internetwor:k environment consists of hosts connected to networks
put:bwhich are in tu:rn interconnected via gateways.  It is assumed here
put:bthat the networ:ks may be either local networks (e.g., the ETHERNET) or
put:blarge networks :(e.g., the ARPANET), but in any case are based on
put:bpacket switchin:g technology.  The active agents that produce and
put:bconsume message:s are processes.  Various levels of protocols in the
put:bnetworks, the g:ateways, and the hosts support an interprocess
put:bcommunication s:ystem that provides two-way data flow on logical
put:bconnections bet:ween process ports.
put:bThe term packet: is used generically here to mean the data of one
put:btransaction bet:ween a host and its network.  The format of data blocks
put:bexchanged withi:n the a network will generally not be of concern to us.
put:bHosts are compu:ters attached to a network, and from the communication
put:bnetwork's point: of view, are the sources and destinations of packets.
put:bProcesses are v:iewed as the active elements in host computers (in
put:baccordance with: the fairly common definition of a process as a program
put:bin execution). : Even terminals and files or other I/O devices are
put:bviewed as commu:nicating with each other through the use of processes.
put:bThus, all commu:nication is viewed as inter-process communication.
put:bSince a process: may need to distinguish among several communication
put:bstreams between: itself and another process (or processes), we imagine
put:bthat each proce:ss may have a number of ports through which it
put:bcommunicates wi:th the ports of other processes.
put:b2.2.  Model of Op:eration
put:bProcesses trans:mit data by calling on the TCP and passing buffers of
put:bdata as argumen:ts.  The TCP packages the data from these buffers into
put:bsegments and ca:lls on the internet module to transmit each segment to
put:bthe destination: TCP.  The receiving TCP places the data from a segment
put:binto the receiv:ing user's buffer and notifies the receiving user.  The
put:bTCPs include co:ntrol information in the segments which they use to
put:bensure reliable: ordered data transmission.
put:bThe model of in:ternet communication is that there is an internet
put:bprotocol module: associated with each TCP which provides an interface
put:bto the local ne:twork.  This internet module packages TCP segments
put:binside internet: datagrams and routes these datagrams to a destination
put:binternet module: or intermediate gateway.  To transmit the datagram
put:bthrough the loc:al network, it is embedded in a local network packet.
put:bThe packet swit:ches may perform further packaging, fragmentation, or
put:bTransmission Cont:rol Protocol
put:bother operation:s to achieve the delivery of the local packet to the
put:bdestination int:ernet module.
put:bAt a gateway be:tween networks, the internet datagram is "unwrapped"
put:bfrom its local :packet and examined to determine through which network
put:bthe internet da:tagram should travel next.  The internet datagram is
put:bthen "wrapped" :in a local packet suitable to the next network and
put:brouted to the n:ext gateway, or to the final destination.
put:bA gateway is pe:rmitted to break up an internet datagram into smaller
put:binternet datagr:am fragments if this is necessary for transmission
put:bthrough the nex:t network.  To do this, the gateway produces a set of
put:binternet datagr:ams; each carrying a fragment.  Fragments may be
put:bfurther broken :into smaller fragments at subsequent gateways.  The
put:binternet datagr:am fragment format is designed so that the destination
put:binternet module: can reassemble fragments into internet datagrams.
put:bA destination i:nternet module unwraps the segment from the datagram
put:b(after reassemb:ling the datagram, if necessary) and passes it to the
put:bdestination TCP:.
put:bThis simple mod:el of the operation glosses over many details.  One
put:bimportant featu:re is the type of service.  This provides information
put:bto the gateway :(or internet module) to guide it in selecting the
put:bservice paramet:ers to be used in traversing the next network.
put:bIncluded in the: type of service information is the precedence of the
put:bdatagram.  Data:grams may also carry security information to permit
put:bhost and gatewa:ys that operate in multilevel secure environments to
put:bproperly segreg:ate datagrams for security considerations.
put:b2.3.  The Host En:vironment
put:bThe TCP is assu:med to be a module in an operating system.  The users
put:baccess the TCP :much like they would access the file system.  The TCP
put:bmay call on oth:er operating system functions, for example, to manage
put:bdata structures:.  The actual interface to the network is assumed to be
put:bcontrolled by a: device driver module.  The TCP does not call on the
put:bnetwork device :driver directly, but rather calls on the internet
put:bdatagram protoc:ol module which may in turn call on the device driver.
put:bThe mechanisms :of TCP do not preclude implementation of the TCP in a
put:bfront-end proce:ssor.  However, in such an implementation, a
put:bhost-to-front-e:nd protocol must provide the functionality to support
put:bthe type of TCP:-user interface described in this document.
put:b[Page 8]         :                                                       
put:bSeptember 1981   :                                                       
put:bThe TCP/user in:terface provides for calls made by the user on the TCP
put:bto OPEN or CLOS:E a connection, to SEND or RECEIVE data, or to obtain
put:bSTATUS about a :connection.  These calls are like other calls from user
put:bprograms on the: operating system, for example, the calls to open, read
put:bfrom, and close: a file.
put:bThe TCP/interne:t interface provides calls to send and receive
put:bdatagrams addre:ssed to TCP modules in hosts anywhere in the internet
put:bsystem.  These :calls have parameters for passing the address, type of
put:bservice, preced:ence, security, and other control information.
put:b2.5.  Relation to: Other Protocols
put:bThe following d:iagram illustrates the place of the TCP in the protocol
put:bhierarchy:
put:b+------+ +:-----+ +-----+       +-----+                    
put:b|Telnet| |: FTP | |Voice|  ...  |     |  Application Level 
put:b+------+ +:-----+ +-----+       +-----+                    
put:b|   :|         |             |                       
put:b+----:-+     +-----+       +-----+                    
put:b| TCP: |     | RTP |  ...  |     |  Host Level        
put:b+----:-+     +-----+       +-----+                    
put:b| :          |             |                       
put:b+----:---------------------------+                    
put:b|    :Internet Protocol & ICMP   |  Gateway Level     
put:b+----:---------------------------+                    
put:b+--:-------------------------+                      
put:b|  : Local Network Protocol  |    Network Level     
put:b+--:-------------------------+                      
put:bIt is expected :that the TCP will be able to support higher level
put:bprotocols effic:iently.  It should be easy to interface higher level
put:bprotocols like :the ARPANET Telnet or AUTODIN II THP to the TCP.
put:b2.6.  Reliable Co:mmunication
put:bA stream of dat:a sent on a TCP connection is delivered reliably and in
put:border at the de:stination.
put:bTransmission Cont:rol Protocol
put:bTransmission is: made reliable via the use of sequence numbers and
put:backnowledgments:.  Conceptually, each octet of data is assigned a
put:bsequence number:.  The sequence number of the first octet of data in a
put:bsegment is tran:smitted with that segment and is called the segment
put:bsequence number:.  Segments also carry an acknowledgment number which
put:bis the sequence: number of the next expected data octet of
put:btransmissions i:n the reverse direction.  When the TCP transmits a
put:bsegment contain:ing data, it puts a copy on a retransmission queue and
put:bstarts a timer;: when the acknowledgment for that data is received, the
put:bsegment is dele:ted from the queue.  If the acknowledgment is not
put:breceived before: the timer runs out, the segment is retransmitted.
put:bAn acknowledgme:nt by TCP does not guarantee that the data has been
put:bdelivered to th:e end user, but only that the receiving TCP has taken
put:bthe responsibil:ity to do so.
put:bTo govern the f:low of data between TCPs, a flow control mechanism is
put:bemployed.  The :receiving TCP reports a "window" to the sending TCP.
put:bThis window spe:cifies the number of octets, starting with the
put:backnowledgment :number, that the receiving TCP is currently prepared to
put:b2.7.  Connection :Establishment and Clearing
put:bTo identify the: separate data streams that a TCP may handle, the TCP
put:bprovides a port: identifier.  Since port identifiers are selected
put:bindependently b:y each TCP they might not be unique.  To provide for
put:bunique addresse:s within each TCP, we concatenate an internet address
put:bidentifying the: TCP with a port identifier to create a socket which
put:bwill be unique :throughout all networks connected together.
put:bA connection is: fully specified by the pair of sockets at the ends.  A
put:blocal socket ma:y participate in many connections to different foreign
put:bsockets.  A con:nection can be used to carry data in both directions,
put:bthat is, it is :"full duplex".
put:bTCPs are free t:o associate ports with processes however they choose.
put:bHowever, severa:l basic concepts are necessary in any implementation.
put:bThere must be w:ell-known sockets which the TCP associates only with
put:bthe "appropriat:e" processes by some means.  We envision that processes
put:bmay "own" ports:, and that processes can initiate connections only on
put:bthe ports they :own.  (Means for implementing ownership is a local
put:bissue, but we e:nvision a Request Port user command, or a method of
put:buniquely alloca:ting a group of ports to a given process, e.g., by
put:bassociating the: high order bits of a port name with a given process.)
put:bA connection is: specified in the OPEN call by the local port and
put:bforeign socket :arguments.  In return, the TCP supplies a (short) local
put:b[Page 10]        :                                                       
put:bSeptember 1981   :                                                       
put:bconnection name: by which the user refers to the connection in
put:bsubsequent call:s.  There are several things that must be remembered
put:babout a connect:ion.  To store this information we imagine that there
put:bis a data struc:ture called a Transmission Control Block (TCB).  One
put:bimplementation :strategy would have the local connection name be a
put:bpointer to the :TCB for this connection.  The OPEN call also specifies
put:bwhether the con:nection establishment is to be actively pursued, or to
put:bbe passively wa:ited for.
put:bA passive OPEN :request means that the process wants to accept incoming
put:bconnection requ:ests rather than attempting to initiate a connection.
put:bOften the proce:ss requesting a passive OPEN will accept a connection
put:brequest from an:y caller.  In this case a foreign socket of all zeros
put:bis used to deno:te an unspecified socket.  Unspecified foreign sockets
put:bare allowed onl:y on passive OPENs.
put:bA service proce:ss that wished to provide services for unknown other
put:bprocesses would: issue a passive OPEN request with an unspecified
put:bforeign socket.:  Then a connection could be made with any process that
put:brequested a con:nection to this local socket.  It would help if this
put:blocal socket we:re known to be associated with this service.
put:bWell-known sock:ets are a convenient mechanism for a priori associating
put:ba socket addres:s with a standard service.  For instance, the
put:b"Telnet-Server": process is permanently assigned to a particular
put:bsocket, and oth:er sockets are reserved for File Transfer, Remote Job
put:bEntry, Text Gen:erator, Echoer, and Sink processes (the last three
put:bbeing for test :purposes).  A socket address might be reserved for
put:baccess to a "Lo:ok-Up" service which would return the specific socket
put:bat which a newl:y created service would be provided.  The concept of a
put:bwell-known sock:et is part of the TCP specification, but the assignment
put:bof sockets to s:ervices is outside this specification.  (See [4].)
put:bProcesses can i:ssue passive OPENs and wait for matching active OPENs
put:bfrom other proc:esses and be informed by the TCP when connections have
put:bbeen establishe:d.  Two processes which issue active OPENs to each
put:bother at the sa:me time will be correctly connected.  This flexibility
put:bis critical for: the support of distributed computing in which
put:bcomponents act :asynchronously with respect to each other.
put:bThere are two p:rincipal cases for matching the sockets in the local
put:bpassive OPENs a:nd an foreign active OPENs.  In the first case, the
put:blocal passive O:PENs has fully specified the foreign socket.  In this
put:bcase, the match: must be exact.  In the second case, the local passive
put:bOPENs has left :the foreign socket unspecified.  In this case, any
put:bforeign socket :is acceptable as long as the local sockets match.
put:bOther possibili:ties include partially restricted matches.
put:bTransmission Cont:rol Protocol
put:bIf there are se:veral pending passive OPENs (recorded in TCBs) with the
put:bsame local sock:et, an foreign active OPEN will be matched to a TCB
put:bwith the specif:ic foreign socket in the foreign active OPEN, if such a
put:bTCB exists, bef:ore selecting a TCB with an unspecified foreign socket.
put:bThe procedures :to establish connections utilize the synchronize (SYN)
put:bcontrol flag an:d involves an exchange of three messages.  This
put:bexchange has be:en termed a three-way hand shake [3].
put:bA connection is: initiated by the rendezvous of an arriving segment
put:bcontaining a SY:N and a waiting TCB entry each created by a user OPEN
put:bcommand.  The m:atching of local and foreign sockets determines when a
put:bconnection has :been initiated.  The connection becomes "established"
put:bwhen sequence n:umbers have been synchronized in both directions.
put:bThe clearing of: a connection also involves the exchange of segments,
put:bin this case ca:rrying the FIN control flag.
put:b2.8.  Data Commun:ication
put:bThe data that f:lows on a connection may be thought of as a stream of
put:boctets.  The se:nding user indicates in each SEND call whether the data
put:bin that call (a:nd any preceeding calls) should be immediately pushed
put:bthrough to the :receiving user by the setting of the PUSH flag.
put:bA sending TCP i:s allowed to collect data from the sending user and to
put:bsend that data :in segments at its own convenience, until the push
put:bfunction is sig:naled, then it must send all unsent data.  When a
put:breceiving TCP s:ees the PUSH flag, it must not wait for more data from
put:bthe sending TCP: before passing the data to the receiving process.
put:bThere is no nec:essary relationship between push functions and segment
put:bboundaries.  Th:e data in any particular segment may be the result of a
put:bsingle SEND cal:l, in whole or part, or of multiple SEND calls.
put:bThe purpose of :push function and the PUSH flag is to push data through
put:bfrom the sendin:g user to the receiving user.  It does not provide a
put:brecord service.:
put:bThere is a coup:ling between the push function and the use of buffers
put:bof data that cr:oss the TCP/user interface.  Each time a PUSH flag is
put:bassociated with: data placed into the receiving user's buffer, the
put:bbuffer is retur:ned to the user for processing even if the buffer is
put:bnot filled.  If: data arrives that fills the user's buffer before a
put:bPUSH is seen, t:he data is passed to the user in buffer size units.
put:bTCP also provid:es a means to communicate to the receiver of data that
put:bat some point f:urther along in the data stream than the receiver is
put:b[Page 12]        :                                                       
put:bSeptember 1981   :                                                       
put:bcurrently readi:ng there is urgent data.  TCP does not attempt to
put:bdefine what the: user specifically does upon being notified of pending
put:burgent data, bu:t the general notion is that the receiving process will
put:btake action to :process the urgent data quickly.
put:b2.9.  Precedence :and Security
put:bThe TCP makes u:se of the internet protocol type of service field and
put:bsecurity option: to provide precedence and security on a per connection
put:bbasis to TCP us:ers.  Not all TCP modules will necessarily function in
put:ba multilevel se:cure environment; some may be limited to unclassified
put:buse only, and o:thers may operate at only one security level and
put:bcompartment.  C:onsequently, some TCP implementations and services to
put:busers may be li:mited to a subset of the multilevel secure case.
put:bTCP modules whi:ch operate in a multilevel secure environment must
put:bproperly mark o:utgoing segments with the security, compartment, and
put:bprecedence.  Su:ch TCP modules must also provide to their users or
put:bhigher level pr:otocols such as Telnet or THP an interface to allow
put:bthem to specify: the desired security level, compartment, and
put:bprecedence of c:onnections.
put:b2.10.  Robustness: Principle
put:bTCP implementat:ions will follow a general principle of robustness:  be
put:bconservative in: what you do, be liberal in what you accept from
put:bTransmission Cont:rol Protocol
put:b[Page 14]        :                                                       
put:bSeptember 1981   :                                                       
put:b3.1.  Header Form:at
put:bTCP segments ar:e sent as internet datagrams.  The Internet Protocol
put:bheader carries :several information fields, including the source and
put:bdestination hos:t addresses [2].  A TCP header follows the internet
put:bheader, supplyi:ng information specific to the TCP protocol.  This
put:bdivision allows: for the existence of host level protocols other than
put:bTCP Header Form:at
put:b0            :       1                   2                   3   
put:b0 1 2 3 4 5 6: 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 
put:b+-+-+-+-+-+-+-:+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
put:b|          Sou:rce Port          |       Destination Port        |
put:b+-+-+-+-+-+-+-:+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
put:b|             :           Sequence Number                        |
put:b+-+-+-+-+-+-+-:+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
put:b|             :       Acknowledgment Number                      |
put:b+-+-+-+-+-+-+-:+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
put:b|  Data |     :      |U|A|P|R|S|F|                               |
put:b| Offset| Rese:rved  |R|C|S|S|Y|I|            Window             |
put:b|       |     :      |G|K|H|T|N|N|                               |
put:b+-+-+-+-+-+-+-:+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
put:b|           Ch:ecksum            |         Urgent Pointer        |
put:b+-+-+-+-+-+-+-:+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
put:b|             :       Options                    |    Padding    |
put:b+-+-+-+-+-+-+-:+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
put:b|             :                data                              |
put:b+-+-+-+-+-+-+-:+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
put:bNote th:at one tick mark represents one bit position.
put:bSource Port:  1:6 bits
put:bThe source po:rt number.
put:bDestination Por:t:  16 bits
put:bThe destinati:on port number.
put:bTransmission Cont:rol Protocol
put:bFunctional Specif:ication
put:bSequence Number::  32 bits
put:bThe sequence :number of the first data octet in this segment (except
put:bwhen SYN is p:resent). If SYN is present the sequence number is the
put:binitial seque:nce number (ISN) and the first data octet is ISN+1.
put:bAcknowledgment :Number:  32 bits
put:bIf the ACK co:ntrol bit is set this field contains the value of the
put:bnext sequence: number the sender of the segment is expecting to
put:breceive.  Onc:e a connection is established this is always sent.
put:bData Offset:  4: bits
put:bThe number of: 32 bit words in the TCP Header.  This indicates where
put:bthe data begi:ns.  The TCP header (even one including options) is an
put:bintegral numb:er of 32 bits long.
put:bReserved:  6 bi:ts
put:bReserved for :future use.  Must be zero.
put:bControl Bits:  :6 bits (from left to right):
put:bURG:  Urgent :Pointer field significant
put:bACK:  Acknowl:edgment field significant
put:bPSH:  Push Fu:nction
put:bRST:  Reset t:he connection
put:bSYN:  Synchro:nize sequence numbers
put:bFIN:  No more: data from sender
put:bWindow:  16 bit:s
put:bThe number of: data octets beginning with the one indicated in the
put:backnowledgmen:t field which the sender of this segment is willing to
put:bChecksum:  16 b:its
put:bThe checksum :field is the 16 bit one's complement of the one's
put:bcomplement su:m of all 16 bit words in the header and text.  If a
put:bsegment conta:ins an odd number of header and text octets to be
put:bchecksummed, :the last octet is padded on the right with zeros to
put:bform a 16 bit: word for checksum purposes.  The pad is not
put:btransmitted a:s part of the segment.  While computing the checksum,
put:bthe checksum :field itself is replaced with zeros.
put:bThe checksum :also covers a 96 bit pseudo header conceptually
put:b[Page 16]        :                                                       
put:bSeptember 1981   :                                                       
put:bprefixed to t:he TCP header.  This pseudo header contains the Source
put:bAddress, the :Destination Address, the Protocol, and TCP length.
put:bThis gives th:e TCP protection against misrouted segments.  This
put:binformation i:s carried in the Internet Protocol and is transferred
put:bacross the TC:P/Network interface in the arguments or results of
put:bcalls by the :TCP on the IP.
put:bThe TCP Len:gth is the TCP header length plus the data length in
put:boctets (thi:s is not an explicitly transmitted quantity, but is
put:bcomputed), :and it does not count the 12 octets of the pseudo
put:bUrgent Pointer::  16 bits
put:bThis field co:mmunicates the current value of the urgent pointer as a
put:bpositive offs:et from the sequence number in this segment.  The
put:burgent pointe:r points to the sequence number of the octet following
put:bthe urgent da:ta.  This field is only be interpreted in segments with
put:bthe URG contr:ol bit set.
put:bOptions:  varia:ble
put:bOptions may o:ccupy space at the end of the TCP header and are a
put:bmultiple of 8: bits in length.  All options are included in the
put:bchecksum.  An: option may begin on any octet boundary.  There are two
put:bcases for the: format of an option:
put:bCase 1:  A :single octet of option-kind.
put:bCase 2:  An: octet of option-kind, an octet of option-length, and
put:bth:e actual option-data octets.
put:bThe option-le:ngth counts the two octets of option-kind and
put:boption-length: as well as the option-data octets.
put:bNote that the: list of options may be shorter than the data offset
put:bfield might i:mply.  The content of the header beyond the
put:bEnd-of-Option: option must be header padding (i.e., zero).
put:bA TCP must im:plement all options.
put:bTransmission Cont:rol Protocol
put:bFunctional Specif:ication
put:bCurrently def:ined options include (kind indicated in octal):
put:bKind     Le:ngth    Meaning
put:b----     --:----    -------
put:b0         :-       End of option list.
put:b1         :-       No-Operation.
put:b2         :4       Maximum Segment Size.
put:bSpecific Opti:on Definitions
put:bEnd of Opti:on List
put:b+--------:+
put:b|00000000:|
put:b+--------:+
put:bThis opti:on code indicates the end of the option list.  This
put:bmight not: coincide with the end of the TCP header according to
put:bthe Data :Offset field.  This is used at the end of all options,
put:bnot the e:nd of each option, and need only be used if the end of
put:bthe optio:ns would not otherwise coincide with the end of the TCP
put:bNo-Operatio:n
put:b+--------:+
put:b|00000001:|
put:b+--------:+
put:bThis opti:on code may be used between options, for example, to
put:balign the: beginning of a subsequent option on a word boundary.
put:bThere is :no guarantee that senders will use this option, so
put:breceivers: must be prepared to process options even if they do
put:bnot begin: on a word boundary.
put:bMaximum Seg:ment Size
put:b+--------:+--------+---------+--------+
put:b|00000010:|00000100|   max seg size   |
put:b+--------:+--------+---------+--------+
put:bKind=2  : Length=4
put:b[Page 18]        :                                                       
put:bSeptember 1981   :                                                       
put:bMaximum S:egment Size Option Data:  16 bits
put:bIf this: option is present, then it communicates the maximum
put:breceive: segment size at the TCP which sends this segment.
put:bThis fi:eld must only be sent in the initial connection request
put:b(i.e., :in segments with the SYN control bit set).  If this
put:boption :is not used, any segment size is allowed.
put:bPadding:  varia:ble
put:bThe TCP heade:r padding is used to ensure that the TCP header ends
put:band data begi:ns on a 32 bit boundary.  The padding is composed of
put:b3.2.  Terminology:
put:bBefore we can d:iscuss very much about the operation of the TCP we need
put:bto introduce so:me detailed terminology.  The maintenance of a TCP
put:bconnection requ:ires the remembering of several variables.  We conceive
put:bof these variab:les being stored in a connection record called a
put:bTransmission Co:ntrol Block or TCB.  Among the variables stored in the
put:bTCB are the loc:al and remote socket numbers, the security and
put:bprecedence of t:he connection, pointers to the user's send and receive
put:bbuffers, pointe:rs to the retransmit queue and to the current segment.
put:bIn addition sev:eral variables relating to the send and receive
put:bsequence number:s are stored in the TCB.
put:bSend Sequence: Variables
put:bSND.UNA - s:end unacknowledged
put:bSND.NXT - s:end next
put:bSND.WND - s:end window
put:bSND.UP  - s:end urgent pointer
put:bSND.WL1 - s:egment sequence number used for last window update
put:bSND.WL2 - s:egment acknowledgment number used for last window
put:bu:pdate
put:bISS     - i:nitial send sequence number
put:bReceive Seque:nce Variables
put:bRCV.NXT - r:eceive next
put:bRCV.WND - r:eceive window
put:bRCV.UP  - r:eceive urgent pointer
put:bIRS     - i:nitial receive sequence number
put:bTransmission Cont:rol Protocol
put:bFunctional Specif:ication
put:bThe following d:iagrams may help to relate some of these variables to
put:bthe sequence sp:ace.
put:bSend Sequence S:pace
put:b---:-------|----------|----------|---------- 
put:b1 - old s:equence numbers which have been acknowledged  
put:b2 - seque:nce numbers of unacknowledged data            
put:b3 - seque:nce numbers allowed for new data transmission 
put:b4 - futur:e sequence numbers which are not yet allowed  
put:bThe send window: is the portion of the sequence space labeled 3 in
put:bReceive Sequenc:e Space
put:b1 - old s:equence numbers which have been acknowledged  
put:b2 - seque:nce numbers allowed for new reception         
put:b3 - futur:e sequence numbers which are not yet allowed  
put:bThe receive win:dow is the portion of the sequence space labeled 2 in
put:bThere are also :some variables used frequently in the discussion that
put:btake their valu:es from the fields of the current segment.
put:b[Page 20]        :                                                       
put:bSeptember 1981   :                                                       
put:bCurrent Segme:nt Variables
put:bSEG.SEQ - s:egment sequence number
put:bSEG.ACK - s:egment acknowledgment number
put:bSEG.LEN - s:egment length
put:bSEG.WND - s:egment window
put:bSEG.UP  - s:egment urgent pointer
put:bSEG.PRC - s:egment precedence value
put:bA connection pr:ogresses through a series of states during its
put:blifetime.  The :states are:  LISTEN, SYN-SENT, SYN-RECEIVED,
put:bESTABLISHED, FI:N-WAIT-1, FIN-WAIT-2, CLOSE-WAIT, CLOSING, LAST-ACK,
put:bTIME-WAIT, and :the fictional state CLOSED.  CLOSED is fictional
put:bbecause it repr:esents the state when there is no TCB, and therefore,
put:bno connection. : Briefly the meanings of the states are:
put:bLISTEN - repr:esents waiting for a connection request from any remote
put:bTCP and port.:
put:bSYN-SENT - re:presents waiting for a matching connection request
put:bafter having :sent a connection request.
put:bSYN-RECEIVED :- represents waiting for a confirming connection
put:brequest ackno:wledgment after having both received and sent a
put:bconnection re:quest.
put:bESTABLISHED -: represents an open connection, data received can be
put:bdelivered to :the user.  The normal state for the data transfer phase
put:bof the connec:tion.
put:bFIN-WAIT-1 - :represents waiting for a connection termination request
put:bfrom the remo:te TCP, or an acknowledgment of the connection
put:btermination r:equest previously sent.
put:bFIN-WAIT-2 - :represents waiting for a connection termination request
put:bfrom the remo:te TCP.
put:bCLOSE-WAIT - :represents waiting for a connection termination request
put:bfrom the loca:l user.
put:bCLOSING - rep:resents waiting for a connection termination request
put:backnowledgmen:t from the remote TCP.
put:bLAST-ACK - re:presents waiting for an acknowledgment of the
put:bconnection te:rmination request previously sent to the remote TCP
put:b(which includ:es an acknowledgment of its connection termination
put:bTransmission Cont:rol Protocol
put:bFunctional Specif:ication
put:bTIME-WAIT - r:epresents waiting for enough time to pass to be sure
put:bthe remote TC:P received the acknowledgment of its connection
put:btermination r:equest.
put:bCLOSED - repr:esents no connection state at all.
put:bA TCP connectio:n progresses from one state to another in response to
put:bevents.  The ev:ents are the user calls, OPEN, SEND, RECEIVE, CLOSE,
put:bABORT, and STAT:US; the incoming segments, particularly those
put:bcontaining the :SYN, ACK, RST and FIN flags; and timeouts.
put:bThe state diagr:am in figure 6 illustrates only state changes, together
put:bwith the causin:g events and resulting actions, but addresses neither
put:berror condition:s nor actions which are not connected with state
put:bchanges.  In a :later section, more detail is offered with respect to
put:bthe reaction of: the TCP to events.
put:bNOTE BENE:  thi:s diagram is only a summary and must not be taken as
put:bthe total speci:fication.
put:b[Page 22]        :                                                       
put:bSeptember 1981   :                                                       
put:b+---------+     : snd SYN,ACK  /       \   snd SYN          +---------+
put:b|         |<----:-------------           ------------------>|         |
put:b|   SYN   |     :               rcv SYN                     |   SYN   |
put:b|   RCVD  |<----:-------------------------------------------|   SENT  |
put:b|         |     :               snd ACK                     |         |
put:b|         |-----:-------------           -------------------|         |
put:b+---------+   rc:v ACK of SYN  \       /  rcv SYN,ACK       +---------+
put:b|           --:------------   |     |   -----------                  
put:b|             :     x         |     |     snd ACK                    
put:b|             :               V     V                                
put:b|  CLOSE      :             +---------+                              
put:b| -------     :             |  ESTAB  |                              
put:b| snd FIN     :             +---------+                              
put:b|             :      CLOSE    |     |    rcv FIN                     
put:bV             :     -------   |     |    -------                     
put:b+---------+     :     snd FIN  /       \   snd ACK          +---------+
put:b|  FIN    |<----:-------------           ------------------>|  CLOSE  |
put:b| WAIT-1  |-----:-------------                              |   WAIT  |
put:b+---------+     :     rcv FIN  \                            +---------+
put:b| rcv ACK of F:IN   -------   |                            CLOSE  |  
put:b| ------------:--   snd ACK   |                           ------- |  
put:bV        x    :               V                           snd FIN V  
put:b+---------+     :             +---------+                   +---------+
put:b|FINWAIT-2|     :             | CLOSING |                   | LAST-ACK|
put:b+---------+     :             +---------+                   +---------+
put:b|             :   rcv ACK of FIN |                 rcv ACK of FIN |  
put:b|  rcv FIN    :   -------------- |    Timeout=2MSL -------------- |  
put:b|  -------    :          x       V    ------------        x       V  
put:b\ snd ACK    :             +---------+delete TCB         +---------+
put:b------------:------------>|TIME WAIT|------------------>| CLOSED  |
put:bTransmission Cont:rol Protocol
put:bFunctional Specif:ication
put:b3.3.  Sequence Nu:mbers
put:bA fundamental n:otion in the design is that every octet of data sent
put:bover a TCP conn:ection has a sequence number.  Since every octet is
put:bsequenced, each: of them can be acknowledged.  The acknowledgment
put:bmechanism emplo:yed is cumulative so that an acknowledgment of sequence
put:bnumber X indica:tes that all octets up to but not including X have been
put:breceived.  This: mechanism allows for straight-forward duplicate
put:bdetection in th:e presence of retransmission.  Numbering of octets
put:bwithin a segmen:t is that the first data octet immediately following
put:bthe header is t:he lowest numbered, and the following octets are
put:bnumbered consec:utively.
put:bIt is essential: to remember that the actual sequence number space is
put:bfinite, though :very large.  This space ranges from 0 to 2**32 - 1.
put:bSince the space: is finite, all arithmetic dealing with sequence
put:bnumbers must be: performed modulo 2**32.  This unsigned arithmetic
put:bpreserves the r:elationship of sequence numbers as they cycle from
put:b2**32 - 1 to 0 :again.  There are some subtleties to computer modulo
put:barithmetic, so :great care should be taken in programming the
put:bcomparison of s:uch values.  The symbol "=<" means "less than or equal"
put:b(modulo 2**32).:
put:bThe typical kin:ds of sequence number comparisons which the TCP must
put:bperform include::
put:b(a)  Determin:ing that an acknowledgment refers to some sequence
put:bnumber s:ent but not yet acknowledged.
put:b(b)  Determin:ing that all sequence numbers occupied by a segment
put:bhave bee:n acknowledged (e.g., to remove the segment from a
put:bretransm:ission queue).
put:b(c)  Determin:ing that an incoming segment contains sequence numbers
put:bwhich ar:e expected (i.e., that the segment "overlaps" the
put:breceive :window).
put:b[Page 24]        :                                                       
put:bSeptember 1981   :                                                       
put:bIn response to :sending data the TCP will receive acknowledgments.  The
put:bfollowing compa:risons are needed to process the acknowledgments.
put:bSND.UNA = old:est unacknowledged sequence number
put:bSND.NXT = nex:t sequence number to be sent
put:bSEG.ACK = ack:nowledgment from the receiving TCP (next sequence
put:bnum:ber expected by the receiving TCP)
put:bSEG.SEQ = fir:st sequence number of a segment
put:bSEG.LEN = the: number of octets occupied by the data in the segment
put:b(co:unting SYN and FIN)
put:bSEG.SEQ+SEG.L:EN-1 = last sequence number of a segment
put:bA new acknowled:gment (called an "acceptable ack"), is one for which
put:bthe inequality :below holds:
put:bSND.UNA < SEG:.ACK =< SND.NXT
put:bA segment on th:e retransmission queue is fully acknowledged if the sum
put:bof its sequence: number and length is less or equal than the
put:backnowledgment :value in the incoming segment.
put:bWhen data is re:ceived the following comparisons are needed:
put:bRCV.NXT = nex:t sequence number expected on an incoming segments, and
put:bis the le:ft or lower edge of the receive window
put:bRCV.NXT+RCV.W:ND-1 = last sequence number expected on an incoming
put:bsegment, :and is the right or upper edge of the receive window
put:bSEG.SEQ = fir:st sequence number occupied by the incoming segment
put:bSEG.SEQ+SEG.L:EN-1 = last sequence number occupied by the incoming
put:bA segment is ju:dged to occupy a portion of valid receive sequence
put:bRCV.NXT =< SE:G.SEQ < RCV.NXT+RCV.WND
put:bRCV.NXT =< SE:G.SEQ+SEG.LEN-1 < RCV.NXT+RCV.WND
put:bTransmission Cont:rol Protocol
put:bFunctional Specif:ication
put:bThe first part :of this test checks to see if the beginning of the
put:bsegment falls i:n the window, the second part of the test checks to see
put:bif the end of t:he segment falls in the window; if the segment passes
put:beither part of :the test it contains data in the window.
put:bActually, it is: a little more complicated than this.  Due to zero
put:bwindows and zer:o length segments, we have four cases for the
put:bacceptability o:f an incoming segment:
put:bSegment Recei:ve  Test
put:bLength  Windo:w
put:b------- -----:--  -------------------------------------------
put:b0       0 :    SEG.SEQ = RCV.NXT
put:b0      >0 :    RCV.NXT =< SEG.SEQ < RCV.NXT+RCV.WND
put:b>0       0 :    not acceptable
put:b>0      >0 :    RCV.NXT =< SEG.SEQ < RCV.NXT+RCV.WND
put:bNote that when :the receive window is zero no segments should be
put:bacceptable exce:pt ACK segments.  Thus, it is be possible for a TCP to
put:bmaintain a zero: receive window while transmitting data and receiving
put:bACKs.  However,: even when the receive window is zero, a TCP must
put:bprocess the RST: and URG fields of all incoming segments.
put:bWe have taken a:dvantage of the numbering scheme to protect certain
put:bcontrol informa:tion as well.  This is achieved by implicitly including
put:bsome control fl:ags in the sequence space so they can be retransmitted
put:band acknowledge:d without confusion (i.e., one and only one copy of the
put:bcontrol will be: acted upon).  Control information is not physically
put:bcarried in the :segment data space.  Consequently, we must adopt rules
put:bfor implicitly :assigning sequence numbers to control.  The SYN and FIN
put:bare the only co:ntrols requiring this protection, and these controls
put:bare used only a:t connection opening and closing.  For sequence number
put:bpurposes, the S:YN is considered to occur before the first actual data
put:boctet of the se:gment in which it occurs, while the FIN is considered
put:bto occur after :the last actual data octet in a segment in which it
put:boccurs.  The se:gment length (SEG.LEN) includes both data and sequence
put:bspace occupying: controls.  When a SYN is present then SEG.SEQ is the
put:bsequence number: of the SYN.
put:b[Page 26]        :                                                       
put:bSeptember 1981   :                                                       
put:bInitial Sequenc:e Number Selection
put:bThe protocol pl:aces no restriction on a particular connection being
put:bused over and o:ver again.  A connection is defined by a pair of
put:bsockets.  New i:nstances of a connection will be referred to as
put:bincarnations of: the connection.  The problem that arises from this is
put:b-- "how does th:e TCP identify duplicate segments from previous
put:bincarnations of: the connection?"  This problem becomes apparent if the
put:bconnection is b:eing opened and closed in quick succession, or if the
put:bconnection brea:ks with loss of memory and is then reestablished.
put:bTo avoid confus:ion we must prevent segments from one incarnation of a
put:bconnection from: being used while the same sequence numbers may still
put:bbe present in t:he network from an earlier incarnation.  We want to
put:bassure this, ev:en if a TCP crashes and loses all knowledge of the
put:bsequence number:s it has been using.  When new connections are created,
put:ban initial sequ:ence number (ISN) generator is employed which selects a
put:bnew 32 bit ISN.:  The generator is bound to a (possibly fictitious) 32
put:bbit clock whose: low order bit is incremented roughly every 4
put:bmicroseconds.  :Thus, the ISN cycles approximately every 4.55 hours.
put:bSince we assume: that segments will stay in the network no more than
put:bthe Maximum Seg:ment Lifetime (MSL) and that the MSL is less than 4.55
put:bhours we can re:asonably assume that ISN's will be unique.
put:bFor each connec:tion there is a send sequence number and a receive
put:bsequence number:.  The initial send sequence number (ISS) is chosen by
put:bthe data sendin:g TCP, and the initial receive sequence number (IRS) is
put:blearned during :the connection establishing procedure.
put:bFor a connectio:n to be established or initialized, the two TCPs must
put:bsynchronize on :each other's initial sequence numbers.  This is done in
put:ban exchange of :connection establishing segments carrying a control bit
put:bcalled "SYN" (f:or synchronize) and the initial sequence numbers.  As a
put:bshorthand, segm:ents carrying the SYN bit are also called "SYNs".
put:bHence, the solu:tion requires a suitable mechanism for picking an
put:binitial sequenc:e number and a slightly involved handshake to exchange
put:bThe synchroniza:tion requires each side to send it's own initial
put:bsequence number: and to receive a confirmation of it in acknowledgment
put:bfrom the other :side.  Each side must also receive the other side's
put:binitial sequenc:e number and send a confirming acknowledgment.
put:b1) A --> B  S:YN my sequence number is X
put:b2) A <-- B  A:CK your sequence number is X
put:b3) A <-- B  S:YN my sequence number is Y
put:b4) A --> B  A:CK your sequence number is Y
put:bTransmission Cont:rol Protocol
put:bFunctional Specif:ication
put:bBecause steps 2: and 3 can be combined in a single message this is
put:bcalled the thre:e way (or three message) handshake.
put:bA three way han:dshake is necessary because sequence numbers are not
put:btied to a globa:l clock in the network, and TCPs may have different
put:bmechanisms for :picking the ISN's.  The receiver of the first SYN has
put:bno way of knowi:ng whether the segment was an old delayed one or not,
put:bunless it remem:bers the last sequence number used on the connection
put:b(which is not a:lways possible), and so it must ask the sender to
put:bverify this SYN:.  The three way handshake and the advantages of a
put:bclock-driven sc:heme are discussed in [3].
put:bKnowing When to: Keep Quiet
put:bTo be sure that: a TCP does not create a segment that carries a
put:bsequence number: which may be duplicated by an old segment remaining in
put:bthe network, th:e TCP must keep quiet for a maximum segment lifetime
put:b(MSL) before as:signing any sequence numbers upon starting up or
put:brecovering from: a crash in which memory of sequence numbers in use was
put:blost.  For this: specification the MSL is taken to be 2 minutes.  This
put:bis an engineeri:ng choice, and may be changed if experience indicates
put:bit is desirable: to do so.  Note that if a TCP is reinitialized in some
put:bsense, yet reta:ins its memory of sequence numbers in use, then it need
put:bnot wait at all:; it must only be sure to use sequence numbers larger
put:bthan those rece:ntly used.
put:bThe TCP Quiet T:ime Concept
put:bThis specific:ation provides that hosts which "crash" without
put:bretaining any: knowledge of the last sequence numbers transmitted on
put:beach active (:i.e., not closed) connection shall delay emitting any
put:bTCP segments :for at least the agreed Maximum Segment Lifetime (MSL)
put:bin the intern:et system of which the host is a part.  In the
put:bparagraphs be:low, an explanation for this specification is given.
put:bTCP implement:ors may violate the "quiet time" restriction, but only
put:bat the risk o:f causing some old data to be accepted as new or new
put:bdata rejected: as old duplicated by some receivers in the internet
put:bTCPs consume :sequence number space each time a segment is formed and
put:bentered into :the network output queue at a source host. The
put:bduplicate det:ection and sequencing algorithm in the TCP protocol
put:brelies on the: unique binding of segment data to sequence space to
put:bthe extent th:at sequence numbers will not cycle through all 2**32
put:bvalues before: the segment data bound to those sequence numbers has
put:bbeen delivere:d and acknowledged by the receiver and all duplicate
put:bcopies of the: segments have "drained" from the internet.  Without
put:bsuch an assum:ption, two distinct TCP segments could conceivably be
put:b[Page 28]        :                                                       
put:bSeptember 1981   :                                                       
put:bassigned the :same or overlapping sequence numbers, causing confusion
put:bat the receiv:er as to which data is new and which is old.  Remember
put:bthat each seg:ment is bound to as many consecutive sequence numbers
put:bas there are :octets of data in the segment.
put:bUnder normal :conditions, TCPs keep track of the next sequence number
put:bto emit and t:he oldest awaiting acknowledgment so as to avoid
put:bmistakenly us:ing a sequence number over before its first use has
put:bbeen acknowle:dged.  This alone does not guarantee that old duplicate
put:bdata is drain:ed from the net, so the sequence space has been made
put:bvery large to: reduce the probability that a wandering duplicate will
put:bcause trouble: upon arrival.  At 2 megabits/sec. it takes 4.5 hours
put:bto use up 2**:32 octets of sequence space.  Since the maximum segment
put:blifetime in t:he net is not likely to exceed a few tens of seconds,
put:bthis is deeme:d ample protection for foreseeable nets, even if data
put:brates escalat:e to l0's of megabits/sec.  At 100 megabits/sec, the
put:bcycle time is: 5.4 minutes which may be a little short, but still
put:bwithin reason:.
put:bThe basic dup:licate detection and sequencing algorithm in TCP can be
put:bdefeated, how:ever, if a source TCP does not have any memory of the
put:bsequence numb:ers it last used on a given connection. For example, if
put:bthe TCP were :to start all connections with sequence number 0, then
put:bupon crashing: and restarting, a TCP might re-form an earlier
put:bconnection (p:ossibly after half-open connection resolution) and emit
put:bpackets with :sequence numbers identical to or overlapping with
put:bpackets still: in the network which were emitted on an earlier
put:bincarnation o:f the same connection.  In the absence of knowledge
put:babout the seq:uence numbers used on a particular connection, the TCP
put:bspecification: recommends that the source delay for MSL seconds
put:bbefore emitti:ng segments on the connection, to allow time for
put:bsegments from: the earlier connection incarnation to drain from the
put:bEven hosts wh:ich can remember the time of day and used it to select
put:binitial seque:nce number values are not immune from this problem
put:b(i.e., even i:f time of day is used to select an initial sequence
put:bnumber for ea:ch new connection incarnation).
put:bSuppose, for :example, that a connection is opened starting with
put:bsequence numb:er S.  Suppose that this connection is not used much
put:band that even:tually the initial sequence number function (ISN(t))
put:btakes on a va:lue equal to the sequence number, say S1, of the last
put:bsegment sent :by this TCP on a particular connection.  Now suppose,
put:bat this insta:nt, the host crashes, recovers, and establishes a new
put:bincarnation o:f the connection. The initial sequence number chosen is
put:bS1 = ISN(t) -:- last used sequence number on old incarnation of
put:bconnection!  :If the recovery occurs quickly enough, any old
put:bTransmission Cont:rol Protocol
put:bFunctional Specif:ication
put:bduplicates in: the net bearing sequence numbers in the neighborhood
put:bof S1 may arr:ive and be treated as new packets by the receiver of
put:bthe new incar:nation of the connection.
put:bThe problem i:s that the recovering host may not know for how long it
put:bcrashed nor d:oes it know whether there are still old duplicates in
put:bthe system fr:om earlier connection incarnations.
put:bOne way to de:al with this problem is to deliberately delay emitting
put:bsegments for :one MSL after recovery from a crash- this is the "quite
put:btime" specifi:cation.  Hosts which prefer to avoid waiting are
put:bwilling to ri:sk possible confusion of old and new packets at a given
put:bdestination m:ay choose not to wait for the "quite time".
put:bImplementors :may provide TCP users with the ability to select on a
put:bconnection by: connection basis whether to wait after a crash, or may
put:binformally im:plement the "quite time" for all connections.
put:bObviously, ev:en where a user selects to "wait," this is not
put:bnecessary aft:er the host has been "up" for at least MSL seconds.
put:bTo summarize:: every segment emitted occupies one or more sequence
put:bnumbers in th:e sequence space, the numbers occupied by a segment are
put:b"busy" or "in: use" until MSL seconds have passed, upon crashing a
put:bblock of spac:e-time is occupied by the octets of the last emitted
put:bsegment, if a: new connection is started too soon and uses any of the
put:bsequence numb:ers in the space-time footprint of the last segment of
put:bthe previous :connection incarnation, there is a potential sequence
put:bnumber overla:p area which could cause confusion at the receiver.
put:b3.4.  Establishin:g a connection
put:bThe "three-way :handshake" is the procedure used to establish a
put:bconnection.  Th:is procedure normally is initiated by one TCP and
put:bresponded to by: another TCP.  The procedure also works if two TCP
put:bsimultaneously :initiate the procedure.  When simultaneous attempt
put:boccurs, each TC:P receives a "SYN" segment which carries no
put:backnowledgment :after it has sent a "SYN".  Of course, the arrival of
put:ban old duplicat:e "SYN" segment can potentially make it appear, to the
put:brecipient, that: a simultaneous connection initiation is in progress.
put:bProper use of ":reset" segments can disambiguate these cases.
put:bSeveral example:s of connection initiation follow.  Although these
put:bexamples do not: show connection synchronization using data-carrying
put:bsegments, this :is perfectly legitimate, so long as the receiving TCP
put:bdoesn't deliver: the data to the user until it is clear the data is
put:bvalid (i.e., th:e data must be buffered at the receiver until the
put:bconnection reac:hes the ESTABLISHED state).  The three-way handshake
put:breduces the pos:sibility of false connections.  It is the
put:b[Page 30]        :                                                       
put:bSeptember 1981   :                                                       
put:bimplementation :of a trade-off between memory and messages to provide
put:binformation for: this checking.
put:bThe simplest th:ree-way handshake is shown in figure 7 below.  The
put:bfigures should :be interpreted in the following way.  Each line is
put:bnumbered for re:ference purposes.  Right arrows (-->) indicate
put:bdeparture of a :TCP segment from TCP A to TCP B, or arrival of a
put:bsegment at B fr:om A.  Left arrows (<--), indicate the reverse.
put:bEllipsis (...) :indicates a segment which is still in the network
put:b(delayed).  An :"XXX" indicates a segment which is lost or rejected.
put:bComments appear: in parentheses.  TCP states represent the state AFTER
put:bthe departure o:r arrival of the segment (whose contents are shown in
put:bthe center of e:ach line).  Segment contents are shown in abbreviated
put:bform, with sequ:ence number, control flags, and ACK field.  Other
put:bfields such as :window, addresses, lengths, and text have been left out
put:bin the interest: of clarity.
put:bTCP A      :                                          TCP B
put:b1.  CLOSED     :                                          LISTEN
put:b2.  SYN-SENT   : --> <SEQ=100><CTL=SYN>               --> SYN-RECEIVED
put:b3.  ESTABLISHED: <-- <SEQ=300><ACK=101><CTL=SYN,ACK>  <-- SYN-RECEIVED
put:b4.  ESTABLISHED: --> <SEQ=101><ACK=301><CTL=ACK>       --> ESTABLISHED
put:b5.  ESTABLISHED: --> <SEQ=101><ACK=301><CTL=ACK><DATA> --> ESTABLISHED
put:bBasic 3:-Way Handshake for Connection Synchronization
put:bIn line 2 of fi:gure 7, TCP A begins by sending a SYN segment
put:bindicating that: it will use sequence numbers starting with sequence
put:bnumber 100.  In: line 3, TCP B sends a SYN and acknowledges the SYN it
put:breceived from T:CP A.  Note that the acknowledgment field indicates TCP
put:bB is now expect:ing to hear sequence 101, acknowledging the SYN which
put:boccupied sequen:ce 100.
put:bAt line 4, TCP :A responds with an empty segment containing an ACK for
put:bTCP B's SYN; an:d in line 5, TCP A sends some data.  Note that the
put:bsequence number: of the segment in line 5 is the same as in line 4
put:bbecause the ACK: does not occupy sequence number space (if it did, we
put:bwould wind up A:CKing ACK's!).
put:bTransmission Cont:rol Protocol
put:bFunctional Specif:ication
put:bSimultaneous in:itiation is only slightly more complex, as is shown in
put:bfigure 8.  Each: TCP cycles from CLOSED to SYN-SENT to SYN-RECEIVED to
put:bTCP A      :                                      TCP B
put:b1.  CLOSED     :                                      CLOSED
put:b2.  SYN-SENT   :  --> <SEQ=100><CTL=SYN>              ...
put:b3.  SYN-RECEIVE:D <-- <SEQ=300><CTL=SYN>              <-- SYN-SENT
put:b4.             :  ... <SEQ=100><CTL=SYN>              --> SYN-RECEIVED
put:b5.  SYN-RECEIVE:D --> <SEQ=100><ACK=301><CTL=SYN,ACK> ...
put:b6.  ESTABLISHED:  <-- <SEQ=300><ACK=101><CTL=SYN,ACK> <-- SYN-RECEIVED
put:b7.             :  ... <SEQ=101><ACK=301><CTL=ACK>     --> ESTABLISHED
put:bS:imultaneous Connection Synchronization
put:bThe principle r:eason for the three-way handshake is to prevent old
put:bduplicate conne:ction initiations from causing confusion.  To deal with
put:bthis, a special: control message, reset, has been devised.  If the
put:breceiving TCP i:s in a  non-synchronized state (i.e., SYN-SENT,
put:bSYN-RECEIVED), :it returns to LISTEN on receiving an acceptable reset.
put:bIf the TCP is i:n one of the synchronized states (ESTABLISHED,
put:bFIN-WAIT-1, FIN:-WAIT-2, CLOSE-WAIT, CLOSING, LAST-ACK, TIME-WAIT), it
put:baborts the conn:ection and informs its user.  We discuss this latter
put:bcase under "hal:f-open" connections below.
put:b[Page 32]        :                                                       
put:bSeptember 1981   :                                                       
put:bTCP A      :                                          TCP B
put:b1.  CLOSED     :                                          LISTEN
put:b2.  SYN-SENT   : --> <SEQ=100><CTL=SYN>               ...
put:b3.  (duplicate): ... <SEQ=90><CTL=SYN>               --> SYN-RECEIVED
put:b4.  SYN-SENT   : <-- <SEQ=300><ACK=91><CTL=SYN,ACK>  <-- SYN-RECEIVED
put:b5.  SYN-SENT   : --> <SEQ=91><CTL=RST>               --> LISTEN
put:b6.             : ... <SEQ=100><CTL=SYN>               --> SYN-RECEIVED
put:b7.  SYN-SENT   : <-- <SEQ=400><ACK=101><CTL=SYN,ACK>  <-- SYN-RECEIVED
put:b8.  ESTABLISHED: --> <SEQ=101><ACK=401><CTL=ACK>      --> ESTABLISHED
put:bAs a simple exa:mple of recovery from old duplicates, consider
put:bfigure 9.  At l:ine 3, an old duplicate SYN arrives at TCP B.  TCP B
put:bcannot tell tha:t this is an old duplicate, so it responds normally
put:b(line 4).  TCP :A detects that the ACK field is incorrect and returns a
put:bRST (reset) wit:h its SEQ field selected to make the segment
put:bbelievable.  TC:P B, on receiving the RST, returns to the LISTEN state.
put:bWhen the origin:al SYN (pun intended) finally arrives at line 6, the
put:bsynchronization: proceeds normally.  If the SYN at line 6 had arrived
put:bbefore the RST,: a more complex exchange might have occurred with RST's
put:bsent in both di:rections.
put:bHalf-Open Conne:ctions and Other Anomalies
put:bAn established :connection is said to be  "half-open" if one of the
put:bTCPs has closed: or aborted the connection at its end without the
put:bknowledge of th:e other, or if the two ends of the connection have
put:bbecome desynchr:onized owing to a crash that resulted in loss of
put:bmemory.  Such c:onnections will automatically become reset if an
put:battempt is made: to send data in either direction.  However, half-open
put:bconnections are: expected to be unusual, and the recovery procedure is
put:bmildly involved:.
put:bIf at site A th:e connection no longer exists, then an attempt by the
put:bTransmission Cont:rol Protocol
put:bFunctional Specif:ication
put:buser at site B :to send any data on it will result in the site B TCP
put:breceiving a res:et control message.  Such a message indicates to the
put:bsite B TCP that: something is wrong, and it is expected to abort the
put:bAssume that two: user processes A and B are communicating with one
put:banother when a :crash occurs causing loss of memory to A's TCP.
put:bDepending on th:e operating system supporting A's TCP, it is likely
put:bthat some error: recovery mechanism exists.  When the TCP is up again,
put:bA is likely to :start again from the beginning or from a recovery
put:bpoint.  As a re:sult, A will probably try to OPEN the connection again
put:bor try to SEND :on the connection it believes open.  In the latter
put:bcase, it receiv:es the error message "connection not open" from the
put:blocal (A's) TCP:.  In an attempt to establish the connection, A's TCP
put:bwill send a seg:ment containing SYN.  This scenario leads to the
put:bexample shown i:n figure 10.  After TCP A crashes, the user attempts to
put:bre-open the con:nection.  TCP B, in the meantime, thinks the connection
put:bTCP A      :                                     TCP B
put:b1.  (CRASH)    :                           (send 300,receive 100)
put:b2.  CLOSED     :                                      ESTABLISHED
put:b3.  SYN-SENT --:> <SEQ=400><CTL=SYN>              --> (??)
put:b4.  (!!)     <-:- <SEQ=300><ACK=100><CTL=ACK>     <-- ESTABLISHED
put:b5.  SYN-SENT --:> <SEQ=100><CTL=RST>              --> (Abort!!)
put:b6.  SYN-SENT   :                                      CLOSED
put:b7.  SYN-SENT --:> <SEQ=400><CTL=SYN>              -->
put:bWhen the SYN ar:rives at line 3, TCP B, being in a synchronized state,
put:band the incomin:g segment outside the window, responds with an
put:backnowledgment :indicating what sequence it next expects to hear (ACK
put:b100).  TCP A se:es that this segment does not acknowledge anything it
put:bsent and, being: unsynchronized, sends a reset (RST) because it has
put:bdetected a half:-open connection.  TCP B aborts at line 5.  TCP A will
put:b[Page 34]        :                                                       
put:bSeptember 1981   :                                                       
put:bcontinue to try: to establish the connection; the problem is now
put:breduced to the :basic 3-way handshake of figure 7.
put:bAn interesting :alternative case occurs when TCP A crashes and TCP B
put:btries to send d:ata on what it thinks is a synchronized connection.
put:bThis is illustr:ated in figure 11.  In this case, the data arriving at
put:bTCP A from TCP :B (line 2) is unacceptable because no such connection
put:bexists, so TCP :A sends a RST.  The RST is acceptable so TCP B
put:bprocesses it an:d aborts the connection.
put:bTCP A    :                                          TCP B
put:b1.  (CRASH)    :                               (send 300,receive 100)
put:b2.  (??)    <--: <SEQ=300><ACK=100><DATA=10><CTL=ACK> <-- ESTABLISHED
put:b3.          -->: <SEQ=100><CTL=RST>                   --> (ABORT!!)
put:bActive: Side Causes Half-Open Connection Discovery
put:bIn figure 12, w:e find the two TCPs A and B with passive connections
put:bwaiting for SYN:.  An old duplicate arriving at TCP B (line 2) stirs B
put:binto action.  A: SYN-ACK is returned (line 3) and causes TCP A to
put:bgenerate a RST :(the ACK in line 3 is not acceptable).  TCP B accepts
put:bthe reset and r:eturns to its passive LISTEN state.
put:bTCP A      :                                   TCP B
put:b1.  LISTEN     :                                   LISTEN
put:b2.       ... <S:EQ=Z><CTL=SYN>                -->  SYN-RECEIVED
put:b3.  (??) <-- <S:EQ=X><ACK=Z+1><CTL=SYN,ACK>   <--  SYN-RECEIVED
put:b4.       --> <S:EQ=Z+1><CTL=RST>              -->  (return to LISTEN!)
put:b5.  LISTEN     :                                   LISTEN
put:bOld Duplic:ate SYN Initiates a Reset on two Passive Sockets
put:bTransmission Cont:rol Protocol
put:bFunctional Specif:ication
put:bA variety of ot:her cases are possible, all of which are accounted for
put:bby the followin:g rules for RST generation and processing.
put:bReset Generatio:n
put:bAs a general ru:le, reset (RST) must be sent whenever a segment arrives
put:bwhich apparentl:y is not intended for the current connection.  A reset
put:bmust not be sen:t if it is not clear that this is the case.
put:bThere are three: groups of states:
put:b1.  If the co:nnection does not exist (CLOSED) then a reset is sent
put:bin response t:o any incoming segment except another reset.  In
put:bparticular, S:YNs addressed to a non-existent connection are rejected
put:bby this means:.
put:bIf the incomi:ng segment has an ACK field, the reset takes its
put:bsequence numb:er from the ACK field of the segment, otherwise the
put:breset has seq:uence number zero and the ACK field is set to the sum
put:bof the sequen:ce number and segment length of the incoming segment.
put:bThe connectio:n remains in the CLOSED state.
put:b2.  If the co:nnection is in any non-synchronized state (LISTEN,
put:bSYN-SENT, SYN:-RECEIVED), and the incoming segment acknowledges
put:bsomething not: yet sent (the segment carries an unacceptable ACK), or
put:bif an incomin:g segment has a security level or compartment which
put:bdoes not exac:tly match the level and compartment requested for the
put:bconnection, a: reset is sent.
put:bIf our SYN ha:s not been acknowledged and the precedence level of the
put:bincoming segm:ent is higher than the precedence level requested then
put:beither raise :the local precedence level (if allowed by the user and
put:bthe system) o:r send a reset; or if the precedence level of the
put:bincoming segm:ent is lower than the precedence level requested then
put:bcontinue as i:f the precedence matched exactly (if the remote TCP
put:bcannot raise :the precedence level to match ours this will be
put:bdetected in t:he next segment it sends, and the connection will be
put:bterminated th:en).  If our SYN has been acknowledged (perhaps in this
put:bincoming segm:ent) the precedence level of the incoming segment must
put:bmatch the loc:al precedence level exactly, if it does not a reset
put:bmust be sent.:
put:bIf the incomi:ng segment has an ACK field, the reset takes its
put:bsequence numb:er from the ACK field of the segment, otherwise the
put:breset has seq:uence number zero and the ACK field is set to the sum
put:bof the sequen:ce number and segment length of the incoming segment.
put:bThe connectio:n remains in the same state.
put:b[Page 36]        :                                                       
put:bSeptember 1981   :                                                       
put:b3.  If the co:nnection is in a synchronized state (ESTABLISHED,
put:bFIN-WAIT-1, F:IN-WAIT-2, CLOSE-WAIT, CLOSING, LAST-ACK, TIME-WAIT),
put:bany unaccepta:ble segment (out of window sequence number or
put:bunacceptible :acknowledgment number) must elicit only an empty
put:backnowledgmen:t segment containing the current send-sequence number
put:band an acknow:ledgment indicating the next sequence number expected
put:bto be receive:d, and the connection remains in the same state.
put:bIf an incomin:g segment has a security level, or compartment, or
put:bprecedence wh:ich does not exactly match the level, and compartment,
put:band precedenc:e requested for the connection,a reset is sent and
put:bconnection go:es to the CLOSED state.  The reset takes its sequence
put:bnumber from t:he ACK field of the incoming segment.
put:bReset Processin:g
put:bIn all states e:xcept SYN-SENT, all reset (RST) segments are validated
put:bby checking the:ir SEQ-fields.  A reset is valid if its sequence number
put:bis in the windo:w.  In the SYN-SENT state (a RST received in response
put:bto an initial S:YN), the RST is acceptable if the ACK field
put:backnowledges th:e SYN.
put:bThe receiver of: a RST first validates it, then changes state.  If the
put:breceiver was in: the LISTEN state, it ignores it.  If the receiver was
put:bin SYN-RECEIVED: state and had previously been in the LISTEN state,
put:bthen the receiv:er returns to the LISTEN state, otherwise the receiver
put:baborts the conn:ection and goes to the CLOSED state.  If the receiver
put:bwas in any othe:r state, it aborts the connection and advises the user
put:band goes to the: CLOSED state.
put:b3.5.  Closing a C:onnection
put:bCLOSE is an ope:ration meaning "I have no more data to send."  The
put:bnotion of closi:ng a full-duplex connection is subject to ambiguous
put:binterpretation,: of course, since it may not be obvious how to treat
put:bthe receiving s:ide of the connection.  We have chosen to treat CLOSE
put:bin a simplex fa:shion.  The user who CLOSEs may continue to RECEIVE
put:buntil he is tol:d that the other side has CLOSED also.  Thus, a program
put:bcould initiate :several SENDs followed by a CLOSE, and then continue to
put:bRECEIVE until s:ignaled that a RECEIVE failed because the other side
put:bhas CLOSED.  We: assume that the TCP will signal a user, even if no
put:bRECEIVEs are ou:tstanding, that the other side has closed, so the user
put:bcan terminate h:is side gracefully.  A TCP will reliably deliver all
put:bbuffers SENT be:fore the connection was CLOSED so a user who expects no
put:bdata in return :need only wait to hear the connection was CLOSED
put:bsuccessfully to: know that all his data was received at the destination
put:bTCP.  Users mus:t keep reading connections they close for sending until
put:bthe TCP says no: more data.
put:bTransmission Cont:rol Protocol
put:bFunctional Specif:ication
put:bThere are essen:tially three cases:
put:b1) The user i:nitiates by telling the TCP to CLOSE the connection
put:b2) The remote: TCP initiates by sending a FIN control signal
put:b3) Both users: CLOSE simultaneously
put:bCase 1:  Local :user initiates the close
put:bIn this case,: a FIN segment can be constructed and placed on the
put:boutgoing segm:ent queue.  No further SENDs from the user will be
put:baccepted by t:he TCP, and it enters the FIN-WAIT-1 state.  RECEIVEs
put:bare allowed i:n this state.  All segments preceding and including FIN
put:bwill be retra:nsmitted until acknowledged.  When the other TCP has
put:bboth acknowle:dged the FIN and sent a FIN of its own, the first TCP
put:bcan ACK this :FIN.  Note that a TCP receiving a FIN will ACK but not
put:bsend its own :FIN until its user has CLOSED the connection also.
put:bCase 2:  TCP re:ceives a FIN from the network
put:bIf an unsolic:ited FIN arrives from the network, the receiving TCP
put:bcan ACK it an:d tell the user that the connection is closing.  The
put:buser will res:pond with a CLOSE, upon which the TCP can send a FIN to
put:bthe other TCP: after sending any remaining data.  The TCP then waits
put:buntil its own: FIN is acknowledged whereupon it deletes the
put:bconnection.  :If an ACK is not forthcoming, after the user timeout
put:bthe connectio:n is aborted and the user is told.
put:bCase 3:  both u:sers close simultaneously
put:bA simultaneou:s CLOSE by users at both ends of a connection causes
put:bFIN segments :to be exchanged.  When all segments preceding the FINs
put:bhave been pro:cessed and acknowledged, each TCP can ACK the FIN it
put:bhas received.:  Both will, upon receiving these ACKs, delete the
put:b[Page 38]        :                                                       
put:bSeptember 1981   :                                                       
put:bTCP A      :                                          TCP B
put:b1.  ESTABLISHED:                                          ESTABLISHED
put:bFIN-WAIT-1 : --> <SEQ=100><ACK=300><CTL=FIN,ACK>  --> CLOSE-WAIT
put:b3.  FIN-WAIT-2 : <-- <SEQ=300><ACK=101><CTL=ACK>      <-- CLOSE-WAIT
put:b4.             :                                          (Close)
put:bTIME-WAIT  : <-- <SEQ=300><ACK=101><CTL=FIN,ACK>  <-- LAST-ACK
put:b5.  TIME-WAIT  : --> <SEQ=101><ACK=301><CTL=ACK>      --> CLOSED
put:bCLOSED     :                                                 
put:bTCP A      :                                          TCP B
put:b1.  ESTABLISHED:                                          ESTABLISHED
put:b2.  (Close)    :                                          (Close)
put:bFIN-WAIT-1 : --> <SEQ=100><ACK=300><CTL=FIN,ACK>  ... FIN-WAIT-1
put:b3.  CLOSING    : --> <SEQ=101><ACK=301><CTL=ACK>      ... CLOSING
put:b4.  TIME-WAIT  :                                          TIME-WAIT
put:b(2 MSL)    :                                          (2 MSL)
put:bCLOSED     :                                          CLOSED
put:bTransmission Cont:rol Protocol
put:bFunctional Specif:ication
put:b3.6.  Precedence :and Security
put:bThe intent is t:hat connection be allowed only between ports operating
put:bwith exactly th:e same security and compartment values and at the
put:bhigher of the p:recedence level requested by the two ports.
put:bThe precedence :and security parameters used in TCP are exactly those
put:bdefined in the :Internet Protocol (IP) [2].  Throughout this TCP
put:bspecification t:he term "security/compartment" is intended to indicate
put:bthe security pa:rameters used in IP including security, compartment,
put:buser group, and: handling restriction.
put:bA connection at:tempt with mismatched security/compartment values or a
put:blower precedenc:e value must be rejected by sending a reset.  Rejecting
put:ba connection du:e to too low a precedence only occurs after an
put:backnowledgment :of the SYN has been received.
put:bNote that TCP m:odules which operate only at the default value of
put:bprecedence will: still have to check the precedence of incoming
put:bsegments and po:ssibly raise the precedence level they use on the
put:bThe security pa:ramaters may be used even in a non-secure environment
put:b(the values wou:ld indicate unclassified data), thus hosts in
put:bnon-secure envi:ronments must be prepared to receive the security
put:bparameters, tho:ugh they need not send them.
put:b3.7.  Data Commun:ication
put:bOnce the connec:tion is established data is communicated by the
put:bexchange of seg:ments.  Because segments may be lost due to errors
put:b(checksum test :failure), or network congestion, TCP uses
put:bretransmission :(after a timeout) to ensure delivery of every segment.
put:bDuplicate segme:nts may arrive due to network or TCP retransmission.
put:bAs discussed in: the section on sequence numbers the TCP performs
put:bcertain tests o:n the sequence and acknowledgment numbers in the
put:bsegments to ver:ify their acceptability.
put:bThe sender of d:ata keeps track of the next sequence number to use in
put:bthe variable SN:D.NXT.  The receiver of data keeps track of the next
put:bsequence number: to expect in the variable RCV.NXT.  The sender of data
put:bkeeps track of :the oldest unacknowledged sequence number in the
put:bvariable SND.UN:A.  If the data flow is momentarily idle and all data
put:bsent has been a:cknowledged then the three variables will be equal.
put:bWhen the sender: creates a segment and transmits it the sender advances
put:bSND.NXT.  When :the receiver accepts a segment it advances RCV.NXT and
put:bsends an acknow:ledgment.  When the data sender receives an
put:b[Page 40]        :                                                       
put:bSeptember 1981   :                                                       
put:backnowledgment :it advances SND.UNA.  The extent to which the values of
put:bthese variables: differ is a measure of the delay in the communication.
put:bThe amount by w:hich the variables are advanced is the length of the
put:bdata in the seg:ment.  Note that once in the ESTABLISHED state all
put:bsegments must c:arry current acknowledgment information.
put:bThe CLOSE user :call implies a push function, as does the FIN control
put:bflag in an inco:ming segment.
put:bRetransmission :Timeout
put:bBecause of the :variability of the networks that compose an
put:binternetwork sy:stem and the wide range of uses of TCP connections the
put:bretransmission :timeout must be dynamically determined.  One procedure
put:bfor determining: a retransmission time out is given here as an
put:bAn Example Re:transmission Timeout Procedure
put:bMeasure the: elapsed time between sending a data octet with a
put:bparticular :sequence number and receiving an acknowledgment that
put:bcovers that: sequence number (segments sent do not have to match
put:bsegments re:ceived).  This measured elapsed time is the Round Trip
put:bTime (RTT).:  Next compute a Smoothed Round Trip Time (SRTT) as:
put:bSRTT = ( :ALPHA * SRTT ) + ((1-ALPHA) * RTT)
put:band based o:n this, compute the retransmission timeout (RTO) as:
put:bRTO = min:[UBOUND,max[LBOUND,(BETA*SRTT)]]
put:bwhere UBOUN:D is an upper bound on the timeout (e.g., 1 minute),
put:bLBOUND is a: lower bound on the timeout (e.g., 1 second), ALPHA is
put:ba smoothing: factor (e.g., .8 to .9), and BETA is a delay variance
put:bfactor (e.g:., 1.3 to 2.0).
put:bThe Communicati:on of Urgent Information
put:bThe objective o:f the TCP urgent mechanism is to allow the sending user
put:bto stimulate th:e receiving user to accept some urgent data and to
put:bpermit the rece:iving TCP to indicate to the receiving user when all
put:bthe currently k:nown urgent data has been received by the user.
put:bThis mechanism :permits a point in the data stream to be designated as
put:bthe end of urge:nt information.  Whenever this point is in advance of
put:bthe receive seq:uence number (RCV.NXT) at the receiving TCP, that TCP
put:bmust tell the u:ser to go into "urgent mode"; when the receive sequence
put:bnumber catches :up to the urgent pointer, the TCP must tell user to go
put:bTransmission Cont:rol Protocol
put:bFunctional Specif:ication
put:binto "normal mo:de".  If the urgent pointer is updated while the user
put:bis in "urgent m:ode", the update will be invisible to the user.
put:bThe method empl:oys a urgent field which is carried in all segments
put:btransmitted.  T:he URG control flag indicates that the urgent field is
put:bmeaningful and :must be added to the segment sequence number to yield
put:bthe urgent poin:ter.  The absence of this flag indicates that there is
put:bno urgent data :outstanding.
put:bTo send an urge:nt indication the user must also send at least one data
put:boctet.  If the :sending user also indicates a push, timely delivery of
put:bthe urgent info:rmation to the destination process is enhanced.
put:bManaging the Wi:ndow
put:bThe window sent: in each segment indicates the range of sequence
put:bnumbers the sen:der of the window (the data receiver) is currently
put:bprepared to acc:ept.  There is an assumption that this is related to
put:bthe currently a:vailable data buffer space available for this
put:bIndicating a la:rge window encourages transmissions.  If more data
put:barrives than ca:n be accepted, it will be discarded.  This will result
put:bin excessive re:transmissions, adding unnecessarily to the load on the
put:bnetwork and the: TCPs.  Indicating a small window may restrict the
put:btransmission of: data to the point of introducing a round trip delay
put:bbetween each ne:w segment transmitted.
put:bThe mechanisms :provided allow a TCP to advertise a large window and to
put:bsubsequently ad:vertise a much smaller window without having accepted
put:bthat much data.:  This, so called "shrinking the window," is strongly
put:bdiscouraged.  T:he robustness principle dictates that TCPs will not
put:bshrink the wind:ow themselves, but will be prepared for such behavior
put:bon the part of :other TCPs.
put:bThe sending TCP: must be prepared to accept from the user and send at
put:bleast one octet: of new data even if the send window is zero.  The
put:bsending TCP mus:t regularly retransmit to the receiving TCP even when
put:bthe window is z:ero.  Two minutes is recommended for the retransmission
put:binterval when t:he window is zero.  This retransmission is essential to
put:bguarantee that :when either TCP has a zero window the re-opening of the
put:bwindow will be :reliably reported to the other.
put:bWhen the receiv:ing TCP has a zero window and a segment arrives it must
put:bstill send an a:cknowledgment showing its next expected sequence number
put:band current win:dow (zero).
put:bThe sending TCP: packages the data to be transmitted into segments
put:b[Page 42]        :                                                       
put:bSeptember 1981   :                                                       
put:bwhich fit the c:urrent window, and may repackage segments on the
put:bretransmission :queue.  Such repackaging is not required, but may be
put:bIn a connection: with a one-way data flow, the window information will
put:bbe carried in a:cknowledgment segments that all have the same sequence
put:bnumber so there: will be no way to reorder them if they arrive out of
put:border.  This is: not a serious problem, but it will allow the window
put:binformation to :be on occasion temporarily based on old reports from
put:bthe data receiv:er.  A refinement to avoid this problem is to act on
put:bthe window info:rmation from segments that carry the highest
put:backnowledgment :number (that is segments with acknowledgment number
put:bequal or greate:r than the highest previously received).
put:bThe window mana:gement procedure has significant influence on the
put:bcommunication p:erformance.  The following comments are suggestions to
put:bWindow Manage:ment Suggestions
put:bAllocating :a very small window causes data to be transmitted in
put:bmany small :segments when better performance is achieved using
put:bfewer large: segments.
put:bOne suggest:ion for avoiding small windows is for the receiver to
put:bdefer updat:ing a window until the additional allocation is at
put:bleast X per:cent of the maximum allocation possible for the
put:bconnection :(where X might be 20 to 40).
put:bAnother sug:gestion is for the sender to avoid sending small
put:bsegments by: waiting until the window is large enough before
put:bsending dat:a.  If the the user signals a push function then the
put:bdata must b:e sent even if it is a small segment.
put:bNote that t:he acknowledgments should not be delayed or unnecessary
put:bretransmiss:ions will result.  One strategy would be to send an
put:backnowledgm:ent when a small segment arrives (with out updating the
put:bwindow info:rmation), and then to send another acknowledgment with
put:bnew window :information when the window is larger.
put:bThe segment: sent to probe a zero window may also begin a break up
put:bof transmit:ted data into smaller and smaller segments.  If a
put:bsegment con:taining a single data octet sent to probe a zero window
put:bis accepted:, it consumes one octet of the window now available.
put:bIf the send:ing TCP simply sends as much as it can whenever the
put:bwindow is n:on zero, the transmitted data will be broken into
put:balternating: big and small segments.  As time goes on, occasional
put:bpauses in t:he receiver making window allocation available will
put:bTransmission Cont:rol Protocol
put:bFunctional Specif:ication
put:bresult in b:reaking the big segments into a small and not quite so
put:bbig pair. A:nd after a while the data transmission will be in
put:bmostly smal:l segments.
put:bThe suggest:ion here is that the TCP implementations need to
put:bactively at:tempt to combine small window allocations into larger
put:bwindows, si:nce the mechanisms for managing the window tend to lead
put:bto many sma:ll windows in the simplest minded implementations.
put:bThere are of co:urse two interfaces of concern:  the user/TCP interface
put:band the TCP/low:er-level interface.  We have a fairly elaborate model
put:bof the user/TCP: interface, but the interface to the lower level
put:bprotocol module: is left unspecified here, since it will be specified
put:bin detail by th:e specification of the lowel level protocol.  For the
put:bcase that the l:ower level is IP we note some of the parameter values
put:bthat TCPs might: use.
put:bUser/TCP Interf:ace
put:bThe following: functional description of user commands to the TCP is,
put:bat best, fict:ional, since every operating system will have different
put:bfacilities.  :Consequently, we must warn readers that different TCP
put:bimplementatio:ns may have different user interfaces.  However, all
put:bTCPs must pro:vide a certain minimum set of services to guarantee
put:bthat all TCP :implementations can support the same protocol
put:bhierarchy.  T:his section specifies the functional interfaces
put:brequired of a:ll TCP implementations.
put:bTCP User Comm:ands
put:bThe followi:ng sections functionally characterize a USER/TCP
put:binterface. : The notation used is similar to most procedure or
put:bfunction ca:lls in high level languages, but this usage is not
put:bmeant to ru:le out trap type service calls (e.g., SVCs, UUOs,
put:bThe user co:mmands described below specify the basic functions the
put:bTCP must pe:rform to support interprocess communication.
put:bIndividual :implementations must define their own exact format, and
put:bmay provide: combinations or subsets of the basic functions in
put:bsingle call:s.  In particular, some implementations may wish to
put:bautomatical:ly OPEN a connection on the first SEND or RECEIVE
put:bissued by t:he user for a given connection.
put:b[Page 44]        :                                                       
put:bSeptember 1981   :                                                       
put:bIn providin:g interprocess communication facilities, the TCP must
put:bnot only ac:cept commands, but must also return information to the
put:bprocesses i:t serves.  The latter consists of:
put:b(a) gener:al information about a connection (e.g., interrupts,
put:bremote cl:ose, binding of unspecified foreign socket).
put:b(b) repli:es to specific user commands indicating success or
put:bvarious t:ypes of failure.
put:bFormat:  :OPEN (local port, foreign socket, active/passive
put:b[, timeou:t] [, precedence] [, security/compartment] [, options])
put:b-> local :connection name
put:bWe assume: that the local TCP is aware of the identity of the
put:bprocesses: it serves and will check the authority of the process
put:bto use th:e connection specified.  Depending upon the
put:bimplement:ation of the TCP, the local network and TCP identifiers
put:bfor the s:ource address will either be supplied by the TCP or the
put:blower lev:el protocol (e.g., IP).  These considerations are the
put:bresult of: concern about security, to the extent that no TCP be
put:bable to m:asquerade as another one, and so on.  Similarly, no
put:bprocess c:an masquerade as another without the collusion of the
put:bIf the ac:tive/passive flag is set to passive, then this is a
put:bcall to L:ISTEN for an incoming connection.  A passive open may
put:bhave eith:er a fully specified foreign socket to wait for a
put:bparticula:r connection or an unspecified foreign socket to wait
put:bfor any c:all.  A fully specified passive call can be made active
put:bby the su:bsequent execution of a SEND.
put:bA transmi:ssion control block (TCB) is created and partially
put:bfilled in: with data from the OPEN command parameters.
put:bOn an act:ive OPEN command, the TCP will begin the procedure to
put:bsynchroni:ze (i.e., establish) the connection at once.
put:bThe timeo:ut, if present, permits the caller to set up a timeout
put:bfor all d:ata submitted to TCP.  If data is not successfully
put:bdelivered: to the destination within the timeout period, the TCP
put:bwill abor:t the connection.  The present global default is five
put:bThe TCP o:r some component of the operating system will verify
put:bthe users: authority to open a connection with the specified
put:bTransmission Cont:rol Protocol
put:bFunctional Specif:ication
put:bprecedenc:e or security/compartment.  The absence of precedence
put:bor securi:ty/compartment specification in the OPEN call indicates
put:bthe defau:lt values must be used.
put:bTCP will :accept incoming requests as matching only if the
put:bsecurity/:compartment information is exactly the same and only if
put:bthe prece:dence is equal to or higher than the precedence
put:brequested: in the OPEN call.
put:bThe prece:dence for the connection is the higher of the values
put:brequested: in the OPEN call and received from the incoming
put:brequest, :and fixed at that value for the life of the
put:bconnectio:n.Implementers may want to give the user control of
put:bthis prec:edence negotiation.  For example, the user might be
put:ballowed t:o specify that the precedence must be exactly matched,
put:bor that a:ny attempt to raise the precedence be confirmed by the
put:bA local c:onnection name will be returned to the user by the TCP.
put:bThe local: connection name can then be used as a short hand term
put:bfor the c:onnection defined by the <local socket, foreign socket>
put:bFormat:  :SEND (local connection name, buffer address, byte
put:bcount, PU:SH flag, URGENT flag [,timeout])
put:bThis call: causes the data contained in the indicated user buffer
put:bto be sen:t on the indicated connection.  If the connection has
put:bnot been :opened, the SEND is considered an error.  Some
put:bimplement:ations may allow users to SEND first; in which case, an
put:bautomatic: OPEN would be done.  If the calling process is not
put:bauthorize:d to use this connection, an error is returned.
put:bIf the PU:SH flag is set, the data must be transmitted promptly
put:bto the re:ceiver, and the PUSH bit will be set in the last TCP
put:bsegment c:reated from the buffer.  If the PUSH flag is not set,
put:bthe data :may be combined with data from subsequent SENDs for
put:btransmiss:ion efficiency.
put:bIf the UR:GENT flag is set, segments sent to the destination TCP
put:bwill have: the urgent pointer set.  The receiving TCP will signal
put:bthe urgen:t condition to the receiving process if the urgent
put:bpointer i:ndicates that data preceding the urgent pointer has not
put:bbeen cons:umed by the receiving process.  The purpose of urgent
put:bis to sti:mulate the receiver to process the urgent data and to
put:bindicate :to the receiver when all the currently known urgent
put:b[Page 46]        :                                                       
put:bSeptember 1981   :                                                       
put:bdata has :been received.  The number of times the sending user's
put:bTCP signa:ls urgent will not necessarily be equal to the number
put:bof times :the receiving user will be notified of the presence of
put:burgent da:ta.
put:bIf no for:eign socket was specified in the OPEN, but the
put:bconnectio:n is established (e.g., because a LISTENing connection
put:bhas becom:e specific due to a foreign segment arriving for the
put:blocal soc:ket), then the designated buffer is sent to the implied
put:bforeign s:ocket.  Users who make use of OPEN with an unspecified
put:bforeign s:ocket can make use of SEND without ever explicitly
put:bknowing t:he foreign socket address.
put:bHowever, :if a SEND is attempted before the foreign socket
put:bbecomes s:pecified, an error will be returned.  Users can use the
put:bSTATUS ca:ll to determine the status of the connection.  In some
put:bimplement:ations the TCP may notify the user when an unspecified
put:bsocket is: bound.
put:bIf a time:out is specified, the current user timeout for this
put:bconnectio:n is changed to the new one.
put:bIn the si:mplest implementation, SEND would not return control to
put:bthe sendi:ng process until either the transmission was complete
put:bor the ti:meout had been exceeded.  However, this simple method
put:bis both s:ubject to deadlocks (for example, both sides of the
put:bconnectio:n might try to do SENDs before doing any RECEIVEs) and
put:boffers po:or performance, so it is not recommended.  A more
put:bsophistic:ated implementation would return immediately to allow
put:bthe proce:ss to run concurrently with network I/O, and,
put:bfurthermo:re, to allow multiple SENDs to be in progress.
put:bMultiple :SENDs are served in first come, first served order, so
put:bthe TCP w:ill queue those it cannot service immediately.
put:bWe have i:mplicitly assumed an asynchronous user interface in
put:bwhich a S:END later elicits some kind of SIGNAL or
put:bpseudo-in:terrupt from the serving TCP.  An alternative is to
put:breturn a :response immediately.  For instance, SENDs might return
put:bimmediate: local acknowledgment, even if the segment sent had not
put:bbeen ackn:owledged by the distant TCP.  We could optimistically
put:bassume ev:entual success.  If we are wrong, the connection will
put:bclose any:way due to the timeout.  In implementations of this
put:bkind (syn:chronous), there will still be some asynchronous
put:bsignals, :but these will deal with the connection itself, and not
put:bwith spec:ific segments or buffers.
put:bIn order :for the process to distinguish among error or success
put:bindicatio:ns for different SENDs, it might be appropriate for the
put:bTransmission Cont:rol Protocol
put:bFunctional Specif:ication
put:bbuffer ad:dress to be returned along with the coded response to
put:bthe SEND :request.  TCP-to-user signals are discussed below,
put:bindicatin:g the information which should be returned to the
put:bcalling p:rocess.
put:bFormat:  :RECEIVE (local connection name, buffer address, byte
put:bcount) ->: byte count, urgent flag, push flag
put:bThis comm:and allocates a receiving buffer associated with the
put:bspecified: connection.  If no OPEN precedes this command or the
put:bcalling p:rocess is not authorized to use this connection, an
put:berror is :returned.
put:bIn the si:mplest implementation, control would not return to the
put:bcalling p:rogram until either the buffer was filled, or some
put:berror occ:urred, but this scheme is highly subject to deadlocks.
put:bA more so:phisticated implementation would permit several
put:bRECEIVEs :to be outstanding at once.  These would be filled as
put:bsegments :arrive.  This strategy permits increased throughput at
put:bthe cost :of a more elaborate scheme (possibly asynchronous) to
put:bnotify th:e calling program that a PUSH has been seen or a buffer
put:bIf enough: data arrive to fill the buffer before a PUSH is seen,
put:bthe PUSH :flag will not be set in the response to the RECEIVE.
put:bThe buffe:r will be filled with as much data as it can hold.  If
put:ba PUSH is: seen before the buffer is filled the buffer will be
put:breturned :partially filled and PUSH indicated.
put:bIf there :is urgent data the user will have been informed as soon
put:bas it arr:ived via a TCP-to-user signal.  The receiving user
put:bshould th:us be in "urgent mode".  If the URGENT flag is on,
put:badditiona:l urgent data remains.  If the URGENT flag is off, this
put:bcall to R:ECEIVE has returned all the urgent data, and the user
put:bmay now l:eave "urgent mode".  Note that data following the
put:burgent po:inter (non-urgent data) cannot be delivered to the user
put:bin the sa:me buffer with preceeding urgent data unless the
put:bboundary :is clearly marked for the user.
put:bTo distin:guish among several outstanding RECEIVEs and to take
put:bcare of t:he case that a buffer is not completely filled, the
put:breturn co:de is accompanied by both a buffer pointer and a byte
put:bcount ind:icating the actual length of the data received.
put:bAlternati:ve implementations of RECEIVE might have the TCP
put:b[Page 48]        :                                                       
put:bSeptember 1981   :                                                       
put:ballocate :buffer storage, or the TCP might share a ring buffer
put:bwith the :user.
put:bFormat:  :CLOSE (local connection name)
put:bThis comm:and causes the connection specified to be closed.  If
put:bthe conne:ction is not open or the calling process is not
put:bauthorize:d to use this connection, an error is returned.
put:bClosing c:onnections is intended to be a graceful operation in
put:bthe sense: that outstanding SENDs will be transmitted (and
put:bretransmi:tted), as flow control permits, until all have been
put:bserviced.:  Thus, it should be acceptable to make several SEND
put:bcalls, fo:llowed by a CLOSE, and expect all the data to be sent
put:bto the de:stination.  It should also be clear that users should
put:bcontinue :to RECEIVE on CLOSING connections, since the other side
put:bmay be tr:ying to transmit the last of its data.  Thus, CLOSE
put:bmeans "I :have no more to send" but does not mean "I will not
put:breceive a:ny more."  It may happen (if the user level protocol is
put:bnot well :thought out) that the closing side is unable to get rid
put:bof all it:s data before timing out.  In this event, CLOSE turns
put:binto ABOR:T, and the closing TCP gives up.
put:bThe user :may CLOSE the connection at any time on his own
put:binitiativ:e, or in response to various prompts from the TCP
put:b(e.g., re:mote close executed, transmission timeout exceeded,
put:bdestinati:on inaccessible).
put:bBecause c:losing a connection requires communication with the
put:bforeign T:CP, connections may remain in the closing state for a
put:bshort tim:e.  Attempts to reopen the connection before the TCP
put:breplies t:o the CLOSE command will result in error responses.
put:bClose als:o implies push function.
put:bFormat:  :STATUS (local connection name) -> status data
put:bThis is a:n implementation dependent user command and could be
put:bexcluded :without adverse effect.  Information returned would
put:btypically: come from the TCB associated with the connection.
put:bThis comm:and returns a data block containing the following
put:binformati:on:
put:blocal s:ocket,
put:bTransmission Cont:rol Protocol
put:bFunctional Specif:ication
put:bforeign: socket,
put:blocal c:onnection name,
put:breceive: window,
put:bsend wi:ndow,
put:bconnect:ion state,
put:bnumber :of buffers awaiting acknowledgment,
put:bnumber :of buffers pending receipt,
put:burgent :state,
put:bprecede:nce,
put:bsecurit:y/compartment,
put:band tra:nsmission timeout.
put:bDepending: on the state of the connection, or on the
put:bimplement:ation itself, some of this information may not be
put:bavailable: or meaningful.  If the calling process is not
put:bauthorize:d to use this connection, an error is returned.  This
put:bprevents :unauthorized processes from gaining information about a
put:bconnectio:n.
put:bFormat:  :ABORT (local connection name)
put:bThis comm:and causes all pending SENDs and RECEIVES to be
put:baborted, :the TCB to be removed, and a special RESET message to
put:bbe sent t:o the TCP on the other side of the connection.
put:bDepending: on the implementation, users may receive abort
put:bindicatio:ns for each outstanding SEND or RECEIVE, or may simply
put:breceive a:n ABORT-acknowledgment.
put:bTCP-to-User M:essages
put:bIt is assum:ed that the operating system environment provides a
put:bmeans for t:he TCP to asynchronously signal the user program.  When
put:bthe TCP doe:s signal a user program, certain information is passed
put:bto the user:.  Often in the specification the information will be
put:ban error me:ssage.  In other cases there will be information
put:brelating to: the completion of processing a SEND or RECEIVE or
put:bother user :call.
put:bThe followi:ng information is provided:
put:bLocal Con:nection Name                    Always
put:bResponse :String                          Always
put:bBuffer Ad:dress                           Send & Receive
put:bByte coun:t (counts bytes received)       Receive
put:bPush flag:                                Receive
put:bUrgent fl:ag                              Receive
put:b[Page 50]        :                                                       
put:bSeptember 1981   :                                                       
put:bTCP/Lower-Level: Interface
put:bThe TCP calls: on a lower level protocol module to actually send and
put:breceive infor:mation over a network.  One case is that of the ARPA
put:binternetwork :system where the lower level module is the Internet
put:bProtocol (IP): [2].
put:bIf the lower :level protocol is IP it provides arguments for a type
put:bof service an:d for a time to live.  TCP uses the following settings
put:bfor these par:ameters:
put:bType of Ser:vice = Precedence: routine, Delay: normal, Throughput:
put:bnormal, Rel:iability: normal; or 00000000.
put:bTime to Liv:e    = one minute, or 00111100.
put:bNote that: the assumed maximum segment lifetime is two minutes.
put:bHere we e:xplicitly ask that a segment be destroyed if it cannot
put:bbe delive:red by the internet system within one minute.
put:bIf the lower :level is IP (or other protocol that provides this
put:bfeature) and :source routing is used, the interface must allow the
put:broute informa:tion to be communicated.  This is especially important
put:bso that the s:ource and destination addresses used in the TCP
put:bchecksum be t:he originating source and ultimate destination. It is
put:balso importan:t to preserve the return route to answer connection
put:bAny lower lev:el protocol will have to provide the source address,
put:bdestination a:ddress, and protocol fields, and some way to determine
put:bthe "TCP leng:th", both to provide the functional equivlent service
put:bof IP and to :be used in the TCP checksum.
put:bTransmission Cont:rol Protocol
put:bFunctional Specif:ication
put:b3.9.  Event Proce:ssing
put:bThe processing :depicted in this section is an example of one possible
put:bimplementation.:  Other implementations may have slightly different
put:bprocessing sequ:ences, but they should differ from those in this
put:bsection only in: detail, not in substance.
put:bThe activity of: the TCP can be characterized as responding to events.
put:bThe events that: occur can be cast into three categories:  user calls,
put:barriving segmen:ts, and timeouts.  This section describes the
put:bprocessing the :TCP does in response to each of the events.  In many
put:bcases the proce:ssing required depends on the state of the connection.
put:bEvents that o:ccur:
put:bArriving Se:gments
put:bSEGMENT A:RRIVES
put:bUSER TIME:OUT
put:bRETRANSMI:SSION TIMEOUT
put:bTIME-WAIT: TIMEOUT
put:bThe model of th:e TCP/user interface is that user commands receive an
put:bimmediate retur:n and possibly a delayed response via an event or
put:bpseudo interrup:t.  In the following descriptions, the term "signal"
put:bmeans cause a d:elayed response.
put:bError responses: are given as character strings.  For example, user
put:bcommands refere:ncing connections that do not exist receive "error:
put:bconnection not :open".
put:bPlease note in :the following that all arithmetic on sequence numbers,
put:backnowledgment :numbers, windows, et cetera, is modulo 2**32 the size
put:bof the sequence: number space.  Also note that "=<" means less than or
put:bequal to (modul:o 2**32).
put:b[Page 52]        :                                                       
put:bSeptember 1981   :                                                       
put:bA natural way t:o think about processing incoming segments is to
put:bimagine that th:ey are first tested for proper sequence number (i.e.,
put:bthat their cont:ents lie in the range of the expected "receive window"
put:bin the sequence: number space) and then that they are generally queued
put:band processed i:n sequence number order.
put:bWhen a segment :overlaps other already received segments we reconstruct
put:bthe segment to :contain just the new data, and adjust the header fields
put:bto be consisten:t.
put:bNote that if no: state change is mentioned the TCP stays in the same
put:bTransmission Cont:rol Protocol
put:bFunctional Specif:ication
put:bCLOSED STATE :(i.e., TCB does not exist)
put:bCreate a ne:w transmission control block (TCB) to hold connection
put:bstate infor:mation.  Fill in local socket identifier, foreign
put:bsocket, pre:cedence, security/compartment, and user timeout
put:binformation:.  Note that some parts of the foreign socket may be
put:bunspecified: in a passive OPEN and are to be filled in by the
put:bparameters :of the incoming SYN segment.  Verify the security and
put:bprecedence :requested are allowed for this user, if not return
put:b"error:  pr:ecedence not allowed" or "error:  security/compartment
put:bnot allowed:."  If passive enter the LISTEN state and return.  If
put:bactive and :the foreign socket is unspecified, return "error:
put:bforeign soc:ket unspecified"; if active and the foreign socket is
put:bspecified, :issue a SYN segment.  An initial send sequence number
put:b(ISS) is se:lected.  A SYN segment of the form <SEQ=ISS><CTL=SYN>
put:bis sent.  S:et SND.UNA to ISS, SND.NXT to ISS+1, enter SYN-SENT
put:bstate, and :return.
put:bIf the call:er does not have access to the local socket specified,
put:breturn "err:or:  connection illegal for this process".  If there is
put:bno room to :create a new connection, return "error:  insufficient
put:bresources".:
put:bIf active a:nd the foreign socket is specified, then change the
put:bconnection :from passive to active, select an ISS.  Send a SYN
put:bsegment, se:t SND.UNA to ISS, SND.NXT to ISS+1.  Enter SYN-SENT
put:bstate.  Dat:a associated with SEND may be sent with SYN segment or
put:bqueued for :transmission after entering ESTABLISHED state.  The
put:burgent bit :if requested in the command must be sent with the data
put:bsegments se:nt as a result of this command.  If there is no room to
put:bqueue the r:equest, respond with "error:  insufficient resources".
put:bIf Foreign :socket was not specified, then return "error:  foreign
put:bsocket unsp:ecified".
put:b[Page 54]        :                                                       
put:bSeptember 1981   :                                                       
put:bSYN-SENT STAT:E
put:bSYN-RECEIVED :STATE
put:bESTABLISHED S:TATE
put:bFIN-WAIT-1 ST:ATE
put:bFIN-WAIT-2 ST:ATE
put:bCLOSE-WAIT ST:ATE
put:bCLOSING STATE:
put:bLAST-ACK STAT:E
put:bTIME-WAIT STA:TE
put:bReturn "err:or:  connection already exists".
put:bTransmission Cont:rol Protocol
put:bFunctional Specif:ication
put:bCLOSED STATE :(i.e., TCB does not exist)
put:bIf the user: does not have access to such a connection, then return
put:b"error:  co:nnection illegal for this process".
put:bOtherwise, :return "error:  connection does not exist".
put:bIf the fore:ign socket is specified, then change the connection
put:bfrom passiv:e to active, select an ISS.  Send a SYN segment, set
put:bSND.UNA to :ISS, SND.NXT to ISS+1.  Enter SYN-SENT state.  Data
put:bassociated :with SEND may be sent with SYN segment or queued for
put:btransmissio:n after entering ESTABLISHED state.  The urgent bit if
put:brequested i:n the command must be sent with the data segments sent
put:bas a result: of this command.  If there is no room to queue the
put:brequest, re:spond with "error:  insufficient resources".  If
put:bForeign soc:ket was not specified, then return "error:  foreign
put:bsocket unsp:ecified".
put:bSYN-SENT STAT:E
put:bSYN-RECEIVED :STATE
put:bQueue the d:ata for transmission after entering ESTABLISHED state.
put:bIf no space: to queue, respond with "error:  insufficient
put:bresources".:
put:bESTABLISHED S:TATE
put:bCLOSE-WAIT ST:ATE
put:bSegmentize :the buffer and send it with a piggybacked
put:backnowledgm:ent (acknowledgment value = RCV.NXT).  If there is
put:binsufficien:t space to remember this buffer, simply return "error:
put:binsufficien:t resources".
put:bIf the urge:nt flag is set, then SND.UP <- SND.NXT-1 and set the
put:burgent poin:ter in the outgoing segments.
put:b[Page 56]        :                                                       
put:bSeptember 1981   :                                                       
put:bFIN-WAIT-1 ST:ATE
put:bFIN-WAIT-2 ST:ATE
put:bCLOSING STATE:
put:bLAST-ACK STAT:E
put:bTIME-WAIT STA:TE
put:bReturn "err:or:  connection closing" and do not service request.
put:bTransmission Cont:rol Protocol
put:bFunctional Specif:ication
put:bCLOSED STATE :(i.e., TCB does not exist)
put:bIf the user: does not have access to such a connection, return
put:b"error:  co:nnection illegal for this process".
put:bOtherwise r:eturn "error:  connection does not exist".
put:bSYN-SENT STAT:E
put:bSYN-RECEIVED :STATE
put:bQueue for p:rocessing after entering ESTABLISHED state.  If there
put:bis no room :to queue this request, respond with "error:
put:binsufficien:t resources".
put:bESTABLISHED S:TATE
put:bFIN-WAIT-1 ST:ATE
put:bFIN-WAIT-2 ST:ATE
put:bIf insuffic:ient incoming segments are queued to satisfy the
put:brequest, qu:eue the request.  If there is no queue space to
put:bremember th:e RECEIVE, respond with "error:  insufficient
put:bresources".:
put:bReassemble :queued incoming segments into receive buffer and return
put:bto user.  M:ark "push seen" (PUSH) if this is the case.
put:bIf RCV.UP i:s in advance of the data currently being passed to the
put:buser notify: the user of the presence of urgent data.
put:bWhen the TC:P takes responsibility for delivering data to the user
put:bthat fact m:ust be communicated to the sender via an
put:backnowledgm:ent.  The formation of such an acknowledgment is
put:bdescribed b:elow in the discussion of processing an incoming
put:b[Page 58]        :                                                       
put:bSeptember 1981   :                                                       
put:bCLOSE-WAIT ST:ATE
put:bSince the r:emote side has already sent FIN, RECEIVEs must be
put:bsatisfied b:y text already on hand, but not yet delivered to the
put:buser.  If n:o text is awaiting delivery, the RECEIVE will get a
put:b"error:  co:nnection closing" response.  Otherwise, any remaining
put:btext can be: used to satisfy the RECEIVE.
put:bCLOSING STATE:
put:bLAST-ACK STAT:E
put:bTIME-WAIT STA:TE
put:bReturn "err:or:  connection closing".
put:bTransmission Cont:rol Protocol
put:bFunctional Specif:ication
put:bCLOSED STATE :(i.e., TCB does not exist)
put:bIf the user: does not have access to such a connection, return
put:b"error:  co:nnection illegal for this process".
put:bOtherwise, :return "error:  connection does not exist".
put:bAny outstan:ding RECEIVEs are returned with "error:  closing"
put:bresponses. : Delete TCB, enter CLOSED state, and return.
put:bSYN-SENT STAT:E
put:bDelete the :TCB and return "error:  closing" responses to any
put:bqueued SEND:s, or RECEIVEs.
put:bSYN-RECEIVED :STATE
put:bIf no SENDs: have been issued and there is no pending data to send,
put:bthen form a: FIN segment and send it, and enter FIN-WAIT-1 state;
put:botherwise q:ueue for processing after entering ESTABLISHED state.
put:bESTABLISHED S:TATE
put:bQueue this :until all preceding SENDs have been segmentized, then
put:bform a FIN :segment and send it.  In any case, enter FIN-WAIT-1
put:bFIN-WAIT-1 ST:ATE
put:bFIN-WAIT-2 ST:ATE
put:bStrictly sp:eaking, this is an error and should receive a "error:
put:bconnection :closing" response.  An "ok" response would be
put:bacceptable,: too, as long as a second FIN is not emitted (the first
put:bFIN may be :retransmitted though).
put:b[Page 60]        :                                                       
put:bSeptember 1981   :                                                       
put:bCLOSE-WAIT ST:ATE
put:bQueue this :request until all preceding SENDs have been
put:bsegmentized:; then send a FIN segment, enter CLOSING state.
put:bCLOSING STATE:
put:bLAST-ACK STAT:E
put:bTIME-WAIT STA:TE
put:bRespond wit:h "error:  connection closing".
put:bTransmission Cont:rol Protocol
put:bFunctional Specif:ication
put:bCLOSED STATE :(i.e., TCB does not exist)
put:bIf the user: should not have access to such a connection, return
put:b"error:  co:nnection illegal for this process".
put:bOtherwise r:eturn "error:  connection does not exist".
put:bAny outstan:ding RECEIVEs should be returned with "error:
put:bconnection :reset" responses.  Delete TCB, enter CLOSED state, and
put:bSYN-SENT STAT:E
put:bAll queued :SENDs and RECEIVEs should be given "connection reset"
put:bnotificatio:n, delete the TCB, enter CLOSED state, and return.
put:bSYN-RECEIVED :STATE
put:bESTABLISHED S:TATE
put:bFIN-WAIT-1 ST:ATE
put:bFIN-WAIT-2 ST:ATE
put:bCLOSE-WAIT ST:ATE
put:bSend a rese:t segment:
put:b<SEQ=SND.:NXT><CTL=RST>
put:bAll queued :SENDs and RECEIVEs should be given "connection reset"
put:bnotificatio:n; all segments queued for transmission (except for the
put:bRST formed :above) or retransmission should be flushed, delete the
put:bTCB, enter :CLOSED state, and return.
put:bCLOSING STATE:
put:bLAST-ACK STAT:E
put:bTIME-WAIT STA:TE
put:bRespond wit:h "ok" and delete the TCB, enter CLOSED state, and
put:b[Page 62]        :                                                       
put:bSeptember 1981   :                                                       
put:bCLOSED STATE :(i.e., TCB does not exist)
put:bIf the user: should not have access to such a connection, return
put:b"error:  co:nnection illegal for this process".
put:bOtherwise r:eturn "error:  connection does not exist".
put:bReturn "sta:te = LISTEN", and the TCB pointer.
put:bSYN-SENT STAT:E
put:bReturn "sta:te = SYN-SENT", and the TCB pointer.
put:bSYN-RECEIVED :STATE
put:bReturn "sta:te = SYN-RECEIVED", and the TCB pointer.
put:bESTABLISHED S:TATE
put:bReturn "sta:te = ESTABLISHED", and the TCB pointer.
put:bFIN-WAIT-1 ST:ATE
put:bReturn "sta:te = FIN-WAIT-1", and the TCB pointer.
put:bFIN-WAIT-2 ST:ATE
put:bReturn "sta:te = FIN-WAIT-2", and the TCB pointer.
put:bCLOSE-WAIT ST:ATE
put:bReturn "sta:te = CLOSE-WAIT", and the TCB pointer.
put:bCLOSING STATE:
put:bReturn "sta:te = CLOSING", and the TCB pointer.
put:bLAST-ACK STAT:E
put:bReturn "sta:te = LAST-ACK", and the TCB pointer.
put:bTransmission Cont:rol Protocol
put:bFunctional Specif:ication
put:bTIME-WAIT STA:TE
put:bReturn "sta:te = TIME-WAIT", and the TCB pointer.
put:b[Page 64]        :                                                       
put:bSeptember 1981   :                                                       
put:bSEGMENT ARRIVES:
put:bIf the state :is CLOSED (i.e., TCB does not exist) then
put:ball data in: the incoming segment is discarded.  An incoming
put:bsegment con:taining a RST is discarded.  An incoming segment not
put:bcontaining :a RST causes a RST to be sent in response.  The
put:backnowledgm:ent and sequence field values are selected to make the
put:breset seque:nce acceptable to the TCP that sent the offending
put:bIf the ACK :bit is off, sequence number zero is used,
put:b<SEQ=0><A:CK=SEG.SEQ+SEG.LEN><CTL=RST,ACK>
put:bIf the ACK :bit is on,
put:b<SEQ=SEG.:ACK><CTL=RST>
put:bIf the state :is LISTEN then
put:bfirst check: for an RST
put:bAn incomi:ng RST should be ignored.  Return.
put:bsecond chec:k for an ACK
put:bAny ackno:wledgment is bad if it arrives on a connection still in
put:bthe LISTE:N state.  An acceptable reset segment should be formed
put:bfor any a:rriving ACK-bearing segment.  The RST should be
put:bformatted: as follows:
put:b<SEQ=SE:G.ACK><CTL=RST>
put:bthird check: for a SYN
put:bIf the SY:N bit is set, check the security.  If the
put:bsecurity/:compartment on the incoming segment does not exactly
put:bmatch the: security/compartment in the TCB then send a reset and
put:b<SEQ=SE:G.ACK><CTL=RST>
put:bTransmission Cont:rol Protocol
put:bFunctional Specif:ication
put:bIf the SE:G.PRC is greater than the TCB.PRC then if allowed by
put:bthe user :and the system set TCB.PRC<-SEG.PRC, if not allowed
put:bsend a re:set and return.
put:b<SEQ=SE:G.ACK><CTL=RST>
put:bIf the SE:G.PRC is less than the TCB.PRC then continue.
put:bSet RCV.N:XT to SEG.SEQ+1, IRS is set to SEG.SEQ and any other
put:bcontrol o:r text should be queued for processing later.  ISS
put:bshould be: selected and a SYN segment sent of the form:
put:b<SEQ=IS:S><ACK=RCV.NXT><CTL=SYN,ACK>
put:bSND.NXT i:s set to ISS+1 and SND.UNA to ISS.  The connection
put:bstate sho:uld be changed to SYN-RECEIVED.  Note that any other
put:bincoming :control or data (combined with SYN) will be processed
put:bin the SY:N-RECEIVED state, but processing of SYN and ACK should
put:bnot be re:peated.  If the listen was not fully specified (i.e.,
put:bthe forei:gn socket was not fully specified), then the
put:bunspecifi:ed fields should be filled in now.
put:bfourth othe:r text or control
put:bAny other: control or text-bearing segment (not containing SYN)
put:bmust have: an ACK and thus would be discarded by the ACK
put:bprocessin:g.  An incoming RST segment could not be valid, since
put:bit could :not have been sent in response to anything sent by this
put:bincarnati:on of the connection.  So you are unlikely to get here,
put:bbut if yo:u do, drop the segment, and return.
put:bIf the state :is SYN-SENT then
put:bfirst check: the ACK bit
put:bIf the AC:K bit is set
put:bIf SEG.:ACK =< ISS, or SEG.ACK > SND.NXT, send a reset (unless
put:bthe RST: bit is set, if so drop the segment and return)
put:b<SEQ=:SEG.ACK><CTL=RST>
put:band dis:card the segment.  Return.
put:bIf SND.:UNA =< SEG.ACK =< SND.NXT then the ACK is acceptable.
put:bsecond chec:k the RST bit
put:b[Page 66]        :                                                       
put:bSeptember 1981   :                                                       
put:bIf the RS:T bit is set
put:bIf the :ACK was acceptable then signal the user "error:
put:bconnect:ion reset", drop the segment, enter CLOSED state,
put:bdelete :TCB, and return.  Otherwise (no ACK) drop the segment
put:band ret:urn.
put:bthird check: the security and precedence
put:bIf the se:curity/compartment in the segment does not exactly
put:bmatch the: security/compartment in the TCB, send a reset
put:bIf ther:e is an ACK
put:b<SEQ=:SEG.ACK><CTL=RST>
put:bOtherwi:se
put:b<SEQ=:0><ACK=SEG.SEQ+SEG.LEN><CTL=RST,ACK>
put:bIf there :is an ACK
put:bThe pre:cedence in the segment must match the precedence in the
put:bTCB, if: not, send a reset
put:b<SEQ=:SEG.ACK><CTL=RST>
put:bIf there :is no ACK
put:bIf the :precedence in the segment is higher than the precedence
put:bin the :TCB then if allowed by the user and the system raise
put:bthe pre:cedence in the TCB to that in the segment, if not
put:ballowed: to raise the prec then send a reset.
put:b<SEQ=:0><ACK=SEG.SEQ+SEG.LEN><CTL=RST,ACK>
put:bIf the :precedence in the segment is lower than the precedence
put:bin the :TCB continue.
put:bIf a rese:t was sent, discard the segment and return.
put:bfourth chec:k the SYN bit
put:bThis step: should be reached only if the ACK is ok, or there is
put:bno ACK, a:nd it the segment did not contain a RST.
put:bIf the SY:N bit is on and the security/compartment and precedence
put:bTransmission Cont:rol Protocol
put:bFunctional Specif:ication
put:bare accep:table then, RCV.NXT is set to SEG.SEQ+1, IRS is set to
put:bSEG.SEQ. : SND.UNA should be advanced to equal SEG.ACK (if there
put:bis an ACK:), and any segments on the retransmission queue which
put:bare there:by acknowledged should be removed.
put:bIf SND.UN:A > ISS (our SYN has been ACKed), change the connection
put:bstate to :ESTABLISHED, form an ACK segment
put:b<SEQ=SN:D.NXT><ACK=RCV.NXT><CTL=ACK>
put:band send :it.  Data or controls which were queued for
put:btransmiss:ion may be included.  If there are other controls or
put:btext in t:he segment then continue processing at the sixth step
put:bbelow whe:re the URG bit is checked, otherwise return.
put:bOtherwise: enter SYN-RECEIVED, form a SYN,ACK segment
put:b<SEQ=IS:S><ACK=RCV.NXT><CTL=SYN,ACK>
put:band send :it.  If there are other controls or text in the
put:bsegment, :queue them for processing after the ESTABLISHED state
put:bhas been :reached, return.
put:bfifth, if n:either of the SYN or RST bits is set then drop the
put:bsegment and: return.
put:b[Page 68]        :                                                       
put:bSeptember 1981   :                                                       
put:bfirst check s:equence number
put:bSYN-RECEIVE:D STATE
put:bESTABLISHED: STATE
put:bFIN-WAIT-1 :STATE
put:bFIN-WAIT-2 :STATE
put:bCLOSE-WAIT :STATE
put:bCLOSING STA:TE
put:bLAST-ACK ST:ATE
put:bTIME-WAIT S:TATE
put:bSegments :are processed in sequence.  Initial tests on arrival
put:bare used :to discard old duplicates, but further processing is
put:bdone in S:EG.SEQ order.  If a segment's contents straddle the
put:bboundary :between old and new, only the new parts should be
put:bprocessed:.
put:bThere are: four cases for the acceptability test for an incoming
put:bsegment:
put:bSegment R:eceive  Test
put:bLength  W:indow
put:b------- -:------  -------------------------------------------
put:b0     :  0     SEG.SEQ = RCV.NXT
put:b0     : >0     RCV.NXT =< SEG.SEQ < RCV.NXT+RCV.WND
put:b>0     :  0     not acceptable
put:b>0     : >0     RCV.NXT =< SEG.SEQ < RCV.NXT+RCV.WND
put:bIf the RC:V.WND is zero, no segments will be acceptable, but
put:bspecial a:llowance should be made to accept valid ACKs, URGs and
put:bIf an inc:oming segment is not acceptable, an acknowledgment
put:bshould be: sent in reply (unless the RST bit is set, if so drop
put:bthe segme:nt and return):
put:b<SEQ=SN:D.NXT><ACK=RCV.NXT><CTL=ACK>
put:bAfter sen:ding the acknowledgment, drop the unacceptable segment
put:band retur:n.
put:bTransmission Cont:rol Protocol
put:bFunctional Specif:ication
put:bIn the fo:llowing it is assumed that the segment is the idealized
put:bsegment t:hat begins at RCV.NXT and does not exceed the window.
put:bOne could: tailor actual segments to fit this assumption by
put:btrimming :off any portions that lie outside the window (including
put:bSYN and F:IN), and only processing further if the segment then
put:bbegins at: RCV.NXT.  Segments with higher begining sequence
put:bnumbers m:ay be held for later processing.
put:bsecond check :the RST bit,
put:bSYN-RECEIVE:D STATE
put:bIf the RS:T bit is set
put:bIf this: connection was initiated with a passive OPEN (i.e.,
put:bcame fr:om the LISTEN state), then return this connection to
put:bLISTEN :state and return.  The user need not be informed.  If
put:bthis co:nnection was initiated with an active OPEN (i.e., came
put:bfrom SY:N-SENT state) then the connection was refused, signal
put:bthe use:r "connection refused".  In either case, all segments
put:bon the :retransmission queue should be removed.  And in the
put:bactive :OPEN case, enter the CLOSED state and delete the TCB,
put:band ret:urn.
put:bESTABLISHED:
put:bIf the RS:T bit is set then, any outstanding RECEIVEs and SEND
put:bshould re:ceive "reset" responses.  All segment queues should be
put:bflushed. : Users should also receive an unsolicited general
put:b"connecti:on reset" signal.  Enter the CLOSED state, delete the
put:bTCB, and :return.
put:bCLOSING STA:TE
put:bLAST-ACK ST:ATE
put:bIf the RS:T bit is set then, enter the CLOSED state, delete the
put:bTCB, and :return.
put:b[Page 70]        :                                                       
put:bSeptember 1981   :                                                       
put:bthird check s:ecurity and precedence
put:bSYN-RECEIVE:D
put:bIf the se:curity/compartment and precedence in the segment do not
put:bexactly m:atch the security/compartment and precedence in the TCB
put:bthen send: a reset, and return.
put:bESTABLISHED: STATE
put:bIf the se:curity/compartment and precedence in the segment do not
put:bexactly m:atch the security/compartment and precedence in the TCB
put:bthen send: a reset, any outstanding RECEIVEs and SEND should
put:breceive ":reset" responses.  All segment queues should be
put:bflushed. : Users should also receive an unsolicited general
put:b"connecti:on reset" signal.  Enter the CLOSED state, delete the
put:bTCB, and :return.
put:bNote this c:heck is placed following the sequence check to prevent
put:ba segment f:rom an old connection between these ports with a
put:bdifferent s:ecurity or precedence from causing an abort of the
put:bcurrent con:nection.
put:bfourth, check: the SYN bit,
put:bSYN-RECEIVE:D
put:bESTABLISHED: STATE
put:bFIN-WAIT ST:ATE-1
put:bFIN-WAIT ST:ATE-2
put:bCLOSE-WAIT :STATE
put:bCLOSING STA:TE
put:bLAST-ACK ST:ATE
put:bTIME-WAIT S:TATE
put:bIf the SY:N is in the window it is an error, send a reset, any
put:boutstandi:ng RECEIVEs and SEND should receive "reset" responses,
put:ball segme:nt queues should be flushed, the user should also
put:breceive a:n unsolicited general "connection reset" signal, enter
put:bthe CLOSE:D state, delete the TCB, and return.
put:bIf the SY:N is not in the window this step would not be reached
put:band an ac:k would have been sent in the first step (sequence
put:bnumber ch:eck).
put:bTransmission Cont:rol Protocol
put:bFunctional Specif:ication
put:bfifth check t:he ACK field,
put:bif the ACK :bit is off drop the segment and return
put:bif the ACK :bit is on
put:bSYN-RECEI:VED STATE
put:bIf SND.:UNA =< SEG.ACK =< SND.NXT then enter ESTABLISHED state
put:band con:tinue processing.
put:bIf th:e segment acknowledgment is not acceptable, form a
put:breset: segment,
put:b<SE:Q=SEG.ACK><CTL=RST>
put:band s:end it.
put:bESTABLISH:ED STATE
put:bIf SND.:UNA < SEG.ACK =< SND.NXT then, set SND.UNA <- SEG.ACK.
put:bAny seg:ments on the retransmission queue which are thereby
put:bentirel:y acknowledged are removed.  Users should receive
put:bpositiv:e acknowledgments for buffers which have been SENT and
put:bfully a:cknowledged (i.e., SEND buffer should be returned with
put:b"ok" re:sponse).  If the ACK is a duplicate
put:b(SEG.AC:K < SND.UNA), it can be ignored.  If the ACK acks
put:bsomethi:ng not yet sent (SEG.ACK > SND.NXT) then send an ACK,
put:bdrop th:e segment, and return.
put:bIf SND.:UNA < SEG.ACK =< SND.NXT, the send window should be
put:bupdated:.  If (SND.WL1 < SEG.SEQ or (SND.WL1 = SEG.SEQ and
put:bSND.WL2: =< SEG.ACK)), set SND.WND <- SEG.WND, set
put:bSND.WL1: <- SEG.SEQ, and set SND.WL2 <- SEG.ACK.
put:bNote th:at SND.WND is an offset from SND.UNA, that SND.WL1
put:brecords: the sequence number of the last segment used to update
put:bSND.WND:, and that SND.WL2 records the acknowledgment number of
put:bthe las:t segment used to update SND.WND.  The check here
put:bprevent:s using old segments to update the window.
put:b[Page 72]        :                                                       
put:bSeptember 1981   :                                                       
put:bFIN-WAIT-:1 STATE
put:bIn addi:tion to the processing for the ESTABLISHED state, if
put:bour FIN: is now acknowledged then enter FIN-WAIT-2 and continue
put:bprocess:ing in that state.
put:bFIN-WAIT-:2 STATE
put:bIn addi:tion to the processing for the ESTABLISHED state, if
put:bthe ret:ransmission queue is empty, the user's CLOSE can be
put:backnowl:edged ("ok") but do not delete the TCB.
put:bCLOSE-WAI:T STATE
put:bDo the :same processing as for the ESTABLISHED state.
put:bCLOSING S:TATE
put:bIn addi:tion to the processing for the ESTABLISHED state, if
put:bthe ACK: acknowledges our FIN then enter the TIME-WAIT state,
put:botherwi:se ignore the segment.
put:bLAST-ACK :STATE
put:bThe onl:y thing that can arrive in this state is an
put:backnowl:edgment of our FIN.  If our FIN is now acknowledged,
put:bdelete :the TCB, enter the CLOSED state, and return.
put:bTIME-WAIT: STATE
put:bThe onl:y thing that can arrive in this state is a
put:bretrans:mission of the remote FIN.  Acknowledge it, and restart
put:bthe 2 M:SL timeout.
put:bsixth, check :the URG bit,
put:bESTABLISHED: STATE
put:bFIN-WAIT-1 :STATE
put:bFIN-WAIT-2 :STATE
put:bIf the UR:G bit is set, RCV.UP <- max(RCV.UP,SEG.UP), and signal
put:bthe user :that the remote side has urgent data if the urgent
put:bpointer (:RCV.UP) is in advance of the data consumed.  If the
put:buser has :already been signaled (or is still in the "urgent
put:bmode") fo:r this continuous sequence of urgent data, do not
put:bsignal th:e user again.
put:bTransmission Cont:rol Protocol
put:bFunctional Specif:ication
put:bCLOSE-WAIT :STATE
put:bCLOSING STA:TE
put:bLAST-ACK ST:ATE
put:bThis shou:ld not occur, since a FIN has been received from the
put:bremote si:de.  Ignore the URG.
put:bseventh, proc:ess the segment text,
put:bESTABLISHED: STATE
put:bFIN-WAIT-1 :STATE
put:bFIN-WAIT-2 :STATE
put:bOnce in t:he ESTABLISHED state, it is possible to deliver segment
put:btext to u:ser RECEIVE buffers.  Text from segments can be moved
put:binto buff:ers until either the buffer is full or the segment is
put:bempty.  I:f the segment empties and carries an PUSH flag, then
put:bthe user :is informed, when the buffer is returned, that a PUSH
put:bhas been :received.
put:bWhen the :TCP takes responsibility for delivering the data to the
put:buser it m:ust also acknowledge the receipt of the data.
put:bOnce the :TCP takes responsibility for the data it advances
put:bRCV.NXT o:ver the data accepted, and adjusts RCV.WND as
put:bapporopri:ate to the current buffer availability.  The total of
put:bRCV.NXT a:nd RCV.WND should not be reduced.
put:bPlease no:te the window management suggestions in section 3.7.
put:bSend an a:cknowledgment of the form:
put:b<SEQ=SN:D.NXT><ACK=RCV.NXT><CTL=ACK>
put:bThis ackn:owledgment should be piggybacked on a segment being
put:btransmitt:ed if possible without incurring undue delay.
put:b[Page 74]        :                                                       
put:bSeptember 1981   :                                                       
put:bCLOSE-WAIT :STATE
put:bCLOSING STA:TE
put:bLAST-ACK ST:ATE
put:bTIME-WAIT S:TATE
put:bThis shou:ld not occur, since a FIN has been received from the
put:bremote si:de.  Ignore the segment text.
put:beighth, check: the FIN bit,
put:bDo not proc:ess the FIN if the state is CLOSED, LISTEN or SYN-SENT
put:bsince the S:EG.SEQ cannot be validated; drop the segment and
put:bIf the FIN :bit is set, signal the user "connection closing" and
put:breturn any :pending RECEIVEs with same message, advance RCV.NXT
put:bover the FI:N, and send an acknowledgment for the FIN.  Note that
put:bFIN implies: PUSH for any segment text not yet delivered to the
put:bSYN-RECEI:VED STATE
put:bESTABLISH:ED STATE
put:bEnter t:he CLOSE-WAIT state.
put:bFIN-WAIT-:1 STATE
put:bIf our :FIN has been ACKed (perhaps in this segment), then
put:benter T:IME-WAIT, start the time-wait timer, turn off the other
put:btimers;: otherwise enter the CLOSING state.
put:bFIN-WAIT-:2 STATE
put:bEnter t:he TIME-WAIT state.  Start the time-wait timer, turn
put:boff the: other timers.
put:bCLOSE-WAI:T STATE
put:bRemain :in the CLOSE-WAIT state.
put:bCLOSING S:TATE
put:bRemain :in the CLOSING state.
put:bLAST-ACK :STATE
put:bRemain :in the LAST-ACK state.
put:bTransmission Cont:rol Protocol
put:bFunctional Specif:ication
put:bTIME-WAIT: STATE
put:bRemain :in the TIME-WAIT state.  Restart the 2 MSL time-wait
put:btimeout:.
put:b[Page 76]        :                                                       
put:bSeptember 1981   :                                                       
put:bFor any state: if the user timeout expires, flush all queues, signal
put:bthe user "err:or:  connection aborted due to user timeout" in general
put:band for any o:utstanding calls, delete the TCB, enter the CLOSED
put:bstate and ret:urn.
put:bRETRANSMISSION :TIMEOUT
put:bFor any state: if the retransmission timeout expires on a segment in
put:bthe retransmi:ssion queue, send the segment at the front of the
put:bretransmissio:n queue again, reinitialize the retransmission timer,
put:bTIME-WAIT TIMEO:UT
put:bIf the time-w:ait timeout expires on a connection delete the TCB,
put:benter the CLO:SED state and return.
put:bTransmission Cont:rol Protocol
put:b[Page 78]        :                                                       
put:bSeptember 1981   :                                                       
put:bBBN Rep:ort 1822, "The Specification of the Interconnection of
put:ba Host :and an IMP".  The specification of interface between a
put:bhost an:d the ARPANET.
put:bA contr:ol bit (acknowledge) occupying no sequence space, which
put:bindicat:es that the acknowledgment field of this segment
put:bspecifi:es the next sequence number the sender of this segment
put:bis expe:cting to receive, hence acknowledging receipt of all
put:bpreviou:s sequence numbers.
put:bThe uni:t of transmission between a host and an IMP in the
put:bARPANET:.  The maximum size is about 1012 octets (8096 bits).
put:bA unit :of transmission used internally in the ARPANET between
put:bIMPs.  :The maximum size is about 126 octets (1008 bits).
put:bA logic:al communication path identified by a pair of sockets.
put:bA messa:ge sent in a packet switched computer communications
put:bnetwork:.
put:bDestination Addre:ss
put:bThe des:tination address, usually the network and host
put:bidentif:iers.
put:bA contr:ol bit (finis) occupying one sequence number, which
put:bindicat:es that the sender will send no more data or control
put:boccupyi:ng sequence space.
put:bA porti:on of a logical unit of data, in particular an internet
put:bfragmen:t is a portion of an internet datagram.
put:bA file :transfer protocol.
put:bTransmission Cont:rol Protocol
put:bControl: information at the beginning of a message, segment,
put:bfragmen:t, packet or block of data.
put:bA compu:ter.  In particular a source or destination of messages
put:bfrom th:e point of view of the communication network.
put:bAn Inte:rnet Protocol field.  This identifying value assigned
put:bby the :sender aids in assembling the fragments of a datagram.
put:bThe Int:erface Message Processor, the packet switch of the
put:bARPANET:.
put:bA sourc:e or destination address specific to the host level.
put:binternet datagram:
put:bThe uni:t of data exchanged between an internet module and the
put:bhigher :level protocol together with the internet header.
put:binternet fragment:
put:bA porti:on of the data of an internet datagram with an internet
put:bheader.:
put:bInterne:t Protocol.
put:bThe Ini:tial Receive Sequence number.  The first sequence
put:bnumber :used by the sender on a connection.
put:bThe Ini:tial Sequence Number.  The first sequence number used
put:bon a co:nnection, (either ISS or IRS).  Selected on a clock
put:bbased p:rocedure.
put:bThe Ini:tial Send Sequence number.  The first sequence number
put:bused by: the sender on a connection.
put:bControl: information at the beginning of a message or block of
put:bdata.  :In particular, in the ARPANET, the control information
put:bon an A:RPANET message at the host-IMP interface.
put:b[Page 80]        :                                                       
put:bSeptember 1981   :                                                       
put:bThis is: the next sequence number to be acknowledged by the
put:bdata re:ceiving TCP (or the lowest currently unacknowledged
put:bsequenc:e number) and is sometimes referred to as the left edge
put:bof the :send window.
put:bThe uni:t of transmission within a local network.
put:bAn impl:ementation, usually in software, of a protocol or other
put:bprocedu:re.
put:bMaximum: Segment Lifetime, the time a TCP segment can exist in
put:bthe int:ernetwork system.  Arbitrarily defined to be 2 minutes.
put:bAn eigh:t bit byte.
put:bAn Opti:on field may contain several options, and each option
put:bmay be :several octets in length.  The options are used
put:bprimari:ly in testing situations; for example, to carry
put:btimesta:mps.  Both the Internet Protocol and TCP provide for
put:boptions: fields.
put:bA packa:ge of data with a header which may or may not be
put:blogical:ly complete.  More often a physical packaging than a
put:blogical: packaging of data.
put:bThe por:tion of a socket that specifies which logical input or
put:boutput :channel of a process is associated with the data.
put:bA progr:am in execution.  A source or destination of data from
put:bthe poi:nt of view of the TCP or other host-to-host protocol.
put:bA contr:ol bit occupying no sequence space, indicating that
put:bthis se:gment contains data that must be pushed through to the
put:breceivi:ng user.
put:breceive: next sequence number
put:bTransmission Cont:rol Protocol
put:breceive: urgent pointer
put:breceive: window
put:breceive next sequ:ence number
put:bThis is: the next sequence number the local TCP is expecting to
put:breceive:.
put:bThis re:presents the sequence numbers the local (receiving) TCP
put:bis will:ing to receive.  Thus, the local TCP considers that
put:bsegment:s overlapping the range RCV.NXT to
put:bRCV.NXT: + RCV.WND - 1 carry acceptable data or control.
put:bSegment:s containing sequence numbers entirely outside of this
put:brange a:re considered duplicates and discarded.
put:bA contr:ol bit (reset), occupying no sequence space, indicating
put:bthat th:e receiver should delete the connection without further
put:binterac:tion.  The receiver can determine, based on the
put:bsequenc:e number and acknowledgment fields of the incoming
put:bsegment:, whether it should honor the reset command or ignore
put:bit.  In: no case does receipt of a segment containing RST give
put:brise to: a RST in response.
put:bReal Ti:me Protocol:  A host-to-host protocol for communication
put:bof time: critical information.
put:bsegment: acknowledgment
put:bsegment: length
put:bsegment: precedence value
put:bsegment: sequence
put:bsegment: urgent pointer field
put:b[Page 82]        :                                                       
put:bSeptember 1981   :                                                       
put:bsegment: window field
put:bA logic:al unit of data, in particular a TCP segment is the
put:bunit of: data transfered between a pair of TCP modules.
put:bsegment acknowled:gment
put:bThe seq:uence number in the acknowledgment field of the
put:barrivin:g segment.
put:bThe amo:unt of sequence number space occupied by a segment,
put:bincludi:ng any controls which occupy sequence space.
put:bThe num:ber in the sequence field of the arriving segment.
put:bThis is: the next sequence number the local (sending) TCP will
put:buse on :the connection.  It is initially selected from an
put:binitial: sequence number curve (ISN) and is incremented for
put:beach oc:tet of data or sequenced control transmitted.
put:bThis re:presents the sequence numbers which the remote
put:b(receiv:ing) TCP is willing to receive.  It is the value of the
put:bwindow :field specified in segments from the remote (data
put:breceivi:ng) TCP.  The range of new sequence numbers which may
put:bbe emit:ted by a TCP lies between SND.NXT and
put:bSND.UNA: + SND.WND - 1. (Retransmissions of sequence numbers
put:bbetween: SND.UNA and SND.NXT are expected, of course.)
put:bsend se:quence
put:bleft se:quence
put:bsend ur:gent pointer
put:bsegment: sequence number at last window update
put:bsegment: acknowledgment number at last window update
put:bTransmission Cont:rol Protocol
put:bsend wi:ndow
put:bAn addr:ess which specifically includes a port identifier, that
put:bis, the: concatenation of an Internet Address with a TCP port.
put:bThe sou:rce address, usually the network and host identifiers.
put:bA contr:ol bit in the incoming segment, occupying one sequence
put:bnumber,: used at the initiation of a connection, to indicate
put:bwhere t:he sequence numbering will start.
put:bTransmi:ssion control block, the data structure that records
put:bthe sta:te of a connection.
put:bThe pre:cedence of the connection.
put:bTransmi:ssion Control Protocol:  A host-to-host protocol for
put:breliabl:e communication in internetwork environments.
put:bType of: Service, an Internet Protocol field.
put:bAn Inte:rnet Protocol field which indicates the type of service
put:bfor thi:s internet fragment.
put:bA contr:ol bit (urgent), occupying no sequence space, used to
put:bindicat:e that the receiving user should be notified to do
put:burgent :processing as long as there is data to be consumed with
put:bsequenc:e numbers less than the value indicated in the urgent
put:bpointer:.
put:bA contr:ol field meaningful only when the URG bit is on.  This
put:bfield c:ommunicates the value of the urgent pointer which
put:bindicat:es the data octet associated with the sending user's
put:burgent :call.
put:b[Page 84]        :                                                       
put:bSeptember 1981   :                                                       
put:b[1]  Cerf, V., an:d R. Kahn, "A Protocol for Packet Network
put:bIntercommuni:cation", IEEE Transactions on Communications,
put:bVol. COM-22,: No. 5, pp 637-648, May 1974.
put:b[2]  Postel, J. (:ed.), "Internet Protocol - DARPA Internet Program
put:bProtocol Spe:cification", RFC 791, USC/Information Sciences
put:bInstitute, S:eptember 1981.
put:b[3]  Dalal, Y. an:d C. Sunshine, "Connection Management in Transport
put:bProtocols", :Computer Networks, Vol. 2, No. 6, pp. 454-473,
put:bDecember 197:8.
put:b[4]  Postel, J., :"Assigned Numbers", RFC 790, USC/Information Sciences
put:bInstitute, S:eptember 1981.
put:baRFC: 793
put:baDe:fense Advanced Research Projects Agency
put:baI:nformation Processing Techniques Office
put:baSeptember 1981   :                                                       
put:baPREFACE .....:................................................... iii
put:ba1.  INTRODUCTION :..................................................... 1
put:ba1.1  Motivation: .................................................... 1
put:ba1.2  Scope ....:..................................................... 2
put:ba1.3  About This: Document ........................................... 2
put:ba1.4  Interfaces: .................................................... 3
put:ba1.5  Operation :..................................................... 3
put:ba2.  PHILOSOPHY ..:..................................................... 7
put:ba2.1  Elements o:f the Internetwork System ........................... 7
put:ba2.2  Model of O:peration ............................................ 7
put:ba2.3  The Host E:nvironment .......................................... 8
put:ba2.4  Interfaces: .................................................... 9
put:ba2.5  Relation t:o Other Protocols ................................... 9
put:ba2.6  Reliable C:ommunication ........................................ 9
put:ba2.7  Connection: Establishment and Clearing ........................ 10
put:ba2.8  Data Commu:nication ........................................... 12
put:ba2.9  Precedence: and Security ...................................... 13
put:ba2.10 Robustness: Principle ......................................... 13
put:ba3.  FUNCTIONAL SP:ECIFICATION ........................................ 15
put:ba3.1  Header For:mat ................................................ 15
put:ba3.2  Terminolog:y .................................................. 19
put:ba3.3  Sequence N:umbers ............................................. 24
put:ba3.4  Establishi:ng a connection .................................... 30
put:ba3.5  Closing a :Connection ......................................... 37
put:ba3.6  Precedence: and Security ...................................... 40
put:ba3.7  Data Commu:nication ........................................... 40
put:ba3.8  Interfaces: ................................................... 44
put:ba3.9  Event Proc:essing ............................................. 52
put:baGLOSSARY ........:.................................................... 79
put:baREFERENCES ......:.................................................... 85
put:baTransmission Cont:rol Protocol
put:ba[Page ii]        :                                                       
put:baSeptember 1981   :                                                       
put:baThis document des:cribes the DoD Standard Transmission Control Protocol
put:ba(TCP).  There hav:e been nine earlier editions of the ARPA TCP
put:baspecification on :which this standard is based, and the present text
put:badraws heavily fro:m them.  There have been many contributors to this work
put:baboth in terms of :concepts and in terms of text.  This edition clarifies
put:baseveral details a:nd removes the end-of-letter buffer-size adjustments,
put:baand redescribes t:he letter mechanism as a push function.
put:baRFC:  793
put:baReplaces: RFC 761:
put:baIENs:  129, 124, :112, 81,
put:ba55, 44, 40, 27, 2:1, 5
put:baThe Transmission :Control Protocol (TCP) is intended for use as a highly
put:bareliable host-to-:host protocol between hosts in packet-switched computer
put:bacommunication net:works, and in interconnected systems of such networks.
put:baThis document des:cribes the functions to be performed by the
put:baTransmission Cont:rol Protocol, the program that implements it, and its
put:bainterface to prog:rams or users that require its services.
put:baComputer commun:ication systems are playing an increasingly important
put:barole in militar:y, government, and civilian environments.  This
put:badocument focuse:s its attention primarily on military computer
put:bacommunication r:equirements, especially robustness in the presence of
put:bacommunication u:nreliability and availability in the presence of
put:bacongestion, but: many of these problems are found in the civilian and
put:bagovernment sect:or as well.
put:baAs strategic an:d tactical computer communication networks are
put:badeveloped and d:eployed, it is essential to provide means of
put:bainterconnecting: them and to provide standard interprocess
put:bacommunication p:rotocols which can support a broad range of
put:baapplications.  :In anticipation of the need for such standards, the
put:baDeputy Undersec:retary of Defense for Research and Engineering has
put:badeclared the Tr:ansmission Control Protocol (TCP) described herein to
put:babe a basis for :DoD-wide inter-process communication protocol
put:bastandardization:.
put:baTCP is a connec:tion-oriented, end-to-end reliable protocol designed to
put:bafit into a laye:red hierarchy of protocols which support multi-network
put:baapplications.  :The TCP provides for reliable inter-process
put:bacommunication b:etween pairs of processes in host computers attached to
put:badistinct but in:terconnected computer communication networks.  Very few
put:baassumptions are: made as to the reliability of the communication
put:baprotocols below: the TCP layer.  TCP assumes it can obtain a simple,
put:bapotentially unr:eliable datagram service from the lower level
put:baprotocols.  In :principle, the TCP should be able to operate above a
put:bawide spectrum o:f communication systems ranging from hard-wired
put:baconnections to :packet-switched or circuit-switched networks.
put:baTransmission Cont:rol Protocol
put:baTCP is based on: concepts first described by Cerf and Kahn in [1].  The
put:baTCP fits into a: layered protocol architecture just above a basic
put:baInternet Protoc:ol [2] which provides a way for the TCP to send and
put:bareceive variabl:e-length segments of information enclosed in internet
put:badatagram "envel:opes".  The internet datagram provides a means for
put:baaddressing sour:ce and destination TCPs in different networks.  The
put:bainternet protoc:ol also deals with any fragmentation or reassembly of
put:bathe TCP segment:s required to achieve transport and delivery through
put:bamultiple networ:ks and interconnecting gateways.  The internet protocol
put:baalso carries in:formation on the precedence, security classification
put:baand compartment:ation of the TCP segments, so this information can be
put:bacommunicated en:d-to-end across multiple networks.
put:baMuch of this do:cument is written in the context of TCP implementations
put:bawhich are co-re:sident with higher level protocols in the host
put:bacomputer.  Some: computer systems will be connected to networks via
put:bafront-end compu:ters which house the TCP and internet protocol layers,
put:baas well as netw:ork specific software.  The TCP specification describes
put:baan interface to: the higher level protocols which appears to be
put:baimplementable e:ven for the front-end case, as long as a suitable
put:bahost-to-front e:nd protocol is implemented.
put:baThe TCP is inte:nded to provide a reliable process-to-process
put:bacommunication s:ervice in a multinetwork environment.  The TCP is
put:baintended to be :a host-to-host protocol in common use in multiple
put:ba1.3.  About this :Document
put:baThis document r:epresents a specification of the behavior required of
put:baany TCP impleme:ntation, both in its interactions with higher level
put:baprotocols and i:n its interactions with other TCPs.  The rest of this
put:ba[Page 2]         :                                                       
put:baSeptember 1981   :                                                       
put:basection offers :a very brief view of the protocol interfaces and
put:baoperation.  Sec:tion 2 summarizes the philosophical basis for the TCP
put:badesign.  Sectio:n 3 offers both a detailed description of the actions
put:barequired of TCP: when various events occur (arrival of new segments,
put:bauser calls, err:ors, etc.) and the details of the formats of TCP
put:baThe TCP interfa:ces on one side to user or application processes and on
put:bathe other side :to a lower level protocol such as Internet Protocol.
put:baThe interface b:etween an application process and the TCP is
put:baillustrated in :reasonable detail.  This interface consists of a set of
put:bacalls much like: the calls an operating system provides to an
put:baapplication pro:cess for manipulating files.  For example, there are
put:bacalls to open a:nd close connections and to send and receive data on
put:baestablished con:nections.  It is also expected that the TCP can
put:baasynchronously :communicate with application programs.  Although
put:baconsiderable fr:eedom is permitted to TCP implementors to design
put:bainterfaces whic:h are appropriate to a particular operating system
put:baenvironment, a :minimum functionality is required at the TCP/user
put:bainterface for a:ny valid implementation.
put:baThe interface b:etween TCP and lower level protocol is essentially
put:baunspecified exc:ept that it is assumed there is a mechanism whereby the
put:batwo levels can :asynchronously pass information to each other.
put:baTypically, one :expects the lower level protocol to specify this
put:bainterface.  TCP: is designed to work in a very general environment of
put:bainterconnected :networks.  The lower level protocol which is assumed
put:bathroughout this: document is the Internet Protocol [2].
put:baAs noted above,: the primary purpose of the TCP is to provide reliable,
put:basecurable logic:al circuit or connection service between pairs of
put:baprocesses.  To :provide this service on top of a less reliable internet
put:bacommunication s:ystem requires facilities in the following areas:
put:baBasic Data Tr:ansfer
put:baPrecedence an:d Security
put:baThe basic opera:tion of the TCP in each of these areas is described in
put:bathe following p:aragraphs.
put:baTransmission Cont:rol Protocol
put:baBasic Data Tran:sfer:
put:baThe TCP is ab:le to transfer a continuous stream of octets in each
put:badirection bet:ween its users by packaging some number of octets into
put:basegments for :transmission through the internet system.  In general,
put:bathe TCPs deci:de when to block and forward data at their own
put:baSometimes use:rs need to be sure that all the data they have
put:basubmitted to :the TCP has been transmitted.  For this purpose a push
put:bafunction is d:efined.  To assure that data submitted to a TCP is
put:baactually tran:smitted the sending user indicates that it should be
put:bapushed throug:h to the receiving user.  A push causes the TCPs to
put:bapromptly forw:ard and deliver data up to that point to the receiver.
put:baThe exact pus:h point might not be visible to the receiving user and
put:bathe push func:tion does not supply a record boundary marker.
put:baReliability:
put:baThe TCP must :recover from data that is damaged, lost, duplicated, or
put:badelivered out: of order by the internet communication system.  This
put:bais achieved b:y assigning a sequence number to each octet
put:batransmitted, :and requiring a positive acknowledgment (ACK) from the
put:bareceiving TCP:.  If the ACK is not received within a timeout
put:bainterval, the: data is retransmitted.  At the receiver, the sequence
put:banumbers are u:sed to correctly order segments that may be received
put:baout of order :and to eliminate duplicates.  Damage is handled by
put:baadding a chec:ksum to each segment transmitted, checking it at the
put:bareceiver, and: discarding damaged segments.
put:baAs long as th:e TCPs continue to function properly and the internet
put:basystem does n:ot become completely partitioned, no transmission
put:baerrors will a:ffect the correct delivery of data.  TCP recovers from
put:bainternet comm:unication system errors.
put:baFlow Control:
put:baTCP provides :a means for the receiver to govern the amount of data
put:basent by the s:ender.  This is achieved by returning a "window" with
put:baevery ACK ind:icating a range of acceptable sequence numbers beyond
put:bathe last segm:ent successfully received.  The window indicates an
put:baallowed numbe:r of octets that the sender may transmit before
put:bareceiving fur:ther permission.
put:ba[Page 4]         :                                                       
put:baSeptember 1981   :                                                       
put:baMultiplexing:
put:baTo allow for :many processes within a single Host to use TCP
put:bacommunication: facilities simultaneously, the TCP provides a set of
put:baaddresses or :ports within each host.  Concatenated with the network
put:baand host addr:esses from the internet communication layer, this forms
put:baa socket.  A :pair of sockets uniquely identifies each connection.
put:baThat is, a so:cket may be simultaneously used in multiple
put:baThe binding o:f ports to processes is handled independently by each
put:baHost.  Howeve:r, it proves useful to attach frequently used processes
put:ba(e.g., a "log:ger" or timesharing service) to fixed sockets which are
put:bamade known to: the public.  These services can then be accessed
put:bathrough the k:nown addresses.  Establishing and learning the port
put:baaddresses of :other processes may involve more dynamic mechanisms.
put:baConnections:
put:baThe reliabili:ty and flow control mechanisms described above require
put:bathat TCPs ini:tialize and maintain certain status information for
put:baeach data str:eam.  The combination of this information, including
put:basockets, sequ:ence numbers, and window sizes, is called a connection.
put:baEach connecti:on is uniquely specified by a pair of sockets
put:baidentifying i:ts two sides.
put:baWhen two proc:esses wish to communicate, their TCP's must first
put:baestablish a c:onnection (initialize the status information on each
put:baside).  When :their communication is complete, the connection is
put:baterminated or: closed to free the resources for other uses.
put:baSince connect:ions must be established between unreliable hosts and
put:baover the unre:liable internet communication system, a handshake
put:bamechanism wit:h clock-based sequence numbers is used to avoid
put:baerroneous ini:tialization of connections.
put:baPrecedence and :Security:
put:baThe users of :TCP may indicate the security and precedence of their
put:bacommunication:.  Provision is made for default values to be used when
put:bathese feature:s are not needed.
put:baTransmission Cont:rol Protocol
put:ba[Page 6]         :                                                       
put:baSeptember 1981   :                                                       
put:ba2.1.  Elements of: the Internetwork System
put:baThe internetwor:k environment consists of hosts connected to networks
put:bawhich are in tu:rn interconnected via gateways.  It is assumed here
put:bathat the networ:ks may be either local networks (e.g., the ETHERNET) or
put:balarge networks :(e.g., the ARPANET), but in any case are based on
put:bapacket switchin:g technology.  The active agents that produce and
put:baconsume message:s are processes.  Various levels of protocols in the
put:banetworks, the g:ateways, and the hosts support an interprocess
put:bacommunication s:ystem that provides two-way data flow on logical
put:baconnections bet:ween process ports.
put:baThe term packet: is used generically here to mean the data of one
put:batransaction bet:ween a host and its network.  The format of data blocks
put:baexchanged withi:n the a network will generally not be of concern to us.
put:baHosts are compu:ters attached to a network, and from the communication
put:banetwork's point: of view, are the sources and destinations of packets.
put:baProcesses are v:iewed as the active elements in host computers (in
put:baaccordance with: the fairly common definition of a process as a program
put:bain execution). : Even terminals and files or other I/O devices are
put:baviewed as commu:nicating with each other through the use of processes.
put:baThus, all commu:nication is viewed as inter-process communication.
put:baSince a process: may need to distinguish among several communication
put:bastreams between: itself and another process (or processes), we imagine
put:bathat each proce:ss may have a number of ports through which it
put:bacommunicates wi:th the ports of other processes.
put:ba2.2.  Model of Op:eration
put:baProcesses trans:mit data by calling on the TCP and passing buffers of
put:badata as argumen:ts.  The TCP packages the data from these buffers into
put:basegments and ca:lls on the internet module to transmit each segment to
put:bathe destination: TCP.  The receiving TCP places the data from a segment
put:bainto the receiv:ing user's buffer and notifies the receiving user.  The
put:baTCPs include co:ntrol information in the segments which they use to
put:baensure reliable: ordered data transmission.
put:baThe model of in:ternet communication is that there is an internet
put:baprotocol module: associated with each TCP which provides an interface
put:bato the local ne:twork.  This internet module packages TCP segments
put:bainside internet: datagrams and routes these datagrams to a destination
put:bainternet module: or intermediate gateway.  To transmit the datagram
put:bathrough the loc:al network, it is embedded in a local network packet.
put:baThe packet swit:ches may perform further packaging, fragmentation, or
put:baTransmission Cont:rol Protocol
put:baother operation:s to achieve the delivery of the local packet to the
put:badestination int:ernet module.
put:baAt a gateway be:tween networks, the internet datagram is "unwrapped"
put:bafrom its local :packet and examined to determine through which network
put:bathe internet da:tagram should travel next.  The internet datagram is
put:bathen "wrapped" :in a local packet suitable to the next network and
put:barouted to the n:ext gateway, or to the final destination.
put:baA gateway is pe:rmitted to break up an internet datagram into smaller
put:bainternet datagr:am fragments if this is necessary for transmission
put:bathrough the nex:t network.  To do this, the gateway produces a set of
put:bainternet datagr:ams; each carrying a fragment.  Fragments may be
put:bafurther broken :into smaller fragments at subsequent gateways.  The
put:bainternet datagr:am fragment format is designed so that the destination
put:bainternet module: can reassemble fragments into internet datagrams.
put:baA destination i:nternet module unwraps the segment from the datagram
put:ba(after reassemb:ling the datagram, if necessary) and passes it to the
put:badestination TCP:.
put:baThis simple mod:el of the operation glosses over many details.  One
put:baimportant featu:re is the type of service.  This provides information
put:bato the gateway :(or internet module) to guide it in selecting the
put:baservice paramet:ers to be used in traversing the next network.
put:baIncluded in the: type of service information is the precedence of the
put:badatagram.  Data:grams may also carry security information to permit
put:bahost and gatewa:ys that operate in multilevel secure environments to
put:baproperly segreg:ate datagrams for security considerations.
put:ba2.3.  The Host En:vironment
put:baThe TCP is assu:med to be a module in an operating system.  The users
put:baaccess the TCP :much like they would access the file system.  The TCP
put:bamay call on oth:er operating system functions, for example, to manage
put:badata structures:.  The actual interface to the network is assumed to be
put:bacontrolled by a: device driver module.  The TCP does not call on the
put:banetwork device :driver directly, but rather calls on the internet
put:badatagram protoc:ol module which may in turn call on the device driver.
put:baThe mechanisms :of TCP do not preclude implementation of the TCP in a
put:bafront-end proce:ssor.  However, in such an implementation, a
put:bahost-to-front-e:nd protocol must provide the functionality to support
put:bathe type of TCP:-user interface described in this document.
put:ba[Page 8]         :                                                       
put:baSeptember 1981   :                                                       
put:baThe TCP/user in:terface provides for calls made by the user on the TCP
put:bato OPEN or CLOS:E a connection, to SEND or RECEIVE data, or to obtain
put:baSTATUS about a :connection.  These calls are like other calls from user
put:baprograms on the: operating system, for example, the calls to open, read
put:bafrom, and close: a file.
put:baThe TCP/interne:t interface provides calls to send and receive
put:badatagrams addre:ssed to TCP modules in hosts anywhere in the internet
put:basystem.  These :calls have parameters for passing the address, type of
put:baservice, preced:ence, security, and other control information.
put:ba2.5.  Relation to: Other Protocols
put:baThe following d:iagram illustrates the place of the TCP in the protocol
put:bahierarchy:
put:ba+------+ +:-----+ +-----+       +-----+                    
put:ba|Telnet| |: FTP | |Voice|  ...  |     |  Application Level 
put:ba+------+ +:-----+ +-----+       +-----+                    
put:ba|   :|         |             |                       
put:ba+----:-+     +-----+       +-----+                    
put:ba| TCP: |     | RTP |  ...  |     |  Host Level        
put:ba+----:-+     +-----+       +-----+                    
put:ba| :          |             |                       
put:ba+----:---------------------------+                    
put:ba|    :Internet Protocol & ICMP   |  Gateway Level     
put:ba+----:---------------------------+                    
put:ba+--:-------------------------+                      
put:ba|  : Local Network Protocol  |    Network Level     
put:ba+--:-------------------------+                      
put:baIt is expected :that the TCP will be able to support higher level
put:baprotocols effic:iently.  It should be easy to interface higher level
put:baprotocols like :the ARPANET Telnet or AUTODIN II THP to the TCP.
put:ba2.6.  Reliable Co:mmunication
put:baA stream of dat:a sent on a TCP connection is delivered reliably and in
put:baorder at the de:stination.
put:baTransmission Cont:rol Protocol
put:baTransmission is: made reliable via the use of sequence numbers and
put:baacknowledgments:.  Conceptually, each octet of data is assigned a
put:basequence number:.  The sequence number of the first octet of data in a
put:basegment is tran:smitted with that segment and is called the segment
put:basequence number:.  Segments also carry an acknowledgment number which
put:bais the sequence: number of the next expected data octet of
put:batransmissions i:n the reverse direction.  When the TCP transmits a
put:basegment contain:ing data, it puts a copy on a retransmission queue and
put:bastarts a timer;: when the acknowledgment for that data is received, the
put:basegment is dele:ted from the queue.  If the acknowledgment is not
put:bareceived before: the timer runs out, the segment is retransmitted.
put:baAn acknowledgme:nt by TCP does not guarantee that the data has been
put:badelivered to th:e end user, but only that the receiving TCP has taken
put:bathe responsibil:ity to do so.
put:baTo govern the f:low of data between TCPs, a flow control mechanism is
put:baemployed.  The :receiving TCP reports a "window" to the sending TCP.
put:baThis window spe:cifies the number of octets, starting with the
put:baacknowledgment :number, that the receiving TCP is currently prepared to
put:ba2.7.  Connection :Establishment and Clearing
put:baTo identify the: separate data streams that a TCP may handle, the TCP
put:baprovides a port: identifier.  Since port identifiers are selected
put:baindependently b:y each TCP they might not be unique.  To provide for
put:baunique addresse:s within each TCP, we concatenate an internet address
put:baidentifying the: TCP with a port identifier to create a socket which
put:bawill be unique :throughout all networks connected together.
put:baA connection is: fully specified by the pair of sockets at the ends.  A
put:balocal socket ma:y participate in many connections to different foreign
put:basockets.  A con:nection can be used to carry data in both directions,
put:bathat is, it is :"full duplex".
put:baTCPs are free t:o associate ports with processes however they choose.
put:baHowever, severa:l basic concepts are necessary in any implementation.
put:baThere must be w:ell-known sockets which the TCP associates only with
put:bathe "appropriat:e" processes by some means.  We envision that processes
put:bamay "own" ports:, and that processes can initiate connections only on
put:bathe ports they :own.  (Means for implementing ownership is a local
put:baissue, but we e:nvision a Request Port user command, or a method of
put:bauniquely alloca:ting a group of ports to a given process, e.g., by
put:baassociating the: high order bits of a port name with a given process.)
put:baA connection is: specified in the OPEN call by the local port and
put:baforeign socket :arguments.  In return, the TCP supplies a (short) local
put:ba[Page 10]        :                                                       
put:baSeptember 1981   :                                                       
put:baconnection name: by which the user refers to the connection in
put:basubsequent call:s.  There are several things that must be remembered
put:baabout a connect:ion.  To store this information we imagine that there
put:bais a data struc:ture called a Transmission Control Block (TCB).  One
put:baimplementation :strategy would have the local connection name be a
put:bapointer to the :TCB for this connection.  The OPEN call also specifies
put:bawhether the con:nection establishment is to be actively pursued, or to
put:babe passively wa:ited for.
put:baA passive OPEN :request means that the process wants to accept incoming
put:baconnection requ:ests rather than attempting to initiate a connection.
put:baOften the proce:ss requesting a passive OPEN will accept a connection
put:barequest from an:y caller.  In this case a foreign socket of all zeros
put:bais used to deno:te an unspecified socket.  Unspecified foreign sockets
put:baare allowed onl:y on passive OPENs.
put:baA service proce:ss that wished to provide services for unknown other
put:baprocesses would: issue a passive OPEN request with an unspecified
put:baforeign socket.:  Then a connection could be made with any process that
put:barequested a con:nection to this local socket.  It would help if this
put:balocal socket we:re known to be associated with this service.
put:baWell-known sock:ets are a convenient mechanism for a priori associating
put:baa socket addres:s with a standard service.  For instance, the
put:ba"Telnet-Server": process is permanently assigned to a particular
put:basocket, and oth:er sockets are reserved for File Transfer, Remote Job
put:baEntry, Text Gen:erator, Echoer, and Sink processes (the last three
put:babeing for test :purposes).  A socket address might be reserved for
put:baaccess to a "Lo:ok-Up" service which would return the specific socket
put:baat which a newl:y created service would be provided.  The concept of a
put:bawell-known sock:et is part of the TCP specification, but the assignment
put:baof sockets to s:ervices is outside this specification.  (See [4].)
put:baProcesses can i:ssue passive OPENs and wait for matching active OPENs
put:bafrom other proc:esses and be informed by the TCP when connections have
put:babeen establishe:d.  Two processes which issue active OPENs to each
put:baother at the sa:me time will be correctly connected.  This flexibility
put:bais critical for: the support of distributed computing in which
put:bacomponents act :asynchronously with respect to each other.
put:baThere are two p:rincipal cases for matching the sockets in the local
put:bapassive OPENs a:nd an foreign active OPENs.  In the first case, the
put:balocal passive O:PENs has fully specified the foreign socket.  In this
put:bacase, the match: must be exact.  In the second case, the local passive
put:baOPENs has left :the foreign socket unspecified.  In this case, any
put:baforeign socket :is acceptable as long as the local sockets match.
put:baOther possibili:ties include partially restricted matches.
put:baTransmission Cont:rol Protocol
put:baIf there are se:veral pending passive OPENs (recorded in TCBs) with the
put:basame local sock:et, an foreign active OPEN will be matched to a TCB
put:bawith the specif:ic foreign socket in the foreign active OPEN, if such a
put:baTCB exists, bef:ore selecting a TCB with an unspecified foreign socket.
put:baThe procedures :to establish connections utilize the synchronize (SYN)
put:bacontrol flag an:d involves an exchange of three messages.  This
put:baexchange has be:en termed a three-way hand shake [3].
put:baA connection is: initiated by the rendezvous of an arriving segment
put:bacontaining a SY:N and a waiting TCB entry each created by a user OPEN
put:bacommand.  The m:atching of local and foreign sockets determines when a
put:baconnection has :been initiated.  The connection becomes "established"
put:bawhen sequence n:umbers have been synchronized in both directions.
put:baThe clearing of: a connection also involves the exchange of segments,
put:bain this case ca:rrying the FIN control flag.
put:ba2.8.  Data Commun:ication
put:baThe data that f:lows on a connection may be thought of as a stream of
put:baoctets.  The se:nding user indicates in each SEND call whether the data
put:bain that call (a:nd any preceeding calls) should be immediately pushed
put:bathrough to the :receiving user by the setting of the PUSH flag.
put:baA sending TCP i:s allowed to collect data from the sending user and to
put:basend that data :in segments at its own convenience, until the push
put:bafunction is sig:naled, then it must send all unsent data.  When a
put:bareceiving TCP s:ees the PUSH flag, it must not wait for more data from
put:bathe sending TCP: before passing the data to the receiving process.
put:baThere is no nec:essary relationship between push functions and segment
put:baboundaries.  Th:e data in any particular segment may be the result of a
put:basingle SEND cal:l, in whole or part, or of multiple SEND calls.
put:baThe purpose of :push function and the PUSH flag is to push data through
put:bafrom the sendin:g user to the receiving user.  It does not provide a
put:barecord service.:
put:baThere is a coup:ling between the push function and the use of buffers
put:baof data that cr:oss the TCP/user interface.  Each time a PUSH flag is
put:baassociated with: data placed into the receiving user's buffer, the
put:babuffer is retur:ned to the user for processing even if the buffer is
put:banot filled.  If: data arrives that fills the user's buffer before a
put:baPUSH is seen, t:he data is passed to the user in buffer size units.
put:baTCP also provid:es a means to communicate to the receiver of data that
put:baat some point f:urther along in the data stream than the receiver is
put:ba[Page 12]        :                                                       
put:baSeptember 1981   :                                                       
put:bacurrently readi:ng there is urgent data.  TCP does not attempt to
put:badefine what the: user specifically does upon being notified of pending
put:baurgent data, bu:t the general notion is that the receiving process will
put:batake action to :process the urgent data quickly.
put:ba2.9.  Precedence :and Security
put:baThe TCP makes u:se of the internet protocol type of service field and
put:basecurity option: to provide precedence and security on a per connection
put:babasis to TCP us:ers.  Not all TCP modules will necessarily function in
put:baa multilevel se:cure environment; some may be limited to unclassified
put:bause only, and o:thers may operate at only one security level and
put:bacompartment.  C:onsequently, some TCP implementations and services to
put:bausers may be li:mited to a subset of the multilevel secure case.
put:baTCP modules whi:ch operate in a multilevel secure environment must
put:baproperly mark o:utgoing segments with the security, compartment, and
put:baprecedence.  Su:ch TCP modules must also provide to their users or
put:bahigher level pr:otocols such as Telnet or THP an interface to allow
put:bathem to specify: the desired security level, compartment, and
put:baprecedence of c:onnections.
put:ba2.10.  Robustness: Principle
put:baTCP implementat:ions will follow a general principle of robustness:  be
put:baconservative in: what you do, be liberal in what you accept from
put:baTransmission Cont:rol Protocol
put:ba[Page 14]        :                                                       
put:baSeptember 1981   :                                                       
put:ba3.1.  Header Form:at
put:baTCP segments ar:e sent as internet datagrams.  The Internet Protocol
put:baheader carries :several information fields, including the source and
put:badestination hos:t addresses [2].  A TCP header follows the internet
put:baheader, supplyi:ng information specific to the TCP protocol.  This
put:badivision allows: for the existence of host level protocols other than
put:baTCP Header Form:at
put:ba0            :       1                   2                   3   
put:ba0 1 2 3 4 5 6: 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 
put:ba+-+-+-+-+-+-+-:+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
put:ba|          Sou:rce Port          |       Destination Port        |
put:ba+-+-+-+-+-+-+-:+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
put:ba|             :           Sequence Number                        |
put:ba+-+-+-+-+-+-+-:+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
put:ba|             :       Acknowledgment Number                      |
put:ba+-+-+-+-+-+-+-:+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
put:ba|  Data |     :      |U|A|P|R|S|F|                               |
put:ba| Offset| Rese:rved  |R|C|S|S|Y|I|            Window             |
put:ba|       |     :      |G|K|H|T|N|N|                               |
put:ba+-+-+-+-+-+-+-:+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
put:ba|           Ch:ecksum            |         Urgent Pointer        |
put:ba+-+-+-+-+-+-+-:+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
put:ba|             :       Options                    |    Padding    |
put:ba+-+-+-+-+-+-+-:+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
put:ba|             :                data                              |
put:ba+-+-+-+-+-+-+-:+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
put:baNote th:at one tick mark represents one bit position.
put:baSource Port:  1:6 bits
put:baThe source po:rt number.
put:baDestination Por:t:  16 bits
put:baThe destinati:on port number.
put:baTransmission Cont:rol Protocol
put:baFunctional Specif:ication
put:baSequence Number::  32 bits
put:baThe sequence :number of the first data octet in this segment (except
put:bawhen SYN is p:resent). If SYN is present the sequence number is the
put:bainitial seque:nce number (ISN) and the first data octet is ISN+1.
put:baAcknowledgment :Number:  32 bits
put:baIf the ACK co:ntrol bit is set this field contains the value of the
put:banext sequence: number the sender of the segment is expecting to
put:bareceive.  Onc:e a connection is established this is always sent.
put:baData Offset:  4: bits
put:baThe number of: 32 bit words in the TCP Header.  This indicates where
put:bathe data begi:ns.  The TCP header (even one including options) is an
put:baintegral numb:er of 32 bits long.
put:baReserved:  6 bi:ts
put:baReserved for :future use.  Must be zero.
put:baControl Bits:  :6 bits (from left to right):
put:baURG:  Urgent :Pointer field significant
put:baACK:  Acknowl:edgment field significant
put:baPSH:  Push Fu:nction
put:baRST:  Reset t:he connection
put:baSYN:  Synchro:nize sequence numbers
put:baFIN:  No more: data from sender
put:baWindow:  16 bit:s
put:baThe number of: data octets beginning with the one indicated in the
put:baacknowledgmen:t field which the sender of this segment is willing to
put:baChecksum:  16 b:its
put:baThe checksum :field is the 16 bit one's complement of the one's
put:bacomplement su:m of all 16 bit words in the header and text.  If a
put:basegment conta:ins an odd number of header and text octets to be
put:bachecksummed, :the last octet is padded on the right with zeros to
put:baform a 16 bit: word for checksum purposes.  The pad is not
put:batransmitted a:s part of the segment.  While computing the checksum,
put:bathe checksum :field itself is replaced with zeros.
put:baThe checksum :also covers a 96 bit pseudo header conceptually
put:ba[Page 16]        :                                                       
put:baSeptember 1981   :                                                       
put:baprefixed to t:he TCP header.  This pseudo header contains the Source
put:baAddress, the :Destination Address, the Protocol, and TCP length.
put:baThis gives th:e TCP protection against misrouted segments.  This
put:bainformation i:s carried in the Internet Protocol and is transferred
put:baacross the TC:P/Network interface in the arguments or results of
put:bacalls by the :TCP on the IP.
put:baThe TCP Len:gth is the TCP header length plus the data length in
put:baoctets (thi:s is not an explicitly transmitted quantity, but is
put:bacomputed), :and it does not count the 12 octets of the pseudo
put:baUrgent Pointer::  16 bits
put:baThis field co:mmunicates the current value of the urgent pointer as a
put:bapositive offs:et from the sequence number in this segment.  The
put:baurgent pointe:r points to the sequence number of the octet following
put:bathe urgent da:ta.  This field is only be interpreted in segments with
put:bathe URG contr:ol bit set.
put:baOptions:  varia:ble
put:baOptions may o:ccupy space at the end of the TCP header and are a
put:bamultiple of 8: bits in length.  All options are included in the
put:bachecksum.  An: option may begin on any octet boundary.  There are two
put:bacases for the: format of an option:
put:baCase 1:  A :single octet of option-kind.
put:baCase 2:  An: octet of option-kind, an octet of option-length, and
put:bath:e actual option-data octets.
put:baThe option-le:ngth counts the two octets of option-kind and
put:baoption-length: as well as the option-data octets.
put:baNote that the: list of options may be shorter than the data offset
put:bafield might i:mply.  The content of the header beyond the
put:baEnd-of-Option: option must be header padding (i.e., zero).
put:baA TCP must im:plement all options.
put:baTransmission Cont:rol Protocol
put:baFunctional Specif:ication
put:baCurrently def:ined options include (kind indicated in octal):
put:baKind     Le:ngth    Meaning
put:ba----     --:----    -------
put:ba0         :-       End of option list.
put:ba1         :-       No-Operation.
put:ba2         :4       Maximum Segment Size.
put:baSpecific Opti:on Definitions
put:baEnd of Opti:on List
put:ba+--------:+
put:ba|00000000:|
put:ba+--------:+
put:baThis opti:on code indicates the end of the option list.  This
put:bamight not: coincide with the end of the TCP header according to
put:bathe Data :Offset field.  This is used at the end of all options,
put:banot the e:nd of each option, and need only be used if the end of
put:bathe optio:ns would not otherwise coincide with the end of the TCP
put:baNo-Operatio:n
put:ba+--------:+
put:ba|00000001:|
put:ba+--------:+
put:baThis opti:on code may be used between options, for example, to
put:baalign the: beginning of a subsequent option on a word boundary.
put:baThere is :no guarantee that senders will use this option, so
put:bareceivers: must be prepared to process options even if they do
put:banot begin: on a word boundary.
put:baMaximum Seg:ment Size
put:ba+--------:+--------+---------+--------+
put:ba|00000010:|00000100|   max seg size   |
put:ba+--------:+--------+---------+--------+
put:baKind=2  : Length=4
put:ba[Page 18]        :                                                       
put:baSeptember 1981   :                                                       
put:baMaximum S:egment Size Option Data:  16 bits
put:baIf this: option is present, then it communicates the maximum
put:bareceive: segment size at the TCP which sends this segment.
put:baThis fi:eld must only be sent in the initial connection request
put:ba(i.e., :in segments with the SYN control bit set).  If this
put:baoption :is not used, any segment size is allowed.
put:baPadding:  varia:ble
put:baThe TCP heade:r padding is used to ensure that the TCP header ends
put:baand data begi:ns on a 32 bit boundary.  The padding is composed of
put:ba3.2.  Terminology:
put:baBefore we can d:iscuss very much about the operation of the TCP we need
put:bato introduce so:me detailed terminology.  The maintenance of a TCP
put:baconnection requ:ires the remembering of several variables.  We conceive
put:baof these variab:les being stored in a connection record called a
put:baTransmission Co:ntrol Block or TCB.  Among the variables stored in the
put:baTCB are the loc:al and remote socket numbers, the security and
put:baprecedence of t:he connection, pointers to the user's send and receive
put:babuffers, pointe:rs to the retransmit queue and to the current segment.
put:baIn addition sev:eral variables relating to the send and receive
put:basequence number:s are stored in the TCB.
put:baSend Sequence: Variables
put:baSND.UNA - s:end unacknowledged
put:baSND.NXT - s:end next
put:baSND.WND - s:end window
put:baSND.UP  - s:end urgent pointer
put:baSND.WL1 - s:egment sequence number used for last window update
put:baSND.WL2 - s:egment acknowledgment number used for last window
put:bau:pdate
put:baISS     - i:nitial send sequence number
put:baReceive Seque:nce Variables
put:baRCV.NXT - r:eceive next
put:baRCV.WND - r:eceive window
put:baRCV.UP  - r:eceive urgent pointer
put:baIRS     - i:nitial receive sequence number
put:baTransmission Cont:rol Protocol
put:baFunctional Specif:ication
put:baThe following d:iagrams may help to relate some of these variables to
put:bathe sequence sp:ace.
put:baSend Sequence S:pace
put:ba---:-------|----------|----------|---------- 
put:ba1 - old s:equence numbers which have been acknowledged  
put:ba2 - seque:nce numbers of unacknowledged data            
put:ba3 - seque:nce numbers allowed for new data transmission 
put:ba4 - futur:e sequence numbers which are not yet allowed  
put:baThe send window: is the portion of the sequence space labeled 3 in
put:baReceive Sequenc:e Space
put:ba1 - old s:equence numbers which have been acknowledged  
put:ba2 - seque:nce numbers allowed for new reception         
put:ba3 - futur:e sequence numbers which are not yet allowed  
put:baThe receive win:dow is the portion of the sequence space labeled 2 in
put:baThere are also :some variables used frequently in the discussion that
put:batake their valu:es from the fields of the current segment.
put:ba[Page 20]        :                                                       
put:baSeptember 1981   :                                                       
put:baCurrent Segme:nt Variables
put:baSEG.SEQ - s:egment sequence number
put:baSEG.ACK - s:egment acknowledgment number
put:baSEG.LEN - s:egment length
put:baSEG.WND - s:egment window
put:baSEG.UP  - s:egment urgent pointer
put:baSEG.PRC - s:egment precedence value
put:baA connection pr:ogresses through a series of states during its
put:balifetime.  The :states are:  LISTEN, SYN-SENT, SYN-RECEIVED,
put:baESTABLISHED, FI:N-WAIT-1, FIN-WAIT-2, CLOSE-WAIT, CLOSING, LAST-ACK,
put:baTIME-WAIT, and :the fictional state CLOSED.  CLOSED is fictional
put:babecause it repr:esents the state when there is no TCB, and therefore,
put:bano connection. : Briefly the meanings of the states are:
put:baLISTEN - repr:esents waiting for a connection request from any remote
put:baTCP and port.:
put:baSYN-SENT - re:presents waiting for a matching connection request
put:baafter having :sent a connection request.
put:baSYN-RECEIVED :- represents waiting for a confirming connection
put:barequest ackno:wledgment after having both received and sent a
put:baconnection re:quest.
put:baESTABLISHED -: represents an open connection, data received can be
put:badelivered to :the user.  The normal state for the data transfer phase
put:baof the connec:tion.
put:baFIN-WAIT-1 - :represents waiting for a connection termination request
put:bafrom the remo:te TCP, or an acknowledgment of the connection
put:batermination r:equest previously sent.
put:baFIN-WAIT-2 - :represents waiting for a connection termination request
put:bafrom the remo:te TCP.
put:baCLOSE-WAIT - :represents waiting for a connection termination request
put:bafrom the loca:l user.
put:baCLOSING - rep:resents waiting for a connection termination request
put:baacknowledgmen:t from the remote TCP.
put:baLAST-ACK - re:presents waiting for an acknowledgment of the
put:baconnection te:rmination request previously sent to the remote TCP
put:ba(which includ:es an acknowledgment of its connection termination
put:baTransmission Cont:rol Protocol
put:baFunctional Specif:ication
put:baTIME-WAIT - r:epresents waiting for enough time to pass to be sure
put:bathe remote TC:P received the acknowledgment of its connection
put:batermination r:equest.
put:baCLOSED - repr:esents no connection state at all.
put:baA TCP connectio:n progresses from one state to another in response to
put:baevents.  The ev:ents are the user calls, OPEN, SEND, RECEIVE, CLOSE,
put:baABORT, and STAT:US; the incoming segments, particularly those
put:bacontaining the :SYN, ACK, RST and FIN flags; and timeouts.
put:baThe state diagr:am in figure 6 illustrates only state changes, together
put:bawith the causin:g events and resulting actions, but addresses neither
put:baerror condition:s nor actions which are not connected with state
put:bachanges.  In a :later section, more detail is offered with respect to
put:bathe reaction of: the TCP to events.
put:baNOTE BENE:  thi:s diagram is only a summary and must not be taken as
put:bathe total speci:fication.
put:ba[Page 22]        :                                                       
put:baSeptember 1981   :                                                       
put:ba+---------+     : snd SYN,ACK  /       \   snd SYN          +---------+
put:ba|         |<----:-------------           ------------------>|         |
put:ba|   SYN   |     :               rcv SYN                     |   SYN   |
put:ba|   RCVD  |<----:-------------------------------------------|   SENT  |
put:ba|         |     :               snd ACK                     |         |
put:ba|         |-----:-------------           -------------------|         |
put:ba+---------+   rc:v ACK of SYN  \       /  rcv SYN,ACK       +---------+
put:ba|           --:------------   |     |   -----------                  
put:ba|             :     x         |     |     snd ACK                    
put:ba|             :               V     V                                
put:ba|  CLOSE      :             +---------+                              
put:ba| -------     :             |  ESTAB  |                              
put:ba| snd FIN     :             +---------+                              
put:ba|             :      CLOSE    |     |    rcv FIN                     
put:baV             :     -------   |     |    -------                     
put:ba+---------+     :     snd FIN  /       \   snd ACK          +---------+
put:ba|  FIN    |<----:-------------           ------------------>|  CLOSE  |
put:ba| WAIT-1  |-----:-------------                              |   WAIT  |
put:ba+---------+     :     rcv FIN  \                            +---------+
put:ba| rcv ACK of F:IN   -------   |                            CLOSE  |  
put:ba| ------------:--   snd ACK   |                           ------- |  
put:baV        x    :               V                           snd FIN V  
put:ba+---------+     :             +---------+                   +---------+
put:ba|FINWAIT-2|     :             | CLOSING |                   | LAST-ACK|
put:ba+---------+     :             +---------+                   +---------+
put:ba|             :   rcv ACK of FIN |                 rcv ACK of FIN |  
put:ba|  rcv FIN    :   -------------- |    Timeout=2MSL -------------- |  
put:ba|  -------    :          x       V    ------------        x       V  
put:ba\ snd ACK    :             +---------+delete TCB         +---------+
put:ba------------:------------>|TIME WAIT|------------------>| CLOSED  |
put:baTransmission Cont:rol Protocol
put:baFunctional Specif:ication
put:ba3.3.  Sequence Nu:mbers
put:baA fundamental n:otion in the design is that every octet of data sent
put:baover a TCP conn:ection has a sequence number.  Since every octet is
put:basequenced, each: of them can be acknowledged.  The acknowledgment
put:bamechanism emplo:yed is cumulative so that an acknowledgment of sequence
put:banumber X indica:tes that all octets up to but not including X have been
put:bareceived.  This: mechanism allows for straight-forward duplicate
put:badetection in th:e presence of retransmission.  Numbering of octets
put:bawithin a segmen:t is that the first data octet immediately following
put:bathe header is t:he lowest numbered, and the following octets are
put:banumbered consec:utively.
put:baIt is essential: to remember that the actual sequence number space is
put:bafinite, though :very large.  This space ranges from 0 to 2**32 - 1.
put:baSince the space: is finite, all arithmetic dealing with sequence
put:banumbers must be: performed modulo 2**32.  This unsigned arithmetic
put:bapreserves the r:elationship of sequence numbers as they cycle from
put:ba2**32 - 1 to 0 :again.  There are some subtleties to computer modulo
put:baarithmetic, so :great care should be taken in programming the
put:bacomparison of s:uch values.  The symbol "=<" means "less than or equal"
put:ba(modulo 2**32).:
put:baThe typical kin:ds of sequence number comparisons which the TCP must
put:baperform include::
put:ba(a)  Determin:ing that an acknowledgment refers to some sequence
put:banumber s:ent but not yet acknowledged.
put:ba(b)  Determin:ing that all sequence numbers occupied by a segment
put:bahave bee:n acknowledged (e.g., to remove the segment from a
put:baretransm:ission queue).
put:ba(c)  Determin:ing that an incoming segment contains sequence numbers
put:bawhich ar:e expected (i.e., that the segment "overlaps" the
put:bareceive :window).
put:ba[Page 24]        :                                                       
put:baSeptember 1981   :                                                       
put:baIn response to :sending data the TCP will receive acknowledgments.  The
put:bafollowing compa:risons are needed to process the acknowledgments.
put:baSND.UNA = old:est unacknowledged sequence number
put:baSND.NXT = nex:t sequence number to be sent
put:baSEG.ACK = ack:nowledgment from the receiving TCP (next sequence
put:banum:ber expected by the receiving TCP)
put:baSEG.SEQ = fir:st sequence number of a segment
put:baSEG.LEN = the: number of octets occupied by the data in the segment
put:ba(co:unting SYN and FIN)
put:baSEG.SEQ+SEG.L:EN-1 = last sequence number of a segment
put:baA new acknowled:gment (called an "acceptable ack"), is one for which
put:bathe inequality :below holds:
put:baSND.UNA < SEG:.ACK =< SND.NXT
put:baA segment on th:e retransmission queue is fully acknowledged if the sum
put:baof its sequence: number and length is less or equal than the
put:baacknowledgment :value in the incoming segment.
put:baWhen data is re:ceived the following comparisons are needed:
put:baRCV.NXT = nex:t sequence number expected on an incoming segments, and
put:bais the le:ft or lower edge of the receive window
put:baRCV.NXT+RCV.W:ND-1 = last sequence number expected on an incoming
put:basegment, :and is the right or upper edge of the receive window
put:baSEG.SEQ = fir:st sequence number occupied by the incoming segment
put:baSEG.SEQ+SEG.L:EN-1 = last sequence number occupied by the incoming
put:baA segment is ju:dged to occupy a portion of valid receive sequence
put:baRCV.NXT =< SE:G.SEQ < RCV.NXT+RCV.WND
put:baRCV.NXT =< SE:G.SEQ+SEG.LEN-1 < RCV.NXT+RCV.WND
put:baTransmission Cont:rol Protocol
put:baFunctional Specif:ication
put:baThe first part :of this test checks to see if the beginning of the
put:basegment falls i:n the window, the second part of the test checks to see
put:baif the end of t:he segment falls in the window; if the segment passes
put:baeither part of :the test it contains data in the window.
put:baActually, it is: a little more complicated than this.  Due to zero
put:bawindows and zer:o length segments, we have four cases for the
put:baacceptability o:f an incoming segment:
put:baSegment Recei:ve  Test
put:baLength  Windo:w
put:ba------- -----:--  -------------------------------------------
put:ba0       0 :    SEG.SEQ = RCV.NXT
put:ba0      >0 :    RCV.NXT =< SEG.SEQ < RCV.NXT+RCV.WND
put:ba>0       0 :    not acceptable
put:ba>0      >0 :    RCV.NXT =< SEG.SEQ < RCV.NXT+RCV.WND
put:baNote that when :the receive window is zero no segments should be
put:baacceptable exce:pt ACK segments.  Thus, it is be possible for a TCP to
put:bamaintain a zero: receive window while transmitting data and receiving
put:baACKs.  However,: even when the receive window is zero, a TCP must
put:baprocess the RST: and URG fields of all incoming segments.
put:baWe have taken a:dvantage of the numbering scheme to protect certain
put:bacontrol informa:tion as well.  This is achieved by implicitly including
put:basome control fl:ags in the sequence space so they can be retransmitted
put:baand acknowledge:d without confusion (i.e., one and only one copy of the
put:bacontrol will be: acted upon).  Control information is not physically
put:bacarried in the :segment data space.  Consequently, we must adopt rules
put:bafor implicitly :assigning sequence numbers to control.  The SYN and FIN
put:baare the only co:ntrols requiring this protection, and these controls
put:baare used only a:t connection opening and closing.  For sequence number
put:bapurposes, the S:YN is considered to occur before the first actual data
put:baoctet of the se:gment in which it occurs, while the FIN is considered
put:bato occur after :the last actual data octet in a segment in which it
put:baoccurs.  The se:gment length (SEG.LEN) includes both data and sequence
put:baspace occupying: controls.  When a SYN is present then SEG.SEQ is the
put:basequence number: of the SYN.
put:ba[Page 26]        :                                                       
put:baSeptember 1981   :                                                       
put:baInitial Sequenc:e Number Selection
put:baThe protocol pl:aces no restriction on a particular connection being
put:baused over and o:ver again.  A connection is defined by a pair of
put:basockets.  New i:nstances of a connection will be referred to as
put:baincarnations of: the connection.  The problem that arises from this is
put:ba-- "how does th:e TCP identify duplicate segments from previous
put:baincarnations of: the connection?"  This problem becomes apparent if the
put:baconnection is b:eing opened and closed in quick succession, or if the
put:baconnection brea:ks with loss of memory and is then reestablished.
put:baTo avoid confus:ion we must prevent segments from one incarnation of a
put:baconnection from: being used while the same sequence numbers may still
put:babe present in t:he network from an earlier incarnation.  We want to
put:baassure this, ev:en if a TCP crashes and loses all knowledge of the
put:basequence number:s it has been using.  When new connections are created,
put:baan initial sequ:ence number (ISN) generator is employed which selects a
put:banew 32 bit ISN.:  The generator is bound to a (possibly fictitious) 32
put:babit clock whose: low order bit is incremented roughly every 4
put:bamicroseconds.  :Thus, the ISN cycles approximately every 4.55 hours.
put:baSince we assume: that segments will stay in the network no more than
put:bathe Maximum Seg:ment Lifetime (MSL) and that the MSL is less than 4.55
put:bahours we can re:asonably assume that ISN's will be unique.
put:baFor each connec:tion there is a send sequence number and a receive
put:basequence number:.  The initial send sequence number (ISS) is chosen by
put:bathe data sendin:g TCP, and the initial receive sequence number (IRS) is
put:balearned during :the connection establishing procedure.
put:baFor a connectio:n to be established or initialized, the two TCPs must
put:basynchronize on :each other's initial sequence numbers.  This is done in
put:baan exchange of :connection establishing segments carrying a control bit
put:bacalled "SYN" (f:or synchronize) and the initial sequence numbers.  As a
put:bashorthand, segm:ents carrying the SYN bit are also called "SYNs".
put:baHence, the solu:tion requires a suitable mechanism for picking an
put:bainitial sequenc:e number and a slightly involved handshake to exchange
put:baThe synchroniza:tion requires each side to send it's own initial
put:basequence number: and to receive a confirmation of it in acknowledgment
put:bafrom the other :side.  Each side must also receive the other side's
put:bainitial sequenc:e number and send a confirming acknowledgment.
put:ba1) A --> B  S:YN my sequence number is X
put:ba2) A <-- B  A:CK your sequence number is X
put:ba3) A <-- B  S:YN my sequence number is Y
put:ba4) A --> B  A:CK your sequence number is Y
put:baTransmission Cont:rol Protocol
put:baFunctional Specif:ication
put:baBecause steps 2: and 3 can be combined in a single message this is
put:bacalled the thre:e way (or three message) handshake.
put:baA three way han:dshake is necessary because sequence numbers are not
put:batied to a globa:l clock in the network, and TCPs may have different
put:bamechanisms for :picking the ISN's.  The receiver of the first SYN has
put:bano way of knowi:ng whether the segment was an old delayed one or not,
put:baunless it remem:bers the last sequence number used on the connection
put:ba(which is not a:lways possible), and so it must ask the sender to
put:baverify this SYN:.  The three way handshake and the advantages of a
put:baclock-driven sc:heme are discussed in [3].
put:baKnowing When to: Keep Quiet
put:baTo be sure that: a TCP does not create a segment that carries a
put:basequence number: which may be duplicated by an old segment remaining in
put:bathe network, th:e TCP must keep quiet for a maximum segment lifetime
put:ba(MSL) before as:signing any sequence numbers upon starting up or
put:barecovering from: a crash in which memory of sequence numbers in use was
put:balost.  For this: specification the MSL is taken to be 2 minutes.  This
put:bais an engineeri:ng choice, and may be changed if experience indicates
put:bait is desirable: to do so.  Note that if a TCP is reinitialized in some
put:basense, yet reta:ins its memory of sequence numbers in use, then it need
put:banot wait at all:; it must only be sure to use sequence numbers larger
put:bathan those rece:ntly used.
put:baThe TCP Quiet T:ime Concept
put:baThis specific:ation provides that hosts which "crash" without
put:baretaining any: knowledge of the last sequence numbers transmitted on
put:baeach active (:i.e., not closed) connection shall delay emitting any
put:baTCP segments :for at least the agreed Maximum Segment Lifetime (MSL)
put:bain the intern:et system of which the host is a part.  In the
put:baparagraphs be:low, an explanation for this specification is given.
put:baTCP implement:ors may violate the "quiet time" restriction, but only
put:baat the risk o:f causing some old data to be accepted as new or new
put:badata rejected: as old duplicated by some receivers in the internet
put:baTCPs consume :sequence number space each time a segment is formed and
put:baentered into :the network output queue at a source host. The
put:baduplicate det:ection and sequencing algorithm in the TCP protocol
put:barelies on the: unique binding of segment data to sequence space to
put:bathe extent th:at sequence numbers will not cycle through all 2**32
put:bavalues before: the segment data bound to those sequence numbers has
put:babeen delivere:d and acknowledged by the receiver and all duplicate
put:bacopies of the: segments have "drained" from the internet.  Without
put:basuch an assum:ption, two distinct TCP segments could conceivably be
put:ba[Page 28]        :                                                       
put:baSeptember 1981   :                                                       
put:baassigned the :same or overlapping sequence numbers, causing confusion
put:baat the receiv:er as to which data is new and which is old.  Remember
put:bathat each seg:ment is bound to as many consecutive sequence numbers
put:baas there are :octets of data in the segment.
put:baUnder normal :conditions, TCPs keep track of the next sequence number
put:bato emit and t:he oldest awaiting acknowledgment so as to avoid
put:bamistakenly us:ing a sequence number over before its first use has
put:babeen acknowle:dged.  This alone does not guarantee that old duplicate
put:badata is drain:ed from the net, so the sequence space has been made
put:bavery large to: reduce the probability that a wandering duplicate will
put:bacause trouble: upon arrival.  At 2 megabits/sec. it takes 4.5 hours
put:bato use up 2**:32 octets of sequence space.  Since the maximum segment
put:balifetime in t:he net is not likely to exceed a few tens of seconds,
put:bathis is deeme:d ample protection for foreseeable nets, even if data
put:barates escalat:e to l0's of megabits/sec.  At 100 megabits/sec, the
put:bacycle time is: 5.4 minutes which may be a little short, but still
put:bawithin reason:.
put:baThe basic dup:licate detection and sequencing algorithm in TCP can be
put:badefeated, how:ever, if a source TCP does not have any memory of the
put:basequence numb:ers it last used on a given connection. For example, if
put:bathe TCP were :to start all connections with sequence number 0, then
put:baupon crashing: and restarting, a TCP might re-form an earlier
put:baconnection (p:ossibly after half-open connection resolution) and emit
put:bapackets with :sequence numbers identical to or overlapping with
put:bapackets still: in the network which were emitted on an earlier
put:baincarnation o:f the same connection.  In the absence of knowledge
put:baabout the seq:uence numbers used on a particular connection, the TCP
put:baspecification: recommends that the source delay for MSL seconds
put:babefore emitti:ng segments on the connection, to allow time for
put:basegments from: the earlier connection incarnation to drain from the
put:baEven hosts wh:ich can remember the time of day and used it to select
put:bainitial seque:nce number values are not immune from this problem
put:ba(i.e., even i:f time of day is used to select an initial sequence
put:banumber for ea:ch new connection incarnation).
put:baSuppose, for :example, that a connection is opened starting with
put:basequence numb:er S.  Suppose that this connection is not used much
put:baand that even:tually the initial sequence number function (ISN(t))
put:batakes on a va:lue equal to the sequence number, say S1, of the last
put:basegment sent :by this TCP on a particular connection.  Now suppose,
put:baat this insta:nt, the host crashes, recovers, and establishes a new
put:baincarnation o:f the connection. The initial sequence number chosen is
put:baS1 = ISN(t) -:- last used sequence number on old incarnation of
put:baconnection!  :If the recovery occurs quickly enough, any old
put:baTransmission Cont:rol Protocol
put:baFunctional Specif:ication
put:baduplicates in: the net bearing sequence numbers in the neighborhood
put:baof S1 may arr:ive and be treated as new packets by the receiver of
put:bathe new incar:nation of the connection.
put:baThe problem i:s that the recovering host may not know for how long it
put:bacrashed nor d:oes it know whether there are still old duplicates in
put:bathe system fr:om earlier connection incarnations.
put:baOne way to de:al with this problem is to deliberately delay emitting
put:basegments for :one MSL after recovery from a crash- this is the "quite
put:batime" specifi:cation.  Hosts which prefer to avoid waiting are
put:bawilling to ri:sk possible confusion of old and new packets at a given
put:badestination m:ay choose not to wait for the "quite time".
put:baImplementors :may provide TCP users with the ability to select on a
put:baconnection by: connection basis whether to wait after a crash, or may
put:bainformally im:plement the "quite time" for all connections.
put:baObviously, ev:en where a user selects to "wait," this is not
put:banecessary aft:er the host has been "up" for at least MSL seconds.
put:baTo summarize:: every segment emitted occupies one or more sequence
put:banumbers in th:e sequence space, the numbers occupied by a segment are
put:ba"busy" or "in: use" until MSL seconds have passed, upon crashing a
put:bablock of spac:e-time is occupied by the octets of the last emitted
put:basegment, if a: new connection is started too soon and uses any of the
put:basequence numb:ers in the space-time footprint of the last segment of
put:bathe previous :connection incarnation, there is a potential sequence
put:banumber overla:p area which could cause confusion at the receiver.
put:ba3.4.  Establishin:g a connection
put:baThe "three-way :handshake" is the procedure used to establish a
put:baconnection.  Th:is procedure normally is initiated by one TCP and
put:baresponded to by: another TCP.  The procedure also works if two TCP
put:basimultaneously :initiate the procedure.  When simultaneous attempt
put:baoccurs, each TC:P receives a "SYN" segment which carries no
put:baacknowledgment :after it has sent a "SYN".  Of course, the arrival of
put:baan old duplicat:e "SYN" segment can potentially make it appear, to the
put:barecipient, that: a simultaneous connection initiation is in progress.
put:baProper use of ":reset" segments can disambiguate these cases.
put:baSeveral example:s of connection initiation follow.  Although these
put:baexamples do not: show connection synchronization using data-carrying
put:basegments, this :is perfectly legitimate, so long as the receiving TCP
put:badoesn't deliver: the data to the user until it is clear the data is
put:bavalid (i.e., th:e data must be buffered at the receiver until the
put:baconnection reac:hes the ESTABLISHED state).  The three-way handshake
put:bareduces the pos:sibility of false connections.  It is the
put:ba[Page 30]        :                                                       
put:baSeptember 1981   :                                                       
put:baimplementation :of a trade-off between memory and messages to provide
put:bainformation for: this checking.
put:baThe simplest th:ree-way handshake is shown in figure 7 below.  The
put:bafigures should :be interpreted in the following way.  Each line is
put:banumbered for re:ference purposes.  Right arrows (-->) indicate
put:badeparture of a :TCP segment from TCP A to TCP B, or arrival of a
put:basegment at B fr:om A.  Left arrows (<--), indicate the reverse.
put:baEllipsis (...) :indicates a segment which is still in the network
put:ba(delayed).  An :"XXX" indicates a segment which is lost or rejected.
put:baComments appear: in parentheses.  TCP states represent the state AFTER
put:bathe departure o:r arrival of the segment (whose contents are shown in
put:bathe center of e:ach line).  Segment contents are shown in abbreviated
put:baform, with sequ:ence number, control flags, and ACK field.  Other
put:bafields such as :window, addresses, lengths, and text have been left out
put:bain the interest: of clarity.
put:baTCP A      :                                          TCP B
put:ba1.  CLOSED     :                                          LISTEN
put:ba2.  SYN-SENT   : --> <SEQ=100><CTL=SYN>               --> SYN-RECEIVED
put:ba3.  ESTABLISHED: <-- <SEQ=300><ACK=101><CTL=SYN,ACK>  <-- SYN-RECEIVED
put:ba4.  ESTABLISHED: --> <SEQ=101><ACK=301><CTL=ACK>       --> ESTABLISHED
put:ba5.  ESTABLISHED: --> <SEQ=101><ACK=301><CTL=ACK><DATA> --> ESTABLISHED
put:baBasic 3:-Way Handshake for Connection Synchronization
put:baIn line 2 of fi:gure 7, TCP A begins by sending a SYN segment
put:baindicating that: it will use sequence numbers starting with sequence
put:banumber 100.  In: line 3, TCP B sends a SYN and acknowledges the SYN it
put:bareceived from T:CP A.  Note that the acknowledgment field indicates TCP
put:baB is now expect:ing to hear sequence 101, acknowledging the SYN which
put:baoccupied sequen:ce 100.
put:baAt line 4, TCP :A responds with an empty segment containing an ACK for
put:baTCP B's SYN; an:d in line 5, TCP A sends some data.  Note that the
put:basequence number: of the segment in line 5 is the same as in line 4
put:babecause the ACK: does not occupy sequence number space (if it did, we
put:bawould wind up A:CKing ACK's!).
put:baTransmission Cont:rol Protocol
put:baFunctional Specif:ication
put:baSimultaneous in:itiation is only slightly more complex, as is shown in
put:bafigure 8.  Each: TCP cycles from CLOSED to SYN-SENT to SYN-RECEIVED to
put:baTCP A      :                                      TCP B
put:ba1.  CLOSED     :                                      CLOSED
put:ba2.  SYN-SENT   :  --> <SEQ=100><CTL=SYN>              ...
put:ba3.  SYN-RECEIVE:D <-- <SEQ=300><CTL=SYN>              <-- SYN-SENT
put:ba4.             :  ... <SEQ=100><CTL=SYN>              --> SYN-RECEIVED
put:ba5.  SYN-RECEIVE:D --> <SEQ=100><ACK=301><CTL=SYN,ACK> ...
put:ba6.  ESTABLISHED:  <-- <SEQ=300><ACK=101><CTL=SYN,ACK> <-- SYN-RECEIVED
put:ba7.             :  ... <SEQ=101><ACK=301><CTL=ACK>     --> ESTABLISHED
put:baS:imultaneous Connection Synchronization
put:baThe principle r:eason for the three-way handshake is to prevent old
put:baduplicate conne:ction initiations from causing confusion.  To deal with
put:bathis, a special: control message, reset, has been devised.  If the
put:bareceiving TCP i:s in a  non-synchronized state (i.e., SYN-SENT,
put:baSYN-RECEIVED), :it returns to LISTEN on receiving an acceptable reset.
put:baIf the TCP is i:n one of the synchronized states (ESTABLISHED,
put:baFIN-WAIT-1, FIN:-WAIT-2, CLOSE-WAIT, CLOSING, LAST-ACK, TIME-WAIT), it
put:baaborts the conn:ection and informs its user.  We discuss this latter
put:bacase under "hal:f-open" connections below.
put:ba[Page 32]        :                                                       
put:baSeptember 1981   :                                                       
put:baTCP A      :                                          TCP B
put:ba1.  CLOSED     :                                          LISTEN
put:ba2.  SYN-SENT   : --> <SEQ=100><CTL=SYN>               ...
put:ba3.  (duplicate): ... <SEQ=90><CTL=SYN>               --> SYN-RECEIVED
put:ba4.  SYN-SENT   : <-- <SEQ=300><ACK=91><CTL=SYN,ACK>  <-- SYN-RECEIVED
put:ba5.  SYN-SENT   : --> <SEQ=91><CTL=RST>               --> LISTEN
put:ba6.             : ... <SEQ=100><CTL=SYN>               --> SYN-RECEIVED
put:ba7.  SYN-SENT   : <-- <SEQ=400><ACK=101><CTL=SYN,ACK>  <-- SYN-RECEIVED
put:ba8.  ESTABLISHED: --> <SEQ=101><ACK=401><CTL=ACK>      --> ESTABLISHED
put:baAs a simple exa:mple of recovery from old duplicates, consider
put:bafigure 9.  At l:ine 3, an old duplicate SYN arrives at TCP B.  TCP B
put:bacannot tell tha:t this is an old duplicate, so it responds normally
put:ba(line 4).  TCP :A detects that the ACK field is incorrect and returns a
put:baRST (reset) wit:h its SEQ field selected to make the segment
put:babelievable.  TC:P B, on receiving the RST, returns to the LISTEN state.
put:baWhen the origin:al SYN (pun intended) finally arrives at line 6, the
put:basynchronization: proceeds normally.  If the SYN at line 6 had arrived
put:babefore the RST,: a more complex exchange might have occurred with RST's
put:basent in both di:rections.
put:baHalf-Open Conne:ctions and Other Anomalies
put:baAn established :connection is said to be  "half-open" if one of the
put:baTCPs has closed: or aborted the connection at its end without the
put:baknowledge of th:e other, or if the two ends of the connection have
put:babecome desynchr:onized owing to a crash that resulted in loss of
put:bamemory.  Such c:onnections will automatically become reset if an
put:baattempt is made: to send data in either direction.  However, half-open
put:baconnections are: expected to be unusual, and the recovery procedure is
put:bamildly involved:.
put:baIf at site A th:e connection no longer exists, then an attempt by the
put:baTransmission Cont:rol Protocol
put:baFunctional Specif:ication
put:bauser at site B :to send any data on it will result in the site B TCP
put:bareceiving a res:et control message.  Such a message indicates to the
put:basite B TCP that: something is wrong, and it is expected to abort the
put:baAssume that two: user processes A and B are communicating with one
put:baanother when a :crash occurs causing loss of memory to A's TCP.
put:baDepending on th:e operating system supporting A's TCP, it is likely
put:bathat some error: recovery mechanism exists.  When the TCP is up again,
put:baA is likely to :start again from the beginning or from a recovery
put:bapoint.  As a re:sult, A will probably try to OPEN the connection again
put:baor try to SEND :on the connection it believes open.  In the latter
put:bacase, it receiv:es the error message "connection not open" from the
put:balocal (A's) TCP:.  In an attempt to establish the connection, A's TCP
put:bawill send a seg:ment containing SYN.  This scenario leads to the
put:baexample shown i:n figure 10.  After TCP A crashes, the user attempts to
put:bare-open the con:nection.  TCP B, in the meantime, thinks the connection
put:baTCP A      :                                     TCP B
put:ba1.  (CRASH)    :                           (send 300,receive 100)
put:ba2.  CLOSED     :                                      ESTABLISHED
put:ba3.  SYN-SENT --:> <SEQ=400><CTL=SYN>              --> (??)
put:ba4.  (!!)     <-:- <SEQ=300><ACK=100><CTL=ACK>     <-- ESTABLISHED
put:ba5.  SYN-SENT --:> <SEQ=100><CTL=RST>              --> (Abort!!)
put:ba6.  SYN-SENT   :                                      CLOSED
put:ba7.  SYN-SENT --:> <SEQ=400><CTL=SYN>              -->
put:baWhen the SYN ar:rives at line 3, TCP B, being in a synchronized state,
put:baand the incomin:g segment outside the window, responds with an
put:baacknowledgment :indicating what sequence it next expects to hear (ACK
put:ba100).  TCP A se:es that this segment does not acknowledge anything it
put:basent and, being: unsynchronized, sends a reset (RST) because it has
put:badetected a half:-open connection.  TCP B aborts at line 5.  TCP A will
put:ba[Page 34]        :                                                       
put:baSeptember 1981   :                                                       
put:bacontinue to try: to establish the connection; the problem is now
put:bareduced to the :basic 3-way handshake of figure 7.
put:baAn interesting :alternative case occurs when TCP A crashes and TCP B
put:batries to send d:ata on what it thinks is a synchronized connection.
put:baThis is illustr:ated in figure 11.  In this case, the data arriving at
put:baTCP A from TCP :B (line 2) is unacceptable because no such connection
put:baexists, so TCP :A sends a RST.  The RST is acceptable so TCP B
put:baprocesses it an:d aborts the connection.
put:baTCP A    :                                          TCP B
put:ba1.  (CRASH)    :                               (send 300,receive 100)
put:ba2.  (??)    <--: <SEQ=300><ACK=100><DATA=10><CTL=ACK> <-- ESTABLISHED
put:ba3.          -->: <SEQ=100><CTL=RST>                   --> (ABORT!!)
put:baActive: Side Causes Half-Open Connection Discovery
put:baIn figure 12, w:e find the two TCPs A and B with passive connections
put:bawaiting for SYN:.  An old duplicate arriving at TCP B (line 2) stirs B
put:bainto action.  A: SYN-ACK is returned (line 3) and causes TCP A to
put:bagenerate a RST :(the ACK in line 3 is not acceptable).  TCP B accepts
put:bathe reset and r:eturns to its passive LISTEN state.
put:baTCP A      :                                   TCP B
put:ba1.  LISTEN     :                                   LISTEN
put:ba2.       ... <S:EQ=Z><CTL=SYN>                -->  SYN-RECEIVED
put:ba3.  (??) <-- <S:EQ=X><ACK=Z+1><CTL=SYN,ACK>   <--  SYN-RECEIVED
put:ba4.       --> <S:EQ=Z+1><CTL=RST>              -->  (return to LISTEN!)
put:ba5.  LISTEN     :                                   LISTEN
put:baOld Duplic:ate SYN Initiates a Reset on two Passive Sockets
put:baTransmission Cont:rol Protocol
put:baFunctional Specif:ication
put:baA variety of ot:her cases are possible, all of which are accounted for
put:baby the followin:g rules for RST generation and processing.
put:baReset Generatio:n
put:baAs a general ru:le, reset (RST) must be sent whenever a segment arrives
put:bawhich apparentl:y is not intended for the current connection.  A reset
put:bamust not be sen:t if it is not clear that this is the case.
put:baThere are three: groups of states:
put:ba1.  If the co:nnection does not exist (CLOSED) then a reset is sent
put:bain response t:o any incoming segment except another reset.  In
put:baparticular, S:YNs addressed to a non-existent connection are rejected
put:baby this means:.
put:baIf the incomi:ng segment has an ACK field, the reset takes its
put:basequence numb:er from the ACK field of the segment, otherwise the
put:bareset has seq:uence number zero and the ACK field is set to the sum
put:baof the sequen:ce number and segment length of the incoming segment.
put:baThe connectio:n remains in the CLOSED state.
put:ba2.  If the co:nnection is in any non-synchronized state (LISTEN,
put:baSYN-SENT, SYN:-RECEIVED), and the incoming segment acknowledges
put:basomething not: yet sent (the segment carries an unacceptable ACK), or
put:baif an incomin:g segment has a security level or compartment which
put:badoes not exac:tly match the level and compartment requested for the
put:baconnection, a: reset is sent.
put:baIf our SYN ha:s not been acknowledged and the precedence level of the
put:baincoming segm:ent is higher than the precedence level requested then
put:baeither raise :the local precedence level (if allowed by the user and
put:bathe system) o:r send a reset; or if the precedence level of the
put:baincoming segm:ent is lower than the precedence level requested then
put:bacontinue as i:f the precedence matched exactly (if the remote TCP
put:bacannot raise :the precedence level to match ours this will be
put:badetected in t:he next segment it sends, and the connection will be
put:baterminated th:en).  If our SYN has been acknowledged (perhaps in this
put:baincoming segm:ent) the precedence level of the incoming segment must
put:bamatch the loc:al precedence level exactly, if it does not a reset
put:bamust be sent.:
put:baIf the incomi:ng segment has an ACK field, the reset takes its
put:basequence numb:er from the ACK field of the segment, otherwise the
put:bareset has seq:uence number zero and the ACK field is set to the sum
put:baof the sequen:ce number and segment length of the incoming segment.
put:baThe connectio:n remains in the same state.
put:ba[Page 36]        :                                                       
put:baSeptember 1981   :                                                       
put:ba3.  If the co:nnection is in a synchronized state (ESTABLISHED,
put:baFIN-WAIT-1, F:IN-WAIT-2, CLOSE-WAIT, CLOSING, LAST-ACK, TIME-WAIT),
put:baany unaccepta:ble segment (out of window sequence number or
put:baunacceptible :acknowledgment number) must elicit only an empty
put:baacknowledgmen:t segment containing the current send-sequence number
put:baand an acknow:ledgment indicating the next sequence number expected
put:bato be receive:d, and the connection remains in the same state.
put:baIf an incomin:g segment has a security level, or compartment, or
put:baprecedence wh:ich does not exactly match the level, and compartment,
put:baand precedenc:e requested for the connection,a reset is sent and
put:baconnection go:es to the CLOSED state.  The reset takes its sequence
put:banumber from t:he ACK field of the incoming segment.
put:baReset Processin:g
put:baIn all states e:xcept SYN-SENT, all reset (RST) segments are validated
put:baby checking the:ir SEQ-fields.  A reset is valid if its sequence number
put:bais in the windo:w.  In the SYN-SENT state (a RST received in response
put:bato an initial S:YN), the RST is acceptable if the ACK field
put:baacknowledges th:e SYN.
put:baThe receiver of: a RST first validates it, then changes state.  If the
put:bareceiver was in: the LISTEN state, it ignores it.  If the receiver was
put:bain SYN-RECEIVED: state and had previously been in the LISTEN state,
put:bathen the receiv:er returns to the LISTEN state, otherwise the receiver
put:baaborts the conn:ection and goes to the CLOSED state.  If the receiver
put:bawas in any othe:r state, it aborts the connection and advises the user
put:baand goes to the: CLOSED state.
put:ba3.5.  Closing a C:onnection
put:baCLOSE is an ope:ration meaning "I have no more data to send."  The
put:banotion of closi:ng a full-duplex connection is subject to ambiguous
put:bainterpretation,: of course, since it may not be obvious how to treat
put:bathe receiving s:ide of the connection.  We have chosen to treat CLOSE
put:bain a simplex fa:shion.  The user who CLOSEs may continue to RECEIVE
put:bauntil he is tol:d that the other side has CLOSED also.  Thus, a program
put:bacould initiate :several SENDs followed by a CLOSE, and then continue to
put:baRECEIVE until s:ignaled that a RECEIVE failed because the other side
put:bahas CLOSED.  We: assume that the TCP will signal a user, even if no
put:baRECEIVEs are ou:tstanding, that the other side has closed, so the user
put:bacan terminate h:is side gracefully.  A TCP will reliably deliver all
put:babuffers SENT be:fore the connection was CLOSED so a user who expects no
put:badata in return :need only wait to hear the connection was CLOSED
put:basuccessfully to: know that all his data was received at the destination
put:baTCP.  Users mus:t keep reading connections they close for sending until
put:bathe TCP says no: more data.
put:baTransmission Cont:rol Protocol
put:baFunctional Specif:ication
put:baThere are essen:tially three cases:
put:ba1) The user i:nitiates by telling the TCP to CLOSE the connection
put:ba2) The remote: TCP initiates by sending a FIN control signal
put:ba3) Both users: CLOSE simultaneously
put:baCase 1:  Local :user initiates the close
put:baIn this case,: a FIN segment can be constructed and placed on the
put:baoutgoing segm:ent queue.  No further SENDs from the user will be
put:baaccepted by t:he TCP, and it enters the FIN-WAIT-1 state.  RECEIVEs
put:baare allowed i:n this state.  All segments preceding and including FIN
put:bawill be retra:nsmitted until acknowledged.  When the other TCP has
put:baboth acknowle:dged the FIN and sent a FIN of its own, the first TCP
put:bacan ACK this :FIN.  Note that a TCP receiving a FIN will ACK but not
put:basend its own :FIN until its user has CLOSED the connection also.
put:baCase 2:  TCP re:ceives a FIN from the network
put:baIf an unsolic:ited FIN arrives from the network, the receiving TCP
put:bacan ACK it an:d tell the user that the connection is closing.  The
put:bauser will res:pond with a CLOSE, upon which the TCP can send a FIN to
put:bathe other TCP: after sending any remaining data.  The TCP then waits
put:bauntil its own: FIN is acknowledged whereupon it deletes the
put:baconnection.  :If an ACK is not forthcoming, after the user timeout
put:bathe connectio:n is aborted and the user is told.
put:baCase 3:  both u:sers close simultaneously
put:baA simultaneou:s CLOSE by users at both ends of a connection causes
put:baFIN segments :to be exchanged.  When all segments preceding the FINs
put:bahave been pro:cessed and acknowledged, each TCP can ACK the FIN it
put:bahas received.:  Both will, upon receiving these ACKs, delete the
put:ba[Page 38]        :                                                       
put:baSeptember 1981   :                                                       
put:baTCP A      :                                          TCP B
put:ba1.  ESTABLISHED:                                          ESTABLISHED
put:baFIN-WAIT-1 : --> <SEQ=100><ACK=300><CTL=FIN,ACK>  --> CLOSE-WAIT
put:ba3.  FIN-WAIT-2 : <-- <SEQ=300><ACK=101><CTL=ACK>      <-- CLOSE-WAIT
put:ba4.             :                                          (Close)
put:baTIME-WAIT  : <-- <SEQ=300><ACK=101><CTL=FIN,ACK>  <-- LAST-ACK
put:ba5.  TIME-WAIT  : --> <SEQ=101><ACK=301><CTL=ACK>      --> CLOSED
put:baCLOSED     :                                                 
put:baTCP A      :                                          TCP B
put:ba1.  ESTABLISHED:                                          ESTABLISHED
put:ba2.  (Close)    :                                          (Close)
put:baFIN-WAIT-1 : --> <SEQ=100><ACK=300><CTL=FIN,ACK>  ... FIN-WAIT-1
put:ba3.  CLOSING    : --> <SEQ=101><ACK=301><CTL=ACK>      ... CLOSING
put:ba4.  TIME-WAIT  :                                          TIME-WAIT
put:ba(2 MSL)    :                                          (2 MSL)
put:baCLOSED     :                                          CLOSED
put:baTransmission Cont:rol Protocol
put:baFunctional Specif:ication
put:ba3.6.  Precedence :and Security
put:baThe intent is t:hat connection be allowed only between ports operating
put:bawith exactly th:e same security and compartment values and at the
put:bahigher of the p:recedence level requested by the two ports.
put:baThe precedence :and security parameters used in TCP are exactly those
put:badefined in the :Internet Protocol (IP) [2].  Throughout this TCP
put:baspecification t:he term "security/compartment" is intended to indicate
put:bathe security pa:rameters used in IP including security, compartment,
put:bauser group, and: handling restriction.
put:baA connection at:tempt with mismatched security/compartment values or a
put:balower precedenc:e value must be rejected by sending a reset.  Rejecting
put:baa connection du:e to too low a precedence only occurs after an
put:baacknowledgment :of the SYN has been received.
put:baNote that TCP m:odules which operate only at the default value of
put:baprecedence will: still have to check the precedence of incoming
put:basegments and po:ssibly raise the precedence level they use on the
put:baThe security pa:ramaters may be used even in a non-secure environment
put:ba(the values wou:ld indicate unclassified data), thus hosts in
put:banon-secure envi:ronments must be prepared to receive the security
put:baparameters, tho:ugh they need not send them.
put:ba3.7.  Data Commun:ication
put:baOnce the connec:tion is established data is communicated by the
put:baexchange of seg:ments.  Because segments may be lost due to errors
put:ba(checksum test :failure), or network congestion, TCP uses
put:baretransmission :(after a timeout) to ensure delivery of every segment.
put:baDuplicate segme:nts may arrive due to network or TCP retransmission.
put:baAs discussed in: the section on sequence numbers the TCP performs
put:bacertain tests o:n the sequence and acknowledgment numbers in the
put:basegments to ver:ify their acceptability.
put:baThe sender of d:ata keeps track of the next sequence number to use in
put:bathe variable SN:D.NXT.  The receiver of data keeps track of the next
put:basequence number: to expect in the variable RCV.NXT.  The sender of data
put:bakeeps track of :the oldest unacknowledged sequence number in the
put:bavariable SND.UN:A.  If the data flow is momentarily idle and all data
put:basent has been a:cknowledged then the three variables will be equal.
put:baWhen the sender: creates a segment and transmits it the sender advances
put:baSND.NXT.  When :the receiver accepts a segment it advances RCV.NXT and
put:basends an acknow:ledgment.  When the data sender receives an
put:ba[Page 40]        :                                                       
put:baSeptember 1981   :                                                       
put:baacknowledgment :it advances SND.UNA.  The extent to which the values of
put:bathese variables: differ is a measure of the delay in the communication.
put:baThe amount by w:hich the variables are advanced is the length of the
put:badata in the seg:ment.  Note that once in the ESTABLISHED state all
put:basegments must c:arry current acknowledgment information.
put:baThe CLOSE user :call implies a push function, as does the FIN control
put:baflag in an inco:ming segment.
put:baRetransmission :Timeout
put:baBecause of the :variability of the networks that compose an
put:bainternetwork sy:stem and the wide range of uses of TCP connections the
put:baretransmission :timeout must be dynamically determined.  One procedure
put:bafor determining: a retransmission time out is given here as an
put:baAn Example Re:transmission Timeout Procedure
put:baMeasure the: elapsed time between sending a data octet with a
put:baparticular :sequence number and receiving an acknowledgment that
put:bacovers that: sequence number (segments sent do not have to match
put:basegments re:ceived).  This measured elapsed time is the Round Trip
put:baTime (RTT).:  Next compute a Smoothed Round Trip Time (SRTT) as:
put:baSRTT = ( :ALPHA * SRTT ) + ((1-ALPHA) * RTT)
put:baand based o:n this, compute the retransmission timeout (RTO) as:
put:baRTO = min:[UBOUND,max[LBOUND,(BETA*SRTT)]]
put:bawhere UBOUN:D is an upper bound on the timeout (e.g., 1 minute),
put:baLBOUND is a: lower bound on the timeout (e.g., 1 second), ALPHA is
put:baa smoothing: factor (e.g., .8 to .9), and BETA is a delay variance
put:bafactor (e.g:., 1.3 to 2.0).
put:baThe Communicati:on of Urgent Information
put:baThe objective o:f the TCP urgent mechanism is to allow the sending user
put:bato stimulate th:e receiving user to accept some urgent data and to
put:bapermit the rece:iving TCP to indicate to the receiving user when all
put:bathe currently k:nown urgent data has been received by the user.
put:baThis mechanism :permits a point in the data stream to be designated as
put:bathe end of urge:nt information.  Whenever this point is in advance of
put:bathe receive seq:uence number (RCV.NXT) at the receiving TCP, that TCP
put:bamust tell the u:ser to go into "urgent mode"; when the receive sequence
put:banumber catches :up to the urgent pointer, the TCP must tell user to go
put:baTransmission Cont:rol Protocol
put:baFunctional Specif:ication
put:bainto "normal mo:de".  If the urgent pointer is updated while the user
put:bais in "urgent m:ode", the update will be invisible to the user.
put:baThe method empl:oys a urgent field which is carried in all segments
put:batransmitted.  T:he URG control flag indicates that the urgent field is
put:bameaningful and :must be added to the segment sequence number to yield
put:bathe urgent poin:ter.  The absence of this flag indicates that there is
put:bano urgent data :outstanding.
put:baTo send an urge:nt indication the user must also send at least one data
put:baoctet.  If the :sending user also indicates a push, timely delivery of
put:bathe urgent info:rmation to the destination process is enhanced.
put:baManaging the Wi:ndow
put:baThe window sent: in each segment indicates the range of sequence
put:banumbers the sen:der of the window (the data receiver) is currently
put:baprepared to acc:ept.  There is an assumption that this is related to
put:bathe currently a:vailable data buffer space available for this
put:baIndicating a la:rge window encourages transmissions.  If more data
put:baarrives than ca:n be accepted, it will be discarded.  This will result
put:bain excessive re:transmissions, adding unnecessarily to the load on the
put:banetwork and the: TCPs.  Indicating a small window may restrict the
put:batransmission of: data to the point of introducing a round trip delay
put:babetween each ne:w segment transmitted.
put:baThe mechanisms :provided allow a TCP to advertise a large window and to
put:basubsequently ad:vertise a much smaller window without having accepted
put:bathat much data.:  This, so called "shrinking the window," is strongly
put:badiscouraged.  T:he robustness principle dictates that TCPs will not
put:bashrink the wind:ow themselves, but will be prepared for such behavior
put:baon the part of :other TCPs.
put:baThe sending TCP: must be prepared to accept from the user and send at
put:baleast one octet: of new data even if the send window is zero.  The
put:basending TCP mus:t regularly retransmit to the receiving TCP even when
put:bathe window is z:ero.  Two minutes is recommended for the retransmission
put:bainterval when t:he window is zero.  This retransmission is essential to
put:baguarantee that :when either TCP has a zero window the re-opening of the
put:bawindow will be :reliably reported to the other.
put:baWhen the receiv:ing TCP has a zero window and a segment arrives it must
put:bastill send an a:cknowledgment showing its next expected sequence number
put:baand current win:dow (zero).
put:baThe sending TCP: packages the data to be transmitted into segments
put:ba[Page 42]        :                                                       
put:baSeptember 1981   :                                                       
put:bawhich fit the c:urrent window, and may repackage segments on the
put:baretransmission :queue.  Such repackaging is not required, but may be
put:baIn a connection: with a one-way data flow, the window information will
put:babe carried in a:cknowledgment segments that all have the same sequence
put:banumber so there: will be no way to reorder them if they arrive out of
put:baorder.  This is: not a serious problem, but it will allow the window
put:bainformation to :be on occasion temporarily based on old reports from
put:bathe data receiv:er.  A refinement to avoid this problem is to act on
put:bathe window info:rmation from segments that carry the highest
put:baacknowledgment :number (that is segments with acknowledgment number
put:baequal or greate:r than the highest previously received).
put:baThe window mana:gement procedure has significant influence on the
put:bacommunication p:erformance.  The following comments are suggestions to
put:baWindow Manage:ment Suggestions
put:baAllocating :a very small window causes data to be transmitted in
put:bamany small :segments when better performance is achieved using
put:bafewer large: segments.
put:baOne suggest:ion for avoiding small windows is for the receiver to
put:badefer updat:ing a window until the additional allocation is at
put:baleast X per:cent of the maximum allocation possible for the
put:baconnection :(where X might be 20 to 40).
put:baAnother sug:gestion is for the sender to avoid sending small
put:basegments by: waiting until the window is large enough before
put:basending dat:a.  If the the user signals a push function then the
put:badata must b:e sent even if it is a small segment.
put:baNote that t:he acknowledgments should not be delayed or unnecessary
put:baretransmiss:ions will result.  One strategy would be to send an
put:baacknowledgm:ent when a small segment arrives (with out updating the
put:bawindow info:rmation), and then to send another acknowledgment with
put:banew window :information when the window is larger.
put:baThe segment: sent to probe a zero window may also begin a break up
put:baof transmit:ted data into smaller and smaller segments.  If a
put:basegment con:taining a single data octet sent to probe a zero window
put:bais accepted:, it consumes one octet of the window now available.
put:baIf the send:ing TCP simply sends as much as it can whenever the
put:bawindow is n:on zero, the transmitted data will be broken into
put:baalternating: big and small segments.  As time goes on, occasional
put:bapauses in t:he receiver making window allocation available will
put:baTransmission Cont:rol Protocol
put:baFunctional Specif:ication
put:baresult in b:reaking the big segments into a small and not quite so
put:babig pair. A:nd after a while the data transmission will be in
put:bamostly smal:l segments.
put:baThe suggest:ion here is that the TCP implementations need to
put:baactively at:tempt to combine small window allocations into larger
put:bawindows, si:nce the mechanisms for managing the window tend to lead
put:bato many sma:ll windows in the simplest minded implementations.
put:baThere are of co:urse two interfaces of concern:  the user/TCP interface
put:baand the TCP/low:er-level interface.  We have a fairly elaborate model
put:baof the user/TCP: interface, but the interface to the lower level
put:baprotocol module: is left unspecified here, since it will be specified
put:bain detail by th:e specification of the lowel level protocol.  For the
put:bacase that the l:ower level is IP we note some of the parameter values
put:bathat TCPs might: use.
put:baUser/TCP Interf:ace
put:baThe following: functional description of user commands to the TCP is,
put:baat best, fict:ional, since every operating system will have different
put:bafacilities.  :Consequently, we must warn readers that different TCP
put:baimplementatio:ns may have different user interfaces.  However, all
put:baTCPs must pro:vide a certain minimum set of services to guarantee
put:bathat all TCP :implementations can support the same protocol
put:bahierarchy.  T:his section specifies the functional interfaces
put:barequired of a:ll TCP implementations.
put:baTCP User Comm:ands
put:baThe followi:ng sections functionally characterize a USER/TCP
put:bainterface. : The notation used is similar to most procedure or
put:bafunction ca:lls in high level languages, but this usage is not
put:bameant to ru:le out trap type service calls (e.g., SVCs, UUOs,
put:baThe user co:mmands described below specify the basic functions the
put:baTCP must pe:rform to support interprocess communication.
put:baIndividual :implementations must define their own exact format, and
put:bamay provide: combinations or subsets of the basic functions in
put:basingle call:s.  In particular, some implementations may wish to
put:baautomatical:ly OPEN a connection on the first SEND or RECEIVE
put:baissued by t:he user for a given connection.
put:ba[Page 44]        :                                                       
put:baSeptember 1981   :                                                       
put:baIn providin:g interprocess communication facilities, the TCP must
put:banot only ac:cept commands, but must also return information to the
put:baprocesses i:t serves.  The latter consists of:
put:ba(a) gener:al information about a connection (e.g., interrupts,
put:baremote cl:ose, binding of unspecified foreign socket).
put:ba(b) repli:es to specific user commands indicating success or
put:bavarious t:ypes of failure.
put:baFormat:  :OPEN (local port, foreign socket, active/passive
put:ba[, timeou:t] [, precedence] [, security/compartment] [, options])
put:ba-> local :connection name
put:baWe assume: that the local TCP is aware of the identity of the
put:baprocesses: it serves and will check the authority of the process
put:bato use th:e connection specified.  Depending upon the
put:baimplement:ation of the TCP, the local network and TCP identifiers
put:bafor the s:ource address will either be supplied by the TCP or the
put:balower lev:el protocol (e.g., IP).  These considerations are the
put:baresult of: concern about security, to the extent that no TCP be
put:baable to m:asquerade as another one, and so on.  Similarly, no
put:baprocess c:an masquerade as another without the collusion of the
put:baIf the ac:tive/passive flag is set to passive, then this is a
put:bacall to L:ISTEN for an incoming connection.  A passive open may
put:bahave eith:er a fully specified foreign socket to wait for a
put:baparticula:r connection or an unspecified foreign socket to wait
put:bafor any c:all.  A fully specified passive call can be made active
put:baby the su:bsequent execution of a SEND.
put:baA transmi:ssion control block (TCB) is created and partially
put:bafilled in: with data from the OPEN command parameters.
put:baOn an act:ive OPEN command, the TCP will begin the procedure to
put:basynchroni:ze (i.e., establish) the connection at once.
put:baThe timeo:ut, if present, permits the caller to set up a timeout
put:bafor all d:ata submitted to TCP.  If data is not successfully
put:badelivered: to the destination within the timeout period, the TCP
put:bawill abor:t the connection.  The present global default is five
put:baThe TCP o:r some component of the operating system will verify
put:bathe users: authority to open a connection with the specified
put:baTransmission Cont:rol Protocol
put:baFunctional Specif:ication
put:baprecedenc:e or security/compartment.  The absence of precedence
put:baor securi:ty/compartment specification in the OPEN call indicates
put:bathe defau:lt values must be used.
put:baTCP will :accept incoming requests as matching only if the
put:basecurity/:compartment information is exactly the same and only if
put:bathe prece:dence is equal to or higher than the precedence
put:barequested: in the OPEN call.
put:baThe prece:dence for the connection is the higher of the values
put:barequested: in the OPEN call and received from the incoming
put:barequest, :and fixed at that value for the life of the
put:baconnectio:n.Implementers may want to give the user control of
put:bathis prec:edence negotiation.  For example, the user might be
put:baallowed t:o specify that the precedence must be exactly matched,
put:baor that a:ny attempt to raise the precedence be confirmed by the
put:baA local c:onnection name will be returned to the user by the TCP.
put:baThe local: connection name can then be used as a short hand term
put:bafor the c:onnection defined by the <local socket, foreign socket>
put:baFormat:  :SEND (local connection name, buffer address, byte
put:bacount, PU:SH flag, URGENT flag [,timeout])
put:baThis call: causes the data contained in the indicated user buffer
put:bato be sen:t on the indicated connection.  If the connection has
put:banot been :opened, the SEND is considered an error.  Some
put:baimplement:ations may allow users to SEND first; in which case, an
put:baautomatic: OPEN would be done.  If the calling process is not
put:baauthorize:d to use this connection, an error is returned.
put:baIf the PU:SH flag is set, the data must be transmitted promptly
put:bato the re:ceiver, and the PUSH bit will be set in the last TCP
put:basegment c:reated from the buffer.  If the PUSH flag is not set,
put:bathe data :may be combined with data from subsequent SENDs for
put:batransmiss:ion efficiency.
put:baIf the UR:GENT flag is set, segments sent to the destination TCP
put:bawill have: the urgent pointer set.  The receiving TCP will signal
put:bathe urgen:t condition to the receiving process if the urgent
put:bapointer i:ndicates that data preceding the urgent pointer has not
put:babeen cons:umed by the receiving process.  The purpose of urgent
put:bais to sti:mulate the receiver to process the urgent data and to
put:baindicate :to the receiver when all the currently known urgent
put:ba[Page 46]        :                                                       
put:baSeptember 1981   :                                                       
put:badata has :been received.  The number of times the sending user's
put:baTCP signa:ls urgent will not necessarily be equal to the number
put:baof times :the receiving user will be notified of the presence of
put:baurgent da:ta.
put:baIf no for:eign socket was specified in the OPEN, but the
put:baconnectio:n is established (e.g., because a LISTENing connection
put:bahas becom:e specific due to a foreign segment arriving for the
put:balocal soc:ket), then the designated buffer is sent to the implied
put:baforeign s:ocket.  Users who make use of OPEN with an unspecified
put:baforeign s:ocket can make use of SEND without ever explicitly
put:baknowing t:he foreign socket address.
put:baHowever, :if a SEND is attempted before the foreign socket
put:babecomes s:pecified, an error will be returned.  Users can use the
put:baSTATUS ca:ll to determine the status of the connection.  In some
put:baimplement:ations the TCP may notify the user when an unspecified
put:basocket is: bound.
put:baIf a time:out is specified, the current user timeout for this
put:baconnectio:n is changed to the new one.
put:baIn the si:mplest implementation, SEND would not return control to
put:bathe sendi:ng process until either the transmission was complete
put:baor the ti:meout had been exceeded.  However, this simple method
put:bais both s:ubject to deadlocks (for example, both sides of the
put:baconnectio:n might try to do SENDs before doing any RECEIVEs) and
put:baoffers po:or performance, so it is not recommended.  A more
put:basophistic:ated implementation would return immediately to allow
put:bathe proce:ss to run concurrently with network I/O, and,
put:bafurthermo:re, to allow multiple SENDs to be in progress.
put:baMultiple :SENDs are served in first come, first served order, so
put:bathe TCP w:ill queue those it cannot service immediately.
put:baWe have i:mplicitly assumed an asynchronous user interface in
put:bawhich a S:END later elicits some kind of SIGNAL or
put:bapseudo-in:terrupt from the serving TCP.  An alternative is to
put:bareturn a :response immediately.  For instance, SENDs might return
put:baimmediate: local acknowledgment, even if the segment sent had not
put:babeen ackn:owledged by the distant TCP.  We could optimistically
put:baassume ev:entual success.  If we are wrong, the connection will
put:baclose any:way due to the timeout.  In implementations of this
put:bakind (syn:chronous), there will still be some asynchronous
put:basignals, :but these will deal with the connection itself, and not
put:bawith spec:ific segments or buffers.
put:baIn order :for the process to distinguish among error or success
put:baindicatio:ns for different SENDs, it might be appropriate for the
put:baTransmission Cont:rol Protocol
put:baFunctional Specif:ication
put:babuffer ad:dress to be returned along with the coded response to
put:bathe SEND :request.  TCP-to-user signals are discussed below,
put:baindicatin:g the information which should be returned to the
put:bacalling p:rocess.
put:baFormat:  :RECEIVE (local connection name, buffer address, byte
put:bacount) ->: byte count, urgent flag, push flag
put:baThis comm:and allocates a receiving buffer associated with the
put:baspecified: connection.  If no OPEN precedes this command or the
put:bacalling p:rocess is not authorized to use this connection, an
put:baerror is :returned.
put:baIn the si:mplest implementation, control would not return to the
put:bacalling p:rogram until either the buffer was filled, or some
put:baerror occ:urred, but this scheme is highly subject to deadlocks.
put:baA more so:phisticated implementation would permit several
put:baRECEIVEs :to be outstanding at once.  These would be filled as
put:basegments :arrive.  This strategy permits increased throughput at
put:bathe cost :of a more elaborate scheme (possibly asynchronous) to
put:banotify th:e calling program that a PUSH has been seen or a buffer
put:baIf enough: data arrive to fill the buffer before a PUSH is seen,
put:bathe PUSH :flag will not be set in the response to the RECEIVE.
put:baThe buffe:r will be filled with as much data as it can hold.  If
put:baa PUSH is: seen before the buffer is filled the buffer will be
put:bareturned :partially filled and PUSH indicated.
put:baIf there :is urgent data the user will have been informed as soon
put:baas it arr:ived via a TCP-to-user signal.  The receiving user
put:bashould th:us be in "urgent mode".  If the URGENT flag is on,
put:baadditiona:l urgent data remains.  If the URGENT flag is off, this
put:bacall to R:ECEIVE has returned all the urgent data, and the user
put:bamay now l:eave "urgent mode".  Note that data following the
put:baurgent po:inter (non-urgent data) cannot be delivered to the user
put:bain the sa:me buffer with preceeding urgent data unless the
put:baboundary :is clearly marked for the user.
put:baTo distin:guish among several outstanding RECEIVEs and to take
put:bacare of t:he case that a buffer is not completely filled, the
put:bareturn co:de is accompanied by both a buffer pointer and a byte
put:bacount ind:icating the actual length of the data received.
put:baAlternati:ve implementations of RECEIVE might have the TCP
put:ba[Page 48]        :                                                       
put:baSeptember 1981   :                                                       
put:baallocate :buffer storage, or the TCP might share a ring buffer
put:bawith the :user.
put:baFormat:  :CLOSE (local connection name)
put:baThis comm:and causes the connection specified to be closed.  If
put:bathe conne:ction is not open or the calling process is not
put:baauthorize:d to use this connection, an error is returned.
put:baClosing c:onnections is intended to be a graceful operation in
put:bathe sense: that outstanding SENDs will be transmitted (and
put:baretransmi:tted), as flow control permits, until all have been
put:baserviced.:  Thus, it should be acceptable to make several SEND
put:bacalls, fo:llowed by a CLOSE, and expect all the data to be sent
put:bato the de:stination.  It should also be clear that users should
put:bacontinue :to RECEIVE on CLOSING connections, since the other side
put:bamay be tr:ying to transmit the last of its data.  Thus, CLOSE
put:bameans "I :have no more to send" but does not mean "I will not
put:bareceive a:ny more."  It may happen (if the user level protocol is
put:banot well :thought out) that the closing side is unable to get rid
put:baof all it:s data before timing out.  In this event, CLOSE turns
put:bainto ABOR:T, and the closing TCP gives up.
put:baThe user :may CLOSE the connection at any time on his own
put:bainitiativ:e, or in response to various prompts from the TCP
put:ba(e.g., re:mote close executed, transmission timeout exceeded,
put:badestinati:on inaccessible).
put:baBecause c:losing a connection requires communication with the
put:baforeign T:CP, connections may remain in the closing state for a
put:bashort tim:e.  Attempts to reopen the connection before the TCP
put:bareplies t:o the CLOSE command will result in error responses.
put:baClose als:o implies push function.
put:baFormat:  :STATUS (local connection name) -> status data
put:baThis is a:n implementation dependent user command and could be
put:baexcluded :without adverse effect.  Information returned would
put:batypically: come from the TCB associated with the connection.
put:baThis comm:and returns a data block containing the following
put:bainformati:on:
put:balocal s:ocket,
put:baTransmission Cont:rol Protocol
put:baFunctional Specif:ication
put:baforeign: socket,
put:balocal c:onnection name,
put:bareceive: window,
put:basend wi:ndow,
put:baconnect:ion state,
put:banumber :of buffers awaiting acknowledgment,
put:banumber :of buffers pending receipt,
put:baurgent :state,
put:baprecede:nce,
put:basecurit:y/compartment,
put:baand tra:nsmission timeout.
put:baDepending: on the state of the connection, or on the
put:baimplement:ation itself, some of this information may not be
put:baavailable: or meaningful.  If the calling process is not
put:baauthorize:d to use this connection, an error is returned.  This
put:baprevents :unauthorized processes from gaining information about a
put:baconnectio:n.
put:baFormat:  :ABORT (local connection name)
put:baThis comm:and causes all pending SENDs and RECEIVES to be
put:baaborted, :the TCB to be removed, and a special RESET message to
put:babe sent t:o the TCP on the other side of the connection.
put:baDepending: on the implementation, users may receive abort
put:baindicatio:ns for each outstanding SEND or RECEIVE, or may simply
put:bareceive a:n ABORT-acknowledgment.
put:baTCP-to-User M:essages
put:baIt is assum:ed that the operating system environment provides a
put:bameans for t:he TCP to asynchronously signal the user program.  When
put:bathe TCP doe:s signal a user program, certain information is passed
put:bato the user:.  Often in the specification the information will be
put:baan error me:ssage.  In other cases there will be information
put:barelating to: the completion of processing a SEND or RECEIVE or
put:baother user :call.
put:baThe followi:ng information is provided:
put:baLocal Con:nection Name                    Always
put:baResponse :String                          Always
put:baBuffer Ad:dress                           Send & Receive
put:baByte coun:t (counts bytes received)       Receive
put:baPush flag:                                Receive
put:baUrgent fl:ag                              Receive
put:ba[Page 50]        :                                                       
put:baSeptember 1981   :                                                       
put:baTCP/Lower-Level: Interface
put:baThe TCP calls: on a lower level protocol module to actually send and
put:bareceive infor:mation over a network.  One case is that of the ARPA
put:bainternetwork :system where the lower level module is the Internet
put:baProtocol (IP): [2].
put:baIf the lower :level protocol is IP it provides arguments for a type
put:baof service an:d for a time to live.  TCP uses the following settings
put:bafor these par:ameters:
put:baType of Ser:vice = Precedence: routine, Delay: normal, Throughput:
put:banormal, Rel:iability: normal; or 00000000.
put:baTime to Liv:e    = one minute, or 00111100.
put:baNote that: the assumed maximum segment lifetime is two minutes.
put:baHere we e:xplicitly ask that a segment be destroyed if it cannot
put:babe delive:red by the internet system within one minute.
put:baIf the lower :level is IP (or other protocol that provides this
put:bafeature) and :source routing is used, the interface must allow the
put:baroute informa:tion to be communicated.  This is especially important
put:baso that the s:ource and destination addresses used in the TCP
put:bachecksum be t:he originating source and ultimate destination. It is
put:baalso importan:t to preserve the return route to answer connection
put:baAny lower lev:el protocol will have to provide the source address,
put:badestination a:ddress, and protocol fields, and some way to determine
put:bathe "TCP leng:th", both to provide the functional equivlent service
put:baof IP and to :be used in the TCP checksum.
put:baTransmission Cont:rol Protocol
put:baFunctional Specif:ication
put:ba3.9.  Event Proce:ssing
put:baThe processing :depicted in this section is an example of one possible
put:baimplementation.:  Other implementations may have slightly different
put:baprocessing sequ:ences, but they should differ from those in this
put:basection only in: detail, not in substance.
put:baThe activity of: the TCP can be characterized as responding to events.
put:baThe events that: occur can be cast into three categories:  user calls,
put:baarriving segmen:ts, and timeouts.  This section describes the
put:baprocessing the :TCP does in response to each of the events.  In many
put:bacases the proce:ssing required depends on the state of the connection.
put:baEvents that o:ccur:
put:baArriving Se:gments
put:baSEGMENT A:RRIVES
put:baUSER TIME:OUT
put:baRETRANSMI:SSION TIMEOUT
put:baTIME-WAIT: TIMEOUT
put:baThe model of th:e TCP/user interface is that user commands receive an
put:baimmediate retur:n and possibly a delayed response via an event or
put:bapseudo interrup:t.  In the following descriptions, the term "signal"
put:bameans cause a d:elayed response.
put:baError responses: are given as character strings.  For example, user
put:bacommands refere:ncing connections that do not exist receive "error:
put:baconnection not :open".
put:baPlease note in :the following that all arithmetic on sequence numbers,
put:baacknowledgment :numbers, windows, et cetera, is modulo 2**32 the size
put:baof the sequence: number space.  Also note that "=<" means less than or
put:baequal to (modul:o 2**32).
put:ba[Page 52]        :                                                       
put:baSeptember 1981   :                                                       
put:baA natural way t:o think about processing incoming segments is to
put:baimagine that th:ey are first tested for proper sequence number (i.e.,
put:bathat their cont:ents lie in the range of the expected "receive window"
put:bain the sequence: number space) and then that they are generally queued
put:baand processed i:n sequence number order.
put:baWhen a segment :overlaps other already received segments we reconstruct
put:bathe segment to :contain just the new data, and adjust the header fields
put:bato be consisten:t.
put:baNote that if no: state change is mentioned the TCP stays in the same
put:baTransmission Cont:rol Protocol
put:baFunctional Specif:ication
put:baCLOSED STATE :(i.e., TCB does not exist)
put:baCreate a ne:w transmission control block (TCB) to hold connection
put:bastate infor:mation.  Fill in local socket identifier, foreign
put:basocket, pre:cedence, security/compartment, and user timeout
put:bainformation:.  Note that some parts of the foreign socket may be
put:baunspecified: in a passive OPEN and are to be filled in by the
put:baparameters :of the incoming SYN segment.  Verify the security and
put:baprecedence :requested are allowed for this user, if not return
put:ba"error:  pr:ecedence not allowed" or "error:  security/compartment
put:banot allowed:."  If passive enter the LISTEN state and return.  If
put:baactive and :the foreign socket is unspecified, return "error:
put:baforeign soc:ket unspecified"; if active and the foreign socket is
put:baspecified, :issue a SYN segment.  An initial send sequence number
put:ba(ISS) is se:lected.  A SYN segment of the form <SEQ=ISS><CTL=SYN>
put:bais sent.  S:et SND.UNA to ISS, SND.NXT to ISS+1, enter SYN-SENT
put:bastate, and :return.
put:baIf the call:er does not have access to the local socket specified,
put:bareturn "err:or:  connection illegal for this process".  If there is
put:bano room to :create a new connection, return "error:  insufficient
put:baresources".:
put:baIf active a:nd the foreign socket is specified, then change the
put:baconnection :from passive to active, select an ISS.  Send a SYN
put:basegment, se:t SND.UNA to ISS, SND.NXT to ISS+1.  Enter SYN-SENT
put:bastate.  Dat:a associated with SEND may be sent with SYN segment or
put:baqueued for :transmission after entering ESTABLISHED state.  The
put:baurgent bit :if requested in the command must be sent with the data
put:basegments se:nt as a result of this command.  If there is no room to
put:baqueue the r:equest, respond with "error:  insufficient resources".
put:baIf Foreign :socket was not specified, then return "error:  foreign
put:basocket unsp:ecified".
put:ba[Page 54]        :                                                       
put:baSeptember 1981   :                                                       
put:baSYN-SENT STAT:E
put:baSYN-RECEIVED :STATE
put:baESTABLISHED S:TATE
put:baFIN-WAIT-1 ST:ATE
put:baFIN-WAIT-2 ST:ATE
put:baCLOSE-WAIT ST:ATE
put:baCLOSING STATE:
put:baLAST-ACK STAT:E
put:baTIME-WAIT STA:TE
put:baReturn "err:or:  connection already exists".
put:baTransmission Cont:rol Protocol
put:baFunctional Specif:ication
put:baCLOSED STATE :(i.e., TCB does not exist)
put:baIf the user: does not have access to such a connection, then return
put:ba"error:  co:nnection illegal for this process".
put:baOtherwise, :return "error:  connection does not exist".
put:baIf the fore:ign socket is specified, then change the connection
put:bafrom passiv:e to active, select an ISS.  Send a SYN segment, set
put:baSND.UNA to :ISS, SND.NXT to ISS+1.  Enter SYN-SENT state.  Data
put:baassociated :with SEND may be sent with SYN segment or queued for
put:batransmissio:n after entering ESTABLISHED state.  The urgent bit if
put:barequested i:n the command must be sent with the data segments sent
put:baas a result: of this command.  If there is no room to queue the
put:barequest, re:spond with "error:  insufficient resources".  If
put:baForeign soc:ket was not specified, then return "error:  foreign
put:basocket unsp:ecified".
put:baSYN-SENT STAT:E
put:baSYN-RECEIVED :STATE
put:baQueue the d:ata for transmission after entering ESTABLISHED state.
put:baIf no space: to queue, respond with "error:  insufficient
put:baresources".:
put:baESTABLISHED S:TATE
put:baCLOSE-WAIT ST:ATE
put:baSegmentize :the buffer and send it with a piggybacked
put:baacknowledgm:ent (acknowledgment value = RCV.NXT).  If there is
put:bainsufficien:t space to remember this buffer, simply return "error:
put:bainsufficien:t resources".
put:baIf the urge:nt flag is set, then SND.UP <- SND.NXT-1 and set the
put:baurgent poin:ter in the outgoing segments.
put:ba[Page 56]        :                                                       
put:baSeptember 1981   :                                                       
put:baFIN-WAIT-1 ST:ATE
put:baFIN-WAIT-2 ST:ATE
put:baCLOSING STATE:
put:baLAST-ACK STAT:E
put:baTIME-WAIT STA:TE
put:baReturn "err:or:  connection closing" and do not service request.
put:baTransmission Cont:rol Protocol
put:baFunctional Specif:ication
put:baCLOSED STATE :(i.e., TCB does not exist)
put:baIf the user: does not have access to such a connection, return
put:ba"error:  co:nnection illegal for this process".
put:baOtherwise r:eturn "error:  connection does not exist".
put:baSYN-SENT STAT:E
put:baSYN-RECEIVED :STATE
put:baQueue for p:rocessing after entering ESTABLISHED state.  If there
put:bais no room :to queue this request, respond with "error:
put:bainsufficien:t resources".
put:baESTABLISHED S:TATE
put:baFIN-WAIT-1 ST:ATE
put:baFIN-WAIT-2 ST:ATE
put:baIf insuffic:ient incoming segments are queued to satisfy the
put:barequest, qu:eue the request.  If there is no queue space to
put:baremember th:e RECEIVE, respond with "error:  insufficient
put:baresources".:
put:baReassemble :queued incoming segments into receive buffer and return
put:bato user.  M:ark "push seen" (PUSH) if this is the case.
put:baIf RCV.UP i:s in advance of the data currently being passed to the
put:bauser notify: the user of the presence of urgent data.
put:baWhen the TC:P takes responsibility for delivering data to the user
put:bathat fact m:ust be communicated to the sender via an
put:baacknowledgm:ent.  The formation of such an acknowledgment is
put:badescribed b:elow in the discussion of processing an incoming
put:ba[Page 58]        :                                                       
put:baSeptember 1981   :                                                       
put:baCLOSE-WAIT ST:ATE
put:baSince the r:emote side has already sent FIN, RECEIVEs must be
put:basatisfied b:y text already on hand, but not yet delivered to the
put:bauser.  If n:o text is awaiting delivery, the RECEIVE will get a
put:ba"error:  co:nnection closing" response.  Otherwise, any remaining
put:batext can be: used to satisfy the RECEIVE.
put:baCLOSING STATE:
put:baLAST-ACK STAT:E
put:baTIME-WAIT STA:TE
put:baReturn "err:or:  connection closing".
put:baTransmission Cont:rol Protocol
put:baFunctional Specif:ication
put:baCLOSED STATE :(i.e., TCB does not exist)
put:baIf the user: does not have access to such a connection, return
put:ba"error:  co:nnection illegal for this process".
put:baOtherwise, :return "error:  connection does not exist".
put:baAny outstan:ding RECEIVEs are returned with "error:  closing"
put:baresponses. : Delete TCB, enter CLOSED state, and return.
put:baSYN-SENT STAT:E
put:baDelete the :TCB and return "error:  closing" responses to any
put:baqueued SEND:s, or RECEIVEs.
put:baSYN-RECEIVED :STATE
put:baIf no SENDs: have been issued and there is no pending data to send,
put:bathen form a: FIN segment and send it, and enter FIN-WAIT-1 state;
put:baotherwise q:ueue for processing after entering ESTABLISHED state.
put:baESTABLISHED S:TATE
put:baQueue this :until all preceding SENDs have been segmentized, then
put:baform a FIN :segment and send it.  In any case, enter FIN-WAIT-1
put:baFIN-WAIT-1 ST:ATE
put:baFIN-WAIT-2 ST:ATE
put:baStrictly sp:eaking, this is an error and should receive a "error:
put:baconnection :closing" response.  An "ok" response would be
put:baacceptable,: too, as long as a second FIN is not emitted (the first
put:baFIN may be :retransmitted though).
put:ba[Page 60]        :                                                       
put:baSeptember 1981   :                                                       
put:baCLOSE-WAIT ST:ATE
put:baQueue this :request until all preceding SENDs have been
put:basegmentized:; then send a FIN segment, enter CLOSING state.
put:baCLOSING STATE:
put:baLAST-ACK STAT:E
put:baTIME-WAIT STA:TE
put:baRespond wit:h "error:  connection closing".
put:baTransmission Cont:rol Protocol
put:baFunctional Specif:ication
put:baCLOSED STATE :(i.e., TCB does not exist)
put:baIf the user: should not have access to such a connection, return
put:ba"error:  co:nnection illegal for this process".
put:baOtherwise r:eturn "error:  connection does not exist".
put:baAny outstan:ding RECEIVEs should be returned with "error:
put:baconnection :reset" responses.  Delete TCB, enter CLOSED state, and
put:baSYN-SENT STAT:E
put:baAll queued :SENDs and RECEIVEs should be given "connection reset"
put:banotificatio:n, delete the TCB, enter CLOSED state, and return.
put:baSYN-RECEIVED :STATE
put:baESTABLISHED S:TATE
put:baFIN-WAIT-1 ST:ATE
put:baFIN-WAIT-2 ST:ATE
put:baCLOSE-WAIT ST:ATE
put:baSend a rese:t segment:
put:ba<SEQ=SND.:NXT><CTL=RST>
put:baAll queued :SENDs and RECEIVEs should be given "connection reset"
put:banotificatio:n; all segments queued for transmission (except for the
put:baRST formed :above) or retransmission should be flushed, delete the
put:baTCB, enter :CLOSED state, and return.
put:baCLOSING STATE:
put:baLAST-ACK STAT:E
put:baTIME-WAIT STA:TE
put:baRespond wit:h "ok" and delete the TCB, enter CLOSED state, and
put:ba[Page 62]        :                                                       
put:baSeptember 1981   :                                                       
put:baCLOSED STATE :(i.e., TCB does not exist)
put:baIf the user: should not have access to such a connection, return
put:ba"error:  co:nnection illegal for this process".
put:baOtherwise r:eturn "error:  connection does not exist".
put:baReturn "sta:te = LISTEN", and the TCB pointer.
put:baSYN-SENT STAT:E
put:baReturn "sta:te = SYN-SENT", and the TCB pointer.
put:baSYN-RECEIVED :STATE
put:baReturn "sta:te = SYN-RECEIVED", and the TCB pointer.
put:baESTABLISHED S:TATE
put:baReturn "sta:te = ESTABLISHED", and the TCB pointer.
put:baFIN-WAIT-1 ST:ATE
put:baReturn "sta:te = FIN-WAIT-1", and the TCB pointer.
put:baFIN-WAIT-2 ST:ATE
put:baReturn "sta:te = FIN-WAIT-2", and the TCB pointer.
put:baCLOSE-WAIT ST:ATE
put:baReturn "sta:te = CLOSE-WAIT", and the TCB pointer.
put:baCLOSING STATE:
put:baReturn "sta:te = CLOSING", and the TCB pointer.
put:baLAST-ACK STAT:E
put:baReturn "sta:te = LAST-ACK", and the TCB pointer.
put:baTransmission Cont:rol Protocol
put:baFunctional Specif:ication
put:baTIME-WAIT STA:TE
put:baReturn "sta:te = TIME-WAIT", and the TCB pointer.
put:ba[Page 64]        :                                                       
put:baSeptember 1981   :                                                       
put:baSEGMENT ARRIVES:
put:baIf the state :is CLOSED (i.e., TCB does not exist) then
put:baall data in: the incoming segment is discarded.  An incoming
put:basegment con:taining a RST is discarded.  An incoming segment not
put:bacontaining :a RST causes a RST to be sent in response.  The
put:baacknowledgm:ent and sequence field values are selected to make the
put:bareset seque:nce acceptable to the TCP that sent the offending
put:baIf the ACK :bit is off, sequence number zero is used,
put:ba<SEQ=0><A:CK=SEG.SEQ+SEG.LEN><CTL=RST,ACK>
put:baIf the ACK :bit is on,
put:ba<SEQ=SEG.:ACK><CTL=RST>
put:baIf the state :is LISTEN then
put:bafirst check: for an RST
put:baAn incomi:ng RST should be ignored.  Return.
put:basecond chec:k for an ACK
put:baAny ackno:wledgment is bad if it arrives on a connection still in
put:bathe LISTE:N state.  An acceptable reset segment should be formed
put:bafor any a:rriving ACK-bearing segment.  The RST should be
put:baformatted: as follows:
put:ba<SEQ=SE:G.ACK><CTL=RST>
put:bathird check: for a SYN
put:baIf the SY:N bit is set, check the security.  If the
put:basecurity/:compartment on the incoming segment does not exactly
put:bamatch the: security/compartment in the TCB then send a reset and
put:ba<SEQ=SE:G.ACK><CTL=RST>
put:baTransmission Cont:rol Protocol
put:baFunctional Specif:ication
put:baIf the SE:G.PRC is greater than the TCB.PRC then if allowed by
put:bathe user :and the system set TCB.PRC<-SEG.PRC, if not allowed
put:basend a re:set and return.
put:ba<SEQ=SE:G.ACK><CTL=RST>
put:baIf the SE:G.PRC is less than the TCB.PRC then continue.
put:baSet RCV.N:XT to SEG.SEQ+1, IRS is set to SEG.SEQ and any other
put:bacontrol o:r text should be queued for processing later.  ISS
put:bashould be: selected and a SYN segment sent of the form:
put:ba<SEQ=IS:S><ACK=RCV.NXT><CTL=SYN,ACK>
put:baSND.NXT i:s set to ISS+1 and SND.UNA to ISS.  The connection
put:bastate sho:uld be changed to SYN-RECEIVED.  Note that any other
put:baincoming :control or data (combined with SYN) will be processed
put:bain the SY:N-RECEIVED state, but processing of SYN and ACK should
put:banot be re:peated.  If the listen was not fully specified (i.e.,
put:bathe forei:gn socket was not fully specified), then the
put:baunspecifi:ed fields should be filled in now.
put:bafourth othe:r text or control
put:baAny other: control or text-bearing segment (not containing SYN)
put:bamust have: an ACK and thus would be discarded by the ACK
put:baprocessin:g.  An incoming RST segment could not be valid, since
put:bait could :not have been sent in response to anything sent by this
put:baincarnati:on of the connection.  So you are unlikely to get here,
put:babut if yo:u do, drop the segment, and return.
put:baIf the state :is SYN-SENT then
put:bafirst check: the ACK bit
put:baIf the AC:K bit is set
put:baIf SEG.:ACK =< ISS, or SEG.ACK > SND.NXT, send a reset (unless
put:bathe RST: bit is set, if so drop the segment and return)
put:ba<SEQ=:SEG.ACK><CTL=RST>
put:baand dis:card the segment.  Return.
put:baIf SND.:UNA =< SEG.ACK =< SND.NXT then the ACK is acceptable.
put:basecond chec:k the RST bit
put:ba[Page 66]        :                                                       
put:baSeptember 1981   :                                                       
put:baIf the RS:T bit is set
put:baIf the :ACK was acceptable then signal the user "error:
put:baconnect:ion reset", drop the segment, enter CLOSED state,
put:badelete :TCB, and return.  Otherwise (no ACK) drop the segment
put:baand ret:urn.
put:bathird check: the security and precedence
put:baIf the se:curity/compartment in the segment does not exactly
put:bamatch the: security/compartment in the TCB, send a reset
put:baIf ther:e is an ACK
put:ba<SEQ=:SEG.ACK><CTL=RST>
put:baOtherwi:se
put:ba<SEQ=:0><ACK=SEG.SEQ+SEG.LEN><CTL=RST,ACK>
put:baIf there :is an ACK
put:baThe pre:cedence in the segment must match the precedence in the
put:baTCB, if: not, send a reset
put:ba<SEQ=:SEG.ACK><CTL=RST>
put:baIf there :is no ACK
put:baIf the :precedence in the segment is higher than the precedence
put:bain the :TCB then if allowed by the user and the system raise
put:bathe pre:cedence in the TCB to that in the segment, if not
put:baallowed: to raise the prec then send a reset.
put:ba<SEQ=:0><ACK=SEG.SEQ+SEG.LEN><CTL=RST,ACK>
put:baIf the :precedence in the segment is lower than the precedence
put:bain the :TCB continue.
put:baIf a rese:t was sent, discard the segment and return.
put:bafourth chec:k the SYN bit
put:baThis step: should be reached only if the ACK is ok, or there is
put:bano ACK, a:nd it the segment did not contain a RST.
put:baIf the SY:N bit is on and the security/compartment and precedence
put:baTransmission Cont:rol Protocol
put:baFunctional Specif:ication
put:baare accep:table then, RCV.NXT is set to SEG.SEQ+1, IRS is set to
put:baSEG.SEQ. : SND.UNA should be advanced to equal SEG.ACK (if there
put:bais an ACK:), and any segments on the retransmission queue which
put:baare there:by acknowledged should be removed.
put:baIf SND.UN:A > ISS (our SYN has been ACKed), change the connection
put:bastate to :ESTABLISHED, form an ACK segment
put:ba<SEQ=SN:D.NXT><ACK=RCV.NXT><CTL=ACK>
put:baand send :it.  Data or controls which were queued for
put:batransmiss:ion may be included.  If there are other controls or
put:batext in t:he segment then continue processing at the sixth step
put:babelow whe:re the URG bit is checked, otherwise return.
put:baOtherwise: enter SYN-RECEIVED, form a SYN,ACK segment
put:ba<SEQ=IS:S><ACK=RCV.NXT><CTL=SYN,ACK>
put:baand send :it.  If there are other controls or text in the
put:basegment, :queue them for processing after the ESTABLISHED state
put:bahas been :reached, return.
put:bafifth, if n:either of the SYN or RST bits is set then drop the
put:basegment and: return.
put:ba[Page 68]        :                                                       
put:baSeptember 1981   :                                                       
put:bafirst check s:equence number
put:baSYN-RECEIVE:D STATE
put:baESTABLISHED: STATE
put:baFIN-WAIT-1 :STATE
put:baFIN-WAIT-2 :STATE
put:baCLOSE-WAIT :STATE
put:baCLOSING STA:TE
put:baLAST-ACK ST:ATE
put:baTIME-WAIT S:TATE
put:baSegments :are processed in sequence.  Initial tests on arrival
put:baare used :to discard old duplicates, but further processing is
put:badone in S:EG.SEQ order.  If a segment's contents straddle the
put:baboundary :between old and new, only the new parts should be
put:baprocessed:.
put:baThere are: four cases for the acceptability test for an incoming
put:basegment:
put:baSegment R:eceive  Test
put:baLength  W:indow
put:ba------- -:------  -------------------------------------------
put:ba0     :  0     SEG.SEQ = RCV.NXT
put:ba0     : >0     RCV.NXT =< SEG.SEQ < RCV.NXT+RCV.WND
put:ba>0     :  0     not acceptable
put:ba>0     : >0     RCV.NXT =< SEG.SEQ < RCV.NXT+RCV.WND
put:baIf the RC:V.WND is zero, no segments will be acceptable, but
put:baspecial a:llowance should be made to accept valid ACKs, URGs and
put:baIf an inc:oming segment is not acceptable, an acknowledgment
put:bashould be: sent in reply (unless the RST bit is set, if so drop
put:bathe segme:nt and return):
put:ba<SEQ=SN:D.NXT><ACK=RCV.NXT><CTL=ACK>
put:baAfter sen:ding the acknowledgment, drop the unacceptable segment
put:baand retur:n.
put:baTransmission Cont:rol Protocol
put:baFunctional Specif:ication
put:baIn the fo:llowing it is assumed that the segment is the idealized
put:basegment t:hat begins at RCV.NXT and does not exceed the window.
put:baOne could: tailor actual segments to fit this assumption by
put:batrimming :off any portions that lie outside the window (including
put:baSYN and F:IN), and only processing further if the segment then
put:babegins at: RCV.NXT.  Segments with higher begining sequence
put:banumbers m:ay be held for later processing.
put:basecond check :the RST bit,
put:baSYN-RECEIVE:D STATE
put:baIf the RS:T bit is set
put:baIf this: connection was initiated with a passive OPEN (i.e.,
put:bacame fr:om the LISTEN state), then return this connection to
put:baLISTEN :state and return.  The user need not be informed.  If
put:bathis co:nnection was initiated with an active OPEN (i.e., came
put:bafrom SY:N-SENT state) then the connection was refused, signal
put:bathe use:r "connection refused".  In either case, all segments
put:baon the :retransmission queue should be removed.  And in the
put:baactive :OPEN case, enter the CLOSED state and delete the TCB,
put:baand ret:urn.
put:baESTABLISHED:
put:baIf the RS:T bit is set then, any outstanding RECEIVEs and SEND
put:bashould re:ceive "reset" responses.  All segment queues should be
put:baflushed. : Users should also receive an unsolicited general
put:ba"connecti:on reset" signal.  Enter the CLOSED state, delete the
put:baTCB, and :return.
put:baCLOSING STA:TE
put:baLAST-ACK ST:ATE
put:baIf the RS:T bit is set then, enter the CLOSED state, delete the
put:baTCB, and :return.
put:ba[Page 70]        :                                                       
put:baSeptember 1981   :                                                       
put:bathird check s:ecurity and precedence
put:baSYN-RECEIVE:D
put:baIf the se:curity/compartment and precedence in the segment do not
put:baexactly m:atch the security/compartment and precedence in the TCB
put:bathen send: a reset, and return.
put:baESTABLISHED: STATE
put:baIf the se:curity/compartment and precedence in the segment do not
put:baexactly m:atch the security/compartment and precedence in the TCB
put:bathen send: a reset, any outstanding RECEIVEs and SEND should
put:bareceive ":reset" responses.  All segment queues should be
put:baflushed. : Users should also receive an unsolicited general
put:ba"connecti:on reset" signal.  Enter the CLOSED state, delete the
put:baTCB, and :return.
put:baNote this c:heck is placed following the sequence check to prevent
put:baa segment f:rom an old connection between these ports with a
put:badifferent s:ecurity or precedence from causing an abort of the
put:bacurrent con:nection.
put:bafourth, check: the SYN bit,
put:baSYN-RECEIVE:D
put:baESTABLISHED: STATE
put:baFIN-WAIT ST:ATE-1
put:baFIN-WAIT ST:ATE-2
put:baCLOSE-WAIT :STATE
put:baCLOSING STA:TE
put:baLAST-ACK ST:ATE
put:baTIME-WAIT S:TATE
put:baIf the SY:N is in the window it is an error, send a reset, any
put:baoutstandi:ng RECEIVEs and SEND should receive "reset" responses,
put:baall segme:nt queues should be flushed, the user should also
put:bareceive a:n unsolicited general "connection reset" signal, enter
put:bathe CLOSE:D state, delete the TCB, and return.
put:baIf the SY:N is not in the window this step would not be reached
put:baand an ac:k would have been sent in the first step (sequence
put:banumber ch:eck).
put:baTransmission Cont:rol Protocol
put:baFunctional Specif:ication
put:bafifth check t:he ACK field,
put:baif the ACK :bit is off drop the segment and return
put:baif the ACK :bit is on
put:baSYN-RECEI:VED STATE
put:baIf SND.:UNA =< SEG.ACK =< SND.NXT then enter ESTABLISHED state
put:baand con:tinue processing.
put:baIf th:e segment acknowledgment is not acceptable, form a
put:bareset: segment,
put:ba<SE:Q=SEG.ACK><CTL=RST>
put:baand s:end it.
put:baESTABLISH:ED STATE
put:baIf SND.:UNA < SEG.ACK =< SND.NXT then, set SND.UNA <- SEG.ACK.
put:baAny seg:ments on the retransmission queue which are thereby
put:baentirel:y acknowledged are removed.  Users should receive
put:bapositiv:e acknowledgments for buffers which have been SENT and
put:bafully a:cknowledged (i.e., SEND buffer should be returned with
put:ba"ok" re:sponse).  If the ACK is a duplicate
put:ba(SEG.AC:K < SND.UNA), it can be ignored.  If the ACK acks
put:basomethi:ng not yet sent (SEG.ACK > SND.NXT) then send an ACK,
put:badrop th:e segment, and return.
put:baIf SND.:UNA < SEG.ACK =< SND.NXT, the send window should be
put:baupdated:.  If (SND.WL1 < SEG.SEQ or (SND.WL1 = SEG.SEQ and
put:baSND.WL2: =< SEG.ACK)), set SND.WND <- SEG.WND, set
put:baSND.WL1: <- SEG.SEQ, and set SND.WL2 <- SEG.ACK.
put:baNote th:at SND.WND is an offset from SND.UNA, that SND.WL1
put:barecords: the sequence number of the last segment used to update
put:baSND.WND:, and that SND.WL2 records the acknowledgment number of
put:bathe las:t segment used to update SND.WND.  The check here
put:baprevent:s using old segments to update the window.
put:ba[Page 72]        :                                                       
put:baSeptember 1981   :                                                       
put:baFIN-WAIT-:1 STATE
put:baIn addi:tion to the processing for the ESTABLISHED state, if
put:baour FIN: is now acknowledged then enter FIN-WAIT-2 and continue
put:baprocess:ing in that state.
put:baFIN-WAIT-:2 STATE
put:baIn addi:tion to the processing for the ESTABLISHED state, if
put:bathe ret:ransmission queue is empty, the user's CLOSE can be
put:baacknowl:edged ("ok") but do not delete the TCB.
put:baCLOSE-WAI:T STATE
put:baDo the :same processing as for the ESTABLISHED state.
put:baCLOSING S:TATE
put:baIn addi:tion to the processing for the ESTABLISHED state, if
put:bathe ACK: acknowledges our FIN then enter the TIME-WAIT state,
put:baotherwi:se ignore the segment.
put:baLAST-ACK :STATE
put:baThe onl:y thing that can arrive in this state is an
put:baacknowl:edgment of our FIN.  If our FIN is now acknowledged,
put:badelete :the TCB, enter the CLOSED state, and return.
put:baTIME-WAIT: STATE
put:baThe onl:y thing that can arrive in this state is a
put:baretrans:mission of the remote FIN.  Acknowledge it, and restart
put:bathe 2 M:SL timeout.
put:basixth, check :the URG bit,
put:baESTABLISHED: STATE
put:baFIN-WAIT-1 :STATE
put:baFIN-WAIT-2 :STATE
put:baIf the UR:G bit is set, RCV.UP <- max(RCV.UP,SEG.UP), and signal
put:bathe user :that the remote side has urgent data if the urgent
put:bapointer (:RCV.UP) is in advance of the data consumed.  If the
put:bauser has :already been signaled (or is still in the "urgent
put:bamode") fo:r this continuous sequence of urgent data, do not
put:basignal th:e user again.
put:baTransmission Cont:rol Protocol
put:baFunctional Specif:ication
put:baCLOSE-WAIT :STATE
put:baCLOSING STA:TE
put:baLAST-ACK ST:ATE
put:baThis shou:ld not occur, since a FIN has been received from the
put:baremote si:de.  Ignore the URG.
put:baseventh, proc:ess the segment text,
put:baESTABLISHED: STATE
put:baFIN-WAIT-1 :STATE
put:baFIN-WAIT-2 :STATE
put:baOnce in t:he ESTABLISHED state, it is possible to deliver segment
put:batext to u:ser RECEIVE buffers.  Text from segments can be moved
put:bainto buff:ers until either the buffer is full or the segment is
put:baempty.  I:f the segment empties and carries an PUSH flag, then
put:bathe user :is informed, when the buffer is returned, that a PUSH
put:bahas been :received.
put:baWhen the :TCP takes responsibility for delivering the data to the
put:bauser it m:ust also acknowledge the receipt of the data.
put:baOnce the :TCP takes responsibility for the data it advances
put:baRCV.NXT o:ver the data accepted, and adjusts RCV.WND as
put:baapporopri:ate to the current buffer availability.  The total of
put:baRCV.NXT a:nd RCV.WND should not be reduced.
put:baPlease no:te the window management suggestions in section 3.7.
put:baSend an a:cknowledgment of the form:
put:ba<SEQ=SN:D.NXT><ACK=RCV.NXT><CTL=ACK>
put:baThis ackn:owledgment should be piggybacked on a segment being
put:batransmitt:ed if possible without incurring undue delay.
put:ba[Page 74]        :                                                       
put:baSeptember 1981   :                                                       
put:baCLOSE-WAIT :STATE
put:baCLOSING STA:TE
put:baLAST-ACK ST:ATE
put:baTIME-WAIT S:TATE
put:baThis shou:ld not occur, since a FIN has been received from the
put:baremote si:de.  Ignore the segment text.
put:baeighth, check: the FIN bit,
put:baDo not proc:ess the FIN if the state is CLOSED, LISTEN or SYN-SENT
put:basince the S:EG.SEQ cannot be validated; drop the segment and
put:baIf the FIN :bit is set, signal the user "connection closing" and
put:bareturn any :pending RECEIVEs with same message, advance RCV.NXT
put:baover the FI:N, and send an acknowledgment for the FIN.  Note that
put:baFIN implies: PUSH for any segment text not yet delivered to the
put:baSYN-RECEI:VED STATE
put:baESTABLISH:ED STATE
put:baEnter t:he CLOSE-WAIT state.
put:baFIN-WAIT-:1 STATE
put:baIf our :FIN has been ACKed (perhaps in this segment), then
put:baenter T:IME-WAIT, start the time-wait timer, turn off the other
put:batimers;: otherwise enter the CLOSING state.
put:baFIN-WAIT-:2 STATE
put:baEnter t:he TIME-WAIT state.  Start the time-wait timer, turn
put:baoff the: other timers.
put:baCLOSE-WAI:T STATE
put:baRemain :in the CLOSE-WAIT state.
put:baCLOSING S:TATE
put:baRemain :in the CLOSING state.
put:baLAST-ACK :STATE
put:baRemain :in the LAST-ACK state.
put:baTransmission Cont:rol Protocol
put:baFunctional Specif:ication
put:baTIME-WAIT: STATE
put:baRemain :in the TIME-WAIT state.  Restart the 2 MSL time-wait
put:batimeout:.
put:ba[Page 76]        :                                                       
put:baSeptember 1981   :                                                       
put:baFor any state: if the user timeout expires, flush all queues, signal
put:bathe user "err:or:  connection aborted due to user timeout" in general
put:baand for any o:utstanding calls, delete the TCB, enter the CLOSED
put:bastate and ret:urn.
put:baRETRANSMISSION :TIMEOUT
put:baFor any state: if the retransmission timeout expires on a segment in
put:bathe retransmi:ssion queue, send the segment at the front of the
put:baretransmissio:n queue again, reinitialize the retransmission timer,
put:baTIME-WAIT TIMEO:UT
put:baIf the time-w:ait timeout expires on a connection delete the TCB,
put:baenter the CLO:SED state and return.
put:baTransmission Cont:rol Protocol
put:ba[Page 78]        :                                                       
put:baSeptember 1981   :                                                       
put:baBBN Rep:ort 1822, "The Specification of the Interconnection of
put:baa Host :and an IMP".  The specification of interface between a
put:bahost an:d the ARPANET.
put:baA contr:ol bit (acknowledge) occupying no sequence space, which
put:baindicat:es that the acknowledgment field of this segment
put:baspecifi:es the next sequence number the sender of this segment
put:bais expe:cting to receive, hence acknowledging receipt of all
put:bapreviou:s sequence numbers.
put:baThe uni:t of transmission between a host and an IMP in the
put:baARPANET:.  The maximum size is about 1012 octets (8096 bits).
put:baA unit :of transmission used internally in the ARPANET between
put:baIMPs.  :The maximum size is about 126 octets (1008 bits).
put:baA logic:al communication path identified by a pair of sockets.
put:baA messa:ge sent in a packet switched computer communications
put:banetwork:.
put:baDestination Addre:ss
put:baThe des:tination address, usually the network and host
put:baidentif:iers.
put:baA contr:ol bit (finis) occupying one sequence number, which
put:baindicat:es that the sender will send no more data or control
put:baoccupyi:ng sequence space.
put:baA porti:on of a logical unit of data, in particular an internet
put:bafragmen:t is a portion of an internet datagram.
put:baA file :transfer protocol.
put:baTransmission Cont:rol Protocol
put:baControl: information at the beginning of a message, segment,
put:bafragmen:t, packet or block of data.
put:baA compu:ter.  In particular a source or destination of messages
put:bafrom th:e point of view of the communication network.
put:baAn Inte:rnet Protocol field.  This identifying value assigned
put:baby the :sender aids in assembling the fragments of a datagram.
put:baThe Int:erface Message Processor, the packet switch of the
put:baARPANET:.
put:baA sourc:e or destination address specific to the host level.
put:bainternet datagram:
put:baThe uni:t of data exchanged between an internet module and the
put:bahigher :level protocol together with the internet header.
put:bainternet fragment:
put:baA porti:on of the data of an internet datagram with an internet
put:baheader.:
put:baInterne:t Protocol.
put:baThe Ini:tial Receive Sequence number.  The first sequence
put:banumber :used by the sender on a connection.
put:baThe Ini:tial Sequence Number.  The first sequence number used
put:baon a co:nnection, (either ISS or IRS).  Selected on a clock
put:babased p:rocedure.
put:baThe Ini:tial Send Sequence number.  The first sequence number
put:baused by: the sender on a connection.
put:baControl: information at the beginning of a message or block of
put:badata.  :In particular, in the ARPANET, the control information
put:baon an A:RPANET message at the host-IMP interface.
put:ba[Page 80]        :                                                       
put:baSeptember 1981   :                                                       
put:baThis is: the next sequence number to be acknowledged by the
put:badata re:ceiving TCP (or the lowest currently unacknowledged
put:basequenc:e number) and is sometimes referred to as the left edge
put:baof the :send window.
put:baThe uni:t of transmission within a local network.
put:baAn impl:ementation, usually in software, of a protocol or other
put:baprocedu:re.
put:baMaximum: Segment Lifetime, the time a TCP segment can exist in
put:bathe int:ernetwork system.  Arbitrarily defined to be 2 minutes.
put:baAn eigh:t bit byte.
put:baAn Opti:on field may contain several options, and each option
put:bamay be :several octets in length.  The options are used
put:baprimari:ly in testing situations; for example, to carry
put:batimesta:mps.  Both the Internet Protocol and TCP provide for
put:baoptions: fields.
put:baA packa:ge of data with a header which may or may not be
put:balogical:ly complete.  More often a physical packaging than a
put:balogical: packaging of data.
put:baThe por:tion of a socket that specifies which logical input or
put:baoutput :channel of a process is associated with the data.
put:baA progr:am in execution.  A source or destination of data from
put:bathe poi:nt of view of the TCP or other host-to-host protocol.
put:baA contr:ol bit occupying no sequence space, indicating that
put:bathis se:gment contains data that must be pushed through to the
put:bareceivi:ng user.
put:bareceive: next sequence number
put:baTransmission Cont:rol Protocol
put:bareceive: urgent pointer
get:RFC
get:De
get:I
get:September 1981   
get:PREFACE .....
get:1.  INTRODUCTION 
get:1.1  Motivation
get:1.2  Scope ....
get:1.3  About This
get:1.4  Interfaces
get:1.5  Operation 
get:2.  PHILOSOPHY ..
get:2.1  Elements o
get:2.2  Model of O
get:2.3  The Host E
get:2.4  Interfaces
get:2.5  Relation t
get:2.6  Reliable C
get:2.7  Connection
get:2.8  Data Commu
get:2.9  Precedence
get:2.10 Robustness
get:3.  FUNCTIONAL SP
get:3.1  Header For
get:3.2  Terminolog
get:3.3  Sequence N
get:3.4  Establishi
get:3.5  Closing a 
get:3.6  Precedence
get:3.7  Data Commu
get:3.8  Interfaces
get:3.9  Event Proc
get:GLOSSARY ........
get:REFERENCES ......
get:Transmission Cont
get:[Page ii]        
get:September 1981   
get:This document des
get:(TCP).  There hav
get:specification on 
get:draws heavily fro
get:both in terms of 
get:several details a
get:and redescribes t
get:RFC
get:Replaces: RFC 761
get:IENs:  129, 124, 
get:55, 44, 40, 27, 2
get:The Transmission 
get:reliable host-to-
get:communication net
get:This document des
get:Transmission Cont
get:interface to prog
get:Computer commun
get:role in militar
get:document focuse
get:communication r
get:communication u
get:congestion, but
get:government sect
get:As strategic an
get:developed and d
get:interconnecting
get:communication p
get:applications.  
get:Deputy Undersec
get:declared the Tr
get:be a basis for 
get:standardization
get:TCP is a connec
get:fit into a laye
get:applications.  
get:communication b
get:distinct but in
get:assumptions are
get:protocols below
get:potentially unr
get:protocols.  In 
get:wide spectrum o
get:connections to 
get:Transmission Cont
get:TCP is based on
get:TCP fits into a
get:Internet Protoc
get:receive variabl
get:datagram "envel
get:addressing sour
get:internet protoc
get:the TCP segment
get:multiple networ
get:also carries in
get:and compartment
get:communicated en
get:Much of this do
get:which are co-re
get:computer.  Some
get:front-end compu
get:as well as netw
get:an interface to
get:implementable e
get:host-to-front e
get:The TCP is inte
get:communication s
get:intended to be 
get:1.3.  About this 
get:This document r
get:any TCP impleme
get:protocols and i
get:[Page 2]         
get:September 1981   
get:section offers 
get:operation.  Sec
get:design.  Sectio
get:required of TCP
get:user calls, err
get:The TCP interfa
get:the other side 
get:The interface b
get:illustrated in 
get:calls much like
get:application pro
get:calls to open a
get:established con
get:asynchronously 
get:considerable fr
get:interfaces whic
get:environment, a 
get:interface for a
get:The interface b
get:unspecified exc
get:two levels can 
get:Typically, one 
get:interface.  TCP
get:interconnected 
get:throughout this
get:As noted above,
get:securable logic
get:processes.  To 
get:communication s:ystem requires facilities in the following areas
get:Basic Data Tr
get:Precedence an
get:The basic opera
get:the following p
get:Transmission Cont
get:Basic Data Tran:sfer
get:The TCP is ab
get:direction bet
get:segments for 
get:the TCPs deci
get:Sometimes use
get:submitted to 
get:function is d
get:actually tran
get:pushed throug
get:promptly forw
get:The exact pus
get:the push func
get:Reliability
get:The TCP must 
get:delivered out
get:is achieved b
get:transmitted, 
get:receiving TCP
get:interval, the
get:numbers are u
get:out of order 
get:adding a chec
get:receiver, and
get:As long as th
get:system does n
get:errors will a
get:internet comm
get:Flow Control
get:TCP provides 
get:sent by the s
get:every ACK ind
get:the last segm
get:allowed numbe
get:receiving fur
get:[Page 4]         
get:September 1981   
get:Multiplexing
get:To allow for 
get:communication
get:addresses or 
get:and host addr
get:a socket.  A 
get:That is, a so
get:The binding o
get:Host.  Howeve
get:(e.g., a "log
get:made known to
get:through the k
get:addresses of 
get:Connections
get:The reliabili
get:that TCPs ini
get:each data str
get:sockets, sequ
get:Each connecti
get:identifying i
get:When two proc
get:establish a c
get:side).  When 
get:terminated or
get:Since connect
get:over the unre
get:mechanism wit
get:erroneous ini
get:Precedence and :Security
get:The users of 
get:communication
get:these feature
get:Transmission Cont
get:[Page 6]         
get:September 1981   
get:2.1.  Elements of
get:The internetwor
get:which are in tu
get:that the networ
get:large networks 
get:packet switchin
get:consume message
get:networks, the g
get:communication s
get:connections bet
get:The term packet
get:transaction bet
get:exchanged withi
get:Hosts are compu
get:network's point
get:Processes are v
get:accordance with
get:in execution). 
get:viewed as commu
get:Thus, all commu
get:Since a process
get:streams between
get:that each proce
get:communicates wi
get:2.2.  Model of Op
get:Processes trans
get:data as argumen
get:segments and ca
get:the destination
get:into the receiv
get:TCPs include co
get:ensure reliable
get:The model of in
get:protocol module
get:to the local ne
get:inside internet
get:internet module
get:through the loc
get:The packet swit
get:Transmission Cont
get:other operation
get:destination int
get:At a gateway be
get:from its local 
get:the internet da
get:then "wrapped" 
get:routed to the n
get:A gateway is pe
get:internet datagr
get:through the nex
get:internet datagr
get:further broken 
get:internet datagr
get:internet module
get:A destination i
get:(after reassemb
get:destination TCP
get:This simple mod
get:important featu
get:to the gateway 
get:service paramet
get:Included in the
get:datagram.  Data
get:host and gatewa
get:properly segreg
get:2.3.  The Host En
get:The TCP is assu
get:access the TCP 
get:may call on oth
get:data structures
get:controlled by a
get:network device 
get:datagram protoc
get:The mechanisms 
get:front-end proce
get:host-to-front-e
get:the type of TCP
get:[Page 8]         
get:September 1981   
get:The TCP/user in
get:to OPEN or CLOS
get:STATUS about a 
get:programs on the
get:from, and close
get:The TCP/interne
get:datagrams addre
get:system.  These 
get:service, preced
get:2.5.  Relation to
get:The following d
get:hierarchy
get:+------+ +
get:|Telnet| |
get:+------+ +
get:|   
get:+----
get:| TCP
get:+----
get:| 
get:+----
get:|    
get:+----
get:+--
get:|  
get:+--
get:It is expected 
get:protocols effic
get:protocols like 
get:2.6.  Reliable Co
get:A stream of dat
get:order at the de
get:Transmission Cont
get:Transmission is
get:acknowledgments
get:sequence number
get:segment is tran
get:sequence number
get:is the sequence
get:transmissions i
get:segment contain
get:starts a timer;
get:segment is dele
get:received before
get:An acknowledgme
get:delivered to th
get:the responsibil
get:To govern the f
get:employed.  The 
get:This window spe
get:acknowledgment 
get:2.7.  Connection 
get:To identify the
get:provides a port
get:independently b
get:unique addresse
get:identifying the
get:will be unique 
get:A connection is
get:local socket ma
get:sockets.  A con
get:that is, it is 
get:TCPs are free t
get:However, severa
get:There must be w
get:the "appropriat
get:may "own" ports
get:the ports they 
get:issue, but we e
get:uniquely alloca
get:associating the
get:A connection is
get:foreign socket 
get:[Page 10]        
get:September 1981   
get:connection name
get:subsequent call
get:about a connect
get:is a data struc
get:implementation 
get:pointer to the 
get:whether the con
get:be passively wa
get:A passive OPEN 
get:connection requ
get:Often the proce
get:request from an
get:is used to deno
get:are allowed onl
get:A service proce
get:processes would
get:foreign socket.
get:requested a con
get:local socket we
get:Well-known sock
get:a socket addres
get:"Telnet-Server"
get:socket, and oth
get:Entry, Text Gen
get:being for test 
get:access to a "Lo
get:at which a newl
get:well-known sock
get:of sockets to s
get:Processes can i
get:from other proc
get:been establishe
get:other at the sa
get:is critical for
get:components act 
get:There are two p
get:passive OPENs a
get:local passive O
get:case, the match
get:OPENs has left 
get:foreign socket 
get:Other possibili
get:Transmission Cont
get:If there are se
get:same local sock
get:with the specif
get:TCB exists, bef
get:The procedures 
get:control flag an
get:exchange has be
get:A connection is
get:containing a SY
get:command.  The m
get:connection has 
get:when sequence n
get:The clearing of
get:in this case ca
get:2.8.  Data Commun
get:The data that f
get:octets.  The se
get:in that call (a
get:through to the 
get:A sending TCP i
get:send that data 
get:function is sig
get:receiving TCP s
get:the sending TCP
get:There is no nec
get:boundaries.  Th
get:single SEND cal
get:The purpose of 
get:from the sendin
get:record service.
get:There is a coup
get:of data that cr
get:associated with
get:buffer is retur
get:not filled.  If
get:PUSH is seen, t
get:TCP also provid
get:at some point f
get:[Page 12]        
get:September 1981   
get:currently readi
get:define what the
get:urgent data, bu
get:take action to 
get:2.9.  Precedence 
get:The TCP makes u
get:security option
get:basis to TCP us
get:a multilevel se
get:use only, and o
get:compartment.  C
get:users may be li
get:TCP modules whi
get:properly mark o
get:precedence.  Su
get:higher level pr
get:them to specify
get:precedence of c
get:2.10.  Robustness
get:TCP implementat:ions will follow a general principle of robustness
get:conservative in
get:Transmission Cont
get:[Page 14]        
get:September 1981   
get:3.1.  Header Form
get:TCP segments ar
get:header carries 
get:destination hos
get:header, supplyi
get:division allows
get:TCP Header Form
get:0            
get:0 1 2 3 4 5 6
get:+-+-+-+-+-+-+-
get:|          Sou
get:+-+-+-+-+-+-+-
get:|             
get:+-+-+-+-+-+-+-
get:|             
get:+-+-+-+-+-+-+-
get:|  Data |     
get:| Offset| Rese
get:|       |     
get:+-+-+-+-+-+-+-
get:|           Ch
get:+-+-+-+-+-+-+-
get:|             
get:+-+-+-+-+-+-+-
get:|             
get:+-+-+-+-+-+-+-
get:Note th
get:Source Port:  1
get:The source po
get:Destination Por:t
get:The destinati
get:Transmission Cont
get:Functional Specif
get:Sequence Number:
get:The sequence 
get:when SYN is p
get:initial seque
get:Acknowledgment :Number
get:If the ACK co
get:next sequence
get:receive.  Onc
get:Data Offset:  4
get:The number of
get:the data begi
get:integral numb
get:Reserved:  6 bi
get:Reserved for 
get:Control Bits:  :6 bits (from left to right)
get:URG:  Urgent 
get:ACK:  Acknowl
get:PSH:  Push Fu
get:RST:  Reset t
get:SYN:  Synchro
get:FIN:  No more
get:Window:  16 bit
get:The number of
get:acknowledgmen
get:Checksum:  16 b
get:The checksum 
get:complement su
get:segment conta
get:checksummed, 
get:form a 16 bit
get:transmitted a
get:the checksum 
get:The checksum 
get:[Page 16]        
get:September 1981   
get:prefixed to t
get:Address, the 
get:This gives th
get:information i
get:across the TC
get:calls by the 
get:The TCP Len
get:octets (thi
get:computed), 
get:Urgent Pointer:
get:This field co
get:positive offs
get:urgent pointe
get:the urgent da
get:the URG contr
get:Options:  varia
get:Options may o
get:multiple of 8
get:checksum.  An
get:cases for the: format of an option
get:Case 1:  A 
get:Case 2:  An
get:th
get:The option-le
get:option-length
get:Note that the
get:field might i
get:End-of-Option
get:A TCP must im
get:Transmission Cont
get:Functional Specif
get:Currently def:ined options include (kind indicated in octal)
get:Kind     Le
get:----     --
get:0         
get:1         
get:2         
get:Specific Opti
get:End of Opti
get:+--------
get:|00000000
get:+--------
get:This opti
get:might not
get:the Data 
get:not the e
get:the optio
get:No-Operatio
get:+--------
get:|00000001
get:+--------
get:This opti
get:align the
get:There is 
get:receivers
get:not begin
get:Maximum Seg
get:+--------
get:|00000010
get:+--------
get:Kind=2  
get:[Page 18]        
get:September 1981   
get:Maximum S:egment Size Option Data
get:If this
get:receive
get:This fi
get:(i.e., 
get:option 
get:Padding:  varia
get:The TCP heade
get:and data begi
get:3.2.  Terminology
get:Before we can d
get:to introduce so
get:connection requ
get:of these variab
get:Transmission Co
get:TCB are the loc
get:precedence of t
get:buffers, pointe
get:In addition sev
get:sequence number
get:Send Sequence
get:SND.UNA - s
get:SND.NXT - s
get:SND.WND - s
get:SND.UP  - s
get:SND.WL1 - s
get:SND.WL2 - s
get:u
get:ISS     - i
get:Receive Seque
get:RCV.NXT - r
get:RCV.WND - r
get:RCV.UP  - r
get:IRS     - i
get:Transmission Cont
get:Functional Specif
get:The following d
get:the sequence sp
get:Send Sequence S
get:---
get:1 - old s
get:2 - seque
get:3 - seque
get:4 - futur
get:The send window
get:Receive Sequenc
get:1 - old s
get:2 - seque
get:3 - futur
get:The receive win
get:There are also 
get:take their valu
get:[Page 20]        
get:September 1981   
get:Current Segme
get:SEG.SEQ - s
get:SEG.ACK - s
get:SEG.LEN - s
get:SEG.WND - s
get:SEG.UP  - s
get:SEG.PRC - s
get:A connection pr
get:lifetime.  The :states are
get:ESTABLISHED, FI
get:TIME-WAIT, and 
get:because it repr
get:no connection. : Briefly the meanings of the states are
get:LISTEN - repr
get:TCP and port.
get:SYN-SENT - re
get:after having 
get:SYN-RECEIVED 
get:request ackno
get:connection re
get:ESTABLISHED -
get:delivered to 
get:of the connec
get:FIN-WAIT-1 - 
get:from the remo
get:termination r
get:FIN-WAIT-2 - 
get:from the remo
get:CLOSE-WAIT - 
get:from the loca
get:CLOSING - rep
get:acknowledgmen
get:LAST-ACK - re
get:connection te
get:(which includ
get:Transmission Cont
get:Functional Specif
get:TIME-WAIT - r
get:the remote TC
get:termination r
get:CLOSED - repr
get:A TCP connectio
get:events.  The ev
get:ABORT, and STAT
get:containing the 
get:The state diagr
get:with the causin
get:error condition
get:changes.  In a 
get:the reaction of
get:NOTE BENE:  thi
get:the total speci
get:[Page 22]        
get:September 1981   
get:+---------+     
get:|         |<----
get:|   SYN   |     
get:|   RCVD  |<----
get:|         |     
get:|         |-----
get:+---------+   rc
get:|           --
get:|             
get:|             
get:|  CLOSE      
get:| -------     
get:| snd FIN     
get:|             
get:V             
get:+---------+     
get:|  FIN    |<----
get:| WAIT-1  |-----
get:+---------+     
get:| rcv ACK of F
get:| ------------
get:V        x    
get:+---------+     
get:|FINWAIT-2|     
get:+---------+     
get:|             
get:|  rcv FIN    
get:|  -------    
get:\ snd ACK    
get:------------
get:Transmission Cont
get:Functional Specif
get:3.3.  Sequence Nu
get:A fundamental n
get:over a TCP conn
get:sequenced, each
get:mechanism emplo
get:number X indica
get:received.  This
get:detection in th
get:within a segmen
get:the header is t
get:numbered consec
get:It is essential
get:finite, though 
get:Since the space
get:numbers must be
get:preserves the r
get:2**32 - 1 to 0 
get:arithmetic, so 
get:comparison of s
get:(modulo 2**32).
get:The typical kin
get:perform include:
get:(a)  Determin
get:number s
get:(b)  Determin
get:have bee
get:retransm
get:(c)  Determin
get:which ar
get:receive 
get:[Page 24]        
get:September 1981   
get:In response to 
get:following compa
get:SND.UNA = old
get:SND.NXT = nex
get:SEG.ACK = ack
get:num
get:SEG.SEQ = fir
get:SEG.LEN = the
get:(co
get:SEG.SEQ+SEG.L
get:A new acknowled
get:the inequality :below holds
get:SND.UNA < SEG
get:A segment on th
get:of its sequence
get:acknowledgment 
get:When data is re:ceived the following comparisons are needed
get:RCV.NXT = nex
get:is the le
get:RCV.NXT+RCV.W
get:segment, 
get:SEG.SEQ = fir
get:SEG.SEQ+SEG.L
get:A segment is ju
get:RCV.NXT =< SE
get:RCV.NXT =< SE
get:Transmission Cont
get:Functional Specif
get:The first part 
get:segment falls i
get:if the end of t
get:either part of 
get:Actually, it is
get:windows and zer
get:acceptability o:f an incoming segment
get:Segment Recei
get:Length  Windo
get:------- -----
get:0       0 
get:0      >0 
get:>0       0 
get:>0      >0 
get:Note that when 
get:acceptable exce
get:maintain a zero
get:ACKs.  However,
get:process the RST
get:We have taken a
get:control informa
get:some control fl
get:and acknowledge
get:control will be
get:carried in the 
get:for implicitly 
get:are the only co
get:are used only a
get:purposes, the S
get:octet of the se
get:to occur after 
get:occurs.  The se
get:space occupying
get:sequence number
get:[Page 26]        
get:September 1981   
get:Initial Sequenc
get:The protocol pl
get:used over and o
get:sockets.  New i
get:incarnations of
get:-- "how does th
get:incarnations of
get:connection is b
get:connection brea
get:To avoid confus
get:connection from
get:be present in t
get:assure this, ev
get:sequence number
get:an initial sequ
get:new 32 bit ISN.
get:bit clock whose
get:microseconds.  
get:Since we assume
get:the Maximum Seg
get:hours we can re
get:For each connec
get:sequence number
get:the data sendin
get:learned during 
get:For a connectio
get:synchronize on 
get:an exchange of 
get:called "SYN" (f
get:shorthand, segm
get:Hence, the solu
get:initial sequenc
get:The synchroniza
get:sequence number
get:from the other 
get:initial sequenc
get:1) A --> B  S
get:2) A <-- B  A
get:3) A <-- B  S
get:4) A --> B  A
get:Transmission Cont
get:Functional Specif
get:Because steps 2
get:called the thre
get:A three way han
get:tied to a globa
get:mechanisms for 
get:no way of knowi
get:unless it remem
get:(which is not a
get:verify this SYN
get:clock-driven sc
get:Knowing When to
get:To be sure that
get:sequence number
get:the network, th
get:(MSL) before as
get:recovering from
get:lost.  For this
get:is an engineeri
get:it is desirable
get:sense, yet reta
get:not wait at all
get:than those rece
get:The TCP Quiet T
get:This specific
get:retaining any
get:each active (
get:TCP segments 
get:in the intern
get:paragraphs be
get:TCP implement
get:at the risk o
get:data rejected
get:TCPs consume 
get:entered into 
get:duplicate det
get:relies on the
get:the extent th
get:values before
get:been delivere
get:copies of the
get:such an assum
get:[Page 28]        
get:September 1981   
get:assigned the 
get:at the receiv
get:that each seg
get:as there are 
get:Under normal 
get:to emit and t
get:mistakenly us
get:been acknowle
get:data is drain
get:very large to
get:cause trouble
get:to use up 2**
get:lifetime in t
get:this is deeme
get:rates escalat
get:cycle time is
get:within reason
get:The basic dup
get:defeated, how
get:sequence numb
get:the TCP were 
get:upon crashing
get:connection (p
get:packets with 
get:packets still
get:incarnation o
get:about the seq
get:specification
get:before emitti
get:segments from
get:Even hosts wh
get:initial seque
get:(i.e., even i
get:number for ea
get:Suppose, for 
get:sequence numb
get:and that even
get:takes on a va
get:segment sent 
get:at this insta
get:incarnation o
get:S1 = ISN(t) -
get:connection!  
get:Transmission Cont
get:Functional Specif
get:duplicates in
get:of S1 may arr
get:the new incar
get:The problem i
get:crashed nor d
get:the system fr
get:One way to de
get:segments for 
get:time" specifi
get:willing to ri
get:destination m
get:Implementors 
get:connection by
get:informally im
get:Obviously, ev
get:necessary aft
get:To summarize:
get:numbers in th
get:"busy" or "in
get:block of spac
get:segment, if a
get:sequence numb
get:the previous 
get:number overla
get:3.4.  Establishin
get:The "three-way 
get:connection.  Th
get:responded to by
get:simultaneously 
get:occurs, each TC
get:acknowledgment 
get:an old duplicat
get:recipient, that
get:Proper use of "
get:Several example
get:examples do not
get:segments, this 
get:doesn't deliver
get:valid (i.e., th
get:connection reac
get:reduces the pos
get:[Page 30]        
get:September 1981   
get:implementation 
get:information for
get:The simplest th
get:figures should 
get:numbered for re
get:departure of a 
get:segment at B fr
get:Ellipsis (...) 
get:(delayed).  An 
get:Comments appear
get:the departure o
get:the center of e
get:form, with sequ
get:fields such as 
get:in the interest
get:TCP A      
get:1.  CLOSED     
get:2.  SYN-SENT   
get:3.  ESTABLISHED
get:4.  ESTABLISHED
get:5.  ESTABLISHED
get:Basic 3
get:In line 2 of fi
get:indicating that
get:number 100.  In
get:received from T
get:B is now expect
get:occupied sequen
get:At line 4, TCP 
get:TCP B's SYN; an
get:sequence number
get:because the ACK
get:would wind up A
get:Transmission Cont
get:Functional Specif
get:Simultaneous in
get:figure 8.  Each
get:TCP A      
get:1.  CLOSED     
get:2.  SYN-SENT   
get:3.  SYN-RECEIVE
get:4.             
get:5.  SYN-RECEIVE
get:6.  ESTABLISHED
get:7.             
get:S
get:The principle r
get:duplicate conne
get:this, a special
get:receiving TCP i
get:SYN-RECEIVED), 
get:If the TCP is i
get:FIN-WAIT-1, FIN
get:aborts the conn
get:case under "hal
get:[Page 32]        
get:September 1981   
get:TCP A      
get:1.  CLOSED     
get:2.  SYN-SENT   
get:3.  (duplicate)
get:4.  SYN-SENT   
get:5.  SYN-SENT   
get:6.             
get:7.  SYN-SENT   
get:8.  ESTABLISHED
get:As a simple exa
get:figure 9.  At l
get:cannot tell tha
get:(line 4).  TCP 
get:RST (reset) wit
get:believable.  TC
get:When the origin
get:synchronization
get:before the RST,
get:sent in both di
get:Half-Open Conne
get:An established 
get:TCPs has closed
get:knowledge of th
get:become desynchr
get:memory.  Such c
get:attempt is made
get:connections are
get:mildly involved
get:If at site A th
get:Transmission Cont
get:Functional Specif
get:user at site B 
get:receiving a res
get:site B TCP that
get:Assume that two
get:another when a 
get:Depending on th
get:that some error
get:A is likely to 
get:point.  As a re
get:or try to SEND 
get:case, it receiv
get:local (A's) TCP
get:will send a seg
get:example shown i
get:re-open the con
get:TCP A      
get:1.  (CRASH)    
get:2.  CLOSED     
get:3.  SYN-SENT --
get:4.  (!!)     <-
get:5.  SYN-SENT --
get:6.  SYN-SENT   
get:7.  SYN-SENT --
get:When the SYN ar
get:and the incomin
get:acknowledgment 
get:100).  TCP A se
get:sent and, being
get:detected a half
get:[Page 34]        
get:September 1981   
get:continue to try
get:reduced to the 
get:An interesting 
get:tries to send d
get:This is illustr
get:TCP A from TCP 
get:exists, so TCP 
get:processes it an
get:TCP A    
get:1.  (CRASH)    
get:2.  (??)    <--
get:3.          -->
get:Active
get:In figure 12, w
get:waiting for SYN
get:into action.  A
get:generate a RST 
get:the reset and r
get:TCP A      
get:1.  LISTEN     
get:2.       ... <S
get:3.  (??) <-- <S
get:4.       --> <S
get:5.  LISTEN     
get:Old Duplic
get:Transmission Cont
get:Functional Specif
get:A variety of ot
get:by the followin
get:Reset Generatio
get:As a general ru
get:which apparentl
get:must not be sen
get:There are three: groups of states
get:1.  If the co
get:in response t
get:particular, S
get:by this means
get:If the incomi
get:sequence numb
get:reset has seq
get:of the sequen
get:The connectio
get:2.  If the co
get:SYN-SENT, SYN
get:something not
get:if an incomin
get:does not exac
get:connection, a
get:If our SYN ha
get:incoming segm
get:either raise 
get:the system) o
get:incoming segm
get:continue as i
get:cannot raise 
get:detected in t
get:terminated th
get:incoming segm
get:match the loc
get:must be sent.
get:If the incomi
get:sequence numb
get:reset has seq
get:of the sequen
get:The connectio
get:[Page 36]        
get:September 1981   
get:3.  If the co
get:FIN-WAIT-1, F
get:any unaccepta
get:unacceptible 
get:acknowledgmen
get:and an acknow
get:to be receive
get:If an incomin
get:precedence wh
get:and precedenc
get:connection go
get:number from t
get:Reset Processin
get:In all states e
get:by checking the
get:is in the windo
get:to an initial S
get:acknowledges th
get:The receiver of
get:receiver was in
get:in SYN-RECEIVED
get:then the receiv
get:aborts the conn
get:was in any othe
get:and goes to the
get:3.5.  Closing a C
get:CLOSE is an ope
get:notion of closi
get:interpretation,
get:the receiving s
get:in a simplex fa
get:until he is tol
get:could initiate 
get:RECEIVE until s
get:has CLOSED.  We
get:RECEIVEs are ou
get:can terminate h
get:buffers SENT be
get:data in return 
get:successfully to
get:TCP.  Users mus
get:the TCP says no
get:Transmission Cont
get:Functional Specif
get:There are essen:tially three cases
get:1) The user i
get:2) The remote
get:3) Both users
get:Case 1:  Local 
get:In this case,
get:outgoing segm
get:accepted by t
get:are allowed i
get:will be retra
get:both acknowle
get:can ACK this 
get:send its own 
get:Case 2:  TCP re
get:If an unsolic
get:can ACK it an
get:user will res
get:the other TCP
get:until its own
get:connection.  
get:the connectio
get:Case 3:  both u
get:A simultaneou
get:FIN segments 
get:have been pro
get:has received.
get:[Page 38]        
get:September 1981   
get:TCP A      
get:1.  ESTABLISHED
get:FIN-WAIT-1 
get:3.  FIN-WAIT-2 
get:4.             
get:TIME-WAIT  
get:5.  TIME-WAIT  
get:CLOSED     
get:TCP A      
get:1.  ESTABLISHED
get:2.  (Close)    
get:FIN-WAIT-1 
get:3.  CLOSING    
get:4.  TIME-WAIT  
get:(2 MSL)    
get:CLOSED     
get:Transmission Cont
get:Functional Specif
get:3.6.  Precedence 
get:The intent is t
get:with exactly th
get:higher of the p
get:The precedence 
get:defined in the 
get:specification t
get:the security pa
get:user group, and
get:A connection at
get:lower precedenc
get:a connection du
get:acknowledgment 
get:Note that TCP m
get:precedence will
get:segments and po
get:The security pa
get:(the values wou
get:non-secure envi
get:parameters, tho
get:3.7.  Data Commun
get:Once the connec
get:exchange of seg
get:(checksum test 
get:retransmission 
get:Duplicate segme
get:As discussed in
get:certain tests o
get:segments to ver
get:The sender of d
get:the variable SN
get:sequence number
get:keeps track of 
get:variable SND.UN
get:sent has been a
get:When the sender
get:SND.NXT.  When 
get:sends an acknow
get:[Page 40]        
get:September 1981   
get:acknowledgment 
get:these variables
get:The amount by w
get:data in the seg
get:segments must c
get:The CLOSE user 
get:flag in an inco
get:Retransmission 
get:Because of the 
get:internetwork sy
get:retransmission 
get:for determining
get:An Example Re
get:Measure the
get:particular 
get:covers that
get:segments re
get:Time (RTT).:  Next compute a Smoothed Round Trip Time (SRTT) as
get:SRTT = ( 
get:and based o:n this, compute the retransmission timeout (RTO) as
get:RTO = min
get:where UBOUN
get:LBOUND is a
get:a smoothing
get:factor (e.g
get:The Communicati
get:The objective o
get:to stimulate th
get:permit the rece
get:the currently k
get:This mechanism 
get:the end of urge
get:the receive seq
get:must tell the u
get:number catches 
get:Transmission Cont
get:Functional Specif
get:into "normal mo
get:is in "urgent m
get:The method empl
get:transmitted.  T
get:meaningful and 
get:the urgent poin
get:no urgent data 
get:To send an urge
get:octet.  If the 
get:the urgent info
get:Managing the Wi
get:The window sent
get:numbers the sen
get:prepared to acc
get:the currently a
get:Indicating a la
get:arrives than ca
get:in excessive re
get:network and the
get:transmission of
get:between each ne
get:The mechanisms 
get:subsequently ad
get:that much data.
get:discouraged.  T
get:shrink the wind
get:on the part of 
get:The sending TCP
get:least one octet
get:sending TCP mus
get:the window is z
get:interval when t
get:guarantee that 
get:window will be 
get:When the receiv
get:still send an a
get:and current win
get:The sending TCP
get:[Page 42]        
get:September 1981   
get:which fit the c
get:retransmission 
get:In a connection
get:be carried in a
get:number so there
get:order.  This is
get:information to 
get:the data receiv
get:the window info
get:acknowledgment 
get:equal or greate
get:The window mana
get:communication p
get:Window Manage
get:Allocating 
get:many small 
get:fewer large
get:One suggest
get:defer updat
get:least X per
get:connection 
get:Another sug
get:segments by
get:sending dat
get:data must b
get:Note that t
get:retransmiss
get:acknowledgm
get:window info
get:new window 
get:The segment
get:of transmit
get:segment con
get:is accepted
get:If the send
get:window is n
get:alternating
get:pauses in t
get:Transmission Cont
get:Functional Specif
get:result in b
get:big pair. A
get:mostly smal
get:The suggest
get:actively at
get:windows, si
get:to many sma
get:There are of co:urse two interfaces of concern
get:and the TCP/low
get:of the user/TCP
get:protocol module
get:in detail by th
get:case that the l
get:that TCPs might
get:User/TCP Interf
get:The following
get:at best, fict
get:facilities.  
get:implementatio
get:TCPs must pro
get:that all TCP 
get:hierarchy.  T
get:required of a
get:TCP User Comm
get:The followi
get:interface. 
get:function ca
get:meant to ru
get:The user co
get:TCP must pe
get:Individual 
get:may provide
get:single call
get:automatical
get:issued by t
get:[Page 44]        
get:September 1981   
get:In providin
get:not only ac
get:processes i:t serves.  The latter consists of
get:(a) gener
get:remote cl
get:(b) repli
get:various t
get:Format:  
get:[, timeou
get:-> local 
get:We assume
get:processes
get:to use th
get:implement
get:for the s
get:lower lev
get:result of
get:able to m
get:process c
get:If the ac
get:call to L
get:have eith
get:particula
get:for any c
get:by the su
get:A transmi
get:filled in
get:On an act
get:synchroni
get:The timeo
get:for all d
get:delivered
get:will abor
get:The TCP o
get:the users
get:Transmission Cont
get:Functional Specif
get:precedenc
get:or securi
get:the defau
get:TCP will 
get:security/
get:the prece
get:requested
get:The prece
get:requested
get:request, 
get:connectio
get:this prec
get:allowed t
get:or that a
get:A local c
get:The local
get:for the c
get:Format:  
get:count, PU
get:This call
get:to be sen
get:not been 
get:implement
get:automatic
get:authorize
get:If the PU
get:to the re
get:segment c
get:the data 
get:transmiss
get:If the UR
get:will have
get:the urgen
get:pointer i
get:been cons
get:is to sti
get:indicate 
get:[Page 46]        
get:September 1981   
get:data has 
get:TCP signa
get:of times 
get:urgent da
get:If no for
get:connectio
get:has becom
get:local soc
get:foreign s
get:foreign s
get:knowing t
get:However, 
get:becomes s
get:STATUS ca
get:implement
get:socket is
get:If a time
get:connectio
get:In the si
get:the sendi
get:or the ti
get:is both s
get:connectio
get:offers po
get:sophistic
get:the proce
get:furthermo
get:Multiple 
get:the TCP w
get:We have i
get:which a S
get:pseudo-in
get:return a 
get:immediate
get:been ackn
get:assume ev
get:close any
get:kind (syn
get:signals, 
get:with spec
get:In order 
get:indicatio
get:Transmission Cont
get:Functional Specif
get:buffer ad
get:the SEND 
get:indicatin
get:calling p
get:Format:  
get:count) ->
get:This comm
get:specified
get:calling p
get:error is 
get:In the si
get:calling p
get:error occ
get:A more so
get:RECEIVEs 
get:segments 
get:the cost 
get:notify th
get:If enough
get:the PUSH 
get:The buffe
get:a PUSH is
get:returned 
get:If there 
get:as it arr
get:should th
get:additiona
get:call to R
get:may now l
get:urgent po
get:in the sa
get:boundary 
get:To distin
get:care of t
get:return co
get:count ind
get:Alternati
get:[Page 48]        
get:September 1981   
get:allocate 
get:with the 
get:Format:  
get:This comm
get:the conne
get:authorize
get:Closing c
get:the sense
get:retransmi
get:serviced.
get:calls, fo
get:to the de
get:continue 
get:may be tr
get:means "I 
get:receive a
get:not well 
get:of all it
get:into ABOR
get:The user 
get:initiativ
get:(e.g., re
get:destinati
get:Because c
get:foreign T
get:short tim
get:replies t
get:Close als
get:Format:  
get:This is a
get:excluded 
get:typically
get:This comm
get:informati:on
get:local s
get:Transmission Cont
get:Functional Specif
get:foreign
get:local c
get:receive
get:send wi
get:connect
get:number 
get:number 
get:urgent 
get:precede
get:securit
get:and tra
get:Depending
get:implement
get:available
get:authorize
get:prevents 
get:connectio
get:Format:  
get:This comm
get:aborted, 
get:be sent t
get:Depending
get:indicatio
get:receive a
get:TCP-to-User M
get:It is assum
get:means for t
get:the TCP doe
get:to the user
get:an error me
get:relating to
get:other user 
get:The followi:ng information is provided
get:Local Con
get:Response 
get:Buffer Ad
get:Byte coun
get:Push flag
get:Urgent fl
get:[Page 50]        
get:September 1981   
get:TCP/Lower-Level
get:The TCP calls
get:receive infor
get:internetwork 
get:Protocol (IP)
get:If the lower 
get:of service an
get:for these par:ameters
get:Type of Ser:vice = Precedence: routine, Delay: normal, Throughput
get:normal, Rel:iability
get:Time to Liv
get:Note that
get:Here we e
get:be delive
get:If the lower 
get:feature) and 
get:route informa
get:so that the s
get:checksum be t
get:also importan
get:Any lower lev
get:destination a
get:the "TCP leng
get:of IP and to 
get:Transmission Cont
get:Functional Specif
get:3.9.  Event Proce
get:The processing 
get:implementation.
get:processing sequ
get:section only in
get:The activity of
get:The events that: occur can be cast into three categories
get:arriving segmen
get:processing the 
get:cases the proce
get:Events that o:ccur
get:Arriving Se
get:SEGMENT A
get:USER TIME
get:RETRANSMI
get:TIME-WAIT
get:The model of th
get:immediate retur
get:pseudo interrup
get:means cause a d
get:Error responses
get:commands refere:ncing connections that do not exist receive "error
get:connection not 
get:Please note in 
get:acknowledgment 
get:of the sequence
get:equal to (modul
get:[Page 52]        
get:September 1981   
get:A natural way t
get:imagine that th
get:that their cont
get:in the sequence
get:and processed i
get:When a segment 
get:the segment to 
get:to be consisten
get:Note that if no
get:Transmission Cont
get:Functional Specif
get:CLOSED STATE 
get:Create a ne
get:state infor
get:socket, pre
get:information
get:unspecified
get:parameters 
get:precedence 
get:"error:  pr:ecedence not allowed" or "error
get:not allowed
get:active and :the foreign socket is unspecified, return "error
get:foreign soc
get:specified, 
get:(ISS) is se
get:is sent.  S
get:state, and 
get:If the call
get:return "err:or
get:no room to :create a new connection, return "error
get:resources".
get:If active a
get:connection 
get:segment, se
get:state.  Dat
get:queued for 
get:urgent bit 
get:segments se
get:queue the r:equest, respond with "error
get:If Foreign :socket was not specified, then return "error
get:socket unsp
get:[Page 54]        
get:September 1981   
get:SYN-SENT STAT
get:SYN-RECEIVED 
get:ESTABLISHED S
get:FIN-WAIT-1 ST
get:FIN-WAIT-2 ST
get:CLOSE-WAIT ST
get:CLOSING STATE
get:LAST-ACK STAT
get:TIME-WAIT STA
get:Return "err:or
get:Transmission Cont
get:Functional Specif
get:CLOSED STATE 
get:If the user
get:"error:  co
get:Otherwise, :return "error
get:If the fore
get:from passiv
get:SND.UNA to 
get:associated 
get:transmissio
get:requested i
get:as a result
get:request, re:spond with "error
get:Foreign soc:ket was not specified, then return "error
get:socket unsp
get:SYN-SENT STAT
get:SYN-RECEIVED 
get:Queue the d
get:If no space: to queue, respond with "error
get:resources".
get:ESTABLISHED S
get:CLOSE-WAIT ST
get:Segmentize 
get:acknowledgm
get:insufficien:t space to remember this buffer, simply return "error
get:insufficien
get:If the urge
get:urgent poin
get:[Page 56]        
get:September 1981   
get:FIN-WAIT-1 ST
get:FIN-WAIT-2 ST
get:CLOSING STATE
get:LAST-ACK STAT
get:TIME-WAIT STA
get:Return "err:or
get:Transmission Cont
get:Functional Specif
get:CLOSED STATE 
get:If the user
get:"error:  co
get:Otherwise r:eturn "error
get:SYN-SENT STAT
get:SYN-RECEIVED 
get:Queue for p
get:is no room :to queue this request, respond with "error
get:insufficien
get:ESTABLISHED S
get:FIN-WAIT-1 ST
get:FIN-WAIT-2 ST
get:If insuffic
get:request, qu
get:remember th:e RECEIVE, respond with "error
get:resources".
get:Reassemble 
get:to user.  M
get:If RCV.UP i
get:user notify
get:When the TC
get:that fact m
get:acknowledgm
get:described b
get:[Page 58]        
get:September 1981   
get:CLOSE-WAIT ST
get:Since the r
get:satisfied b
get:user.  If n
get:"error:  co
get:text can be
get:CLOSING STATE
get:LAST-ACK STAT
get:TIME-WAIT STA
get:Return "err:or
get:Transmission Cont
get:Functional Specif
get:CLOSED STATE 
get:If the user
get:"error:  co
get:Otherwise, :return "error
get:Any outstan:ding RECEIVEs are returned with "error
get:responses. 
get:SYN-SENT STAT
get:Delete the :TCB and return "error
get:queued SEND
get:SYN-RECEIVED 
get:If no SENDs
get:then form a
get:otherwise q
get:ESTABLISHED S
get:Queue this 
get:form a FIN 
get:FIN-WAIT-1 ST
get:FIN-WAIT-2 ST
get:Strictly sp:eaking, this is an error and should receive a "error
get:connection 
get:acceptable,
get:FIN may be 
get:[Page 60]        
get:September 1981   
get:CLOSE-WAIT ST
get:Queue this 
get:segmentized
get:CLOSING STATE
get:LAST-ACK STAT
get:TIME-WAIT STA
get:Respond wit:h "error
get:Transmission Cont
get:Functional Specif
get:CLOSED STATE 
get:If the user
get:"error:  co
get:Otherwise r:eturn "error
get:Any outstan:ding RECEIVEs should be returned with "error
get:connection 
get:SYN-SENT STAT
get:All queued 
get:notificatio
get:SYN-RECEIVED 
get:ESTABLISHED S
get:FIN-WAIT-1 ST
get:FIN-WAIT-2 ST
get:CLOSE-WAIT ST
get:Send a rese:t segment
get:<SEQ=SND.
get:All queued 
get:notificatio
get:RST formed 
get:TCB, enter 
get:CLOSING STATE
get:LAST-ACK STAT
get:TIME-WAIT STA
get:Respond wit
get:[Page 62]        
get:September 1981   
get:CLOSED STATE 
get:If the user
get:"error:  co
get:Otherwise r:eturn "error
get:Return "sta
get:SYN-SENT STAT
get:Return "sta
get:SYN-RECEIVED 
get:Return "sta
get:ESTABLISHED S
get:Return "sta
get:FIN-WAIT-1 ST
get:Return "sta
get:FIN-WAIT-2 ST
get:Return "sta
get:CLOSE-WAIT ST
get:Return "sta
get:CLOSING STATE
get:Return "sta
get:LAST-ACK STAT
get:Return "sta
get:Transmission Cont
get:Functional Specif
get:TIME-WAIT STA
get:Return "sta
get:[Page 64]        
get:September 1981   
get:SEGMENT ARRIVES
get:If the state 
get:all data in
get:segment con
get:containing 
get:acknowledgm
get:reset seque
get:If the ACK 
get:<SEQ=0><A
get:If the ACK 
get:<SEQ=SEG.
get:If the state 
get:first check
get:An incomi
get:second chec
get:Any ackno
get:the LISTE
get:for any a
get:formatted: as follows
get:<SEQ=SE
get:third check
get:If the SY
get:security/
get:match the
get:<SEQ=SE
get:Transmission Cont
get:Functional Specif
get:If the SE
get:the user 
get:send a re
get:<SEQ=SE
get:If the SE
get:Set RCV.N
get:control o
get:should be: selected and a SYN segment sent of the form
get:<SEQ=IS
get:SND.NXT i
get:state sho
get:incoming 
get:in the SY
get:not be re
get:the forei
get:unspecifi
get:fourth othe
get:Any other
get:must have
get:processin
get:it could 
get:incarnati
get:but if yo
get:If the state 
get:first check
get:If the AC
get:If SEG.
get:the RST
get:<SEQ=
get:and dis
get:If SND.
get:second chec
get:[Page 66]        
get:September 1981   
get:If the RS
get:If the :ACK was acceptable then signal the user "error
get:connect
get:delete 
get:and ret
get:third check
get:If the se
get:match the
get:If ther
get:<SEQ=
get:Otherwi
get:<SEQ=
get:If there 
get:The pre
get:TCB, if
get:<SEQ=
get:If there 
get:If the 
get:in the 
get:the pre
get:allowed
get:<SEQ=
get:If the 
get:in the 
get:If a rese
get:fourth chec
get:This step
get:no ACK, a
get:If the SY
get:Transmission Cont
get:Functional Specif
get:are accep
get:SEG.SEQ. 
get:is an ACK
get:are there
get:If SND.UN
get:state to 
get:<SEQ=SN
get:and send 
get:transmiss
get:text in t
get:below whe
get:Otherwise
get:<SEQ=IS
get:and send 
get:segment, 
get:has been 
get:fifth, if n
get:segment and
get:[Page 68]        
get:September 1981   
get:first check s
get:SYN-RECEIVE
get:ESTABLISHED
get:FIN-WAIT-1 
get:FIN-WAIT-2 
get:CLOSE-WAIT 
get:CLOSING STA
get:LAST-ACK ST
get:TIME-WAIT S
get:Segments 
get:are used 
get:done in S
get:boundary 
get:processed
get:There are
get:segment
get:Segment R
get:Length  W
get:------- -
get:0     
get:0     
get:>0     
get:>0     
get:If the RC
get:special a
get:If an inc
get:should be
get:the segme:nt and return)
get:<SEQ=SN
get:After sen
get:and retur
get:Transmission Cont
get:Functional Specif
get:In the fo
get:segment t
get:One could
get:trimming 
get:SYN and F
get:begins at
get:numbers m
get:second check 
get:SYN-RECEIVE
get:If the RS
get:If this
get:came fr
get:LISTEN 
get:this co
get:from SY
get:the use
get:on the 
get:active 
get:and ret
get:ESTABLISHED
get:If the RS
get:should re
get:flushed. 
get:"connecti
get:TCB, and 
get:CLOSING STA
get:LAST-ACK ST
get:If the RS
get:TCB, and 
get:[Page 70]        
get:September 1981   
get:third check s
get:SYN-RECEIVE
get:If the se
get:exactly m
get:then send
get:ESTABLISHED
get:If the se
get:exactly m
get:then send
get:receive "
get:flushed. 
get:"connecti
get:TCB, and 
get:Note this c
get:a segment f
get:different s
get:current con
get:fourth, check
get:SYN-RECEIVE
get:ESTABLISHED
get:FIN-WAIT ST
get:FIN-WAIT ST
get:CLOSE-WAIT 
get:CLOSING STA
get:LAST-ACK ST
get:TIME-WAIT S
get:If the SY
get:outstandi
get:all segme
get:receive a
get:the CLOSE
get:If the SY
get:and an ac
get:number ch
get:Transmission Cont
get:Functional Specif
get:fifth check t
get:if the ACK 
get:if the ACK 
get:SYN-RECEI
get:If SND.
get:and con
get:If th
get:reset
get:<SE
get:and s
get:ESTABLISH
get:If SND.
get:Any seg
get:entirel
get:positiv
get:fully a
get:"ok" re
get:(SEG.AC
get:somethi
get:drop th
get:If SND.
get:updated
get:SND.WL2
get:SND.WL1
get:Note th
get:records
get:SND.WND
get:the las
get:prevent
get:[Page 72]        
get:September 1981   
get:FIN-WAIT-
get:In addi
get:our FIN
get:process
get:FIN-WAIT-
get:In addi
get:the ret
get:acknowl
get:CLOSE-WAI
get:Do the 
get:CLOSING S
get:In addi
get:the ACK
get:otherwi
get:LAST-ACK 
get:The onl
get:acknowl
get:delete 
get:TIME-WAIT
get:The onl
get:retrans
get:the 2 M
get:sixth, check 
get:ESTABLISHED
get:FIN-WAIT-1 
get:FIN-WAIT-2 
get:If the UR
get:the user 
get:pointer (
get:user has 
get:mode") fo
get:signal th
get:Transmission Cont
get:Functional Specif
get:CLOSE-WAIT 
get:CLOSING STA
get:LAST-ACK ST
get:This shou
get:remote si
get:seventh, proc
get:ESTABLISHED
get:FIN-WAIT-1 
get:FIN-WAIT-2 
get:Once in t
get:text to u
get:into buff
get:empty.  I
get:the user 
get:has been 
get:When the 
get:user it m
get:Once the 
get:RCV.NXT o
get:apporopri
get:RCV.NXT a
get:Please no
get:Send an a:cknowledgment of the form
get:<SEQ=SN
get:This ackn
get:transmitt
get:[Page 74]        
get:September 1981   
get:CLOSE-WAIT 
get:CLOSING STA
get:LAST-ACK ST
get:TIME-WAIT S
get:This shou
get:remote si
get:eighth, check
get:Do not proc
get:since the S
get:If the FIN 
get:return any 
get:over the FI
get:FIN implies
get:SYN-RECEI
get:ESTABLISH
get:Enter t
get:FIN-WAIT-
get:If our 
get:enter T
get:timers;
get:FIN-WAIT-
get:Enter t
get:off the
get:CLOSE-WAI
get:Remain 
get:CLOSING S
get:Remain 
get:LAST-ACK 
get:Remain 
get:Transmission Cont
get:Functional Specif
get:TIME-WAIT
get:Remain 
get:timeout
get:[Page 76]        
get:September 1981   
get:For any state
get:the user "err:or
get:and for any o
get:state and ret
get:RETRANSMISSION 
get:For any state
get:the retransmi
get:retransmissio
get:TIME-WAIT TIMEO
get:If the time-w
get:enter the CLO
get:Transmission Cont
get:[Page 78]        
get:September 1981   
get:BBN Rep
get:a Host 
get:host an
get:A contr
get:indicat
get:specifi
get:is expe
get:previou
get:The uni
get:ARPANET
get:A unit 
get:IMPs.  
get:A logic
get:A messa
get:network
get:Destination Addre
get:The des
get:identif
get:A contr
get:indicat
get:occupyi
get:A porti
get:fragmen
get:A file 
get:Transmission Cont
get:Control
get:fragmen
get:A compu
get:from th
get:An Inte
get:by the 
get:The Int
get:ARPANET
get:A sourc
get:internet datagram
get:The uni
get:higher 
get:internet fragment
get:A porti
get:header.
get:Interne
get:The Ini
get:number 
get:The Ini
get:on a co
get:based p
get:The Ini
get:used by
get:Control
get:data.  
get:on an A
get:[Page 80]        
get:September 1981   
get:This is
get:data re
get:sequenc
get:of the 
get:The uni
get:An impl
get:procedu
get:Maximum
get:the int
get:An eigh
get:An Opti
get:may be 
get:primari
get:timesta
get:options
get:A packa
get:logical
get:logical
get:The por
get:output 
get:A progr
get:the poi
get:A contr
get:this se
get:receivi
get:receive
get:Transmission Cont
get:receive
get:receive
get:receive next sequ
get:This is
get:receive
get:This re
get:is will
get:segment
get:RCV.NXT
get:Segment
get:range a
get:A contr
get:that th
get:interac
get:sequenc
get:segment
get:it.  In
get:rise to
get:Real Ti:me Protocol
get:of time
get:segment
get:segment
get:segment
get:segment
get:segment
get:[Page 82]        
get:September 1981   
get:segment
get:A logic
get:unit of
get:segment acknowled
get:The seq
get:arrivin
get:The amo
get:includi
get:The num
get:This is
get:use on 
get:initial
get:each oc
get:This re
get:(receiv
get:window 
get:receivi
get:be emit
get:SND.UNA
get:between
get:send se
get:left se
get:send ur
get:segment
get:segment
get:Transmission Cont
get:send wi
get:An addr
get:is, the
get:The sou
get:A contr
get:number,
get:where t
get:Transmi
get:the sta
get:The pre
get:Transmi:ssion Control Protocol
get:reliabl
get:Type of
get:An Inte
get:for thi
get:A contr
get:indicat
get:urgent 
get:sequenc
get:pointer
get:A contr
get:field c
get:indicat
get:urgent 
get:[Page 84]        
get:September 1981   
get:[1]  Cerf, V., an
get:Intercommuni
get:Vol. COM-22,
get:[2]  Postel, J. (
get:Protocol Spe
get:Institute, S
get:[3]  Dalal, Y. an
get:Protocols", 
get:December 197
get:[4]  Postel, J., 
get:Institute, S
get:aRFC
get:aDe
get:aI
get:aSeptember 1981   
get:aPREFACE .....
get:a1.  INTRODUCTION 
get:a1.1  Motivation
get:a1.2  Scope ....
get:a1.3  About This
get:a1.4  Interfaces
get:a1.5  Operation 
get:a2.  PHILOSOPHY ..
get:a2.1  Elements o
get:a2.2  Model of O
get:a2.3  The Host E
get:a2.4  Interfaces
get:a2.5  Relation t
get:a2.6  Reliable C
get:a2.7  Connection
get:a2.8  Data Commu
get:a2.9  Precedence
get:a2.10 Robustness
get:a3.  FUNCTIONAL SP
get:a3.1  Header For
get:a3.2  Terminolog
get:a3.3  Sequence N
get:a3.4  Establishi
get:a3.5  Closing a 
get:a3.6  Precedence
get:a3.7  Data Commu
get:a3.8  Interfaces
get:a3.9  Event Proc
get:aGLOSSARY ........
get:aREFERENCES ......
get:aTransmission Cont
get:a[Page ii]        
get:aSeptember 1981   
get:aThis document des
get:a(TCP).  There hav
get:aspecification on 
get:adraws heavily fro
get:aboth in terms of 
get:aseveral details a
get:aand redescribes t
get:aRFC
get:aReplaces: RFC 761
get:aIENs:  129, 124, 
get:a55, 44, 40, 27, 2
get:aThe Transmission 
get:areliable host-to-
get:acommunication net
get:aThis document des
get:aTransmission Cont
get:ainterface to prog
get:aComputer commun
get:arole in militar
get:adocument focuse
get:acommunication r
get:acommunication u
get:acongestion, but
get:agovernment sect
get:aAs strategic an
get:adeveloped and d
get:ainterconnecting
get:acommunication p
get:aapplications.  
get:aDeputy Undersec
get:adeclared the Tr
get:abe a basis for 
get:astandardization
get:aTCP is a connec
get:afit into a laye
get:aapplications.  
get:acommunication b
get:adistinct but in
get:aassumptions are
get:aprotocols below
get:apotentially unr
get:aprotocols.  In 
get:awide spectrum o
get:aconnections to 
get:aTransmission Cont
get:aTCP is based on
get:aTCP fits into a
get:aInternet Protoc
get:areceive variabl
get:adatagram "envel
get:aaddressing sour
get:ainternet protoc
get:athe TCP segment
get:amultiple networ
get:aalso carries in
get:aand compartment
get:acommunicated en
get:aMuch of this do
get:awhich are co-re
get:acomputer.  Some
get:afront-end compu
get:aas well as netw
get:aan interface to
get:aimplementable e
get:ahost-to-front e
get:aThe TCP is inte
get:acommunication s
get:aintended to be 
get:a1.3.  About this 
get:aThis document r
get:aany TCP impleme
get:aprotocols and i
get:a[Page 2]         
get:aSeptember 1981   
get:asection offers 
get:aoperation.  Sec
get:adesign.  Sectio
get:arequired of TCP
get:auser calls, err
get:aThe TCP interfa
get:athe other side 
get:aThe interface b
get:aillustrated in 
get:acalls much like
get:aapplication pro
get:acalls to open a
get:aestablished con
get:aasynchronously 
get:aconsiderable fr
get:ainterfaces whic
get:aenvironment, a 
get:ainterface for a
get:aThe interface b
get:aunspecified exc
get:atwo levels can 
get:aTypically, one 
get:ainterface.  TCP
get:ainterconnected 
get:athroughout this
get:aAs noted above,
get:asecurable logic
get:aprocesses.  To 
get:acommunication s:ystem requires facilities in the following areas
get:aBasic Data Tr
get:aPrecedence an
get:aThe basic opera
get:athe following p
get:aTransmission Cont
get:aBasic Data Tran:sfer
get:aThe TCP is ab
get:adirection bet
get:asegments for 
get:athe TCPs deci
get:aSometimes use
get:asubmitted to 
get:afunction is d
get:aactually tran
get:apushed throug
get:apromptly forw
get:aThe exact pus
get:athe push func
get:aReliability
get:aThe TCP must 
get:adelivered out
get:ais achieved b
get:atransmitted, 
get:areceiving TCP
get:ainterval, the
get:anumbers are u
get:aout of order 
get:aadding a chec
get:areceiver, and
get:aAs long as th
get:asystem does n
get:aerrors will a
get:ainternet comm
get:aFlow Control
get:aTCP provides 
get:asent by the s
get:aevery ACK ind
get:athe last segm
get:aallowed numbe
get:areceiving fur
get:a[Page 4]         
get:aSeptember 1981   
get:aMultiplexing
get:aTo allow for 
get:acommunication
get:aaddresses or 
get:aand host addr
get:aa socket.  A 
get:aThat is, a so
get:aThe binding o
get:aHost.  Howeve
get:a(e.g., a "log
get:amade known to
get:athrough the k
get:aaddresses of 
get:aConnections
get:aThe reliabili
get:athat TCPs ini
get:aeach data str
get:asockets, sequ
get:aEach connecti
get:aidentifying i
get:aWhen two proc
get:aestablish a c
get:aside).  When 
get:aterminated or
get:aSince connect
get:aover the unre
get:amechanism wit
get:aerroneous ini
get:aPrecedence and :Security
get:aThe users of 
get:acommunication
get:athese feature
get:aTransmission Cont
get:a[Page 6]         
get:aSeptember 1981   
get:a2.1.  Elements of
get:aThe internetwor
get:awhich are in tu
get:athat the networ
get:alarge networks 
get:apacket switchin
get:aconsume message
get:anetworks, the g
get:acommunication s
get:aconnections bet
get:aThe term packet
get:atransaction bet
get:aexchanged withi
get:aHosts are compu
get:anetwork's point
get:aProcesses are v
get:aaccordance with
get:ain execution). 
get:aviewed as commu
get:aThus, all commu
get:aSince a process
get:astreams between
get:athat each proce
get:acommunicates wi
get:a2.2.  Model of Op
get:aProcesses trans
get:adata as argumen
get:asegments and ca
get:athe destination
get:ainto the receiv
get:aTCPs include co
get:aensure reliable
get:aThe model of in
get:aprotocol module
get:ato the local ne
get:ainside internet
get:ainternet module
get:athrough the loc
get:aThe packet swit
get:aTransmission Cont
get:aother operation
get:adestination int
get:aAt a gateway be
get:afrom its local 
get:athe internet da
get:athen "wrapped" 
get:arouted to the n
get:aA gateway is pe
get:ainternet datagr
get:athrough the nex
get:ainternet datagr
get:afurther broken 
get:ainternet datagr
get:ainternet module
get:aA destination i
get:a(after reassemb
get:adestination TCP
get:aThis simple mod
get:aimportant featu
get:ato the gateway 
get:aservice paramet
get:aIncluded in the
get:adatagram.  Data
get:ahost and gatewa
get:aproperly segreg
get:a2.3.  The Host En
get:aThe TCP is assu
get:aaccess the TCP 
get:amay call on oth
get:adata structures
get:acontrolled by a
get:anetwork device 
get:adatagram protoc
get:aThe mechanisms 
get:afront-end proce
get:ahost-to-front-e
get:athe type of TCP
get:a[Page 8]         
get:aSeptember 1981   
get:aThe TCP/user in
get:ato OPEN or CLOS
get:aSTATUS about a 
get:aprograms on the
get:afrom, and close
get:aThe TCP/interne
get:adatagrams addre
get:asystem.  These 
get:aservice, preced
get:a2.5.  Relation to
get:aThe following d
get:ahierarchy
get:a+------+ +
get:a|Telnet| |
get:a+------+ +
get:a|   
get:a+----
get:a| TCP
get:a+----
get:a| 
get:a+----
get:a|    
get:a+----
get:a+--
get:a|  
get:a+--
get:aIt is expected 
get:aprotocols effic
get:aprotocols like 
get:a2.6.  Reliable Co
get:aA stream of dat
get:aorder at the de
get:aTransmission Cont
get:aTransmission is
get:aacknowledgments
get:asequence number
get:asegment is tran
get:asequence number
get:ais the sequence
get:atransmissions i
get:asegment contain
get:astarts a timer;
get:asegment is dele
get:areceived before
get:aAn acknowledgme
get:adelivered to th
get:athe responsibil
get:aTo govern the f
get:aemployed.  The 
get:aThis window spe
get:aacknowledgment 
get:a2.7.  Connection 
get:aTo identify the
get:aprovides a port
get:aindependently b
get:aunique addresse
get:aidentifying the
get:awill be unique 
get:aA connection is
get:alocal socket ma
get:asockets.  A con
get:athat is, it is 
get:aTCPs are free t
get:aHowever, severa
get:aThere must be w
get:athe "appropriat
get:amay "own" ports
get:athe ports they 
get:aissue, but we e
get:auniquely alloca
get:aassociating the
get:aA connection is
get:aforeign socket 
get:a[Page 10]        
get:aSeptember 1981   
get:aconnection name
get:asubsequent call
get:aabout a connect
get:ais a data struc
get:aimplementation 
get:apointer to the 
get:awhether the con
get:abe passively wa
get:aA passive OPEN 
get:aconnection requ
get:aOften the proce
get:arequest from an
get:ais used to deno
get:aare allowed onl
get:aA service proce
get:aprocesses would
get:aforeign socket.
get:arequested a con
get:alocal socket we
get:aWell-known sock
get:aa socket addres
get:a"Telnet-Server"
get:asocket, and oth
get:aEntry, Text Gen
get:abeing for test 
get:aaccess to a "Lo
get:aat which a newl
get:awell-known sock
get:aof sockets to s
get:aProcesses can i
get:afrom other proc
get:abeen establishe
get:aother at the sa
get:ais critical for
get:acomponents act 
get:aThere are two p
get:apassive OPENs a
get:alocal passive O
get:acase, the match
get:aOPENs has left 
get:aforeign socket 
get:aOther possibili
get:aTransmission Cont
get:aIf there are se
get:asame local sock
get:awith the specif
get:aTCB exists, bef
get:aThe procedures 
get:acontrol flag an
get:aexchange has be
get:aA connection is
get:acontaining a SY
get:acommand.  The m
get:aconnection has 
get:awhen sequence n
get:aThe clearing of
get:ain this case ca
get:a2.8.  Data Commun
get:aThe data that f
get:aoctets.  The se
get:ain that call (a
get:athrough to the 
get:aA sending TCP i
get:asend that data 
get:afunction is sig
get:areceiving TCP s
get:athe sending TCP
get:aThere is no nec
get:aboundaries.  Th
get:asingle SEND cal
get:aThe purpose of 
get:afrom the sendin
get:arecord service.
get:aThere is a coup
get:aof data that cr
get:aassociated with
get:abuffer is retur
get:anot filled.  If
get:aPUSH is seen, t
get:aTCP also provid
get:aat some point f
get:a[Page 12]        
get:aSeptember 1981   
get:acurrently readi
get:adefine what the
get:aurgent data, bu
get:atake action to 
get:a2.9.  Precedence 
get:aThe TCP makes u
get:asecurity option
get:abasis to TCP us
get:aa multilevel se
get:ause only, and o
get:acompartment.  C
get:ausers may be li
get:aTCP modules whi
get:aproperly mark o
get:aprecedence.  Su
get:ahigher level pr
get:athem to specify
get:aprecedence of c
get:a2.10.  Robustness
get:aTCP implementat:ions will follow a general principle of robustness
get:aconservative in
get:aTransmission Cont
get:a[Page 14]        
get:aSeptember 1981   
get:a3.1.  Header Form
get:aTCP segments ar
get:aheader carries 
get:adestination hos
get:aheader, supplyi
get:adivision allows
get:aTCP Header Form
get:a0            
get:a0 1 2 3 4 5 6
get:a+-+-+-+-+-+-+-
get:a|          Sou
get:a+-+-+-+-+-+-+-
get:a|             
get:a+-+-+-+-+-+-+-
get:a|             
get:a+-+-+-+-+-+-+-
get:a|  Data |     
get:a| Offset| Rese
get:a|       |     
get:a+-+-+-+-+-+-+-
get:a|           Ch
get:a+-+-+-+-+-+-+-
get:a|             
get:a+-+-+-+-+-+-+-
get:a|             
get:a+-+-+-+-+-+-+-
get:aNote th
get:aSource Port:  1
get:aThe source po
get:aDestination Por:t
get:aThe destinati
get:aTransmission Cont
get:aFunctional Specif
get:aSequence Number:
get:aThe sequence 
get:awhen SYN is p
get:ainitial seque
get:aAcknowledgment :Number
get:aIf the ACK co
get:anext sequence
get:areceive.  Onc
get:aData Offset:  4
get:aThe number of
get:athe data begi
get:aintegral numb
get:aReserved:  6 bi
get:aReserved for 
get:aControl Bits:  :6 bits (from left to right)
get:aURG:  Urgent 
get:aACK:  Acknowl
get:aPSH:  Push Fu
get:aRST:  Reset t
get:aSYN:  Synchro
get:aFIN:  No more
get:aWindow:  16 bit
get:aThe number of
get:aacknowledgmen
get:aChecksum:  16 b
get:aThe checksum 
get:acomplement su
get:asegment conta
get:achecksummed, 
get:aform a 16 bit
get:atransmitted a
get:athe checksum 
get:aThe checksum 
get:a[Page 16]        
get:aSeptember 1981   
get:aprefixed to t
get:aAddress, the 
get:aThis gives th
get:ainformation i
get:aacross the TC
get:acalls by the 
get:aThe TCP Len
get:aoctets (thi
get:acomputed), 
get:aUrgent Pointer:
get:aThis field co
get:apositive offs
get:aurgent pointe
get:athe urgent da
get:athe URG contr
get:aOptions:  varia
get:aOptions may o
get:amultiple of 8
get:achecksum.  An
get:acases for the: format of an option
get:aCase 1:  A 
get:aCase 2:  An
get:ath
get:aThe option-le
get:aoption-length
get:aNote that the
get:afield might i
get:aEnd-of-Option
get:aA TCP must im
get:aTransmission Cont
get:aFunctional Specif
get:aCurrently def:ined options include (kind indicated in octal)
get:aKind     Le
get:a----     --
get:a0         
get:a1         
get:a2         
get:aSpecific Opti
get:aEnd of Opti
get:a+--------
get:a|00000000
get:a+--------
get:aThis opti
get:amight not
get:athe Data 
get:anot the e
get:athe optio
get:aNo-Operatio
get:a+--------
get:a|00000001
get:a+--------
get:aThis opti
get:aalign the
get:aThere is 
get:areceivers
get:anot begin
get:aMaximum Seg
get:a+--------
get:a|00000010
get:a+--------
get:aKind=2  
get:a[Page 18]        
get:aSeptember 1981   
get:aMaximum S:egment Size Option Data
get:aIf this
get:areceive
get:aThis fi
get:a(i.e., 
get:aoption 
get:aPadding:  varia
get:aThe TCP heade
get:aand data begi
get:a3.2.  Terminology
get:aBefore we can d
get:ato introduce so
get:aconnection requ
get:aof these variab
get:aTransmission Co
get:aTCB are the loc
get:aprecedence of t
get:abuffers, pointe
get:aIn addition sev
get:asequence number
get:aSend Sequence
get:aSND.UNA - s
get:aSND.NXT - s
get:aSND.WND - s
get:aSND.UP  - s
get:aSND.WL1 - s
get:aSND.WL2 - s
get:au
get:aISS     - i
get:aReceive Seque
get:aRCV.NXT - r
get:aRCV.WND - r
get:aRCV.UP  - r
get:aIRS     - i
get:aTransmission Cont
get:aFunctional Specif
get:aThe following d
get:athe sequence sp
get:aSend Sequence S
get:a---
get:a1 - old s
get:a2 - seque
get:a3 - seque
get:a4 - futur
get:aThe send window
get:aReceive Sequenc
get:a1 - old s
get:a2 - seque
get:a3 - futur
get:aThe receive win
get:aThere are also 
get:atake their valu
get:a[Page 20]        
get:aSeptember 1981   
get:aCurrent Segme
get:aSEG.SEQ - s
get:aSEG.ACK - s
get:aSEG.LEN - s
get:aSEG.WND - s
get:aSEG.UP  - s
get:aSEG.PRC - s
get:aA connection pr
get:alifetime.  The :states are
get:aESTABLISHED, FI
get:aTIME-WAIT, and 
get:abecause it repr
get:ano connection. : Briefly the meanings of the states are
get:aLISTEN - repr
get:aTCP and port.
get:aSYN-SENT - re
get:aafter having 
get:aSYN-RECEIVED 
get:arequest ackno
get:aconnection re
get:aESTABLISHED -
get:adelivered to 
get:aof the connec
get:aFIN-WAIT-1 - 
get:afrom the remo
get:atermination r
get:aFIN-WAIT-2 - 
get:afrom the remo
get:aCLOSE-WAIT - 
get:afrom the loca
get:aCLOSING - rep
get:aacknowledgmen
get:aLAST-ACK - re
get:aconnection te
get:a(which includ
get:aTransmission Cont
get:aFunctional Specif
get:aTIME-WAIT - r
get:athe remote TC
get:atermination r
get:aCLOSED - repr
get:aA TCP connectio
get:aevents.  The ev
get:aABORT, and STAT
get:acontaining the 
get:aThe state diagr
get:awith the causin
get:aerror condition
get:achanges.  In a 
get:athe reaction of
get:aNOTE BENE:  thi
get:athe total speci
get:a[Page 22]        
get:aSeptember 1981   
get:a+---------+     
get:a|         |<----
get:a|   SYN   |     
get:a|   RCVD  |<----
get:a|         |     
get:a|         |-----
get:a+---------+   rc
get:a|           --
get:a|             
get:a|             
get:a|  CLOSE      
get:a| -------     
get:a| snd FIN     
get:a|             
get:aV             
get:a+---------+     
get:a|  FIN    |<----
get:a| WAIT-1  |-----
get:a+---------+     
get:a| rcv ACK of F
get:a| ------------
get:aV        x    
get:a+---------+     
get:a|FINWAIT-2|     
get:a+---------+     
get:a|             
get:a|  rcv FIN    
get:a|  -------    
get:a\ snd ACK    
get:a------------
get:aTransmission Cont
get:aFunctional Specif
get:a3.3.  Sequence Nu
get:aA fundamental n
get:aover a TCP conn
get:asequenced, each
get:amechanism emplo
get:anumber X indica
get:areceived.  This
get:adetection in th
get:awithin a segmen
get:athe header is t
get:anumbered consec
get:aIt is essential
get:afinite, though 
get:aSince the space
get:anumbers must be
get:apreserves the r
get:a2**32 - 1 to 0 
get:aarithmetic, so 
get:acomparison of s
get:a(modulo 2**32).
get:aThe typical kin
get:aperform include:
get:a(a)  Determin
get:anumber s
get:a(b)  Determin
get:ahave bee
get:aretransm
get:a(c)  Determin
get:awhich ar
get:areceive 
get:a[Page 24]        
get:aSeptember 1981   
get:aIn response to 
get:afollowing compa
get:aSND.UNA = old
get:aSND.NXT = nex
get:aSEG.ACK = ack
get:anum
get:aSEG.SEQ = fir
get:aSEG.LEN = the
get:a(co
get:aSEG.SEQ+SEG.L
get:aA new acknowled
get:athe inequality :below holds
get:aSND.UNA < SEG
get:aA segment on th
get:aof its sequence
get:aacknowledgment 
get:aWhen data is re:ceived the following comparisons are needed
get:aRCV.NXT = nex
get:ais the le
get:aRCV.NXT+RCV.W
get:asegment, 
get:aSEG.SEQ = fir
get:aSEG.SEQ+SEG.L
get:aA segment is ju
get:aRCV.NXT =< SE
get:aRCV.NXT =< SE
get:aTransmission Cont
get:aFunctional Specif
get:aThe first part 
get:asegment falls i
get:aif the end of t
get:aeither part of 
get:aActually, it is
get:awindows and zer
get:aacceptability o:f an incoming segment
get:aSegment Recei
get:aLength  Windo
get:a------- -----
get:a0       0 
get:a0      >0 
get:a>0       0 
get:a>0      >0 
get:aNote that when 
get:aacceptable exce
get:amaintain a zero
get:aACKs.  However,
get:aprocess the RST
get:aWe have taken a
get:acontrol informa
get:asome control fl
get:aand acknowledge
get:acontrol will be
get:acarried in the 
get:afor implicitly 
get:aare the only co
get:aare used only a
get:apurposes, the S
get:aoctet of the se
get:ato occur after 
get:aoccurs.  The se
get:aspace occupying
get:asequence number
get:a[Page 26]        
get:aSeptember 1981   
get:aInitial Sequenc
get:aThe protocol pl
get:aused over and o
get:asockets.  New i
get:aincarnations of
get:a-- "how does th
get:aincarnations of
get:aconnection is b
get:aconnection brea
get:aTo avoid confus
get:aconnection from
get:abe present in t
get:aassure this, ev
get:asequence number
get:aan initial sequ
get:anew 32 bit ISN.
get:abit clock whose
get:amicroseconds.  
get:aSince we assume
get:athe Maximum Seg
get:ahours we can re
get:aFor each connec
get:asequence number
get:athe data sendin
get:alearned during 
get:aFor a connectio
get:asynchronize on 
get:aan exchange of 
get:acalled "SYN" (f
get:ashorthand, segm
get:aHence, the solu
get:ainitial sequenc
get:aThe synchroniza
get:asequence number
get:afrom the other 
get:ainitial sequenc
get:a1) A --> B  S
get:a2) A <-- B  A
get:a3) A <-- B  S
get:a4) A --> B  A
get:aTransmission Cont
get:aFunctional Specif
get:aBecause steps 2
get:acalled the thre
get:aA three way han
get:atied to a globa
get:amechanisms for 
get:ano way of knowi
get:aunless it remem
get:a(which is not a
get:averify this SYN
get:aclock-driven sc
get:aKnowing When to
get:aTo be sure that
get:asequence number
get:athe network, th
get:a(MSL) before as
get:arecovering from
get:alost.  For this
get:ais an engineeri
get:ait is desirable
get:asense, yet reta
get:anot wait at all
get:athan those rece
get:aThe TCP Quiet T
get:aThis specific
get:aretaining any
get:aeach active (
get:aTCP segments 
get:ain the intern
get:aparagraphs be
get:aTCP implement
get:aat the risk o
get:adata rejected
get:aTCPs consume 
get:aentered into 
get:aduplicate det
get:arelies on the
get:athe extent th
get:avalues before
get:abeen delivere
get:acopies of the
get:asuch an assum
get:a[Page 28]        
get:aSeptember 1981   
get:aassigned the 
get:aat the receiv
get:athat each seg
get:aas there are 
get:aUnder normal 
get:ato emit and t
get:amistakenly us
get:abeen acknowle
get:adata is drain
get:avery large to
get:acause trouble
get:ato use up 2**
get:alifetime in t
get:athis is deeme
get:arates escalat
get:acycle time is
get:awithin reason
get:aThe basic dup
get:adefeated, how
get:asequence numb
get:athe TCP were 
get:aupon crashing
get:aconnection (p
get:apackets with 
get:apackets still
get:aincarnation o
get:aabout the seq
get:aspecification
get:abefore emitti
get:asegments from
get:aEven hosts wh
get:ainitial seque
get:a(i.e., even i
get:anumber for ea
get:aSuppose, for 
get:asequence numb
get:aand that even
get:atakes on a va
get:asegment sent 
get:aat this insta
get:aincarnation o
get:aS1 = ISN(t) -
get:aconnection!  
get:aTransmission Cont
get:aFunctional Specif
get:aduplicates in
get:aof S1 may arr
get:athe new incar
get:aThe problem i
get:acrashed nor d
get:athe system fr
get:aOne way to de
get:asegments for 
get:atime" specifi
get:awilling to ri
get:adestination m
get:aImplementors 
get:aconnection by
get:ainformally im
get:aObviously, ev
get:anecessary aft
get:aTo summarize:
get:anumbers in th
get:a"busy" or "in
get:ablock of spac
get:asegment, if a
get:asequence numb
get:athe previous 
get:anumber overla
get:a3.4.  Establishin
get:aThe "three-way 
get:aconnection.  Th
get:aresponded to by
get:asimultaneously 
get:aoccurs, each TC
get:aacknowledgment 
get:aan old duplicat
get:arecipient, that
get:aProper use of "
get:aSeveral example
get:aexamples do not
get:asegments, this 
get:adoesn't deliver
get:avalid (i.e., th
get:aconnection reac
get:areduces the pos
get:a[Page 30]        
get:aSeptember 1981   
get:aimplementation 
get:ainformation for
get:aThe simplest th
get:afigures should 
get:anumbered for re
get:adeparture of a 
get:asegment at B fr
get:aEllipsis (...) 
get:a(delayed).  An 
get:aComments appear
get:athe departure o
get:athe center of e
get:aform, with sequ
get:afields such as 
get:ain the interest
get:aTCP A      
get:a1.  CLOSED     
get:a2.  SYN-SENT   
get:a3.  ESTABLISHED
get:a4.  ESTABLISHED
get:a5.  ESTABLISHED
get:aBasic 3
get:aIn line 2 of fi
get:aindicating that
get:anumber 100.  In
get:areceived from T
get:aB is now expect
get:aoccupied sequen
get:aAt line 4, TCP 
get:aTCP B's SYN; an
get:asequence number
get:abecause the ACK
get:awould wind up A
get:aTransmission Cont
get:aFunctional Specif
get:aSimultaneous in
get:afigure 8.  Each
get:aTCP A      
get:a1.  CLOSED     
get:a2.  SYN-SENT   
get:a3.  SYN-RECEIVE
get:a4.             
get:a5.  SYN-RECEIVE
get:a6.  ESTABLISHED
get:a7.             
get:aS
get:aThe principle r
get:aduplicate conne
get:athis, a special
get:areceiving TCP i
get:aSYN-RECEIVED), 
get:aIf the TCP is i
get:aFIN-WAIT-1, FIN
get:aaborts the conn
get:acase under "hal
get:a[Page 32]        
get:aSeptember 1981   
get:aTCP A      
get:a1.  CLOSED     
get:a2.  SYN-SENT   
get:a3.  (duplicate)
get:a4.  SYN-SENT   
get:a5.  SYN-SENT   
get:a6.             
get:a7.  SYN-SENT   
get:a8.  ESTABLISHED
get:aAs a simple exa
get:afigure 9.  At l
get:acannot tell tha
get:a(line 4).  TCP 
get:aRST (reset) wit
get:abelievable.  TC
get:aWhen the origin
get:asynchronization
get:abefore the RST,
get:asent in both di
get:aHalf-Open Conne
get:aAn established 
get:aTCPs has closed
get:aknowledge of th
get:abecome desynchr
get:amemory.  Such c
get:aattempt is made
get:aconnections are
get:amildly involved
get:aIf at site A th
get:aTransmission Cont
get:aFunctional Specif
get:auser at site B 
get:areceiving a res
get:asite B TCP that
get:aAssume that two
get:aanother when a 
get:aDepending on th
get:athat some error
get:aA is likely to 
get:apoint.  As a re
get:aor try to SEND 
get:acase, it receiv
get:alocal (A's) TCP
get:awill send a seg
get:aexample shown i
get:are-open the con
get:aTCP A      
get:a1.  (CRASH)    
get:a2.  CLOSED     
get:a3.  SYN-SENT --
get:a4.  (!!)     <-
get:a5.  SYN-SENT --
get:a6.  SYN-SENT   
get:a7.  SYN-SENT --
get:aWhen the SYN ar
get:aand the incomin
get:aacknowledgment 
get:a100).  TCP A se
get:asent and, being
get:adetected a half
get:a[Page 34]        
get:aSeptember 1981   
get:acontinue to try
get:areduced to the 
get:aAn interesting 
get:atries to send d
get:aThis is illustr
get:aTCP A from TCP 
get:aexists, so TCP 
get:aprocesses it an
get:aTCP A    
get:a1.  (CRASH)    
get:a2.  (??)    <--
get:a3.          -->
get:aActive
get:aIn figure 12, w
get:awaiting for SYN
get:ainto action.  A
get:agenerate a RST 
get:athe reset and r
get:aTCP A      
get:a1.  LISTEN     
get:a2.       ... <S
get:a3.  (??) <-- <S
get:a4.       --> <S
get:a5.  LISTEN     
get:aOld Duplic
get:aTransmission Cont
get:aFunctional Specif
get:aA variety of ot
get:aby the followin
get:aReset Generatio
get:aAs a general ru
get:awhich apparentl
get:amust not be sen
get:aThere are three: groups of states
get:a1.  If the co
get:ain response t
get:aparticular, S
get:aby this means
get:aIf the incomi
get:asequence numb
get:areset has seq
get:aof the sequen
get:aThe connectio
get:a2.  If the co
get:aSYN-SENT, SYN
get:asomething not
get:aif an incomin
get:adoes not exac
get:aconnection, a
get:aIf our SYN ha
get:aincoming segm
get:aeither raise 
get:athe system) o
get:aincoming segm
get:acontinue as i
get:acannot raise 
get:adetected in t
get:aterminated th
get:aincoming segm
get:amatch the loc
get:amust be sent.
get:aIf the incomi
get:asequence numb
get:areset has seq
get:aof the sequen
get:aThe connectio
get:a[Page 36]        
get:aSeptember 1981   
get:a3.  If the co
get:aFIN-WAIT-1, F
get:aany unaccepta
get:aunacceptible 
get:aacknowledgmen
get:aand an acknow
get:ato be receive
get:aIf an incomin
get:aprecedence wh
get:aand precedenc
get:aconnection go
get:anumber from t
get:aReset Processin
get:aIn all states e
get:aby checking the
get:ais in the windo
get:ato an initial S
get:aacknowledges th
get:aThe receiver of
get:areceiver was in
get:ain SYN-RECEIVED
get:athen the receiv
get:aaborts the conn
get:awas in any othe
get:aand goes to the
get:a3.5.  Closing a C
get:aCLOSE is an ope
get:anotion of closi
get:ainterpretation,
get:athe receiving s
get:ain a simplex fa
get:auntil he is tol
get:acould initiate 
get:aRECEIVE until s
get:ahas CLOSED.  We
get:aRECEIVEs are ou
get:acan terminate h
get:abuffers SENT be
get:adata in return 
get:asuccessfully to
get:aTCP.  Users mus
get:athe TCP says no
get:aTransmission Cont
get:aFunctional Specif
get:aThere are essen:tially three cases
get:a1) The user i
get:a2) The remote
get:a3) Both users
get:aCase 1:  Local 
get:aIn this case,
get:aoutgoing segm
get:aaccepted by t
get:aare allowed i
get:awill be retra
get:aboth acknowle
get:acan ACK this 
get:asend its own 
get:aCase 2:  TCP re
get:aIf an unsolic
get:acan ACK it an
get:auser will res
get:athe other TCP
get:auntil its own
get:aconnection.  
get:athe connectio
get:aCase 3:  both u
get:aA simultaneou
get:aFIN segments 
get:ahave been pro
get:ahas received.
get:a[Page 38]        
get:aSeptember 1981   
get:aTCP A      
get:a1.  ESTABLISHED
get:aFIN-WAIT-1 
get:a3.  FIN-WAIT-2 
get:a4.             
get:aTIME-WAIT  
get:a5.  TIME-WAIT  
get:aCLOSED     
get:aTCP A      
get:a1.  ESTABLISHED
get:a2.  (Close)    
get:aFIN-WAIT-1 
get:a3.  CLOSING    
get:a4.  TIME-WAIT  
get:a(2 MSL)    
get:aCLOSED     
get:aTransmission Cont
get:aFunctional Specif
get:a3.6.  Precedence 
get:aThe intent is t
get:awith exactly th
get:ahigher of the p
get:aThe precedence 
get:adefined in the 
get:aspecification t
get:athe security pa
get:auser group, and
get:aA connection at
get:alower precedenc
get:aa connection du
get:aacknowledgment 
get:aNote that TCP m
get:aprecedence will
get:asegments and po
get:aThe security pa
get:a(the values wou
get:anon-secure envi
get:aparameters, tho
get:a3.7.  Data Commun
get:aOnce the connec
get:aexchange of seg
get:a(checksum test 
get:aretransmission 
get:aDuplicate segme
get:aAs discussed in
get:acertain tests o
get:asegments to ver
get:aThe sender of d
get:athe variable SN
get:asequence number
get:akeeps track of 
get:avariable SND.UN
get:asent has been a
get:aWhen the sender
get:aSND.NXT.  When 
get:asends an acknow
get:a[Page 40]        
get:aSeptember 1981   
get:aacknowledgment 
get:athese variables
get:aThe amount by w
get:adata in the seg
get:asegments must c
get:aThe CLOSE user 
get:aflag in an inco
get:aRetransmission 
get:aBecause of the 
get:ainternetwork sy
get:aretransmission 
get:afor determining
get:aAn Example Re
get:aMeasure the
get:aparticular 
get:acovers that
get:asegments re
get:aTime (RTT).:  Next compute a Smoothed Round Trip Time (SRTT) as
get:aSRTT = ( 
get:aand based o:n this, compute the retransmission timeout (RTO) as
get:aRTO = min
get:awhere UBOUN
get:aLBOUND is a
get:aa smoothing
get:afactor (e.g
get:aThe Communicati
get:aThe objective o
get:ato stimulate th
get:apermit the rece
get:athe currently k
get:aThis mechanism 
get:athe end of urge
get:athe receive seq
get:amust tell the u
get:anumber catches 
get:aTransmission Cont
get:aFunctional Specif
get:ainto "normal mo
get:ais in "urgent m
get:aThe method empl
get:atransmitted.  T
get:ameaningful and 
get:athe urgent poin
get:ano urgent data 
get:aTo send an urge
get:aoctet.  If the 
get:athe urgent info
get:aManaging the Wi
get:aThe window sent
get:anumbers the sen
get:aprepared to acc
get:athe currently a
get:aIndicating a la
get:aarrives than ca
get:ain excessive re
get:anetwork and the
get:atransmission of
get:abetween each ne
get:aThe mechanisms 
get:asubsequently ad
get:athat much data.
get:adiscouraged.  T
get:ashrink the wind
get:aon the part of 
get:aThe sending TCP
get:aleast one octet
get:asending TCP mus
get:athe window is z
get:ainterval when t
get:aguarantee that 
get:awindow will be 
get:aWhen the receiv
get:astill send an a
get:aand current win
get:aThe sending TCP
get:a[Page 42]        
get:aSeptember 1981   
get:awhich fit the c
get:aretransmission 
get:aIn a connection
get:abe carried in a
get:anumber so there
get:aorder.  This is
get:ainformation to 
get:athe data receiv
get:athe window info
get:aacknowledgment 
get:aequal or greate
get:aThe window mana
get:acommunication p
get:aWindow Manage
get:aAllocating 
get:amany small 
get:afewer large
get:aOne suggest
get:adefer updat
get:aleast X per
get:aconnection 
get:aAnother sug
get:asegments by
get:asending dat
get:adata must b
get:aNote that t
get:aretransmiss
get:aacknowledgm
get:awindow info
get:anew window 
get:aThe segment
get:aof transmit
get:asegment con
get:ais accepted
get:aIf the send
get:awindow is n
get:aalternating
get:apauses in t
get:aTransmission Cont
get:aFunctional Specif
get:aresult in b
get:abig pair. A
get:amostly smal
get:aThe suggest
get:aactively at
get:awindows, si
get:ato many sma
get:aThere are of co:urse two interfaces of concern
get:aand the TCP/low
get:aof the user/TCP
get:aprotocol module
get:ain detail by th
get:acase that the l
get:athat TCPs might
get:aUser/TCP Interf
get:aThe following
get:aat best, fict
get:afacilities.  
get:aimplementatio
get:aTCPs must pro
get:athat all TCP 
get:ahierarchy.  T
get:arequired of a
get:aTCP User Comm
get:aThe followi
get:ainterface. 
get:afunction ca
get:ameant to ru
get:aThe user co
get:aTCP must pe
get:aIndividual 
get:amay provide
get:asingle call
get:aautomatical
get:aissued by t
get:a[Page 44]        
get:aSeptember 1981   
get:aIn providin
get:anot only ac
get:aprocesses i:t serves.  The latter consists of
get:a(a) gener
get:aremote cl
get:a(b) repli
get:avarious t
get:aFormat:  
get:a[, timeou
get:a-> local 
get:aWe assume
get:aprocesses
get:ato use th
get:aimplement
get:afor the s
get:alower lev
get:aresult of
get:aable to m
get:aprocess c
get:aIf the ac
get:acall to L
get:ahave eith
get:aparticula
get:afor any c
get:aby the su
get:aA transmi
get:afilled in
get:aOn an act
get:asynchroni
get:aThe timeo
get:afor all d
get:adelivered
get:awill abor
get:aThe TCP o
get:athe users
get:aTransmission Cont
get:aFunctional Specif
get:aprecedenc
get:aor securi
get:athe defau
get:aTCP will 
get:asecurity/
get:athe prece
get:arequested
get:aThe prece
get:arequested
get:arequest, 
get:aconnectio
get:athis prec
get:aallowed t
get:aor that a
get:aA local c
get:aThe local
get:afor the c
get:aFormat:  
get:acount, PU
get:aThis call
get:ato be sen
get:anot been 
get:aimplement
get:aautomatic
get:aauthorize
get:aIf the PU
get:ato the re
get:asegment c
get:athe data 
get:atransmiss
get:aIf the UR
get:awill have
get:athe urgen
get:apointer i
get:abeen cons
get:ais to sti
get:aindicate 
get:a[Page 46]        
get:aSeptember 1981   
get:adata has 
get:aTCP signa
get:aof times 
get:aurgent da
get:aIf no for
get:aconnectio
get:ahas becom
get:alocal soc
get:aforeign s
get:aforeign s
get:aknowing t
get:aHowever, 
get:abecomes s
get:aSTATUS ca
get:aimplement
get:asocket is
get:aIf a time
get:aconnectio
get:aIn the si
get:athe sendi
get:aor the ti
get:ais both s
get:aconnectio
get:aoffers po
get:asophistic
get:athe proce
get:afurthermo
get:aMultiple 
get:athe TCP w
get:aWe have i
get:awhich a S
get:apseudo-in
get:areturn a 
get:aimmediate
get:abeen ackn
get:aassume ev
get:aclose any
get:akind (syn
get:asignals, 
get:awith spec
get:aIn order 
get:aindicatio
get:aTransmission Cont
get:aFunctional Specif
get:abuffer ad
get:athe SEND 
get:aindicatin
get:acalling p
get:aFormat:  
get:acount) ->
get:aThis comm
get:aspecified
get:acalling p
get:aerror is 
get:aIn the si
get:acalling p
get:aerror occ
get:aA more so
get:aRECEIVEs 
get:asegments 
get:athe cost 
get:anotify th
get:aIf enough
get:athe PUSH 
get:aThe buffe
get:aa PUSH is
get:areturned 
get:aIf there 
get:aas it arr
get:ashould th
get:aadditiona
get:acall to R
get:amay now l
get:aurgent po
get:ain the sa
get:aboundary 
get:aTo distin
get:acare of t
get:areturn co
get:acount ind
get:aAlternati
get:a[Page 48]        
get:aSeptember 1981   
get:aallocate 
get:awith the 
get:aFormat:  
get:aThis comm
get:athe conne
get:aauthorize
get:aClosing c
get:athe sense
get:aretransmi
get:aserviced.
get:acalls, fo
get:ato the de
get:acontinue 
get:amay be tr
get:ameans "I 
get:areceive a
get:anot well 
get:aof all it
get:ainto ABOR
get:aThe user 
get:ainitiativ
get:a(e.g., re
get:adestinati
get:aBecause c
get:aforeign T
get:ashort tim
get:areplies t
get:aClose als
get:aFormat:  
get:aThis is a
get:aexcluded 
get:atypically
get:aThis comm
get:ainformati:on
get:alocal s
get:aTransmission Cont
get:aFunctional Specif
get:aforeign
get:alocal c
get:areceive
get:asend wi
get:aconnect
get:anumber 
get:anumber 
get:aurgent 
get:aprecede
get:asecurit
get:aand tra
get:aDepending
get:aimplement
get:aavailable
get:aauthorize
get:aprevents 
get:aconnectio
get:aFormat:  
get:aThis comm
get:aaborted, 
get:abe sent t
get:aDepending
get:aindicatio
get:areceive a
get:aTCP-to-User M
get:aIt is assum
get:ameans for t
get:athe TCP doe
get:ato the user
get:aan error me
get:arelating to
get:aother user 
get:aThe followi:ng information is provided
get:aLocal Con
get:aResponse 
get:aBuffer Ad
get:aByte coun
get:aPush flag
get:aUrgent fl
get:a[Page 50]        
get:aSeptember 1981   
get:aTCP/Lower-Level
get:aThe TCP calls
get:areceive infor
get:ainternetwork 
get:aProtocol (IP)
get:aIf the lower 
get:aof service an
get:afor these par:ameters
get:aType of Ser:vice = Precedence: routine, Delay: normal, Throughput
get:anormal, Rel:iability
get:aTime to Liv
get:aNote that
get:aHere we e
get:abe delive
get:aIf the lower 
get:afeature) and 
get:aroute informa
get:aso that the s
get:achecksum be t
get:aalso importan
get:aAny lower lev
get:adestination a
get:athe "TCP leng
get:aof IP and to 
get:aTransmission Cont
get:aFunctional Specif
get:a3.9.  Event Proce
get:aThe processing 
get:aimplementation.
get:aprocessing sequ
get:asection only in
get:aThe activity of
get:aThe events that: occur can be cast into three categories
get:aarriving segmen
get:aprocessing the 
get:acases the proce
get:aEvents that o:ccur
get:aArriving Se
get:aSEGMENT A
get:aUSER TIME
get:aRETRANSMI
get:aTIME-WAIT
get:aThe model of th
get:aimmediate retur
get:apseudo interrup
get:ameans cause a d
get:aError responses
get:acommands refere:ncing connections that do not exist receive "error
get:aconnection not 
get:aPlease note in 
get:aacknowledgment 
get:aof the sequence
get:aequal to (modul
get:a[Page 52]        
get:aSeptember 1981   
get:aA natural way t
get:aimagine that th
get:athat their cont
get:ain the sequence
get:aand processed i
get:aWhen a segment 
get:athe segment to 
get:ato be consisten
get:aNote that if no
get:aTransmission Cont
get:aFunctional Specif
get:aCLOSED STATE 
get:aCreate a ne
get:astate infor
get:asocket, pre
get:ainformation
get:aunspecified
get:aparameters 
get:aprecedence 
get:a"error:  pr:ecedence not allowed" or "error
get:anot allowed
get:aactive and :the foreign socket is unspecified, return "error
get:aforeign soc
get:aspecified, 
get:a(ISS) is se
get:ais sent.  S
get:astate, and 
get:aIf the call
get:areturn "err:or
get:ano room to :create a new connection, return "error
get:aresources".
get:aIf active a
get:aconnection 
get:asegment, se
get:astate.  Dat
get:aqueued for 
get:aurgent bit 
get:asegments se
get:aqueue the r:equest, respond with "error
get:aIf Foreign :socket was not specified, then return "error
get:asocket unsp
get:a[Page 54]        
get:aSeptember 1981   
get:aSYN-SENT STAT
get:aSYN-RECEIVED 
get:aESTABLISHED S
get:aFIN-WAIT-1 ST
get:aFIN-WAIT-2 ST
get:aCLOSE-WAIT ST
get:aCLOSING STATE
get:aLAST-ACK STAT
get:aTIME-WAIT STA
get:aReturn "err:or
get:aTransmission Cont
get:aFunctional Specif
get:aCLOSED STATE 
get:aIf the user
get:a"error:  co
get:aOtherwise, :return "error
get:aIf the fore
get:afrom passiv
get:aSND.UNA to 
get:aassociated 
get:atransmissio
get:arequested i
get:aas a result
get:arequest, re:spond with "error
get:aForeign soc:ket was not specified, then return "error
get:asocket unsp
get:aSYN-SENT STAT
get:aSYN-RECEIVED 
get:aQueue the d
get:aIf no space: to queue, respond with "error
get:aresources".
get:aESTABLISHED S
get:aCLOSE-WAIT ST
get:aSegmentize 
get:aacknowledgm
get:ainsufficien:t space to remember this buffer, simply return "error
get:ainsufficien
get:aIf the urge
get:aurgent poin
get:a[Page 56]        
get:aSeptember 1981   
get:aFIN-WAIT-1 ST
get:aFIN-WAIT-2 ST
get:aCLOSING STATE
get:aLAST-ACK STAT
get:aTIME-WAIT STA
get:aReturn "err:or
get:aTransmission Cont
get:aFunctional Specif
get:aCLOSED STATE 
get:aIf the user
get:a"error:  co
get:aOtherwise r:eturn "error
get:aSYN-SENT STAT
get:aSYN-RECEIVED 
get:aQueue for p
get:ais no room :to queue this request, respond with "error
get:ainsufficien
get:aESTABLISHED S
get:aFIN-WAIT-1 ST
get:aFIN-WAIT-2 ST
get:aIf insuffic
get:arequest, qu
get:aremember th:e RECEIVE, respond with "error
get:aresources".
get:aReassemble 
get:ato user.  M
get:aIf RCV.UP i
get:auser notify
get:aWhen the TC
get:athat fact m
get:aacknowledgm
get:adescribed b
get:a[Page 58]        
get:aSeptember 1981   
get:aCLOSE-WAIT ST
get:aSince the r
get:asatisfied b
get:auser.  If n
get:a"error:  co
get:atext can be
get:aCLOSING STATE
get:aLAST-ACK STAT
get:aTIME-WAIT STA
get:aReturn "err:or
get:aTransmission Cont
get:aFunctional Specif
get:aCLOSED STATE 
get:aIf the user
get:a"error:  co
get:aOtherwise, :return "error
get:aAny outstan:ding RECEIVEs are returned with "error
get:aresponses. 
get:aSYN-SENT STAT
get:aDelete the :TCB and return "error
get:aqueued SEND
get:aSYN-RECEIVED 
get:aIf no SENDs
get:athen form a
get:aotherwise q
get:aESTABLISHED S
get:aQueue this 
get:aform a FIN 
get:aFIN-WAIT-1 ST
get:aFIN-WAIT-2 ST
get:aStrictly sp:eaking, this is an error and should receive a "error
get:aconnection 
get:aacceptable,
get:aFIN may be 
get:a[Page 60]        
get:aSeptember 1981   
get:aCLOSE-WAIT ST
get:aQueue this 
get:asegmentized
get:aCLOSING STATE
get:aLAST-ACK STAT
get:aTIME-WAIT STA
get:aRespond wit:h "error
get:aTransmission Cont
get:aFunctional Specif
get:aCLOSED STATE 
get:aIf the user
get:a"error:  co
get:aOtherwise r:eturn "error
get:aAny outstan:ding RECEIVEs should be returned with "error
get:aconnection 
get:aSYN-SENT STAT
get:aAll queued 
get:anotificatio
get:aSYN-RECEIVED 
get:aESTABLISHED S
get:aFIN-WAIT-1 ST
get:aFIN-WAIT-2 ST
get:aCLOSE-WAIT ST
get:aSend a rese:t segment
get:a<SEQ=SND.
get:aAll queued 
get:anotificatio
get:aRST formed 
get:aTCB, enter 
get:aCLOSING STATE
get:aLAST-ACK STAT
get:aTIME-WAIT STA
get:aRespond wit
get:a[Page 62]        
get:aSeptember 1981   
get:aCLOSED STATE 
get:aIf the user
get:a"error:  co
get:aOtherwise r:eturn "error
get:aReturn "sta
get:aSYN-SENT STAT
get:aReturn "sta
get:aSYN-RECEIVED 
get:aReturn "sta
get:aESTABLISHED S
get:aReturn "sta
get:aFIN-WAIT-1 ST
get:aReturn "sta
get:aFIN-WAIT-2 ST
get:aReturn "sta
get:aCLOSE-WAIT ST
get:aReturn "sta
get:aCLOSING STATE
get:aReturn "sta
get:aLAST-ACK STAT
get:aReturn "sta
get:aTransmission Cont
get:aFunctional Specif
get:aTIME-WAIT STA
get:aReturn "sta
get:a[Page 64]        
get:aSeptember 1981   
get:aSEGMENT ARRIVES
get:aIf the state 
get:aall data in
get:asegment con
get:acontaining 
get:aacknowledgm
get:areset seque
get:aIf the ACK 
get:a<SEQ=0><A
get:aIf the ACK 
get:a<SEQ=SEG.
get:aIf the state 
get:afirst check
get:aAn incomi
get:asecond chec
get:aAny ackno
get:athe LISTE
get:afor any a
get:aformatted: as follows
get:a<SEQ=SE
get:athird check
get:aIf the SY
get:asecurity/
get:amatch the
get:a<SEQ=SE
get:aTransmission Cont
get:aFunctional Specif
get:aIf the SE
get:athe user 
get:asend a re
get:a<SEQ=SE
get:aIf the SE
get:aSet RCV.N
get:acontrol o
get:ashould be: selected and a SYN segment sent of the form
get:a<SEQ=IS
get:aSND.NXT i
get:astate sho
get:aincoming 
get:ain the SY
get:anot be re
get:athe forei
get:aunspecifi
get:afourth othe
get:aAny other
get:amust have
get:aprocessin
get:ait could 
get:aincarnati
get:abut if yo
get:aIf the state 
get:afirst check
get:aIf the AC
get:aIf SEG.
get:athe RST
get:a<SEQ=
get:aand dis
get:aIf SND.
get:asecond chec
get:a[Page 66]        
get:aSeptember 1981   
get:aIf the RS
get:aIf the :ACK was acceptable then signal the user "error
get:aconnect
get:adelete 
get:aand ret
get:athird check
get:aIf the se
get:amatch the
get:aIf ther
get:a<SEQ=
get:aOtherwi
get:a<SEQ=
get:aIf there 
get:aThe pre
get:aTCB, if
get:a<SEQ=
get:aIf there 
get:aIf the 
get:ain the 
get:athe pre
get:aallowed
get:a<SEQ=
get:aIf the 
get:ain the 
get:aIf a rese
get:afourth chec
get:aThis step
get:ano ACK, a
get:aIf the SY
get:aTransmission Cont
get:aFunctional Specif
get:aare accep
get:aSEG.SEQ. 
get:ais an ACK
get:aare there
get:aIf SND.UN
get:astate to 
get:a<SEQ=SN
get:aand send 
get:atransmiss
get:atext in t
get:abelow whe
get:aOtherwise
get:a<SEQ=IS
get:aand send 
get:asegment, 
get:ahas been 
get:afifth, if n
get:asegment and
get:a[Page 68]        
get:aSeptember 1981   
get:afirst check s
get:aSYN-RECEIVE
get:aESTABLISHED
get:aFIN-WAIT-1 
get:aFIN-WAIT-2 
get:aCLOSE-WAIT 
get:aCLOSING STA
get:aLAST-ACK ST
get:aTIME-WAIT S
get:aSegments 
get:aare used 
get:adone in S
get:aboundary 
get:aprocessed
get:aThere are
get:asegment
get:aSegment R
get:aLength  W
get:a------- -
get:a0     
get:a0     
get:a>0     
get:a>0     
get:aIf the RC
get:aspecial a
get:aIf an inc
get:ashould be
get:athe segme:nt and return)
get:a<SEQ=SN
get:aAfter sen
get:aand retur
get:aTransmission Cont
get:aFunctional Specif
get:aIn the fo
get:asegment t
get:aOne could
get:atrimming 
get:aSYN and F
get:abegins at
get:anumbers m
get:asecond check 
get:aSYN-RECEIVE
get:aIf the RS
get:aIf this
get:acame fr
get:aLISTEN 
get:athis co
get:afrom SY
get:athe use
get:aon the 
get:aactive 
get:aand ret
get:aESTABLISHED
get:aIf the RS
get:ashould re
get:aflushed. 
get:a"connecti
get:aTCB, and 
get:aCLOSING STA
get:aLAST-ACK ST
get:aIf the RS
get:aTCB, and 
get:a[Page 70]        
get:aSeptember 1981   
get:athird check s
get:aSYN-RECEIVE
get:aIf the se
get:aexactly m
get:athen send
get:aESTABLISHED
get:aIf the se
get:aexactly m
get:athen send
get:areceive "
get:aflushed. 
get:a"connecti
get:aTCB, and 
get:aNote this c
get:aa segment f
get:adifferent s
get:acurrent con
get:afourth, check
get:aSYN-RECEIVE
get:aESTABLISHED
get:aFIN-WAIT ST
get:aFIN-WAIT ST
get:aCLOSE-WAIT 
get:aCLOSING STA
get:aLAST-ACK ST
get:aTIME-WAIT S
get:aIf the SY
get:aoutstandi
get:aall segme
get:areceive a
get:athe CLOSE
get:aIf the SY
get:aand an ac
get:anumber ch
get:aTransmission Cont
get:aFunctional Specif
get:afifth check t
get:aif the ACK 
get:aif the ACK 
get:aSYN-RECEI
get:aIf SND.
get:aand con
get:aIf th
get:areset
get:a<SE
get:aand s
get:aESTABLISH
get:aIf SND.
get:aAny seg
get:aentirel
get:apositiv
get:afully a
get:a"ok" re
get:a(SEG.AC
get:asomethi
get:adrop th
get:aIf SND.
get:aupdated
get:aSND.WL2
get:aSND.WL1
get:aNote th
get:arecords
get:aSND.WND
get:athe las
get:aprevent
get:a[Page 72]        
get:aSeptember 1981   
get:aFIN-WAIT-
get:aIn addi
get:aour FIN
get:aprocess
get:aFIN-WAIT-
get:aIn addi
get:athe ret
get:aacknowl
get:aCLOSE-WAI
get:aDo the 
get:aCLOSING S
get:aIn addi
get:athe ACK
get:aotherwi
get:aLAST-ACK 
get:aThe onl
get:aacknowl
get:adelete 
get:aTIME-WAIT
get:aThe onl
get:aretrans
get:athe 2 M
get:asixth, check 
get:aESTABLISHED
get:aFIN-WAIT-1 
get:aFIN-WAIT-2 
get:aIf the UR
get:athe user 
get:apointer (
get:auser has 
get:amode") fo
get:asignal th
get:aTransmission Cont
get:aFunctional Specif
get:aCLOSE-WAIT 
get:aCLOSING STA
get:aLAST-ACK ST
get:aThis shou
get:aremote si
get:aseventh, proc
get:aESTABLISHED
get:aFIN-WAIT-1 
get:aFIN-WAIT-2 
get:aOnce in t
get:atext to u
get:ainto buff
get:aempty.  I
get:athe user 
get:ahas been 
get:aWhen the 
get:auser it m
get:aOnce the 
get:aRCV.NXT o
get:aapporopri
get:aRCV.NXT a
get:aPlease no
get:aSend an a:cknowledgment of the form
get:a<SEQ=SN
get:aThis ackn
get:atransmitt
get:a[Page 74]        
get:aSeptember 1981   
get:aCLOSE-WAIT 
get:aCLOSING STA
get:aLAST-ACK ST
get:aTIME-WAIT S
get:aThis shou
get:aremote si
get:aeighth, check
get:aDo not proc
get:asince the S
get:aIf the FIN 
get:areturn any 
get:aover the FI
get:aFIN implies
get:aSYN-RECEI
get:aESTABLISH
get:aEnter t
get:aFIN-WAIT-
get:aIf our 
get:aenter T
get:atimers;
get:aFIN-WAIT-
get:aEnter t
get:aoff the
get:aCLOSE-WAI
get:aRemain 
get:aCLOSING S
get:aRemain 
get:aLAST-ACK 
get:aRemain 
get:aTransmission Cont
get:aFunctional Specif
get:aTIME-WAIT
get:aRemain 
get:atimeout
get:a[Page 76]        
get:aSeptember 1981   
get:aFor any state
get:athe user "err:or
get:aand for any o
get:astate and ret
get:aRETRANSMISSION 
get:aFor any state
get:athe retransmi
get:aretransmissio
get:aTIME-WAIT TIMEO
get:aIf the time-w
get:aenter the CLO
get:aTransmission Cont
get:a[Page 78]        
get:aSeptember 1981   
get:aBBN Rep
get:aa Host 
get:ahost an
get:aA contr
get:aindicat
get:aspecifi
get:ais expe
get:apreviou
get:aThe uni
get:aARPANET
get:aA unit 
get:aIMPs.  
get:aA logic
get:aA messa
get:anetwork
get:aDestination Addre
get:aThe des
get:aidentif
get:aA contr
get:aindicat
get:aoccupyi
get:aA porti
get:afragmen
get:aA file 
get:aTransmission Cont
get:aControl
get:afragmen
get:aA compu
get:afrom th
get:aAn Inte
get:aby the 
get:aThe Int
get:aARPANET
get:aA sourc
get:ainternet datagram
get:aThe uni
get:ahigher 
get:ainternet fragment
get:aA porti
get:aheader.
get:aInterne
get:aThe Ini
get:anumber 
get:aThe Ini
get:aon a co
get:abased p
get:aThe Ini
get:aused by
get:aControl
get:adata.  
get:aon an A
get:a[Page 80]        
get:aSeptember 1981   
get:aThis is
get:adata re
get:asequenc
get:aof the 
get:aThe uni
get:aAn impl
get:aprocedu
get:aMaximum
get:athe int
get:aAn eigh
get:aAn Opti
get:amay be 
get:aprimari
get:atimesta
get:aoptions
get:aA packa
get:alogical
get:alogical
get:aThe por
get:aoutput 
get:aA progr
get:athe poi
get:aA contr
get:athis se
get:areceivi
get:areceive
get:aTransmission Cont
get:areceive
get:areceive
get:areceive next sequ
get:aThis is
get:areceive
get:aThis re
get:ais will
get:asegment
get:aRCV.NXT
get:aSegment
get:arange a
get:aA contr
get:athat th
get:ainterac
get:asequenc
get:asegment
get:ait.  In
get:arise to
get:aReal Ti:me Protocol
get:aof time
get:asegment
get:asegment
get:asegment
get:asegment
get:asegment
get:a[Page 82]        
get:aSeptember 1981   
get:asegment
get:aA logic
get:aunit of
get:asegment acknowled
get:aThe seq
get:aarrivin
get:aThe amo
get:aincludi
get:aThe num
get:aThis is
get:ause on 
get:ainitial
get:aeach oc
get:aThis re
get:a(receiv
get:awindow 
get:areceivi
get:abe emit
get:aSND.UNA
get:abetween
get:asend se
get:aleft se
get:asend ur
get:asegment
get:asegment
get:aTransmission Cont
get:asend wi
get:aAn addr
get:ais, the
get:aThe sou
get:aA contr
get:anumber,
get:awhere t
get:aTransmi
get:athe sta
get:aThe pre
get:aTransmi:ssion Control Protocol
get:areliabl
get:aType of
get:aAn Inte
get:afor thi
get:aA contr
get:aindicat
get:aurgent 
get:asequenc
get:apointer
get:aA contr
get:afield c
get:aindicat
get:aurgent 
get:a[Page 84]        
get:aSeptember 1981   
get:a[1]  Cerf, V., an
get:aIntercommuni
get:aVol. COM-22,
get:a[2]  Postel, J. (
get:aProtocol Spe
get:aInstitute, S
get:a[3]  Dalal, Y. an
get:aProtocols", 
get:aDecember 197
get:a[4]  Postel, J., 
get:aInstitute, S
get:bRFC
get:bDe
get:bI
get:bSeptember 1981   
get:bPREFACE .....
get:b1.  INTRODUCTION 
get:b1.1  Motivation
get:b1.2  Scope ....
get:b1.3  About This
get:b1.4  Interfaces
get:b1.5  Operation 
get:b2.  PHILOSOPHY ..
get:b2.1  Elements o
get:b2.2  Model of O
get:b2.3  The Host E
get:b2.4  Interfaces
get:b2.5  Relation t
get:b2.6  Reliable C
get:b2.7  Connection
get:b2.8  Data Commu
get:b2.9  Precedence
get:b2.10 Robustness
get:b3.  FUNCTIONAL SP
get:b3.1  Header For
get:b3.2  Terminolog
get:b3.3  Sequence N
get:b3.4  Establishi
get:b3.5  Closing a 
get:b3.6  Precedence
get:b3.7  Data Commu
get:b3.8  Interfaces
get:b3.9  Event Proc
get:bGLOSSARY ........
get:bREFERENCES ......
get:bTransmission Cont
get:b[Page ii]        
get:bSeptember 1981   
get:bThis document des
get:b(TCP).  There hav
get:bspecification on 
get:bdraws heavily fro
get:bboth in terms of 
get:bseveral details a
get:band redescribes t
get:bRFC
get:bReplaces: RFC 761
get:bIENs:  129, 124, 
get:b55, 44, 40, 27, 2
get:bThe Transmission 
get:breliable host-to-
get:bcommunication net
get:bThis document des
get:bTransmission Cont
get:binterface to prog
get:bComputer commun
get:brole in militar
get:bdocument focuse
get:bcommunication r
get:bcommunication u
get:bcongestion, but
get:bgovernment sect
get:bAs strategic an
get:bdeveloped and d
get:binterconnecting
get:bcommunication p
get:bapplications.  
get:bDeputy Undersec
get:bdeclared the Tr
get:bbe a basis for 
get:bstandardization
get:bTCP is a connec
get:bfit into a laye
get:bapplications.  
get:bcommunication b
get:bdistinct but in
get:bassumptions are
get:bprotocols below
get:bpotentially unr
get:bprotocols.  In 
get:bwide spectrum o
get:bconnections to 
get:bTransmission Cont
get:bTCP is based on
get:bTCP fits into a
get:bInternet Protoc
get:breceive variabl
get:bdatagram "envel
get:baddressing sour
get:binternet protoc
get:bthe TCP segment
get:bmultiple networ
get:balso carries in
get:band compartment
get:bcommunicated en
get:bMuch of this do
get:bwhich are co-re
get:bcomputer.  Some
get:bfront-end compu
get:bas well as netw
get:ban interface to
get:bimplementable e
get:bhost-to-front e
get:bThe TCP is inte
get:bcommunication s
get:bintended to be 
get:b1.3.  About this 
get:bThis document r
get:bany TCP impleme
get:bprotocols and i
get:b[Page 2]         
get:bSeptember 1981   
get:bsection offers 
get:boperation.  Sec
get:bdesign.  Sectio
get:brequired of TCP
get:buser calls, err
get:bThe TCP interfa
get:bthe other side 
get:bThe interface b
get:billustrated in 
get:bcalls much like
get:bapplication pro
get:bcalls to open a
get:bestablished con
get:basynchronously 
get:bconsiderable fr
get:binterfaces whic
get:benvironment, a 
get:binterface for a
get:bThe interface b
get:bunspecified exc
get:btwo levels can 
get:bTypically, one 
get:binterface.  TCP
get:binterconnected 
get:bthroughout this
get:bAs noted above,
get:bsecurable logic
get:bprocesses.  To 
get:bcommunication s:ystem requires facilities in the following areas
get:bBasic Data Tr
get:bPrecedence an
get:bThe basic opera
get:bthe following p
get:bTransmission Cont
get:bBasic Data Tran:sfer
get:bThe TCP is ab
get:bdirection bet
get:bsegments for 
get:bthe TCPs deci
get:bSometimes use
get:bsubmitted to 
get:bfunction is d
get:bactually tran
get:bpushed throug
get:bpromptly forw
get:bThe exact pus
get:bthe push func
get:bReliability
get:bThe TCP must 
get:bdelivered out
get:bis achieved b
get:btransmitted, 
get:breceiving TCP
get:binterval, the
get:bnumbers are u
get:bout of order 
get:badding a chec
get:breceiver, and
get:bAs long as th
get:bsystem does n
get:berrors will a
get:binternet comm
get:bFlow Control
get:bTCP provides 
get:bsent by the s
get:bevery ACK ind
get:bthe last segm
get:ballowed numbe
get:breceiving fur
get:b[Page 4]         
get:bSeptember 1981   
get:bMultiplexing
get:bTo allow for 
get:bcommunication
get:baddresses or 
get:band host addr
get:ba socket.  A 
get:bThat is, a so
get:bThe binding o
get:bHost.  Howeve
get:b(e.g., a "log
get:bmade known to
get:bthrough the k
get:baddresses of 
get:bConnections
get:bThe reliabili
get:bthat TCPs ini
get:beach data str
get:bsockets, sequ
get:bEach connecti
get:bidentifying i
get:bWhen two proc
get:bestablish a c
get:bside).  When 
get:bterminated or
get:bSince connect
get:bover the unre
get:bmechanism wit
get:berroneous ini
get:bPrecedence and :Security
get:bThe users of 
get:bcommunication
get:bthese feature
get:bTransmission Cont
get:b[Page 6]         
get:bSeptember 1981   
get:b2.1.  Elements of
get:bThe internetwor
get:bwhich are in tu
get:bthat the networ
get:blarge networks 
get:bpacket switchin
get:bconsume message
get:bnetworks, the g
get:bcommunication s
get:bconnections bet
get:bThe term packet
get:btransaction bet
get:bexchanged withi
get:bHosts are compu
get:bnetwork's point
get:bProcesses are v
get:baccordance with
get:bin execution). 
get:bviewed as commu
get:bThus, all commu
get:bSince a process
get:bstreams between
get:bthat each proce
get:bcommunicates wi
get:b2.2.  Model of Op
get:bProcesses trans
get:bdata as argumen
get:bsegments and ca
get:bthe destination
get:binto the receiv
get:bTCPs include co
get:bensure reliable
get:bThe model of in
get:bprotocol module
get:bto the local ne
get:binside internet
get:binternet module
get:bthrough the loc
get:bThe packet swit
get:bTransmission Cont
get:bother operation
get:bdestination int
get:bAt a gateway be
get:bfrom its local 
get:bthe internet da
get:bthen "wrapped" 
get:brouted to the n
get:bA gateway is pe
get:binternet datagr
get:bthrough the nex
get:binternet datagr
get:bfurther broken 
get:binternet datagr
get:binternet module
get:bA destination i
get:b(after reassemb
get:bdestination TCP
get:bThis simple mod
get:bimportant featu
get:bto the gateway 
get:bservice paramet
get:bIncluded in the
get:bdatagram.  Data
get:bhost and gatewa
get:bproperly segreg
get:b2.3.  The Host En
get:bThe TCP is assu
get:baccess the TCP 
get:bmay call on oth
get:bdata structures
get:bcontrolled by a
get:bnetwork device 
get:bdatagram protoc
get:bThe mechanisms 
get:bfront-end proce
get:bhost-to-front-e
get:bthe type of TCP
get:b[Page 8]         
get:bSeptember 1981   
get:bThe TCP/user in
get:bto OPEN or CLOS
get:bSTATUS about a 
get:bprograms on the
get:bfrom, and close
get:bThe TCP/interne
get:bdatagrams addre
get:bsystem.  These 
get:bservice, preced
get:b2.5.  Relation to
get:bThe following d
get:bhierarchy
get:b+------+ +
get:b|Telnet| |
get:b+------+ +
get:b|   
get:b+----
get:b| TCP
get:b+----
get:b| 
get:b+----
get:b|    
get:b+----
get:b+--
get:b|  
get:b+--
get:bIt is expected 
get:bprotocols effic
get:bprotocols like 
get:b2.6.  Reliable Co
get:bA stream of dat
get:border at the de
get:bTransmission Cont
get:bTransmission is
get:backnowledgments
get:bsequence number
get:bsegment is tran
get:bsequence number
get:bis the sequence
get:btransmissions i
get:bsegment contain
get:bstarts a timer;
get:bsegment is dele
get:breceived before
get:bAn acknowledgme
get:bdelivered to th
get:bthe responsibil
get:bTo govern the f
get:bemployed.  The 
get:bThis window spe
get:backnowledgment 
get:b2.7.  Connection 
get:bTo identify the
get:bprovides a port
get:bindependently b
get:bunique addresse
get:bidentifying the
get:bwill be unique 
get:bA connection is
get:blocal socket ma
get:bsockets.  A con
get:bthat is, it is 
get:bTCPs are free t
get:bHowever, severa
get:bThere must be w
get:bthe "appropriat
get:bmay "own" ports
get:bthe ports they 
get:bissue, but we e
get:buniquely alloca
get:bassociating the
get:bA connection is
get:bforeign socket 
get:b[Page 10]        
get:bSeptember 1981   
get:bconnection name
get:bsubsequent call
get:babout a connect
get:bis a data struc
get:bimplementation 
get:bpointer to the 
get:bwhether the con
get:bbe passively wa
get:bA passive OPEN 
get:bconnection requ
get:bOften the proce
get:brequest from an
get:bis used to deno
get:bare allowed onl
get:bA service proce
get:bprocesses would
get:bforeign socket.
get:brequested a con
get:blocal socket we
get:bWell-known sock
get:ba socket addres
get:b"Telnet-Server"
get:bsocket, and oth
get:bEntry, Text Gen
get:bbeing for test 
get:baccess to a "Lo
get:bat which a newl
get:bwell-known sock
get:bof sockets to s
get:bProcesses can i
get:bfrom other proc
get:bbeen establishe
get:bother at the sa
get:bis critical for
get:bcomponents act 
get:bThere are two p
get:bpassive OPENs a
get:blocal passive O
get:bcase, the match
get:bOPENs has left 
get:bforeign socket 
get:bOther possibili
get:bTransmission Cont
get:bIf there are se
get:bsame local sock
get:bwith the specif
get:bTCB exists, bef
get:bThe procedures 
get:bcontrol flag an
get:bexchange has be
get:bA connection is
get:bcontaining a SY
get:bcommand.  The m
get:bconnection has 
get:bwhen sequence n
get:bThe clearing of
get:bin this case ca
get:b2.8.  Data Commun
get:bThe data that f
get:boctets.  The se
get:bin that call (a
get:bthrough to the 
get:bA sending TCP i
get:bsend that data 
get:bfunction is sig
get:breceiving TCP s
get:bthe sending TCP
get:bThere is no nec
get:bboundaries.  Th
get:bsingle SEND cal
get:bThe purpose of 
get:bfrom the sendin
get:brecord service.
get:bThere is a coup
get:bof data that cr
get:bassociated with
get:bbuffer is retur
get:bnot filled.  If
get:bPUSH is seen, t
get:bTCP also provid
get:bat some point f
get:b[Page 12]        
get:bSeptember 1981   
get:bcurrently readi
get:bdefine what the
get:burgent data, bu
get:btake action to 
get:b2.9.  Precedence 
get:bThe TCP makes u
get:bsecurity option
get:bbasis to TCP us
get:ba multilevel se
get:buse only, and o
get:bcompartment.  C
get:busers may be li
get:bTCP modules whi
get:bproperly mark o
get:bprecedence.  Su
get:bhigher level pr
get:bthem to specify
get:bprecedence of c
get:b2.10.  Robustness
get:bTCP implementat:ions will follow a general principle of robustness
get:bconservative in
get:bTransmission Cont
get:b[Page 14]        
get:bSeptember 1981   
get:b3.1.  Header Form
get:bTCP segments ar
get:bheader carries 
get:bdestination hos
get:bheader, supplyi
get:bdivision allows
get:bTCP Header Form
get:b0            
get:b0 1 2 3 4 5 6
get:b+-+-+-+-+-+-+-
get:b|          Sou
get:b+-+-+-+-+-+-+-
get:b|             
get:b+-+-+-+-+-+-+-
get:b|             
get:b+-+-+-+-+-+-+-
get:b|  Data |     
get:b| Offset| Rese
get:b|       |     
get:b+-+-+-+-+-+-+-
get:b|           Ch
get:b+-+-+-+-+-+-+-
get:b|             
get:b+-+-+-+-+-+-+-
get:b|             
get:b+-+-+-+-+-+-+-
get:bNote th
get:bSource Port:  1
get:bThe source po
get:bDestination Por:t
get:bThe destinati
get:bTransmission Cont
get:bFunctional Specif
get:bSequence Number:
get:bThe sequence 
get:bwhen SYN is p
get:binitial seque
get:bAcknowledgment :Number
get:bIf the ACK co
get:bnext sequence
get:breceive.  Onc
get:bData Offset:  4
get:bThe number of
get:bthe data begi
get:bintegral numb
get:bReserved:  6 bi
get:bReserved for 
get:bControl Bits:  :6 bits (from left to right)
get:bURG:  Urgent 
get:bACK:  Acknowl
get:bPSH:  Push Fu
get:bRST:  Reset t
get:bSYN:  Synchro
get:bFIN:  No more
get:bWindow:  16 bit
get:bThe number of
get:backnowledgmen
get:bChecksum:  16 b
get:bThe checksum 
get:bcomplement su
get:bsegment conta
get:bchecksummed, 
get:bform a 16 bit
get:btransmitted a
get:bthe checksum 
get:bThe checksum 
get:b[Page 16]        
get:bSeptember 1981   
get:bprefixed to t
get:bAddress, the 
get:bThis gives th
get:binformation i
get:bacross the TC
get:bcalls by the 
get:bThe TCP Len
get:boctets (thi
get:bcomputed), 
get:bUrgent Pointer:
get:bThis field co
get:bpositive offs
get:burgent pointe
get:bthe urgent da
get:bthe URG contr
get:bOptions:  varia
get:bOptions may o
get:bmultiple of 8
get:bchecksum.  An
get:bcases for the: format of an option
get:bCase 1:  A 
get:bCase 2:  An
get:bth
get:bThe option-le
get:boption-length
get:bNote that the
get:bfield might i
get:bEnd-of-Option
get:bA TCP must im
get:bTransmission Cont
get:bFunctional Specif
get:bCurrently def:ined options include (kind indicated in octal)
get:bKind     Le
get:b----     --
get:b0         
get:b1         
get:b2         
get:bSpecific Opti
get:bEnd of Opti
get:b+--------
get:b|00000000
get:b+--------
get:bThis opti
get:bmight not
get:bthe Data 
get:bnot the e
get:bthe optio
get:bNo-Operatio
get:b+--------
get:b|00000001
get:b+--------
get:bThis opti
get:balign the
get:bThere is 
get:breceivers
get:bnot begin
get:bMaximum Seg
get:b+--------
get:b|00000010
get:b+--------
get:bKind=2  
get:b[Page 18]        
get:bSeptember 1981   
get:bMaximum S:egment Size Option Data
get:bIf this
get:breceive
get:bThis fi
get:b(i.e., 
get:boption 
get:bPadding:  varia
get:bThe TCP heade
get:band data begi
get:b3.2.  Terminology
get:bBefore we can d
get:bto introduce so
get:bconnection requ
get:bof these variab
get:bTransmission Co
get:bTCB are the loc
get:bprecedence of t
get:bbuffers, pointe
get:bIn addition sev
get:bsequence number
get:bSend Sequence
get:bSND.UNA - s
get:bSND.NXT - s
get:bSND.WND - s
get:bSND.UP  - s
get:bSND.WL1 - s
get:bSND.WL2 - s
get:bu
get:bISS     - i
get:bReceive Seque
get:bRCV.NXT - r
get:bRCV.WND - r
get:bRCV.UP  - r
get:bIRS     - i
get:bTransmission Cont
get:bFunctional Specif
get:bThe following d
get:bthe sequence sp
get:bSend Sequence S
get:b---
get:b1 - old s
get:b2 - seque
get:b3 - seque
get:b4 - futur
get:bThe send window
get:bReceive Sequenc
get:b1 - old s
get:b2 - seque
get:b3 - futur
get:bThe receive win
get:bThere are also 
get:btake their valu
get:b[Page 20]        
get:bSeptember 1981   
get:bCurrent Segme
get:bSEG.SEQ - s
get:bSEG.ACK - s
get:bSEG.LEN - s
get:bSEG.WND - s
get:bSEG.UP  - s
get:bSEG.PRC - s
get:bA connection pr
get:blifetime.  The :states are
get:bESTABLISHED, FI
get:bTIME-WAIT, and 
get:bbecause it repr
get:bno connection. : Briefly the meanings of the states are
get:bLISTEN - repr
get:bTCP and port.
get:bSYN-SENT - re
get:bafter having 
get:bSYN-RECEIVED 
get:brequest ackno
get:bconnection re
get:bESTABLISHED -
get:bdelivered to 
get:bof the connec
get:bFIN-WAIT-1 - 
get:bfrom the remo
get:btermination r
get:bFIN-WAIT-2 - 
get:bfrom the remo
get:bCLOSE-WAIT - 
get:bfrom the loca
get:bCLOSING - rep
get:backnowledgmen
get:bLAST-ACK - re
get:bconnection te
get:b(which includ
get:bTransmission Cont
get:bFunctional Specif
get:bTIME-WAIT - r
get:bthe remote TC
get:btermination r
get:bCLOSED - repr
get:bA TCP connectio
get:bevents.  The ev
get:bABORT, and STAT
get:bcontaining the 
get:bThe state diagr
get:bwith the causin
get:berror condition
get:bchanges.  In a 
get:bthe reaction of
get:bNOTE BENE:  thi
get:bthe total speci
get:b[Page 22]        
get:bSeptember 1981   
get:b+---------+     
get:b|         |<----
get:b|   SYN   |     
get:b|   RCVD  |<----
get:b|         |     
get:b|         |-----
get:b+---------+   rc
get:b|           --
get:b|             
get:b|             
get:b|  CLOSE      
get:b| -------     
get:b| snd FIN     
get:b|             
get:bV             
get:b+---------+     
get:b|  FIN    |<----
get:b| WAIT-1  |-----
get:b+---------+     
get:b| rcv ACK of F
get:b| ------------
get:bV        x    
get:b+---------+     
get:b|FINWAIT-2|     
get:b+---------+     
get:b|             
get:b|  rcv FIN    
get:b|  -------    
get:b\ snd ACK    
get:b------------
get:bTransmission Cont
get:bFunctional Specif
get:b3.3.  Sequence Nu
get:bA fundamental n
get:bover a TCP conn
get:bsequenced, each
get:bmechanism emplo
get:bnumber X indica
get:breceived.  This
get:bdetection in th
get:bwithin a segmen
get:bthe header is t
get:bnumbered consec
get:bIt is essential
get:bfinite, though 
get:bSince the space
get:bnumbers must be
get:bpreserves the r
get:b2**32 - 1 to 0 
get:barithmetic, so 
get:bcomparison of s
get:b(modulo 2**32).
get:bThe typical kin
get:bperform include:
get:b(a)  Determin
get:bnumber s
get:b(b)  Determin
get:bhave bee
get:bretransm
get:b(c)  Determin
get:bwhich ar
get:breceive 
get:b[Page 24]        
get:bSeptember 1981   
get:bIn response to 
get:bfollowing compa
get:bSND.UNA = old
get:bSND.NXT = nex
get:bSEG.ACK = ack
get:bnum
get:bSEG.SEQ = fir
get:bSEG.LEN = the
get:b(co
get:bSEG.SEQ+SEG.L
get:bA new acknowled
get:bthe inequality :below holds
get:bSND.UNA < SEG
get:bA segment on th
get:bof its sequence
get:backnowledgment 
get:bWhen data is re:ceived the following comparisons are needed
get:bRCV.NXT = nex
get:bis the le
get:bRCV.NXT+RCV.W
get:bsegment, 
get:bSEG.SEQ = fir
get:bSEG.SEQ+SEG.L
get:bA segment is ju
get:bRCV.NXT =< SE
get:bRCV.NXT =< SE
get:bTransmission Cont
get:bFunctional Specif
get:bThe first part 
get:bsegment falls i
get:bif the end of t
get:beither part of 
get:bActually, it is
get:bwindows and zer
get:bacceptability o:f an incoming segment
get:bSegment Recei
get:bLength  Windo
get:b------- -----
get:b0       0 
get:b0      >0 
get:b>0       0 
get:b>0      >0 
get:bNote that when 
get:bacceptable exce
get:bmaintain a zero
get:bACKs.  However,
get:bprocess the RST
get:bWe have taken a
get:bcontrol informa
get:bsome control fl
get:band acknowledge
get:bcontrol will be
get:bcarried in the 
get:bfor implicitly 
get:bare the only co
get:bare used only a
get:bpurposes, the S
get:boctet of the se
get:bto occur after 
get:boccurs.  The se
get:bspace occupying
get:bsequence number
get:b[Page 26]        
get:bSeptember 1981   
get:bInitial Sequenc
get:bThe protocol pl
get:bused over and o
get:bsockets.  New i
get:bincarnations of
get:b-- "how does th
get:bincarnations of
get:bconnection is b
get:bconnection brea
get:bTo avoid confus
get:bconnection from
get:bbe present in t
get:bassure this, ev
get:bsequence number
get:ban initial sequ
get:bnew 32 bit ISN.
get:bbit clock whose
get:bmicroseconds.  
get:bSince we assume
get:bthe Maximum Seg
get:bhours we can re
get:bFor each connec
get:bsequence number
get:bthe data sendin
get:blearned during 
get:bFor a connectio
get:bsynchronize on 
get:ban exchange of 
get:bcalled "SYN" (f
get:bshorthand, segm
get:bHence, the solu
get:binitial sequenc
get:bThe synchroniza
get:bsequence number
get:bfrom the other 
get:binitial sequenc
get:b1) A --> B  S
get:b2) A <-- B  A
get:b3) A <-- B  S
get:b4) A --> B  A
get:bTransmission Cont
get:bFunctional Specif
get:bBecause steps 2
get:bcalled the thre
get:bA three way han
get:btied to a globa
get:bmechanisms for 
get:bno way of knowi
get:bunless it remem
get:b(which is not a
get:bverify this SYN
get:bclock-driven sc
get:bKnowing When to
get:bTo be sure that
get:bsequence number
get:bthe network, th
get:b(MSL) before as
get:brecovering from
get:blost.  For this
get:bis an engineeri
get:bit is desirable
get:bsense, yet reta
get:bnot wait at all
get:bthan those rece
get:bThe TCP Quiet T
get:bThis specific
get:bretaining any
get:beach active (
get:bTCP segments 
get:bin the intern
get:bparagraphs be
get:bTCP implement
get:bat the risk o
get:bdata rejected
get:bTCPs consume 
get:bentered into 
get:bduplicate det
get:brelies on the
get:bthe extent th
get:bvalues before
get:bbeen delivere
get:bcopies of the
get:bsuch an assum
get:b[Page 28]        
get:bSeptember 1981   
get:bassigned the 
get:bat the receiv
get:bthat each seg
get:bas there are 
get:bUnder normal 
get:bto emit and t
get:bmistakenly us
get:bbeen acknowle
get:bdata is drain
get:bvery large to
get:bcause trouble
get:bto use up 2**
get:blifetime in t
get:bthis is deeme
get:brates escalat
get:bcycle time is
get:bwithin reason
get:bThe basic dup
get:bdefeated, how
get:bsequence numb
get:bthe TCP were 
get:bupon crashing
get:bconnection (p
get:bpackets with 
get:bpackets still
get:bincarnation o
get:babout the seq
get:bspecification
get:bbefore emitti
get:bsegments from
get:bEven hosts wh
get:binitial seque
get:b(i.e., even i
get:bnumber for ea
get:bSuppose, for 
get:bsequence numb
get:band that even
get:btakes on a va
get:bsegment sent 
get:bat this insta
get:bincarnation o
get:bS1 = ISN(t) -
get:bconnection!  
get:bTransmission Cont
get:bFunctional Specif
get:bduplicates in
get:bof S1 may arr
get:bthe new incar
get:bThe problem i
get:bcrashed nor d
get:bthe system fr
get:bOne way to de
get:bsegments for 
get:btime" specifi
get:bwilling to ri
get:bdestination m
get:bImplementors 
get:bconnection by
get:binformally im
get:bObviously, ev
get:bnecessary aft
get:bTo summarize:
get:bnumbers in th
get:b"busy" or "in
get:bblock of spac
get:bsegment, if a
get:bsequence numb
get:bthe previous 
get:bnumber overla
get:b3.4.  Establishin
get:bThe "three-way 
get:bconnection.  Th
get:bresponded to by
get:bsimultaneously 
get:boccurs, each TC
get:backnowledgment 
get:ban old duplicat
get:brecipient, that
get:bProper use of "
get:bSeveral example
get:bexamples do not
get:bsegments, this 
get:bdoesn't deliver
get:bvalid (i.e., th
get:bconnection reac
get:breduces the pos
get:b[Page 30]        
get:bSeptember 1981   
get:bimplementation 
get:binformation for
get:bThe simplest th
get:bfigures should 
get:bnumbered for re
get:bdeparture of a 
get:bsegment at B fr
get:bEllipsis (...) 
get:b(delayed).  An 
get:bComments appear
get:bthe departure o
get:bthe center of e
get:bform, with sequ
get:bfields such as 
get:bin the interest
get:bTCP A      
get:b1.  CLOSED     
get:b2.  SYN-SENT   
get:b3.  ESTABLISHED
get:b4.  ESTABLISHED
get:b5.  ESTABLISHED
get:bBasic 3
get:bIn line 2 of fi
get:bindicating that
get:bnumber 100.  In
get:breceived from T
get:bB is now expect
get:boccupied sequen
get:bAt line 4, TCP 
get:bTCP B's SYN; an
get:bsequence number
get:bbecause the ACK
get:bwould wind up A
get:bTransmission Cont
get:bFunctional Specif
get:bSimultaneous in
get:bfigure 8.  Each
get:bTCP A      
get:b1.  CLOSED     
get:b2.  SYN-SENT   
get:b3.  SYN-RECEIVE
get:b4.             
get:b5.  SYN-RECEIVE
get:b6.  ESTABLISHED
get:b7.             
get:bS
get:bThe principle r
get:bduplicate conne
get:bthis, a special
get:breceiving TCP i
get:bSYN-RECEIVED), 
get:bIf the TCP is i
get:bFIN-WAIT-1, FIN
get:baborts the conn
get:bcase under "hal
get:b[Page 32]        
get:bSeptember 1981   
get:bTCP A      
get:b1.  CLOSED     
get:b2.  SYN-SENT   
get:b3.  (duplicate)
get:b4.  SYN-SENT   
get:b5.  SYN-SENT   
get:b6.             
get:b7.  SYN-SENT   
get:b8.  ESTABLISHED
get:bAs a simple exa
get:bfigure 9.  At l
get:bcannot tell tha
get:b(line 4).  TCP 
get:bRST (reset) wit
get:bbelievable.  TC
get:bWhen the origin
get:bsynchronization
get:bbefore the RST,
get:bsent in both di
get:bHalf-Open Conne
get:bAn established 
get:bTCPs has closed
get:bknowledge of th
get:bbecome desynchr
get:bmemory.  Such c
get:battempt is made
get:bconnections are
get:bmildly involved
get:bIf at site A th
get:bTransmission Cont
get:bFunctional Specif
get:buser at site B 
get:breceiving a res
get:bsite B TCP that
get:bAssume that two
get:banother when a 
get:bDepending on th
get:bthat some error
get:bA is likely to 
get:bpoint.  As a re
get:bor try to SEND 
get:bcase, it receiv
get:blocal (A's) TCP
get:bwill send a seg
get:bexample shown i
get:bre-open the con
get:bTCP A      
get:b1.  (CRASH)    
get:b2.  CLOSED     
get:b3.  SYN-SENT --
get:b4.  (!!)     <-
get:b5.  SYN-SENT --
get:b6.  SYN-SENT   
get:b7.  SYN-SENT --
get:bWhen the SYN ar
get:band the incomin
get:backnowledgment 
get:b100).  TCP A se
get:bsent and, being
get:bdetected a half
get:b[Page 34]        
get:bSeptember 1981   
get:bcontinue to try
get:breduced to the 
get:bAn interesting 
get:btries to send d
get:bThis is illustr
get:bTCP A from TCP 
get:bexists, so TCP 
get:bprocesses it an
get:bTCP A    
get:b1.  (CRASH)    
get:b2.  (??)    <--
get:b3.          -->
get:bActive
get:bIn figure 12, w
get:bwaiting for SYN
get:binto action.  A
get:bgenerate a RST 
get:bthe reset and r
get:bTCP A      
get:b1.  LISTEN     
get:b2.       ... <S
get:b3.  (??) <-- <S
get:b4.       --> <S
get:b5.  LISTEN     
get:bOld Duplic
get:bTransmission Cont
get:bFunctional Specif
get:bA variety of ot
get:bby the followin
get:bReset Generatio
get:bAs a general ru
get:bwhich apparentl
get:bmust not be sen
get:bThere are three: groups of states
get:b1.  If the co
get:bin response t
get:bparticular, S
get:bby this means
get:bIf the incomi
get:bsequence numb
get:breset has seq
get:bof the sequen
get:bThe connectio
get:b2.  If the co
get:bSYN-SENT, SYN
get:bsomething not
get:bif an incomin
get:bdoes not exac
get:bconnection, a
get:bIf our SYN ha
get:bincoming segm
get:beither raise 
get:bthe system) o
get:bincoming segm
get:bcontinue as i
get:bcannot raise 
get:bdetected in t
get:bterminated th
get:bincoming segm
get:bmatch the loc
get:bmust be sent.
get:bIf the incomi
get:bsequence numb
get:breset has seq
get:bof the sequen
get:bThe connectio
get:b[Page 36]        
get:bSeptember 1981   
get:b3.  If the co
get:bFIN-WAIT-1, F
get:bany unaccepta
get:bunacceptible 
get:backnowledgmen
get:band an acknow
get:bto be receive
get:bIf an incomin
get:bprecedence wh
get:band precedenc
get:bconnection go
get:bnumber from t
get:bReset Processin
get:bIn all states e
get:bby checking the
get:bis in the windo
get:bto an initial S
get:backnowledges th
get:bThe receiver of
get:breceiver was in
get:bin SYN-RECEIVED
get:bthen the receiv
get:baborts the conn
get:bwas in any othe
get:band goes to the
get:b3.5.  Closing a C
get:bCLOSE is an ope
get:bnotion of closi
get:binterpretation,
get:bthe receiving s
get:bin a simplex fa
get:buntil he is tol
get:bcould initiate 
get:bRECEIVE until s
get:bhas CLOSED.  We
get:bRECEIVEs are ou
get:bcan terminate h
get:bbuffers SENT be
get:bdata in return 
get:bsuccessfully to
get:bTCP.  Users mus
get:bthe TCP says no
get:bTransmission Cont
get:bFunctional Specif
get:bThere are essen:tially three cases
get:b1) The user i
get:b2) The remote
get:b3) Both users
get:bCase 1:  Local 
get:bIn this case,
get:boutgoing segm
get:baccepted by t
get:bare allowed i
get:bwill be retra
get:bboth acknowle
get:bcan ACK this 
get:bsend its own 
get:bCase 2:  TCP re
get:bIf an unsolic
get:bcan ACK it an
get:buser will res
get:bthe other TCP
get:buntil its own
get:bconnection.  
get:bthe connectio
get:bCase 3:  both u
get:bA simultaneou
get:bFIN segments 
get:bhave been pro
get:bhas received.
get:b[Page 38]        
get:bSeptember 1981   
get:bTCP A      
get:b1.  ESTABLISHED
get:bFIN-WAIT-1 
get:b3.  FIN-WAIT-2 
get:b4.             
get:bTIME-WAIT  
get:b5.  TIME-WAIT  
get:bCLOSED     
get:bTCP A      
get:b1.  ESTABLISHED
get:b2.  (Close)    
get:bFIN-WAIT-1 
get:b3.  CLOSING    
get:b4.  TIME-WAIT  
get:b(2 MSL)    
get:bCLOSED     
get:bTransmission Cont
get:bFunctional Specif
get:b3.6.  Precedence 
get:bThe intent is t
get:bwith exactly th
get:bhigher of the p
get:bThe precedence 
get:bdefined in the 
get:bspecification t
get:bthe security pa
get:buser group, and
get:bA connection at
get:blower precedenc
get:ba connection du
get:backnowledgment 
get:bNote that TCP m
get:bprecedence will
get:bsegments and po
get:bThe security pa
get:b(the values wou
get:bnon-secure envi
get:bparameters, tho
get:b3.7.  Data Commun
get:bOnce the connec
get:bexchange of seg
get:b(checksum test 
get:bretransmission 
get:bDuplicate segme
get:bAs discussed in
get:bcertain tests o
get:bsegments to ver
get:bThe sender of d
get:bthe variable SN
get:bsequence number
get:bkeeps track of 
get:bvariable SND.UN
get:bsent has been a
get:bWhen the sender
get:bSND.NXT.  When 
get:bsends an acknow
get:b[Page 40]        
get:bSeptember 1981   
get:backnowledgment 
get:bthese variables
get:bThe amount by w
get:bdata in the seg
get:bsegments must c
get:bThe CLOSE user 
get:bflag in an inco
get:bRetransmission 
get:bBecause of the 
get:binternetwork sy
get:bretransmission 
get:bfor determining
get:bAn Example Re
get:bMeasure the
get:bparticular 
get:bcovers that
get:bsegments re
get:bTime (RTT).:  Next compute a Smoothed Round Trip Time (SRTT) as
get:bSRTT = ( 
get:band based o:n this, compute the retransmission timeout (RTO) as
get:bRTO = min
get:bwhere UBOUN
get:bLBOUND is a
get:ba smoothing
get:bfactor (e.g
get:bThe Communicati
get:bThe objective o
get:bto stimulate th
get:bpermit the rece
get:bthe currently k
get:bThis mechanism 
get:bthe end of urge
get:bthe receive seq
get:bmust tell the u
get:bnumber catches 
get:bTransmission Cont
get:bFunctional Specif
get:binto "normal mo
get:bis in "urgent m
get:bThe method empl
get:btransmitted.  T
get:bmeaningful and 
get:bthe urgent poin
get:bno urgent data 
get:bTo send an urge
get:boctet.  If the 
get:bthe urgent info
get:bManaging the Wi
get:bThe window sent
get:bnumbers the sen
get:bprepared to acc
get:bthe currently a
get:bIndicating a la
get:barrives than ca
get:bin excessive re
get:bnetwork and the
get:btransmission of
get:bbetween each ne
get:bThe mechanisms 
get:bsubsequently ad
get:bthat much data.
get:bdiscouraged.  T
get:bshrink the wind
get:bon the part of 
get:bThe sending TCP
get:bleast one octet
get:bsending TCP mus
get:bthe window is z
get:binterval when t
get:bguarantee that 
get:bwindow will be 
get:bWhen the receiv
get:bstill send an a
get:band current win
get:bThe sending TCP
get:b[Page 42]        
get:bSeptember 1981   
get:bwhich fit the c
get:bretransmission 
get:bIn a connection
get:bbe carried in a
get:bnumber so there
get:border.  This is
get:binformation to 
get:bthe data receiv
get:bthe window info
get:backnowledgment 
get:bequal or greate
get:bThe window mana
get:bcommunication p
get:bWindow Manage
get:bAllocating 
get:bmany small 
get:bfewer large
get:bOne suggest
get:bdefer updat
get:bleast X per
get:bconnection 
get:bAnother sug
get:bsegments by
get:bsending dat
get:bdata must b
get:bNote that t
get:bretransmiss
get:backnowledgm
get:bwindow info
get:bnew window 
get:bThe segment
get:bof transmit
get:bsegment con
get:bis accepted
get:bIf the send
get:bwindow is n
get:balternating
get:bpauses in t
get:bTransmission Cont
get:bFunctional Specif
get:bresult in b
get:bbig pair. A
get:bmostly smal
get:bThe suggest
get:bactively at
get:bwindows, si
get:bto many sma
get:bThere are of co:urse two interfaces of concern
get:band the TCP/low
get:bof the user/TCP
get:bprotocol module
get:bin detail by th
get:bcase that the l
get:bthat TCPs might
get:bUser/TCP Interf
get:bThe following
get:bat best, fict
get:bfacilities.  
get:bimplementatio
get:bTCPs must pro
get:bthat all TCP 
get:bhierarchy.  T
get:brequired of a
get:bTCP User Comm
get:bThe followi
get:binterface. 
get:bfunction ca
get:bmeant to ru
get:bThe user co
get:bTCP must pe
get:bIndividual 
get:bmay provide
get:bsingle call
get:bautomatical
get:bissued by t
get:b[Page 44]        
get:bSeptember 1981   
get:bIn providin
get:bnot only ac
get:bprocesses i:t serves.  The latter consists of
get:b(a) gener
get:bremote cl
get:b(b) repli
get:bvarious t
get:bFormat:  
get:b[, timeou
get:b-> local 
get:bWe assume
get:bprocesses
get:bto use th
get:bimplement
get:bfor the s
get:blower lev
get:bresult of
get:bable to m
get:bprocess c
get:bIf the ac
get:bcall to L
get:bhave eith
get:bparticula
get:bfor any c
get:bby the su
get:bA transmi
get:bfilled in
get:bOn an act
get:bsynchroni
get:bThe timeo
get:bfor all d
get:bdelivered
get:bwill abor
get:bThe TCP o
get:bthe users
get:bTransmission Cont
get:bFunctional Specif
get:bprecedenc
get:bor securi
get:bthe defau
get:bTCP will 
get:bsecurity/
get:bthe prece
get:brequested
get:bThe prece
get:brequested
get:brequest, 
get:bconnectio
get:bthis prec
get:ballowed t
get:bor that a
get:bA local c
get:bThe local
get:bfor the c
get:bFormat:  
get:bcount, PU
get:bThis call
get:bto be sen
get:bnot been 
get:bimplement
get:bautomatic
get:bauthorize
get:bIf the PU
get:bto the re
get:bsegment c
get:bthe data 
get:btransmiss
get:bIf the UR
get:bwill have
get:bthe urgen
get:bpointer i
get:bbeen cons
get:bis to sti
get:bindicate 
get:b[Page 46]        
get:bSeptember 1981   
get:bdata has 
get:bTCP signa
get:bof times 
get:burgent da
get:bIf no for
get:bconnectio
get:bhas becom
get:blocal soc
get:bforeign s
get:bforeign s
get:bknowing t
get:bHowever, 
get:bbecomes s
get:bSTATUS ca
get:bimplement
get:bsocket is
get:bIf a time
get:bconnectio
get:bIn the si
get:bthe sendi
get:bor the ti
get:bis both s
get:bconnectio
get:boffers po
get:bsophistic
get:bthe proce
get:bfurthermo
get:bMultiple 
get:bthe TCP w
get:bWe have i
get:bwhich a S
get:bpseudo-in
get:breturn a 
get:bimmediate
get:bbeen ackn
get:bassume ev
get:bclose any
get:bkind (syn
get:bsignals, 
get:bwith spec
get:bIn order 
get:bindicatio
get:bTransmission Cont
get:bFunctional Specif
get:bbuffer ad
get:bthe SEND 
get:bindicatin
get:bcalling p
get:bFormat:  
get:bcount) ->
get:bThis comm
get:bspecified
get:bcalling p
get:berror is 
get:bIn the si
get:bcalling p
get:berror occ
get:bA more so
get:bRECEIVEs 
get:bsegments 
get:bthe cost 
get:bnotify th
get:bIf enough
get:bthe PUSH 
get:bThe buffe
get:ba PUSH is
get:breturned 
get:bIf there 
get:bas it arr
get:bshould th
get:badditiona
get:bcall to R
get:bmay now l
get:burgent po
get:bin the sa
get:bboundary 
get:bTo distin
get:bcare of t
get:breturn co
get:bcount ind
get:bAlternati
get:b[Page 48]        
get:bSeptember 1981   
get:ballocate 
get:bwith the 
get:bFormat:  
get:bThis comm
get:bthe conne
get:bauthorize
get:bClosing c
get:bthe sense
get:bretransmi
get:bserviced.
get:bcalls, fo
get:bto the de
get:bcontinue 
get:bmay be tr
get:bmeans "I 
get:breceive a
get:bnot well 
get:bof all it
get:binto ABOR
get:bThe user 
get:binitiativ
get:b(e.g., re
get:bdestinati
get:bBecause c
get:bforeign T
get:bshort tim
get:breplies t
get:bClose als
get:bFormat:  
get:bThis is a
get:bexcluded 
get:btypically
get:bThis comm
get:binformati:on
get:blocal s
get:bTransmission Cont
get:bFunctional Specif
get:bforeign
get:blocal c
get:breceive
get:bsend wi
get:bconnect
get:bnumber 
get:bnumber 
get:burgent 
get:bprecede
get:bsecurit
get:band tra
get:bDepending
get:bimplement
get:bavailable
get:bauthorize
get:bprevents 
get:bconnectio
get:bFormat:  
get:bThis comm
get:baborted, 
get:bbe sent t
get:bDepending
get:bindicatio
get:breceive a
get:bTCP-to-User M
get:bIt is assum
get:bmeans for t
get:bthe TCP doe
get:bto the user
get:ban error me
get:brelating to
get:bother user 
get:bThe followi:ng information is provided
get:bLocal Con
get:bResponse 
get:bBuffer Ad
get:bByte coun
get:bPush flag
get:bUrgent fl
get:b[Page 50]        
get:bSeptember 1981   
get:bTCP/Lower-Level
get:bThe TCP calls
get:breceive infor
get:binternetwork 
get:bProtocol (IP)
get:bIf the lower 
get:bof service an
get:bfor these par:ameters
get:bType of Ser:vice = Precedence: routine, Delay: normal, Throughput
get:bnormal, Rel:iability
get:bTime to Liv
get:bNote that
get:bHere we e
get:bbe delive
get:bIf the lower 
get:bfeature) and 
get:broute informa
get:bso that the s
get:bchecksum be t
get:balso importan
get:bAny lower lev
get:bdestination a
get:bthe "TCP leng
get:bof IP and to 
get:bTransmission Cont
get:bFunctional Specif
get:b3.9.  Event Proce
get:bThe processing 
get:bimplementation.
get:bprocessing sequ
get:bsection only in
get:bThe activity of
get:bThe events that: occur can be cast into three categories
get:barriving segmen
get:bprocessing the 
get:bcases the proce
get:bEvents that o:ccur
get:bArriving Se
get:bSEGMENT A
get:bUSER TIME
get:bRETRANSMI
get:bTIME-WAIT
get:bThe model of th
get:bimmediate retur
get:bpseudo interrup
get:bmeans cause a d
get:bError responses
get:bcommands refere:ncing connections that do not exist receive "error
get:bconnection not 
get:bPlease note in 
get:backnowledgment 
get:bof the sequence
get:bequal to (modul
get:b[Page 52]        
get:bSeptember 1981   
get:bA natural way t
get:bimagine that th
get:bthat their cont
get:bin the sequence
get:band processed i
get:bWhen a segment 
get:bthe segment to 
get:bto be consisten
get:bNote that if no
get:bTransmission Cont
get:bFunctional Specif
get:bCLOSED STATE 
get:bCreate a ne
get:bstate infor
get:bsocket, pre
get:binformation
get:bunspecified
get:bparameters 
get:bprecedence 
get:b"error:  pr:ecedence not allowed" or "error
get:bnot allowed
get:bactive and :the foreign socket is unspecified, return "error
get:bforeign soc
get:bspecified, 
get:b(ISS) is se
get:bis sent.  S
get:bstate, and 
get:bIf the call
get:breturn "err:or
get:bno room to :create a new connection, return "error
get:bresources".
get:bIf active a
get:bconnection 
get:bsegment, se
get:bstate.  Dat
get:bqueued for 
get:burgent bit 
get:bsegments se
get:bqueue the r:equest, respond with "error
get:bIf Foreign :socket was not specified, then return "error
get:bsocket unsp
get:b[Page 54]        
get:bSeptember 1981   
get:bSYN-SENT STAT
get:bSYN-RECEIVED 
get:bESTABLISHED S
get:bFIN-WAIT-1 ST
get:bFIN-WAIT-2 ST
get:bCLOSE-WAIT ST
get:bCLOSING STATE
get:bLAST-ACK STAT
get:bTIME-WAIT STA
get:bReturn "err:or
get:bTransmission Cont
get:bFunctional Specif
get:bCLOSED STATE 
get:bIf the user
get:b"error:  co
get:bOtherwise, :return "error
get:bIf the fore
get:bfrom passiv
get:bSND.UNA to 
get:bassociated 
get:btransmissio
get:brequested i
get:bas a result
get:brequest, re:spond with "error
get:bForeign soc:ket was not specified, then return "error
get:bsocket unsp
get:bSYN-SENT STAT
get:bSYN-RECEIVED 
get:bQueue the d
get:bIf no space: to queue, respond with "error
get:bresources".
get:bESTABLISHED S
get:bCLOSE-WAIT ST
get:bSegmentize 
get:backnowledgm
get:binsufficien:t space to remember this buffer, simply return "error
get:binsufficien
get:bIf the urge
get:burgent poin
get:b[Page 56]        
get:bSeptember 1981   
get:bFIN-WAIT-1 ST
get:bFIN-WAIT-2 ST
get:bCLOSING STATE
get:bLAST-ACK STAT
get:bTIME-WAIT STA
get:bReturn "err:or
get:bTransmission Cont
get:bFunctional Specif
get:bCLOSED STATE 
get:bIf the user
get:b"error:  co
get:bOtherwise r:eturn "error
get:bSYN-SENT STAT
get:bSYN-RECEIVED 
get:bQueue for p
get:bis no room :to queue this request, respond with "error
get:binsufficien
get:bESTABLISHED S
get:bFIN-WAIT-1 ST
get:bFIN-WAIT-2 ST
get:bIf insuffic
get:brequest, qu
get:bremember th:e RECEIVE, respond with "error
get:bresources".
get:bReassemble 
get:bto user.  M
get:bIf RCV.UP i
get:buser notify
get:bWhen the TC
get:bthat fact m
get:backnowledgm
get:bdescribed b
get:b[Page 58]        
get:bSeptember 1981   
get:bCLOSE-WAIT ST
get:bSince the r
get:bsatisfied b
get:buser.  If n
get:b"error:  co
get:btext can be
get:bCLOSING STATE
get:bLAST-ACK STAT
get:bTIME-WAIT STA
get:bReturn "err:or
get:bTransmission Cont
get:bFunctional Specif
get:bCLOSED STATE 
get:bIf the user
get:b"error:  co
get:bOtherwise, :return "error
get:bAny outstan:ding RECEIVEs are returned with "error
get:bresponses. 
get:bSYN-SENT STAT
get:bDelete the :TCB and return "error
get:bqueued SEND
get:bSYN-RECEIVED 
get:bIf no SENDs
get:bthen form a
get:botherwise q
get:bESTABLISHED S
get:bQueue this 
get:bform a FIN 
get:bFIN-WAIT-1 ST
get:bFIN-WAIT-2 ST
get:bStrictly sp:eaking, this is an error and should receive a "error
get:bconnection 
get:bacceptable,
get:bFIN may be 
get:b[Page 60]        
get:bSeptember 1981   
get:bCLOSE-WAIT ST
get:bQueue this 
get:bsegmentized
get:bCLOSING STATE
get:bLAST-ACK STAT
get:bTIME-WAIT STA
get:bRespond wit:h "error
get:bTransmission Cont
get:bFunctional Specif
get:bCLOSED STATE 
get:bIf the user
get:b"error:  co
get:bOtherwise r:eturn "error
get:bAny outstan:ding RECEIVEs should be returned with "error
get:bconnection 
get:bSYN-SENT STAT
get:bAll queued 
get:bnotificatio
get:bSYN-RECEIVED 
get:bESTABLISHED S
get:bFIN-WAIT-1 ST
get:bFIN-WAIT-2 ST
get:bCLOSE-WAIT ST
get:bSend a rese:t segment
get:b<SEQ=SND.
get:bAll queued 
get:bnotificatio
get:bRST formed 
get:bTCB, enter 
get:bCLOSING STATE
get:bLAST-ACK STAT
get:bTIME-WAIT STA
get:bRespond wit
get:b[Page 62]        
get:bSeptember 1981   
get:bCLOSED STATE 
get:bIf the user
get:b"error:  co
get:bOtherwise r:eturn "error
get:bReturn "sta
get:bSYN-SENT STAT
get:bReturn "sta
get:bSYN-RECEIVED 
get:bReturn "sta
get:bESTABLISHED S
get:bReturn "sta
get:bFIN-WAIT-1 ST
get:bReturn "sta
get:bFIN-WAIT-2 ST
get:bReturn "sta
get:bCLOSE-WAIT ST
get:bReturn "sta
get:bCLOSING STATE
get:bReturn "sta
get:bLAST-ACK STAT
get:bReturn "sta
get:bTransmission Cont
get:bFunctional Specif
get:bTIME-WAIT STA
get:bReturn "sta
get:b[Page 64]        
get:bSeptember 1981   
get:bSEGMENT ARRIVES
get:bIf the state 
get:ball data in
get:bsegment con
get:bcontaining 
get:backnowledgm
get:breset seque
get:bIf the ACK 
get:b<SEQ=0><A
get:bIf the ACK 
get:b<SEQ=SEG.
get:bIf the state 
get:bfirst check
get:bAn incomi
get:bsecond chec
get:bAny ackno
get:bthe LISTE
get:bfor any a
get:bformatted: as follows
get:b<SEQ=SE
get:bthird check
get:bIf the SY
get:bsecurity/
get:bmatch the
get:b<SEQ=SE
get:bTransmission Cont
get:bFunctional Specif
get:bIf the SE
get:bthe user 
get:bsend a re
get:b<SEQ=SE
get:bIf the SE
get:bSet RCV.N
get:bcontrol o
get:bshould be: selected and a SYN segment sent of the form
get:b<SEQ=IS
get:bSND.NXT i
get:bstate sho
get:bincoming 
get:bin the SY
get:bnot be re
get:bthe forei
get:bunspecifi
get:bfourth othe
get:bAny other
get:bmust have
get:bprocessin
get:bit could 
get:bincarnati
get:bbut if yo
get:bIf the state 
get:bfirst check
get:bIf the AC
get:bIf SEG.
get:bthe RST
get:b<SEQ=
get:band dis
get:bIf SND.
get:bsecond chec
get:b[Page 66]        
get:bSeptember 1981   
get:bIf the RS
get:bIf the :ACK was acceptable then signal the user "error
get:bconnect
get:bdelete 
get:band ret
get:bthird check
get:bIf the se
get:bmatch the
get:bIf ther
get:b<SEQ=
get:bOtherwi
get:b<SEQ=
get:bIf there 
get:bThe pre
get:bTCB, if
get:b<SEQ=
get:bIf there 
get:bIf the 
get:bin the 
get:bthe pre
get:ballowed
get:b<SEQ=
get:bIf the 
get:bin the 
get:bIf a rese
get:bfourth chec
get:bThis step
get:bno ACK, a
get:bIf the SY
get:bTransmission Cont
get:bFunctional Specif
get:bare accep
get:bSEG.SEQ. 
get:bis an ACK
get:bare there
get:bIf SND.UN
get:bstate to 
get:b<SEQ=SN
get:band send 
get:btransmiss
get:btext in t
get:bbelow whe
get:bOtherwise
get:b<SEQ=IS
get:band send 
get:bsegment, 
get:bhas been 
get:bfifth, if n
get:bsegment and
get:b[Page 68]        
get:bSeptember 1981   
get:bfirst check s
get:bSYN-RECEIVE
get:bESTABLISHED
get:bFIN-WAIT-1 
get:bFIN-WAIT-2 
get:bCLOSE-WAIT 
get:bCLOSING STA
get:bLAST-ACK ST
get:bTIME-WAIT S
get:bSegments 
get:bare used 
get:bdone in S
get:bboundary 
get:bprocessed
get:bThere are
get:bsegment
get:bSegment R
get:bLength  W
get:b------- -
get:b0     
get:b0     
get:b>0     
get:b>0     
get:bIf the RC
get:bspecial a
get:bIf an inc
get:bshould be
get:bthe segme:nt and return)
get:b<SEQ=SN
get:bAfter sen
get:band retur
get:bTransmission Cont
get:bFunctional Specif
get:bIn the fo
get:bsegment t
get:bOne could
get:btrimming 
get:bSYN and F
get:bbegins at
get:bnumbers m
get:bsecond check 
get:bSYN-RECEIVE
get:bIf the RS
get:bIf this
get:bcame fr
get:bLISTEN 
get:bthis co
get:bfrom SY
get:bthe use
get:bon the 
get:bactive 
get:band ret
get:bESTABLISHED
get:bIf the RS
get:bshould re
get:bflushed. 
get:b"connecti
get:bTCB, and 
get:bCLOSING STA
get:bLAST-ACK ST
get:bIf the RS
get:bTCB, and 
get:b[Page 70]        
get:bSeptember 1981   
get:bthird check s
get:bSYN-RECEIVE
get:bIf the se
get:bexactly m
get:bthen send
get:bESTABLISHED
get:bIf the se
get:bexactly m
get:bthen send
get:breceive "
get:bflushed. 
get:b"connecti
get:bTCB, and 
get:bNote this c
get:ba segment f
get:bdifferent s
get:bcurrent con
get:bfourth, check
get:bSYN-RECEIVE
get:bESTABLISHED
get:bFIN-WAIT ST
get:bFIN-WAIT ST
get:bCLOSE-WAIT 
get:bCLOSING STA
get:bLAST-ACK ST
get:bTIME-WAIT S
get:bIf the SY
get:boutstandi
get:ball segme
get:breceive a
get:bthe CLOSE
get:bIf the SY
get:band an ac
get:bnumber ch
get:bTransmission Cont
get:bFunctional Specif
get:bfifth check t
get:bif the ACK 
get:bif the ACK 
get:bSYN-RECEI
get:bIf SND.
get:band con
get:bIf th
get:breset
get:b<SE
get:band s
get:bESTABLISH
get:bIf SND.
get:bAny seg
get:bentirel
get:bpositiv
get:bfully a
get:b"ok" re
get:b(SEG.AC
get:bsomethi
get:bdrop th
get:bIf SND.
get:bupdated
get:bSND.WL2
get:bSND.WL1
get:bNote th
get:brecords
get:bSND.WND
get:bthe las
get:bprevent
get:b[Page 72]        
get:bSeptember 1981   
get:bFIN-WAIT-
get:bIn addi
get:bour FIN
get:bprocess
get:bFIN-WAIT-
get:bIn addi
get:bthe ret
get:backnowl
get:bCLOSE-WAI
get:bDo the 
get:bCLOSING S
get:bIn addi
get:bthe ACK
get:botherwi
get:bLAST-ACK 
get:bThe onl
get:backnowl
get:bdelete 
get:bTIME-WAIT
get:bThe onl
get:bretrans
get:bthe 2 M
get:bsixth, check 
get:bESTABLISHED
get:bFIN-WAIT-1 
get:bFIN-WAIT-2 
get:bIf the UR
get:bthe user 
get:bpointer (
get:buser has 
get:bmode") fo
get:bsignal th
get:bTransmission Cont
get:bFunctional Specif
get:bCLOSE-WAIT 
get:bCLOSING STA
get:bLAST-ACK ST
get:bThis shou
get:bremote si
get:bseventh, proc
get:bESTABLISHED
get:bFIN-WAIT-1 
get:bFIN-WAIT-2 
get:bOnce in t
get:btext to u
get:binto buff
get:bempty.  I
get:bthe user 
get:bhas been 
get:bWhen the 
get:buser it m
get:bOnce the 
get:bRCV.NXT o
get:bapporopri
get:bRCV.NXT a
get:bPlease no
get:bSend an a:cknowledgment of the form
get:b<SEQ=SN
get:bThis ackn
get:btransmitt
get:b[Page 74]        
get:bSeptember 1981   
get:bCLOSE-WAIT 
get:bCLOSING STA
get:bLAST-ACK ST
get:bTIME-WAIT S
get:bThis shou
get:bremote si
get:beighth, check
get:bDo not proc
get:bsince the S
get:bIf the FIN 
get:breturn any 
get:bover the FI
get:bFIN implies
get:bSYN-RECEI
get:bESTABLISH
get:bEnter t
get:bFIN-WAIT-
get:bIf our 
get:benter T
get:btimers;
get:bFIN-WAIT-
get:bEnter t
get:boff the
get:bCLOSE-WAI
get:bRemain 
get:bCLOSING S
get:bRemain 
get:bLAST-ACK 
get:bRemain 
get:bTransmission Cont
get:bFunctional Specif
get:bTIME-WAIT
get:bRemain 
get:btimeout
get:b[Page 76]        
get:bSeptember 1981   
get:bFor any state
get:bthe user "err:or
get:band for any o
get:bstate and ret
get:bRETRANSMISSION 
get:bFor any state
get:bthe retransmi
get:bretransmissio
get:bTIME-WAIT TIMEO
get:bIf the time-w
get:benter the CLO
get:bTransmission Cont
get:b[Page 78]        
get:bSeptember 1981   
get:bBBN Rep
get:ba Host 
get:bhost an
get:bA contr
get:bindicat
get:bspecifi
get:bis expe
get:bpreviou
get:bThe uni
get:bARPANET
get:bA unit 
get:bIMPs.  
get:bA logic
get:bA messa
get:bnetwork
get:bDestination Addre
get:bThe des
get:bidentif
get:bA contr
get:bindicat
get:boccupyi
get:bA porti
get:bfragmen
get:bA file 
get:bTransmission Cont
get:bControl
get:bfragmen
get:bA compu
get:bfrom th
get:bAn Inte
get:bby the 
get:bThe Int
get:bARPANET
get:bA sourc
get:binternet datagram
get:bThe uni
get:bhigher 
get:binternet fragment
get:bA porti
get:bheader.
get:bInterne
get:bThe Ini
get:bnumber 
get:bThe Ini
get:bon a co
get:bbased p
get:bThe Ini
get:bused by
get:bControl
get:bdata.  
get:bon an A
get:b[Page 80]        
get:bSeptember 1981   
get:bThis is
get:bdata re
get:bsequenc
get:bof the 
get:bThe uni
get:bAn impl
get:bprocedu
get:bMaximum
get:bthe int
get:bAn eigh
get:bAn Opti
get:bmay be 
get:bprimari
get:btimesta
get:boptions
get:bA packa
get:blogical
get:blogical
get:bThe por
get:boutput 
get:bA progr
get:bthe poi
get:bA contr
get:bthis se
get:breceivi
get:breceive
get:bTransmission Cont
get:breceive
get:breceive
get:breceive next sequ
get:bThis is
get:breceive
get:bThis re
get:bis will
get:bsegment
get:bRCV.NXT
get:bSegment
get:brange a
get:bA contr
get:bthat th
get:binterac
get:bsequenc
get:bsegment
get:bit.  In
get:brise to
get:bReal Ti:me Protocol
get:bof time
get:bsegment
get:bsegment
get:bsegment
get:bsegment
get:bsegment
get:b[Page 82]        
get:bSeptember 1981   
get:bsegment
get:bA logic
get:bunit of
get:bsegment acknowled
get:bThe seq
get:barrivin
get:bThe amo
get:bincludi
get:bThe num
get:bThis is
get:buse on 
get:binitial
get:beach oc
get:bThis re
get:b(receiv
get:bwindow 
get:breceivi
get:bbe emit
get:bSND.UNA
get:bbetween
get:bsend se
get:bleft se
get:bsend ur
get:bsegment
get:bsegment
get:bTransmission Cont
get:bsend wi
get:bAn addr
get:bis, the
get:bThe sou
get:bA contr
get:bnumber,
get:bwhere t
get:bTransmi
get:bthe sta
get:bThe pre
get:bTransmi:ssion Control Protocol
get:breliabl
get:bType of
get:bAn Inte
get:bfor thi
get:bA contr
get:bindicat
get:burgent 
get:bsequenc
get:bpointer
get:bA contr
get:bfield c
get:bindicat
get:burgent 
get:b[Page 84]        
get:bSeptember 1981   
get:b[1]  Cerf, V., an
get:bIntercommuni
get:bVol. COM-22,
get:b[2]  Postel, J. (
get:bProtocol Spe
get:bInstitute, S
get:b[3]  Dalal, Y. an
get:bProtocols", 
get:bDecember 197
get:b[4]  Postel, J., 
get:bInstitute, S
get:baRFC
get:baDe
get:baI
get:baSeptember 1981   
get:baPREFACE .....
get:ba1.  INTRODUCTION 
get:ba1.1  Motivation
get:ba1.2  Scope ....
get:ba1.3  About This
get:ba1.4  Interfaces
get:ba1.5  Operation 
get:ba2.  PHILOSOPHY ..
get:ba2.1  Elements o
get:ba2.2  Model of O
get:ba2.3  The Host E
get:ba2.4  Interfaces
get:ba2.5  Relation t
get:ba2.6  Reliable C
get:ba2.7  Connection
get:ba2.8  Data Commu
get:ba2.9  Precedence
get:ba2.10 Robustness
get:ba3.  FUNCTIONAL SP
get:ba3.1  Header For
get:ba3.2  Terminolog
get:ba3.3  Sequence N
get:ba3.4  Establishi
get:ba3.5  Closing a 
get:ba3.6  Precedence
get:ba3.7  Data Commu
get:ba3.8  Interfaces
get:ba3.9  Event Proc
get:baGLOSSARY ........
get:baREFERENCES ......
get:baTransmission Cont
get:ba[Page ii]        
get:baSeptember 1981   
get:baThis document des
get:ba(TCP).  There hav
get:baspecification on 
get:badraws heavily fro
get:baboth in terms of 
get:baseveral details a
get:baand redescribes t
get:baRFC
get:baReplaces: RFC 761
get:baIENs:  129, 124, 
get:ba55, 44, 40, 27, 2
get:baThe Transmission 
get:bareliable host-to-
get:bacommunication net
get:baThis document des
get:baTransmission Cont
get:bainterface to prog
get:baComputer commun
get:barole in militar
get:badocument focuse
get:bacommunication r
get:bacommunication u
get:bacongestion, but
get:bagovernment sect
get:baAs strategic an
get:badeveloped and d
get:bainterconnecting
get:bacommunication p
get:baapplications.  
get:baDeputy Undersec
get:badeclared the Tr
get:babe a basis for 
get:bastandardization
get:baTCP is a connec
get:bafit into a laye
get:baapplications.  
get:bacommunication b
get:badistinct but in
get:baassumptions are
get:baprotocols below
get:bapotentially unr
get:baprotocols.  In 
get:bawide spectrum o
get:baconnections to 
get:baTransmission Cont
get:baTCP is based on
get:baTCP fits into a
get:baInternet Protoc
get:bareceive variabl
get:badatagram "envel
get:baaddressing sour
get:bainternet protoc
get:bathe TCP segment
get:bamultiple networ
get:baalso carries in
get:baand compartment
get:bacommunicated en
get:baMuch of this do
get:bawhich are co-re
get:bacomputer.  Some
get:bafront-end compu
get:baas well as netw
get:baan interface to
get:baimplementable e
get:bahost-to-front e
get:baThe TCP is inte
get:bacommunication s
get:baintended to be 
get:ba1.3.  About this 
get:baThis document r
get:baany TCP impleme
get:baprotocols and i
get:ba[Page 2]         
get:baSeptember 1981   
get:basection offers 
get:baoperation.  Sec
get:badesign.  Sectio
get:barequired of TCP
get:bauser calls, err
get:baThe TCP interfa
get:bathe other side 
get:baThe interface b
get:baillustrated in 
get:bacalls much like
get:baapplication pro
get:bacalls to open a
get:baestablished con
get:baasynchronously 
get:baconsiderable fr
get:bainterfaces whic
get:baenvironment, a 
get:bainterface for a
get:baThe interface b
get:baunspecified exc
get:batwo levels can 
get:baTypically, one 
get:bainterface.  TCP
get:bainterconnected 
get:bathroughout this
get:baAs noted above,
get:basecurable logic
get:baprocesses.  To 
get:bacommunication s:ystem requires facilities in the following areas
get:baBasic Data Tr
get:baPrecedence an
get:baThe basic opera
get:bathe following p
get:baTransmission Cont
get:baBasic Data Tran:sfer
get:baThe TCP is ab
get:badirection bet
get:basegments for 
get:bathe TCPs deci
get:baSometimes use
get:basubmitted to 
get:bafunction is d
get:baactually tran
get:bapushed throug
get:bapromptly forw
get:baThe exact pus
get:bathe push func
get:baReliability
get:baThe TCP must 
get:badelivered out
get:bais achieved b
get:batransmitted, 
get:bareceiving TCP
get:bainterval, the
get:banumbers are u
get:baout of order 
get:baadding a chec
get:bareceiver, and
get:baAs long as th
get:basystem does n
get:baerrors will a
get:bainternet comm
get:baFlow Control
get:baTCP provides 
get:basent by the s
get:baevery ACK ind
get:bathe last segm
get:baallowed numbe
get:bareceiving fur
get:ba[Page 4]         
get:baSeptember 1981   
get:baMultiplexing
get:baTo allow for 
get:bacommunication
get:baaddresses or 
get:baand host addr
get:baa socket.  A 
get:baThat is, a so
get:baThe binding o
get:baHost.  Howeve
get:ba(e.g., a "log
get:bamade known to
get:bathrough the k
get:baaddresses of 
get:baConnections
get:baThe reliabili
get:bathat TCPs ini
get:baeach data str
get:basockets, sequ
get:baEach connecti
get:baidentifying i
get:baWhen two proc
get:baestablish a c
get:baside).  When 
get:baterminated or
get:baSince connect
get:baover the unre
get:bamechanism wit
get:baerroneous ini
get:baPrecedence and :Security
get:baThe users of 
get:bacommunication
get:bathese feature
get:baTransmission Cont
get:ba[Page 6]         
get:baSeptember 1981   
get:ba2.1.  Elements of
get:baThe internetwor
get:bawhich are in tu
get:bathat the networ
get:balarge networks 
get:bapacket switchin
get:baconsume message
get:banetworks, the g
get:bacommunication s
get:baconnections bet
get:baThe term packet
get:batransaction bet
get:baexchanged withi
get:baHosts are compu
get:banetwork's point
get:baProcesses are v
get:baaccordance with
get:bain execution). 
get:baviewed as commu
get:baThus, all commu
get:baSince a process
get:bastreams between
get:bathat each proce
get:bacommunicates wi
get:ba2.2.  Model of Op
get:baProcesses trans
get:badata as argumen
get:basegments and ca
get:bathe destination
get:bainto the receiv
get:baTCPs include co
get:baensure reliable
get:baThe model of in
get:baprotocol module
get:bato the local ne
get:bainside internet
get:bainternet module
get:bathrough the loc
get:baThe packet swit
get:baTransmission Cont
get:baother operation
get:badestination int
get:baAt a gateway be
get:bafrom its local 
get:bathe internet da
get:bathen "wrapped" 
get:barouted to the n
get:baA gateway is pe
get:bainternet datagr
get:bathrough the nex
get:bainternet datagr
get:bafurther broken 
get:bainternet datagr
get:bainternet module
get:baA destination i
get:ba(after reassemb
get:badestination TCP
get:baThis simple mod
get:baimportant featu
get:bato the gateway 
get:baservice paramet
get:baIncluded in the
get:badatagram.  Data
get:bahost and gatewa
get:baproperly segreg
get:ba2.3.  The Host En
get:baThe TCP is assu
get:baaccess the TCP 
get:bamay call on oth
get:badata structures
get:bacontrolled by a
get:banetwork device 
get:badatagram protoc
get:baThe mechanisms 
get:bafront-end proce
get:bahost-to-front-e
get:bathe type of TCP
get:ba[Page 8]         
get:baSeptember 1981   
get:baThe TCP/user in
get:bato OPEN or CLOS
get:baSTATUS about a 
get:baprograms on the
get:bafrom, and close
get:baThe TCP/interne
get:badatagrams addre
get:basystem.  These 
get:baservice, preced
get:ba2.5.  Relation to
get:baThe following d
get:bahierarchy
get:ba+------+ +
get:ba|Telnet| |
get:ba+------+ +
get:ba|   
get:ba+----
get:ba| TCP
get:ba+----
get:ba| 
get:ba+----
get:ba|    
get:ba+----
get:ba+--
get:ba|  
get:ba+--
get:baIt is expected 
get:baprotocols effic
get:baprotocols like 
get:ba2.6.  Reliable Co
get:baA stream of dat
get:baorder at the de
get:baTransmission Cont
get:baTransmission is
get:baacknowledgments
get:basequence number
get:basegment is tran
get:basequence number
get:bais the sequence
get:batransmissions i
get:basegment contain
get:bastarts a timer;
get:basegment is dele
get:bareceived before
get:baAn acknowledgme
get:badelivered to th
get:bathe responsibil
get:baTo govern the f
get:baemployed.  The 
get:baThis window spe
get:baacknowledgment 
get:ba2.7.  Connection 
get:baTo identify the
get:baprovides a port
get:baindependently b
get:baunique addresse
get:baidentifying the
get:bawill be unique 
get:baA connection is
get:balocal socket ma
get:basockets.  A con
get:bathat is, it is 
get:baTCPs are free t
get:baHowever, severa
get:baThere must be w
get:bathe "appropriat
get:bamay "own" ports
get:bathe ports they 
get:baissue, but we e
get:bauniquely alloca
get:baassociating the
get:baA connection is
get:baforeign socket 
get:ba[Page 10]        
get:baSeptember 1981   
get:baconnection name
get:basubsequent call
get:baabout a connect
get:bais a data struc
get:baimplementation 
get:bapointer to the 
get:bawhether the con
get:babe passively wa
get:baA passive OPEN 
get:baconnection requ
get:baOften the proce
get:barequest from an
get:bais used to deno
get:baare allowed onl
get:baA service proce
get:baprocesses would
get:baforeign socket.
get:barequested a con
get:balocal socket we
get:baWell-known sock
get:baa socket addres
get:ba"Telnet-Server"
get:basocket, and oth
get:baEntry, Text Gen
get:babeing for test 
get:baaccess to a "Lo
get:baat which a newl
get:bawell-known sock
get:baof sockets to s
get:baProcesses can i
get:bafrom other proc
get:babeen establishe
get:baother at the sa
get:bais critical for
get:bacomponents act 
get:baThere are two p
get:bapassive OPENs a
get:balocal passive O
get:bacase, the match
get:baOPENs has left 
get:baforeign socket 
get:baOther possibili
get:baTransmission Cont
get:baIf there are se
get:basame local sock
get:bawith the specif
get:baTCB exists, bef
get:baThe procedures 
get:bacontrol flag an
get:baexchange has be
get:baA connection is
get:bacontaining a SY
get:bacommand.  The m
get:baconnection has 
get:bawhen sequence n
get:baThe clearing of
get:bain this case ca
get:ba2.8.  Data Commun
get:baThe data that f
get:baoctets.  The se
get:bain that call (a
get:bathrough to the 
get:baA sending TCP i
get:basend that data 
get:bafunction is sig
get:bareceiving TCP s
get:bathe sending TCP
get:baThere is no nec
get:baboundaries.  Th
get:basingle SEND cal
get:baThe purpose of 
get:bafrom the sendin
get:barecord service.
get:baThere is a coup
get:baof data that cr
get:baassociated with
get:babuffer is retur
get:banot filled.  If
get:baPUSH is seen, t
get:baTCP also provid
get:baat some point f
get:ba[Page 12]        
get:baSeptember 1981   
get:bacurrently readi
get:badefine what the
get:baurgent data, bu
get:batake action to 
get:ba2.9.  Precedence 
get:baThe TCP makes u
get:basecurity option
get:babasis to TCP us
get:baa multilevel se
get:bause only, and o
get:bacompartment.  C
get:bausers may be li
get:baTCP modules whi
get:baproperly mark o
get:baprecedence.  Su
get:bahigher level pr
get:bathem to specify
get:baprecedence of c
get:ba2.10.  Robustness
get:baTCP implementat:ions will follow a general principle of robustness
get:baconservative in
get:baTransmission Cont
get:ba[Page 14]        
get:baSeptember 1981   
get:ba3.1.  Header Form
get:baTCP segments ar
get:baheader carries 
get:badestination hos
get:baheader, supplyi
get:badivision allows
get:baTCP Header Form
get:ba0            
get:ba0 1 2 3 4 5 6
get:ba+-+-+-+-+-+-+-
get:ba|          Sou
get:ba+-+-+-+-+-+-+-
get:ba|             
get:ba+-+-+-+-+-+-+-
get:ba|             
get:ba+-+-+-+-+-+-+-
get:ba|  Data |     
get:ba| Offset| Rese
get:ba|       |     
get:ba+-+-+-+-+-+-+-
get:ba|           Ch
get:ba+-+-+-+-+-+-+-
get:ba|             
get:ba+-+-+-+-+-+-+-
get:ba|             
get:ba+-+-+-+-+-+-+-
get:baNote th
get:baSource Port:  1
get:baThe source po
get:baDestination Por:t
get:baThe destinati
get:baTransmission Cont
get:baFunctional Specif
get:baSequence Number:
get:baThe sequence 
get:bawhen SYN is p
get:bainitial seque
get:baAcknowledgment :Number
get:baIf the ACK co
get:banext sequence
get:bareceive.  Onc
get:baData Offset:  4
get:baThe number of
get:bathe data begi
get:baintegral numb
get:baReserved:  6 bi
get:baReserved for 
get:baControl Bits:  :6 bits (from left to right)
get:baURG:  Urgent 
get:baACK:  Acknowl
get:baPSH:  Push Fu
get:baRST:  Reset t
get:baSYN:  Synchro
get:baFIN:  No more
get:baWindow:  16 bit
get:baThe number of
get:baacknowledgmen
get:baChecksum:  16 b
get:baThe checksum 
get:bacomplement su
get:basegment conta
get:bachecksummed, 
get:baform a 16 bit
get:batransmitted a
get:bathe checksum 
get:baThe checksum 
get:ba[Page 16]        
get:baSeptember 1981   
get:baprefixed to t
get:baAddress, the 
get:baThis gives th
get:bainformation i
get:baacross the TC
get:bacalls by the 
get:baThe TCP Len
get:baoctets (thi
get:bacomputed), 
get:baUrgent Pointer:
get:baThis field co
get:bapositive offs
get:baurgent pointe
get:bathe urgent da
get:bathe URG contr
get:baOptions:  varia
get:baOptions may o
get:bamultiple of 8
get:bachecksum.  An
get:bacases for the: format of an option
get:baCase 1:  A 
get:baCase 2:  An
get:bath
get:baThe option-le
get:baoption-length
get:baNote that the
get:bafield might i
get:baEnd-of-Option
get:baA TCP must im
get:baTransmission Cont
get:baFunctional Specif
get:baCurrently def:ined options include (kind indicated in octal)
get:baKind     Le
get:ba----     --
get:ba0         
get:ba1         
get:ba2         
get:baSpecific Opti
get:baEnd of Opti
get:ba+--------
get:ba|00000000
get:ba+--------
get:baThis opti
get:bamight not
get:bathe Data 
get:banot the e
get:bathe optio
get:baNo-Operatio
get:ba+--------
get:ba|00000001
get:ba+--------
get:baThis opti
get:baalign the
get:baThere is 
get:bareceivers
get:banot begin
get:baMaximum Seg
get:ba+--------
get:ba|00000010
get:ba+--------
get:baKind=2  
get:ba[Page 18]        
get:baSeptember 1981   
get:baMaximum S:egment Size Option Data
get:baIf this
get:bareceive
get:baThis fi
get:ba(i.e., 
get:baoption 
get:baPadding:  varia
get:baThe TCP heade
get:baand data begi
get:ba3.2.  Terminology
get:baBefore we can d
get:bato introduce so
get:baconnection requ
get:baof these variab
get:baTransmission Co
get:baTCB are the loc
get:baprecedence of t
get:babuffers, pointe
get:baIn addition sev
get:basequence number
get:baSend Sequence
get:baSND.UNA - s
get:baSND.NXT - s
get:baSND.WND - s
get:baSND.UP  - s
get:baSND.WL1 - s
get:baSND.WL2 - s
get:bau
get:baISS     - i
get:baReceive Seque
get:baRCV.NXT - r
get:baRCV.WND - r
get:baRCV.UP  - r
get:baIRS     - i
get:baTransmission Cont
get:baFunctional Specif
get:baThe following d
get:bathe sequence sp
get:baSend Sequence S
get:ba---
get:ba1 - old s
get:ba2 - seque
get:ba3 - seque
get:ba4 - futur
get:baThe send window
get:baReceive Sequenc
get:ba1 - old s
get:ba2 - seque
get:ba3 - futur
get:baThe receive win
get:baThere are also 
get:batake their valu
get:ba[Page 20]        
get:baSeptember 1981   
get:baCurrent Segme
get:baSEG.SEQ - s
get:baSEG.ACK - s
get:baSEG.LEN - s
get:baSEG.WND - s
get:baSEG.UP  - s
get:baSEG.PRC - s
get:baA connection pr
get:balifetime.  The :states are
get:baESTABLISHED, FI
get:baTIME-WAIT, and 
get:babecause it repr
get:bano connection. : Briefly the meanings of the states are
get:baLISTEN - repr
get:baTCP and port.
get:baSYN-SENT - re
get:baafter having 
get:baSYN-RECEIVED 
get:barequest ackno
get:baconnection re
get:baESTABLISHED -
get:badelivered to 
get:baof the connec
get:baFIN-WAIT-1 - 
get:bafrom the remo
get:batermination r
get:baFIN-WAIT-2 - 
get:bafrom the remo
get:baCLOSE-WAIT - 
get:bafrom the loca
get:baCLOSING - rep
get:baacknowledgmen
get:baLAST-ACK - re
get:baconnection te
get:ba(which includ
get:baTransmission Cont
get:baFunctional Specif
get:baTIME-WAIT - r
get:bathe remote TC
get:batermination r
get:baCLOSED - repr
get:baA TCP connectio
get:baevents.  The ev
get:baABORT, and STAT
get:bacontaining the 
get:baThe state diagr
get:bawith the causin
get:baerror condition
get:bachanges.  In a 
get:bathe reaction of
get:baNOTE BENE:  thi
get:bathe total speci
get:ba[Page 22]        
get:baSeptember 1981   
get:ba+---------+     
get:ba|         |<----
get:ba|   SYN   |     
get:ba|   RCVD  |<----
get:ba|         |     
get:ba|         |-----
get:ba+---------+   rc
get:ba|           --
get:ba|             
get:ba|             
get:ba|  CLOSE      
get:ba| -------     
get:ba| snd FIN     
get:ba|             
get:baV             
get:ba+---------+     
get:ba|  FIN    |<----
get:ba| WAIT-1  |-----
get:ba+---------+     
get:ba| rcv ACK of F
get:ba| ------------
get:baV        x    
get:ba+---------+     
get:ba|FINWAIT-2|     
get:ba+---------+     
get:ba|             
get:ba|  rcv FIN    
get:ba|  -------    
get:ba\ snd ACK    
get:ba------------
get:baTransmission Cont
get:baFunctional Specif
get:ba3.3.  Sequence Nu
get:baA fundamental n
get:baover a TCP conn
get:basequenced, each
get:bamechanism emplo
get:banumber X indica
get:bareceived.  This
get:badetection in th
get:bawithin a segmen
get:bathe header is t
get:banumbered consec
get:baIt is essential
get:bafinite, though 
get:baSince the space
get:banumbers must be
get:bapreserves the r
get:ba2**32 - 1 to 0 
get:baarithmetic, so 
get:bacomparison of s
get:ba(modulo 2**32).
get:baThe typical kin
get:baperform include:
get:ba(a)  Determin
get:banumber s
get:ba(b)  Determin
get:bahave bee
get:baretransm
get:ba(c)  Determin
get:bawhich ar
get:bareceive 
get:ba[Page 24]        
get:baSeptember 1981   
get:baIn response to 
get:bafollowing compa
get:baSND.UNA = old
get:baSND.NXT = nex
get:baSEG.ACK = ack
get:banum
get:baSEG.SEQ = fir
get:baSEG.LEN = the
get:ba(co
get:baSEG.SEQ+SEG.L
get:baA new acknowled
get:bathe inequality :below holds
get:baSND.UNA < SEG
get:baA segment on th
get:baof its sequence
get:baacknowledgment 
get:baWhen data is re:ceived the following comparisons are needed
get:baRCV.NXT = nex
get:bais the le
get:baRCV.NXT+RCV.W
get:basegment, 
get:baSEG.SEQ = fir
get:baSEG.SEQ+SEG.L
get:baA segment is ju
get:baRCV.NXT =< SE
get:baRCV.NXT =< SE
get:baTransmission Cont
get:baFunctional Specif
get:baThe first part 
get:basegment falls i
get:baif the end of t
get:baeither part of 
get:baActually, it is
get:bawindows and zer
get:baacceptability o:f an incoming segment
get:baSegment Recei
get:baLength  Windo
get:ba------- -----
get:ba0       0 
get:ba0      >0 
get:ba>0       0 
get:ba>0      >0 
get:baNote that when 
get:baacceptable exce
get:bamaintain a zero
get:baACKs.  However,
get:baprocess the RST
get:baWe have taken a
get:bacontrol informa
get:basome control fl
get:baand acknowledge
get:bacontrol will be
get:bacarried in the 
get:bafor implicitly 
get:baare the only co
get:baare used only a
get:bapurposes, the S
get:baoctet of the se
get:bato occur after 
get:baoccurs.  The se
get:baspace occupying
get:basequence number
get:ba[Page 26]        
get:baSeptember 1981   
get:baInitial Sequenc
get:baThe protocol pl
get:baused over and o
get:basockets.  New i
get:baincarnations of
get:ba-- "how does th
get:baincarnations of
get:baconnection is b
get:baconnection brea
get:baTo avoid confus
get:baconnection from
get:babe present in t
get:baassure this, ev
get:basequence number
get:baan initial sequ
get:banew 32 bit ISN.
get:babit clock whose
get:bamicroseconds.  
get:baSince we assume
get:bathe Maximum Seg
get:bahours we can re
get:baFor each connec
get:basequence number
get:bathe data sendin
get:balearned during 
get:baFor a connectio
get:basynchronize on 
get:baan exchange of 
get:bacalled "SYN" (f
get:bashorthand, segm
get:baHence, the solu
get:bainitial sequenc
get:baThe synchroniza
get:basequence number
get:bafrom the other 
get:bainitial sequenc
get:ba1) A --> B  S
get:ba2) A <-- B  A
get:ba3) A <-- B  S
get:ba4) A --> B  A
get:baTransmission Cont
get:baFunctional Specif
get:baBecause steps 2
get:bacalled the thre
get:baA three way han
get:batied to a globa
get:bamechanisms for 
get:bano way of knowi
get:baunless it remem
get:ba(which is not a
get:baverify this SYN
get:baclock-driven sc
get:baKnowing When to
get:baTo be sure that
get:basequence number
get:bathe network, th
get:ba(MSL) before as
get:barecovering from
get:balost.  For this
get:bais an engineeri
get:bait is desirable
get:basense, yet reta
get:banot wait at all
get:bathan those rece
get:baThe TCP Quiet T
get:baThis specific
get:baretaining any
get:baeach active (
get:baTCP segments 
get:bain the intern
get:baparagraphs be
get:baTCP implement
get:baat the risk o
get:badata rejected
get:baTCPs consume 
get:baentered into 
get:baduplicate det
get:barelies on the
get:bathe extent th
get:bavalues before
get:babeen delivere
get:bacopies of the
get:basuch an assum
get:ba[Page 28]        
get:baSeptember 1981   
get:baassigned the 
get:baat the receiv
get:bathat each seg
get:baas there are 
get:baUnder normal 
get:bato emit and t
get:bamistakenly us
get:babeen acknowle
get:badata is drain
get:bavery large to
get:bacause trouble
get:bato use up 2**
get:balifetime in t
get:bathis is deeme
get:barates escalat
get:bacycle time is
get:bawithin reason
get:baThe basic dup
get:badefeated, how
get:basequence numb
get:bathe TCP were 
get:baupon crashing
get:baconnection (p
get:bapackets with 
get:bapackets still
get:baincarnation o
get:baabout the seq
get:baspecification
get:babefore emitti
get:basegments from
get:baEven hosts wh
get:bainitial seque
get:ba(i.e., even i
get:banumber for ea
get:baSuppose, for 
get:basequence numb
get:baand that even
get:batakes on a va
get:basegment sent 
get:baat this insta
get:baincarnation o
get:baS1 = ISN(t) -
get:baconnection!  
get:baTransmission Cont
get:baFunctional Specif
get:baduplicates in
get:baof S1 may arr
get:bathe new incar
get:baThe problem i
get:bacrashed nor d
get:bathe system fr
get:baOne way to de
get:basegments for 
get:batime" specifi
get:bawilling to ri
get:badestination m
get:baImplementors 
get:baconnection by
get:bainformally im
get:baObviously, ev
get:banecessary aft
get:baTo summarize:
get:banumbers in th
get:ba"busy" or "in
get:bablock of spac
get:basegment, if a
get:basequence numb
get:bathe previous 
get:banumber overla
get:ba3.4.  Establishin
get:baThe "three-way 
get:baconnection.  Th
get:baresponded to by
get:basimultaneously 
get:baoccurs, each TC
get:baacknowledgment 
get:baan old duplicat
get:barecipient, that
get:baProper use of "
get:baSeveral example
get:baexamples do not
get:basegments, this 
get:badoesn't deliver
get:bavalid (i.e., th
get:baconnection reac
get:bareduces the pos
get:ba[Page 30]        
get:baSeptember 1981   
get:baimplementation 
get:bainformation for
get:baThe simplest th
get:bafigures should 
get:banumbered for re
get:badeparture of a 
get:basegment at B fr
get:baEllipsis (...) 
get:ba(delayed).  An 
get:baComments appear
get:bathe departure o
get:bathe center of e
get:baform, with sequ
get:bafields such as 
get:bain the interest
get:baTCP A      
get:ba1.  CLOSED     
get:ba2.  SYN-SENT   
get:ba3.  ESTABLISHED
get:ba4.  ESTABLISHED
get:ba5.  ESTABLISHED
get:baBasic 3
get:baIn line 2 of fi
get:baindicating that
get:banumber 100.  In
get:bareceived from T
get:baB is now expect
get:baoccupied sequen
get:baAt line 4, TCP 
get:baTCP B's SYN; an
get:basequence number
get:babecause the ACK
get:bawould wind up A
get:baTransmission Cont
get:baFunctional Specif
get:baSimultaneous in
get:bafigure 8.  Each
get:baTCP A      
get:ba1.  CLOSED     
get:ba2.  SYN-SENT   
get:ba3.  SYN-RECEIVE
get:ba4.             
get:ba5.  SYN-RECEIVE
get:ba6.  ESTABLISHED
get:ba7.             
get:baS
get:baThe principle r
get:baduplicate conne
get:bathis, a special
get:bareceiving TCP i
get:baSYN-RECEIVED), 
get:baIf the TCP is i
get:baFIN-WAIT-1, FIN
get:baaborts the conn
get:bacase under "hal
get:ba[Page 32]        
get:baSeptember 1981   
get:baTCP A      
get:ba1.  CLOSED     
get:ba2.  SYN-SENT   
get:ba3.  (duplicate)
get:ba4.  SYN-SENT   
get:ba5.  SYN-SENT   
get:ba6.             
get:ba7.  SYN-SENT   
get:ba8.  ESTABLISHED
get:baAs a simple exa
get:bafigure 9.  At l
get:bacannot tell tha
get:ba(line 4).  TCP 
get:baRST (reset) wit
get:babelievable.  TC
get:baWhen the origin
get:basynchronization
get:babefore the RST,
get:basent in both di
get:baHalf-Open Conne
get:baAn established 
get:baTCPs has closed
get:baknowledge of th
get:babecome desynchr
get:bamemory.  Such c
get:baattempt is made
get:baconnections are
get:bamildly involved
get:baIf at site A th
get:baTransmission Cont
get:baFunctional Specif
get:bauser at site B 
get:bareceiving a res
get:basite B TCP that
get:baAssume that two
get:baanother when a 
get:baDepending on th
get:bathat some error
get:baA is likely to 
get:bapoint.  As a re
get:baor try to SEND 
get:bacase, it receiv
get:balocal (A's) TCP
get:bawill send a seg
get:baexample shown i
get:bare-open the con
get:baTCP A      
get:ba1.  (CRASH)    
get:ba2.  CLOSED     
get:ba3.  SYN-SENT --
get:ba4.  (!!)     <-
get:ba5.  SYN-SENT --
get:ba6.  SYN-SENT   
get:ba7.  SYN-SENT --
get:baWhen the SYN ar
get:baand the incomin
get:baacknowledgment 
get:ba100).  TCP A se
get:basent and, being
get:badetected a half
get:ba[Page 34]        
get:baSeptember 1981   
get:bacontinue to try
get:bareduced to the 
get:baAn interesting 
get:batries to send d
get:baThis is illustr
get:baTCP A from TCP 
get:baexists, so TCP 
get:baprocesses it an
get:baTCP A    
get:ba1.  (CRASH)    
get:ba2.  (??)    <--
get:ba3.          -->
get:baActive
get:baIn figure 12, w
get:bawaiting for SYN
get:bainto action.  A
get:bagenerate a RST 
get:bathe reset and r
get:baTCP A      
get:ba1.  LISTEN     
get:ba2.       ... <S
get:ba3.  (??) <-- <S
get:ba4.       --> <S
get:ba5.  LISTEN     
get:baOld Duplic
get:baTransmission Cont
get:baFunctional Specif
get:baA variety of ot
get:baby the followin
get:baReset Generatio
get:baAs a general ru
get:bawhich apparentl
get:bamust not be sen
get:baThere are three: groups of states
get:ba1.  If the co
get:bain response t
get:baparticular, S
get:baby this means
get:baIf the incomi
get:basequence numb
get:bareset has seq
get:baof the sequen
get:baThe connectio
get:ba2.  If the co
get:baSYN-SENT, SYN
get:basomething not
get:baif an incomin
get:badoes not exac
get:baconnection, a
get:baIf our SYN ha
get:baincoming segm
get:baeither raise 
get:bathe system) o
get:baincoming segm
get:bacontinue as i
get:bacannot raise 
get:badetected in t
get:baterminated th
get:baincoming segm
get:bamatch the loc
get:bamust be sent.
get:baIf the incomi
get:basequence numb
get:bareset has seq
get:baof the sequen
get:baThe connectio
get:ba[Page 36]        
get:baSeptember 1981   
get:ba3.  If the co
get:baFIN-WAIT-1, F
get:baany unaccepta
get:baunacceptible 
get:baacknowledgmen
get:baand an acknow
get:bato be receive
get:baIf an incomin
get:baprecedence wh
get:baand precedenc
get:baconnection go
get:banumber from t
get:baReset Processin
get:baIn all states e
get:baby checking the
get:bais in the windo
get:bato an initial S
get:baacknowledges th
get:baThe receiver of
get:bareceiver was in
get:bain SYN-RECEIVED
get:bathen the receiv
get:baaborts the conn
get:bawas in any othe
get:baand goes to the
get:ba3.5.  Closing a C
get:baCLOSE is an ope
get:banotion of closi
get:bainterpretation,
get:bathe receiving s
get:bain a simplex fa
get:bauntil he is tol
get:bacould initiate 
get:baRECEIVE until s
get:bahas CLOSED.  We
get:baRECEIVEs are ou
get:bacan terminate h
get:babuffers SENT be
get:badata in return 
get:basuccessfully to
get:baTCP.  Users mus
get:bathe TCP says no
get:baTransmission Cont
get:baFunctional Specif
get:baThere are essen:tially three cases
get:ba1) The user i
get:ba2) The remote
get:ba3) Both users
get:baCase 1:  Local 
get:baIn this case,
get:baoutgoing segm
get:baaccepted by t
get:baare allowed i
get:bawill be retra
get:baboth acknowle
get:bacan ACK this 
get:basend its own 
get:baCase 2:  TCP re
get:baIf an unsolic
get:bacan ACK it an
get:bauser will res
get:bathe other TCP
get:bauntil its own
get:baconnection.  
get:bathe connectio
get:baCase 3:  both u
get:baA simultaneou
get:baFIN segments 
get:bahave been pro
get:bahas received.
get:ba[Page 38]        
get:baSeptember 1981   
get:baTCP A      
get:ba1.  ESTABLISHED
get:baFIN-WAIT-1 
get:ba3.  FIN-WAIT-2 
get:ba4.             
get:baTIME-WAIT  
get:ba5.  TIME-WAIT  
get:baCLOSED     
get:baTCP A      
get:ba1.  ESTABLISHED
get:ba2.  (Close)    
get:baFIN-WAIT-1 
get:ba3.  CLOSING    
get:ba4.  TIME-WAIT  
get:ba(2 MSL)    
get:baCLOSED     
get:baTransmission Cont
get:baFunctional Specif
get:ba3.6.  Precedence 
get:baThe intent is t
get:bawith exactly th
get:bahigher of the p
get:baThe precedence 
get:badefined in the 
get:baspecification t
get:bathe security pa
get:bauser group, and
get:baA connection at
get:balower precedenc
get:baa connection du
get:baacknowledgment 
get:baNote that TCP m
get:baprecedence will
get:basegments and po
get:baThe security pa
get:ba(the values wou
get:banon-secure envi
get:baparameters, tho
get:ba3.7.  Data Commun
get:baOnce the connec
get:baexchange of seg
get:ba(checksum test 
get:baretransmission 
get:baDuplicate segme
get:baAs discussed in
get:bacertain tests o
get:basegments to ver
get:baThe sender of d
get:bathe variable SN
get:basequence number
get:bakeeps track of 
get:bavariable SND.UN
get:basent has been a
get:baWhen the sender
get:baSND.NXT.  When 
get:basends an acknow
get:ba[Page 40]        
get:baSeptember 1981   
get:baacknowledgment 
get:bathese variables
get:baThe amount by w
get:badata in the seg
get:basegments must c
get:baThe CLOSE user 
get:baflag in an inco
get:baRetransmission 
get:baBecause of the 
get:bainternetwork sy
get:baretransmission 
get:bafor determining
get:baAn Example Re
get:baMeasure the
get:baparticular 
get:bacovers that
get:basegments re
get:baTime (RTT).:  Next compute a Smoothed Round Trip Time (SRTT) as
get:baSRTT = ( 
get:baand based o:n this, compute the retransmission timeout (RTO) as
get:baRTO = min
get:bawhere UBOUN
get:baLBOUND is a
get:baa smoothing
get:bafactor (e.g
get:baThe Communicati
get:baThe objective o
get:bato stimulate th
get:bapermit the rece
get:bathe currently k
get:baThis mechanism 
get:bathe end of urge
get:bathe receive seq
get:bamust tell the u
get:banumber catches 
get:baTransmission Cont
get:baFunctional Specif
get:bainto "normal mo
get:bais in "urgent m
get:baThe method empl
get:batransmitted.  T
get:bameaningful and 
get:bathe urgent poin
get:bano urgent data 
get:baTo send an urge
get:baoctet.  If the 
get:bathe urgent info
get:baManaging the Wi
get:baThe window sent
get:banumbers the sen
get:baprepared to acc
get:bathe currently a
get:baIndicating a la
get:baarrives than ca
get:bain excessive re
get:banetwork and the
get:batransmission of
get:babetween each ne
get:baThe mechanisms 
get:basubsequently ad
get:bathat much data.
get:badiscouraged.  T
get:bashrink the wind
get:baon the part of 
get:baThe sending TCP
get:baleast one octet
get:basending TCP mus
get:bathe window is z
get:bainterval when t
get:baguarantee that 
get:bawindow will be 
get:baWhen the receiv
get:bastill send an a
get:baand current win
get:baThe sending TCP
get:ba[Page 42]        
get:baSeptember 1981   
get:bawhich fit the c
get:baretransmission 
get:baIn a connection
get:babe carried in a
get:banumber so there
get:baorder.  This is
get:bainformation to 
get:bathe data receiv
get:bathe window info
get:baacknowledgment 
get:baequal or greate
get:baThe window mana
get:bacommunication p
get:baWindow Manage
get:baAllocating 
get:bamany small 
get:bafewer large
get:baOne suggest
get:badefer updat
get:baleast X per
get:baconnection 
get:baAnother sug
get:basegments by
get:basending dat
get:badata must b
get:baNote that t
get:baretransmiss
get:baacknowledgm
get:bawindow info
get:banew window 
get:baThe segment
get:baof transmit
get:basegment con
get:bais accepted
get:baIf the send
get:bawindow is n
get:baalternating
get:bapauses in t
get:baTransmission Cont
get:baFunctional Specif
get:baresult in b
get:babig pair. A
get:bamostly smal
get:baThe suggest
get:baactively at
get:bawindows, si
get:bato many sma
get:baThere are of co:urse two interfaces of concern
get:baand the TCP/low
get:baof the user/TCP
get:baprotocol module
get:bain detail by th
get:bacase that the l
get:bathat TCPs might
get:baUser/TCP Interf
get:baThe following
get:baat best, fict
get:bafacilities.  
get:baimplementatio
get:baTCPs must pro
get:bathat all TCP 
get:bahierarchy.  T
get:barequired of a
get:baTCP User Comm
get:baThe followi
get:bainterface. 
get:bafunction ca
get:bameant to ru
get:baThe user co
get:baTCP must pe
get:baIndividual 
get:bamay provide
get:basingle call
get:baautomatical
get:baissued by t
get:ba[Page 44]        
get:baSeptember 1981   
get:baIn providin
get:banot only ac
get:baprocesses i:t serves.  The latter consists of
get:ba(a) gener
get:baremote cl
get:ba(b) repli
get:bavarious t
get:baFormat:  
get:ba[, timeou
get:ba-> local 
get:baWe assume
get:baprocesses
get:bato use th
get:baimplement
get:bafor the s
get:balower lev
get:baresult of
get:baable to m
get:baprocess c
get:baIf the ac
get:bacall to L
get:bahave eith
get:baparticula
get:bafor any c
get:baby the su
get:baA transmi
get:bafilled in
get:baOn an act
get:basynchroni
get:baThe timeo
get:bafor all d
get:badelivered
get:bawill abor
get:baThe TCP o
get:bathe users
get:baTransmission Cont
get:baFunctional Specif
get:baprecedenc
get:baor securi
get:bathe defau
get:baTCP will 
get:basecurity/
get:bathe prece
get:barequested
get:baThe prece
get:barequested
get:barequest, 
get:baconnectio
get:bathis prec
get:baallowed t
get:baor that a
get:baA local c
get:baThe local
get:bafor the c
get:baFormat:  
get:bacount, PU
get:baThis call
get:bato be sen
get:banot been 
get:baimplement
get:baautomatic
get:baauthorize
get:baIf the PU
get:bato the re
get:basegment c
get:bathe data 
get:batransmiss
get:baIf the UR
get:bawill have
get:bathe urgen
get:bapointer i
get:babeen cons
get:bais to sti
get:baindicate 
get:ba[Page 46]        
get:baSeptember 1981   
get:badata has 
get:baTCP signa
get:baof times 
get:baurgent da
get:baIf no for
get:baconnectio
get:bahas becom
get:balocal soc
get:baforeign s
get:baforeign s
get:baknowing t
get:baHowever, 
get:babecomes s
get:baSTATUS ca
get:baimplement
get:basocket is
get:baIf a time
get:baconnectio
get:baIn the si
get:bathe sendi
get:baor the ti
get:bais both s
get:baconnectio
get:baoffers po
get:basophistic
get:bathe proce
get:bafurthermo
get:baMultiple 
get:bathe TCP w
get:baWe have i
get:bawhich a S
get:bapseudo-in
get:bareturn a 
get:baimmediate
get:babeen ackn
get:baassume ev
get:baclose any
get:bakind (syn
get:basignals, 
get:bawith spec
get:baIn order 
get:baindicatio
get:baTransmission Cont
get:baFunctional Specif
get:babuffer ad
get:bathe SEND 
get:baindicatin
get:bacalling p
get:baFormat:  
get:bacount) ->
get:baThis comm
get:baspecified
get:bacalling p
get:baerror is 
get:baIn the si
get:bacalling p
get:baerror occ
get:baA more so
get:baRECEIVEs 
get:basegments 
get:bathe cost 
get:banotify th
get:baIf enough
get:bathe PUSH 
get:baThe buffe
get:baa PUSH is
get:bareturned 
get:baIf there 
get:baas it arr
get:bashould th
get:baadditiona
get:bacall to R
get:bamay now l
get:baurgent po
get:bain the sa
get:baboundary 
get:baTo distin
get:bacare of t
get:bareturn co
get:bacount ind
get:baAlternati
get:ba[Page 48]        
get:baSeptember 1981   
get:baallocate 
get:bawith the 
get:baFormat:  
get:baThis comm
get:bathe conne
get:baauthorize
get:baClosing c
get:bathe sense
get:baretransmi
get:baserviced.
get:bacalls, fo
get:bato the de
get:bacontinue 
get:bamay be tr
get:bameans "I 
get:bareceive a
get:banot well 
get:baof all it
get:bainto ABOR
get:baThe user 
get:bainitiativ
get:ba(e.g., re
get:badestinati
get:baBecause c
get:baforeign T
get:bashort tim
get:bareplies t
get:baClose als
get:baFormat:  
get:baThis is a
get:baexcluded 
get:batypically
get:baThis comm
get:bainformati:on
get:balocal s
get:baTransmission Cont
get:baFunctional Specif
get:baforeign
get:balocal c
get:bareceive
get:basend wi
get:baconnect
get:banumber 
get:banumber 
get:baurgent 
get:baprecede
get:basecurit
get:baand tra
get:baDepending
get:baimplement
get:baavailable
get:baauthorize
get:baprevents 
get:baconnectio
get:baFormat:  
get:baThis comm
get:baaborted, 
get:babe sent t
get:baDepending
get:baindicatio
get:bareceive a
get:baTCP-to-User M
get:baIt is assum
get:bameans for t
get:bathe TCP doe
get:bato the user
get:baan error me
get:barelating to
get:baother user 
get:baThe followi:ng information is provided
get:baLocal Con
get:baResponse 
get:baBuffer Ad
get:baByte coun
get:baPush flag
get:baUrgent fl
get:ba[Page 50]        
get:baSeptember 1981   
get:baTCP/Lower-Level
get:baThe TCP calls
get:bareceive infor
get:bainternetwork 
get:baProtocol (IP)
get:baIf the lower 
get:baof service an
get:bafor these par:ameters
get:baType of Ser:vice = Precedence: routine, Delay: normal, Throughput
get:banormal, Rel:iability
get:baTime to Liv
get:baNote that
get:baHere we e
get:babe delive
get:baIf the lower 
get:bafeature) and 
get:baroute informa
get:baso that the s
get:bachecksum be t
get:baalso importan
get:baAny lower lev
get:badestination a
get:bathe "TCP leng
get:baof IP and to 
get:baTransmission Cont
get:baFunctional Specif
get:ba3.9.  Event Proce
get:baThe processing 
get:baimplementation.
get:baprocessing sequ
get:basection only in
get:baThe activity of
get:baThe events that: occur can be cast into three categories
get:baarriving segmen
get:baprocessing the 
get:bacases the proce
get:baEvents that o:ccur
get:baArriving Se
get:baSEGMENT A
get:baUSER TIME
get:baRETRANSMI
get:baTIME-WAIT
get:baThe model of th
get:baimmediate retur
get:bapseudo interrup
get:bameans cause a d
get:baError responses
get:bacommands refere:ncing connections that do not exist receive "error
get:baconnection not 
get:baPlease note in 
get:baacknowledgment 
get:baof the sequence
get:baequal to (modul
get:ba[Page 52]        
get:baSeptember 1981   
get:baA natural way t
get:baimagine that th
get:bathat their cont
get:bain the sequence
get:baand processed i
get:baWhen a segment 
get:bathe segment to 
get:bato be consisten
get:baNote that if no
get:baTransmission Cont
get:baFunctional Specif
get:baCLOSED STATE 
get:baCreate a ne
get:bastate infor
get:basocket, pre
get:bainformation
get:baunspecified
get:baparameters 
get:baprecedence 
get:ba"error:  pr:ecedence not allowed" or "error
get:banot allowed
get:baactive and :the foreign socket is unspecified, return "error
get:baforeign soc
get:baspecified, 
get:ba(ISS) is se
get:bais sent.  S
get:bastate, and 
get:baIf the call
get:bareturn "err:or
get:bano room to :create a new connection, return "error
get:baresources".
get:baIf active a
get:baconnection 
get:basegment, se
get:bastate.  Dat
get:baqueued for 
get:baurgent bit 
get:basegments se
get:baqueue the r:equest, respond with "error
get:baIf Foreign :socket was not specified, then return "error
get:basocket unsp
get:ba[Page 54]        
get:baSeptember 1981   
get:baSYN-SENT STAT
get:baSYN-RECEIVED 
get:baESTABLISHED S
get:baFIN-WAIT-1 ST
get:baFIN-WAIT-2 ST
get:baCLOSE-WAIT ST
get:baCLOSING STATE
get:baLAST-ACK STAT
get:baTIME-WAIT STA
get:baReturn "err:or
get:baTransmission Cont
get:baFunctional Specif
get:baCLOSED STATE 
get:baIf the user
get:ba"error:  co
get:baOtherwise, :return "error
get:baIf the fore
get:bafrom passiv
get:baSND.UNA to 
get:baassociated 
get:batransmissio
get:barequested i
get:baas a result
get:barequest, re:spond with "error
get:baForeign soc:ket was not specified, then return "error
get:basocket unsp
get:baSYN-SENT STAT
get:baSYN-RECEIVED 
get:baQueue the d
get:baIf no space: to queue, respond with "error
get:baresources".
get:baESTABLISHED S
get:baCLOSE-WAIT ST
get:baSegmentize 
get:baacknowledgm
get:bainsufficien:t space to remember this buffer, simply return "error
get:bainsufficien
get:baIf the urge
get:baurgent poin
get:ba[Page 56]        
get:baSeptember 1981   
get:baFIN-WAIT-1 ST
get:baFIN-WAIT-2 ST
get:baCLOSING STATE
get:baLAST-ACK STAT
get:baTIME-WAIT STA
get:baReturn "err:or
get:baTransmission Cont
get:baFunctional Specif
get:baCLOSED STATE 
get:baIf the user
get:ba"error:  co
get:baOtherwise r:eturn "error
get:baSYN-SENT STAT
get:baSYN-RECEIVED 
get:baQueue for p
get:bais no room :to queue this request, respond with "error
get:bainsufficien
get:baESTABLISHED S
get:baFIN-WAIT-1 ST
get:baFIN-WAIT-2 ST
get:baIf insuffic
get:barequest, qu
get:baremember th:e RECEIVE, respond with "error
get:baresources".
get:baReassemble 
get:bato user.  M
get:baIf RCV.UP i
get:bauser notify
get:baWhen the TC
get:bathat fact m
get:baacknowledgm
get:badescribed b
get:ba[Page 58]        
get:baSeptember 1981   
get:baCLOSE-WAIT ST
get:baSince the r
get:basatisfied b
get:bauser.  If n
get:ba"error:  co
get:batext can be
get:baCLOSING STATE
get:baLAST-ACK STAT
get:baTIME-WAIT STA
get:baReturn "err:or
get:baTransmission Cont
get:baFunctional Specif
get:baCLOSED STATE 
get:baIf the user
get:ba"error:  co
get:baOtherwise, :return "error
get:baAny outstan:ding RECEIVEs are returned with "error
get:baresponses. 
get:baSYN-SENT STAT
get:baDelete the :TCB and return "error
get:baqueued SEND
get:baSYN-RECEIVED 
get:baIf no SENDs
get:bathen form a
get:baotherwise q
get:baESTABLISHED S
get:baQueue this 
get:baform a FIN 
get:baFIN-WAIT-1 ST
get:baFIN-WAIT-2 ST
get:baStrictly sp:eaking, this is an error and should receive a "error
get:baconnection 
get:baacceptable,
get:baFIN may be 
get:ba[Page 60]        
get:baSeptember 1981   
get:baCLOSE-WAIT ST
get:baQueue this 
get:basegmentized
get:baCLOSING STATE
get:baLAST-ACK STAT
get:baTIME-WAIT STA
get:baRespond wit:h "error
get:baTransmission Cont
get:baFunctional Specif
get:baCLOSED STATE 
get:baIf the user
get:ba"error:  co
get:baOtherwise r:eturn "error
get:baAny outstan:ding RECEIVEs should be returned with "error
get:baconnection 
get:baSYN-SENT STAT
get:baAll queued 
get:banotificatio
get:baSYN-RECEIVED 
get:baESTABLISHED S
get:baFIN-WAIT-1 ST
get:baFIN-WAIT-2 ST
get:baCLOSE-WAIT ST
get:baSend a rese:t segment
get:ba<SEQ=SND.
get:baAll queued 
get:banotificatio
get:baRST formed 
get:baTCB, enter 
get:baCLOSING STATE
get:baLAST-ACK STAT
get:baTIME-WAIT STA
get:baRespond wit
get:ba[Page 62]        
get:baSeptember 1981   
get:baCLOSED STATE 
get:baIf the user
get:ba"error:  co
get:baOtherwise r:eturn "error
get:baReturn "sta
get:baSYN-SENT STAT
get:baReturn "sta
get:baSYN-RECEIVED 
get:baReturn "sta
get:baESTABLISHED S
get:baReturn "sta
get:baFIN-WAIT-1 ST
get:baReturn "sta
get:baFIN-WAIT-2 ST
get:baReturn "sta
get:baCLOSE-WAIT ST
get:baReturn "sta
get:baCLOSING STATE
get:baReturn "sta
get:baLAST-ACK STAT
get:baReturn "sta
get:baTransmission Cont
get:baFunctional Specif
get:baTIME-WAIT STA
get:baReturn "sta
get:ba[Page 64]        
get:baSeptember 1981   
get:baSEGMENT ARRIVES
get:baIf the state 
get:baall data in
get:basegment con
get:bacontaining 
get:baacknowledgm
get:bareset seque
get:baIf the ACK 
get:ba<SEQ=0><A
get:baIf the ACK 
get:ba<SEQ=SEG.
get:baIf the state 
get:bafirst check
get:baAn incomi
get:basecond chec
get:baAny ackno
get:bathe LISTE
get:bafor any a
get:baformatted: as follows
get:ba<SEQ=SE
get:bathird check
get:baIf the SY
get:basecurity/
get:bamatch the
get:ba<SEQ=SE
get:baTransmission Cont
get:baFunctional Specif
get:baIf the SE
get:bathe user 
get:basend a re
get:ba<SEQ=SE
get:baIf the SE
get:baSet RCV.N
get:bacontrol o
get:bashould be: selected and a SYN segment sent of the form
get:ba<SEQ=IS
get:baSND.NXT i
get:bastate sho
get:baincoming 
get:bain the SY
get:banot be re
get:bathe forei
get:baunspecifi
get:bafourth othe
get:baAny other
get:bamust have
get:baprocessin
get:bait could 
get:baincarnati
get:babut if yo
get:baIf the state 
get:bafirst check
get:baIf the AC
get:baIf SEG.
get:bathe RST
get:ba<SEQ=
get:baand dis
get:baIf SND.
get:basecond chec
get:ba[Page 66]        
get:baSeptember 1981   
get:baIf the RS
get:baIf the :ACK was acceptable then signal the user "error
get:baconnect
get:badelete 
get:baand ret
get:bathird check
get:baIf the se
get:bamatch the
get:baIf ther
get:ba<SEQ=
get:baOtherwi
get:ba<SEQ=
get:baIf there 
get:baThe pre
get:baTCB, if
get:ba<SEQ=
get:baIf there 
get:baIf the 
get:bain the 
get:bathe pre
get:baallowed
get:ba<SEQ=
get:baIf the 
get:bain the 
get:baIf a rese
get:bafourth chec
get:baThis step
get:bano ACK, a
get:baIf the SY
get:baTransmission Cont
get:baFunctional Specif
get:baare accep
get:baSEG.SEQ. 
get:bais an ACK
get:baare there
get:baIf SND.UN
get:bastate to 
get:ba<SEQ=SN
get:baand send 
get:batransmiss
get:batext in t
get:babelow whe
get:baOtherwise
get:ba<SEQ=IS
get:baand send 
get:basegment, 
get:bahas been 
get:bafifth, if n
get:basegment and
get:ba[Page 68]        
get:baSeptember 1981   
get:bafirst check s
get:baSYN-RECEIVE
get:baESTABLISHED
get:baFIN-WAIT-1 
get:baFIN-WAIT-2 
get:baCLOSE-WAIT 
get:baCLOSING STA
get:baLAST-ACK ST
get:baTIME-WAIT S
get:baSegments 
get:baare used 
get:badone in S
get:baboundary 
get:baprocessed
get:baThere are
get:basegment
get:baSegment R
get:baLength  W
get:ba------- -
get:ba0     
get:ba0     
get:ba>0     
get:ba>0     
get:baIf the RC
get:baspecial a
get:baIf an inc
get:bashould be
get:bathe segme:nt and return)
get:ba<SEQ=SN
get:baAfter sen
get:baand retur
get:baTransmission Cont
get:baFunctional Specif
get:baIn the fo
get:basegment t
get:baOne could
get:batrimming 
get:baSYN and F
get:babegins at
get:banumbers m
get:basecond check 
get:baSYN-RECEIVE
get:baIf the RS
get:baIf this
get:bacame fr
get:baLISTEN 
get:bathis co
get:bafrom SY
get:bathe use
get:baon the 
get:baactive 
get:baand ret
get:baESTABLISHED
get:baIf the RS
get:bashould re
get:baflushed. 
get:ba"connecti
get:baTCB, and 
get:baCLOSING STA
get:baLAST-ACK ST
get:baIf the RS
get:baTCB, and 
get:ba[Page 70]        
get:baSeptember 1981   
get:bathird check s
get:baSYN-RECEIVE
get:baIf the se
get:baexactly m
get:bathen send
get:baESTABLISHED
get:baIf the se
get:baexactly m
get:bathen send
get:bareceive "
get:baflushed. 
get:ba"connecti
get:baTCB, and 
get:baNote this c
get:baa segment f
get:badifferent s
get:bacurrent con
get:bafourth, check
get:baSYN-RECEIVE
get:baESTABLISHED
get:baFIN-WAIT ST
get:baFIN-WAIT ST
get:baCLOSE-WAIT 
get:baCLOSING STA
get:baLAST-ACK ST
get:baTIME-WAIT S
get:baIf the SY
get:baoutstandi
get:baall segme
get:bareceive a
get:bathe CLOSE
get:baIf the SY
get:baand an ac
get:banumber ch
get:baTransmission Cont
get:baFunctional Specif
get:bafifth check t
get:baif the ACK 
get:baif the ACK 
get:baSYN-RECEI
get:baIf SND.
get:baand con
get:baIf th
get:bareset
get:ba<SE
get:baand s
get:baESTABLISH
get:baIf SND.
get:baAny seg
get:baentirel
get:bapositiv
get:bafully a
get:ba"ok" re
get:ba(SEG.AC
get:basomethi
get:badrop th
get:baIf SND.
get:baupdated
get:baSND.WL2
get:baSND.WL1
get:baNote th
get:barecords
get:baSND.WND
get:bathe las
get:baprevent
get:ba[Page 72]        
get:baSeptember 1981   
get:baFIN-WAIT-
get:baIn addi
get:baour FIN
get:baprocess
get:baFIN-WAIT-
get:baIn addi
get:bathe ret
get:baacknowl
get:baCLOSE-WAI
get:baDo the 
get:baCLOSING S
get:baIn addi
get:bathe ACK
get:baotherwi
get:baLAST-ACK 
get:baThe onl
get:baacknowl
get:badelete 
get:baTIME-WAIT
get:baThe onl
get:baretrans
get:bathe 2 M
get:basixth, check 
get:baESTABLISHED
get:baFIN-WAIT-1 
get:baFIN-WAIT-2 
get:baIf the UR
get:bathe user 
get:bapointer (
get:bauser has 
get:bamode") fo
get:basignal th
get:baTransmission Cont
get:baFunctional Specif
get:baCLOSE-WAIT 
get:baCLOSING STA
get:baLAST-ACK ST
get:baThis shou
get:baremote si
get:baseventh, proc
get:baESTABLISHED
get:baFIN-WAIT-1 
get:baFIN-WAIT-2 
get:baOnce in t
get:batext to u
get:bainto buff
get:baempty.  I
get:bathe user 
get:bahas been 
get:baWhen the 
get:bauser it m
get:baOnce the 
get:baRCV.NXT o
get:baapporopri
get:baRCV.NXT a
get:baPlease no
get:baSend an a:cknowledgment of the form
get:ba<SEQ=SN
get:baThis ackn
get:batransmitt
get:ba[Page 74]        
get:baSeptember 1981   
get:baCLOSE-WAIT 
get:baCLOSING STA
get:baLAST-ACK ST
get:baTIME-WAIT S
get:baThis shou
get:baremote si
get:baeighth, check
get:baDo not proc
get:basince the S
get:baIf the FIN 
get:bareturn any 
get:baover the FI
get:baFIN implies
get:baSYN-RECEI
get:baESTABLISH
get:baEnter t
get:baFIN-WAIT-
get:baIf our 
get:baenter T
get:batimers;
get:baFIN-WAIT-
get:baEnter t
get:baoff the
get:baCLOSE-WAI
get:baRemain 
get:baCLOSING S
get:baRemain 
get:baLAST-ACK 
get:baRemain 
get:baTransmission Cont
get:baFunctional Specif
get:baTIME-WAIT
get:baRemain 
get:batimeout
get:ba[Page 76]        
get:baSeptember 1981   
get:baFor any state
get:bathe user "err:or
get:baand for any o
get:bastate and ret
get:baRETRANSMISSION 
get:baFor any state
get:bathe retransmi
get:baretransmissio
get:baTIME-WAIT TIMEO
get:baIf the time-w
get:baenter the CLO
get:baTransmission Cont
get:ba[Page 78]        
get:baSeptember 1981   
get:baBBN Rep
get:baa Host 
get:bahost an
get:baA contr
get:baindicat
get:baspecifi
get:bais expe
get:bapreviou
get:baThe uni
get:baARPANET
get:baA unit 
get:baIMPs.  
get:baA logic
get:baA messa
get:banetwork
get:baDestination Addre
get:baThe des
get:baidentif
get:baA contr
get:baindicat
get:baoccupyi
get:baA porti
get:bafragmen
get:baA file 
get:baTransmission Cont
get:baControl
get:bafragmen
get:baA compu
get:bafrom th
get:baAn Inte
get:baby the 
get:baThe Int
get:baARPANET
get:baA sourc
get:bainternet datagram
get:baThe uni
get:bahigher 
get:bainternet fragment
get:baA porti
get:baheader.
get:baInterne
get:baThe Ini
get:banumber 
get:baThe Ini
get:baon a co
get:babased p
get:baThe Ini
get:baused by
get:baControl
get:badata.  
get:baon an A
get:ba[Page 80]        
get:baSeptember 1981   
get:baThis is
get:badata re
get:basequenc
get:baof the 
get:baThe uni
get:baAn impl
get:baprocedu
get:baMaximum
get:bathe int
get:baAn eigh
get:baAn Opti
get:bamay be 
get:baprimari
get:batimesta
get:baoptions
get:baA packa
get:balogical
get:balogical
get:baThe por
get:baoutput 
get:baA progr
get:bathe poi
get:baA contr
get:bathis se
get:bareceivi
get:bareceive
get:baTransmission Cont
get:bareceive
get:RFC
get:De
get:I
get:September 1981   
get:PREFACE .....
get:1.  INTRODUCTION 
get:1.1  Motivation
get:1.2  Scope ....
get:1.3  About This
get:1.4  Interfaces
get:1.5  Operation 
get:2.  PHILOSOPHY ..
get:2.1  Elements o
get:2.2  Model of O
get:2.3  The Host E
get:2.4  Interfaces
get:2.5  Relation t
get:2.6  Reliable C
get:2.7  Connection
get:2.8  Data Commu
get:2.9  Precedence
get:2.10 Robustness
get:3.  FUNCTIONAL SP
get:3.1  Header For
get:3.2  Terminolog
get:3.3  Sequence N
get:3.4  Establishi
get:3.5  Closing a 
get:3.6  Precedence
get:3.7  Data Commu
get:3.8  Interfaces
get:3.9  Event Proc
get:GLOSSARY ........
get:REFERENCES ......
get:Transmission Cont
get:[Page ii]        
get:September 1981   
get:This document des
get:(TCP).  There hav
get:specification on 
get:draws heavily fro
get:both in terms of 
get:several details a
get:and redescribes t
get:RFC
get:Replaces: RFC 761
get:IENs:  129, 124, 
get:55, 44, 40, 27, 2
get:The Transmission 
get:reliable host-to-
get:communication net
get:This document des
get:Transmission Cont
get:interface to prog
get:Computer commun
get:role in militar
get:document focuse
get:communication r
get:communication u
get:congestion, but
get:government sect
get:As strategic an
get:developed and d
get:interconnecting
get:communication p
get:applications.  
get:Deputy Undersec
get:declared the Tr
get:be a basis for 
get:standardization
get:TCP is a connec
get:fit into a laye
get:applications.  
get:communication b
get:distinct but in
get:assumptions are
get:protocols below
get:potentially unr
get:protocols.  In 
get:wide spectrum o
get:connections to 
get:Transmission Cont
get:TCP is based on
get:TCP fits into a
get:Internet Protoc
get:receive variabl
get:datagram "envel
get:addressing sour
get:internet protoc
get:the TCP segment
get:multiple networ
get:also carries in
get:and compartment
get:communicated en
get:Much of this do
get:which are co-re
get:computer.  Some
get:front-end compu
get:as well as netw
get:an interface to
get:implementable e
get:host-to-front e
get:The TCP is inte
get:communication s
get:intended to be 
get:1.3.  About this 
get:This document r
get:any TCP impleme
get:protocols and i
get:[Page 2]         
get:September 1981   
get:section offers 
get:operation.  Sec
get:design.  Sectio
get:required of TCP
get:user calls, err
get:The TCP interfa
get:the other side 
get:The interface b
get:illustrated in 
get:calls much like
get:application pro
get:calls to open a
get:established con
get:asynchronously 
get:considerable fr
get:interfaces whic
get:environment, a 
get:interface for a
get:The interface b
get:unspecified exc
get:two levels can 
get:Typically, one 
get:interface.  TCP
get:interconnected 
get:throughout this
get:As noted above,
get:securable logic
get:processes.  To 
get:communication s:ystem requires facilities in the following areas
get:Basic Data Tr
get:Precedence an
get:The basic opera
get:the following p
get:Transmission Cont
get:Basic Data Tran:sfer
get:The TCP is ab
get:direction bet
get:segments for 
get:the TCPs deci
get:Sometimes use
get:submitted to 
get:function is d
get:actually tran
get:pushed throug
get:promptly forw
get:The exact pus
get:the push func
get:Reliability
get:The TCP must 
get:delivered out
get:is achieved b
get:transmitted, 
get:receiving TCP
get:interval, the
get:numbers are u
get:out of order 
get:adding a chec
get:receiver, and
get:As long as th
get:system does n
get:errors will a
get:internet comm
get:Flow Control
get:TCP provides 
get:sent by the s
get:every ACK ind
get:the last segm
get:allowed numbe
get:receiving fur
get:[Page 4]         
get:September 1981   
get:Multiplexing
get:To allow for 
get:communication
get:addresses or 
get:and host addr
get:a socket.  A 
get:That is, a so
get:The binding o
get:Host.  Howeve
get:(e.g., a "log
get:made known to
get:through the k
get:addresses of 
get:Connections
get:The reliabili
get:that TCPs ini
get:each data str
get:sockets, sequ
get:Each connecti
get:identifying i
get:When two proc
get:establish a c
get:side).  When 
get:terminated or
get:Since connect
get:over the unre
get:mechanism wit
get:erroneous ini
get:Precedence and :Security
get:The users of 
get:communication
get:these feature
get:Transmission Cont
get:[Page 6]         
get:September 1981   
get:2.1.  Elements of
get:The internetwor
get:which are in tu
get:that the networ
get:large networks 
get:packet switchin
get:consume message
get:networks, the g
get:communication s
get:connections bet
get:The term packet
get:transaction bet
get:exchanged withi
get:Hosts are compu
get:network's point
get:Processes are v
get:accordance with
get:in execution). 
get:viewed as commu
get:Thus, all commu
get:Since a process
get:streams between
get:that each proce
get:communicates wi
get:2.2.  Model of Op
get:Processes trans
get:data as argumen
get:segments and ca
get:the destination
get:into the receiv
get:TCPs include co
get:ensure reliable
get:The model of in
get:protocol module
get:to the local ne
get:inside internet
get:internet module
get:through the loc
get:The packet swit
get:Transmission Cont
get:other operation
get:destination int
get:At a gateway be
get:from its local 
get:the internet da
get:then "wrapped" 
get:routed to the n
get:A gateway is pe
get:internet datagr
get:through the nex
get:internet datagr
get:further broken 
get:internet datagr
get:internet module
get:A destination i
get:(after reassemb
get:destination TCP
get:This simple mod
get:important featu
get:to the gateway 
get:service paramet
get:Included in the
get:datagram.  Data
get:host and gatewa
get:properly segreg
get:2.3.  The Host En
get:The TCP is assu
get:access the TCP 
get:may call on oth
get:data structures
get:controlled by a
get:network device 
get:datagram protoc
get:The mechanisms 
get:front-end proce
get:host-to-front-e
get:the type of TCP
get:[Page 8]         
get:September 1981   
get:The TCP/user in
get:to OPEN or CLOS
get:STATUS about a 
get:programs on the
get:from, and close
get:The TCP/interne
get:datagrams addre
get:system.  These 
get:service, preced
get:2.5.  Relation to
get:The following d
get:hierarchy
get:+------+ +
get:|Telnet| |
get:+------+ +
get:|   
get:+----
get:| TCP
get:+----
get:| 
get:+----
get:|    
get:+----
get:+--
get:|  
get:+--
get:It is expected 
get:protocols effic
get:protocols like 
get:2.6.  Reliable Co
get:A stream of dat
get:order at the de
get:Transmission Cont
get:Transmission is
get:acknowledgments
get:sequence number
get:segment is tran
get:sequence number
get:is the sequence
get:transmissions i
get:segment contain
get:starts a timer;
get:segment is dele
get:received before
get:An acknowledgme
get:delivered to th
get:the responsibil
get:To govern the f
get:employed.  The 
get:This window spe
get:acknowledgment 
get:2.7.  Connection 
get:To identify the
get:provides a port
get:independently b
get:unique addresse
get:identifying the
get:will be unique 
get:A connection is
get:local socket ma
get:sockets.  A con
get:that is, it is 
get:TCPs are free t
get:However, severa
get:There must be w
get:the "appropriat
get:may "own" ports
get:the ports they 
get:issue, but we e
get:uniquely alloca
get:associating the
get:A connection is
get:foreign socket 
get:[Page 10]        
get:September 1981   
get:connection name
get:subsequent call
get:about a connect
get:is a data struc
get:implementation 
get:pointer to the 
get:whether the con
get:be passively wa
get:A passive OPEN 
get:connection requ
get:Often the proce
get:request from an
get:is used to deno
get:are allowed onl
get:A service proce
get:processes would
get:foreign socket.
get:requested a con
get:local socket we
get:Well-known sock
get:a socket addres
get:"Telnet-Server"
get:socket, and oth
get:Entry, Text Gen
get:being for test 
get:access to a "Lo
get:at which a newl
get:well-known sock
get:of sockets to s
get:Processes can i
get:from other proc
get:been establishe
get:other at the sa
get:is critical for
get:components act 
get:There are two p
get:passive OPENs a
get:local passive O
get:case, the match
get:OPENs has left 
get:foreign socket 
get:Other possibili
get:Transmission Cont
get:If there are se
get:same local sock
get:with the specif
get:TCB exists, bef
get:The procedures 
get:control flag an
get:exchange has be
get:A connection is
get:containing a SY
get:command.  The m
get:connection has 
get:when sequence n
get:The clearing of
get:in this case ca
get:2.8.  Data Commun
get:The data that f
get:octets.  The se
get:in that call (a
get:through to the 
get:A sending TCP i
get:send that data 
get:function is sig
get:receiving TCP s
get:the sending TCP
get:There is no nec
get:boundaries.  Th
get:single SEND cal
get:The purpose of 
get:from the sendin
get:record service.
get:There is a coup
get:of data that cr
get:associated with
get:buffer is retur
get:not filled.  If
get:PUSH is seen, t
get:TCP also provid
get:at some point f
get:[Page 12]        
get:September 1981   
get:currently readi
get:define what the
get:urgent data, bu
get:take action to 
get:2.9.  Precedence 
get:The TCP makes u
get:security option
get:basis to TCP us
get:a multilevel se
get:use only, and o
get:compartment.  C
get:users may be li
get:TCP modules whi
get:properly mark o
get:precedence.  Su
get:higher level pr
get:them to specify
get:precedence of c
get:2.10.  Robustness
get:TCP implementat:ions will follow a general principle of robustness
get:conservative in
get:Transmission Cont
get:[Page 14]        
get:September 1981   
get:3.1.  Header Form
get:TCP segments ar
get:header carries 
get:destination hos
get:header, supplyi
get:division allows
get:TCP Header Form
get:0            
get:0 1 2 3 4 5 6
get:+-+-+-+-+-+-+-
get:|          Sou
get:+-+-+-+-+-+-+-
get:|             
get:+-+-+-+-+-+-+-
get:|             
get:+-+-+-+-+-+-+-
get:|  Data |     
get:| Offset| Rese
get:|       |     
get:+-+-+-+-+-+-+-
get:|           Ch
get:+-+-+-+-+-+-+-
get:|             
get:+-+-+-+-+-+-+-
get:|             
get:+-+-+-+-+-+-+-
get:Note th
get:Source Port:  1
get:The source po
get:Destination Por:t
get:The destinati
get:Transmission Cont
get:Functional Specif
get:Sequence Number:
get:The sequence 
get:when SYN is p
get:initial seque
get:Acknowledgment :Number
get:If the ACK co
get:next sequence
get:receive.  Onc
get:Data Offset:  4
get:The number of
get:the data begi
get:integral numb
get:Reserved:  6 bi
get:Reserved for 
get:Control Bits:  :6 bits (from left to right)
get:URG:  Urgent 
get:ACK:  Acknowl
get:PSH:  Push Fu
get:RST:  Reset t
get:SYN:  Synchro
get:FIN:  No more
get:Window:  16 bit
get:The number of
get:acknowledgmen
get:Checksum:  16 b
get:The checksum 
get:complement su
get:segment conta
get:checksummed, 
get:form a 16 bit
get:transmitted a
get:the checksum 
get:The checksum 
get:[Page 16]        
get:September 1981   
get:prefixed to t
get:Address, the 
get:This gives th
get:information i
get:across the TC
get:calls by the 
get:The TCP Len
get:octets (thi
get:computed), 
get:Urgent Pointer:
get:This field co
get:positive offs
get:urgent pointe
get:the urgent da
get:the URG contr
get:Options:  varia
get:Options may o
get:multiple of 8
get:checksum.  An
get:cases for the: format of an option
get:Case 1:  A 
get:Case 2:  An
get:th
get:The option-le
get:option-length
get:Note that the
get:field might i
get:End-of-Option
get:A TCP must im
get:Transmission Cont
get:Functional Specif
get:Currently def:ined options include (kind indicated in octal)
get:Kind     Le
get:----     --
get:0         
get:1         
get:2         
get:Specific Opti
get:End of Opti
get:+--------
get:|00000000
get:+--------
get:This opti
get:might not
get:the Data 
get:not the e
get:the optio
get:No-Operatio
get:+--------
get:|00000001
get:+--------
get:This opti
get:align the
get:There is 
get:receivers
get:not begin
get:Maximum Seg
get:+--------
get:|00000010
get:+--------
get:Kind=2  
get:[Page 18]        
get:September 1981   
get:Maximum S:egment Size Option Data
get:If this
get:receive
get:This fi
get:(i.e., 
get:option 
get:Padding:  varia
get:The TCP heade
get:and data begi
get:3.2.  Terminology
get:Before we can d
get:to introduce so
get:connection requ
get:of these variab
get:Transmission Co
get:TCB are the loc
get:precedence of t
get:buffers, pointe
get:In addition sev
get:sequence number
get:Send Sequence
get:SND.UNA - s
get:SND.NXT - s
get:SND.WND - s
get:SND.UP  - s
get:SND.WL1 - s
get:SND.WL2 - s
get:u
get:ISS     - i
get:Receive Seque
get:RCV.NXT - r
get:RCV.WND - r
get:RCV.UP  - r
get:IRS     - i
get:Transmission Cont
get:Functional Specif
get:The following d
get:the sequence sp
get:Send Sequence S
get:---
get:1 - old s
get:2 - seque
get:3 - seque
get:4 - futur
get:The send window
get:Receive Sequenc
get:1 - old s
get:2 - seque
get:3 - futur
get:The receive win
get:There are also 
get:take their valu
get:[Page 20]        
get:September 1981   
get:Current Segme
get:SEG.SEQ - s
get:SEG.ACK - s
get:SEG.LEN - s
get:SEG.WND - s
get:SEG.UP  - s
get:SEG.PRC - s
get:A connection pr
get:lifetime.  The :states are
get:ESTABLISHED, FI
get:TIME-WAIT, and 
get:because it repr
get:no connection. : Briefly the meanings of the states are
get:LISTEN - repr
get:TCP and port.
get:SYN-SENT - re
get:after having 
get:SYN-RECEIVED 
get:request ackno
get:connection re
get:ESTABLISHED -
get:delivered to 
get:of the connec
get:FIN-WAIT-1 - 
get:from the remo
get:termination r
get:FIN-WAIT-2 - 
get:from the remo
get:CLOSE-WAIT - 
get:from the loca
get:CLOSING - rep
get:acknowledgmen
get:LAST-ACK - re
get:connection te
get:(which includ
get:Transmission Cont
get:Functional Specif
get:TIME-WAIT - r
get:the remote TC
get:termination r
get:CLOSED - repr
get:A TCP connectio
get:events.  The ev
get:ABORT, and STAT
get:containing the 
get:The state diagr
get:with the causin
get:error condition
get:changes.  In a 
get:the reaction of
get:NOTE BENE:  thi
get:the total speci
get:[Page 22]        
get:September 1981   
get:+---------+     
get:|         |<----
get:|   SYN   |     
get:|   RCVD  |<----
get:|         |     
get:|         |-----
get:+---------+   rc
get:|           --
get:|             
get:|             
get:|  CLOSE      
get:| -------     
get:| snd FIN     
get:|             
get:V             
get:+---------+     
get:|  FIN    |<----
get:| WAIT-1  |-----
get:+---------+     
get:| rcv ACK of F
get:| ------------
get:V        x    
get:+---------+     
get:|FINWAIT-2|     
get:+---------+     
get:|             
get:|  rcv FIN    
get:|  -------    
get:\ snd ACK    
get:------------
get:Transmission Cont
get:Functional Specif
get:3.3.  Sequence Nu
get:A fundamental n
get:over a TCP conn
get:sequenced, each
get:mechanism emplo
get:number X indica
get:received.  This
get:detection in th
get:within a segmen
get:the header is t
get:numbered consec
get:It is essential
get:finite, though 
get:Since the space
get:numbers must be
get:preserves the r
get:2**32 - 1 to 0 
get:arithmetic, so 
get:comparison of s
get:(modulo 2**32).
get:The typical kin
get:perform include:
get:(a)  Determin
get:number s
get:(b)  Determin
get:have bee
get:retransm
get:(c)  Determin
get:which ar
get:receive 
get:[Page 24]        
get:September 1981   
get:In response to 
get:following compa
get:SND.UNA = old
get:SND.NXT = nex
get:SEG.ACK = ack
get:num
get:SEG.SEQ = fir
get:SEG.LEN = the
get:(co
get:SEG.SEQ+SEG.L
get:A new acknowled
get:the inequality :below holds
get:SND.UNA < SEG
get:A segment on th
get:of its sequence
get:acknowledgment 
get:When data is re:ceived the following comparisons are needed
get:RCV.NXT = nex
get:is the le
get:RCV.NXT+RCV.W
get:segment, 
get:SEG.SEQ = fir
get:SEG.SEQ+SEG.L
get:A segment is ju
get:RCV.NXT =< SE
get:RCV.NXT =< SE
get:Transmission Cont
get:Functional Specif
get:The first part 
get:segment falls i
get:if the end of t
get:either part of 
get:Actually, it is
get:windows and zer
get:acceptability o:f an incoming segment
get:Segment Recei
get:Length  Windo
get:------- -----
get:0       0 
get:0      >0 
get:>0       0 
get:>0      >0 
get:Note that when 
get:acceptable exce
get:maintain a zero
get:ACKs.  However,
get:process the RST
get:We have taken a
get:control informa
get:some control fl
get:and acknowledge
get:control will be
get:carried in the 
get:for implicitly 
get:are the only co
get:are used only a
get:purposes, the S
get:octet of the se
get:to occur after 
get:occurs.  The se
get:space occupying
get:sequence number
get:[Page 26]        
get:September 1981   
get:Initial Sequenc
get:The protocol pl
get:used over and o
get:sockets.  New i
get:incarnations of
get:-- "how does th
get:incarnations of
get:connection is b
get:connection brea
get:To avoid confus
get:connection from
get:be present in t
get:assure this, ev
get:sequence number
get:an initial sequ
get:new 32 bit ISN.
get:bit clock whose
get:microseconds.  
get:Since we assume
get:the Maximum Seg
get:hours we can re
get:For each connec
get:sequence number
get:the data sendin
get:learned during 
get:For a connectio
get:synchronize on 
get:an exchange of 
get:called "SYN" (f
get:shorthand, segm
get:Hence, the solu
get:initial sequenc
get:The synchroniza
get:sequence number
get:from the other 
get:initial sequenc
get:1) A --> B  S
get:2) A <-- B  A
get:3) A <-- B  S
get:4) A --> B  A
get:Transmission Cont
get:Functional Specif
get:Because steps 2
get:called the thre
get:A three way han
get:tied to a globa
get:mechanisms for 
get:no way of knowi
get:unless it remem
get:(which is not a
get:verify this SYN
get:clock-driven sc
get:Knowing When to
get:To be sure that
get:sequence number
get:the network, th
get:(MSL) before as
get:recovering from
get:lost.  For this
get:is an engineeri
get:it is desirable
get:sense, yet reta
get:not wait at all
get:than those rece
get:The TCP Quiet T
get:This specific
get:retaining any
get:each active (
get:TCP segments 
get:in the intern
get:paragraphs be
get:TCP implement
get:at the risk o
get:data rejected
get:TCPs consume 
get:entered into 
get:duplicate det
get:relies on the
get:the extent th
get:values before
get:been delivere
get:copies of the
get:such an assum
get:[Page 28]        
get:September 1981   
get:assigned the 
get:at the receiv
get:that each seg
get:as there are 
get:Under normal 
get:to emit and t
get:mistakenly us
get:been acknowle
get:data is drain
get:very large to
get:cause trouble
get:to use up 2**
get:lifetime in t
get:this is deeme
get:rates escalat
get:cycle time is
get:within reason
get:The basic dup
get:defeated, how
get:sequence numb
get:the TCP were 
get:upon crashing
get:connection (p
get:packets with 
get:packets still
get:incarnation o
get:about the seq
get:specification
get:before emitti
get:segments from
get:Even hosts wh
get:initial seque
get:(i.e., even i
get:number for ea
get:Suppose, for 
get:sequence numb
get:and that even
get:takes on a va
get:segment sent 
get:at this insta
get:incarnation o
get:S1 = ISN(t) -
get:connection!  
get:Transmission Cont
get:Functional Specif
get:duplicates in
get:of S1 may arr
get:the new incar
get:The problem i
get:crashed nor d
get:the system fr
get:One way to de
get:segments for 
get:time" specifi
get:willing to ri
get:destination m
get:Implementors 
get:connection by
get:informally im
get:Obviously, ev
get:necessary aft
get:To summarize:
get:numbers in th
get:"busy" or "in
get:block of spac
get:segment, if a
get:sequence numb
get:the previous 
get:number overla
get:3.4.  Establishin
get:The "three-way 
get:connection.  Th
get:responded to by
get:simultaneously 
get:occurs, each TC
get:acknowledgment 
get:an old duplicat
get:recipient, that
get:Proper use of "
get:Several example
get:examples do not
get:segments, this 
get:doesn't deliver
get:valid (i.e., th
get:connection reac
get:reduces the pos
get:[Page 30]        
get:September 1981   
get:implementation 
get:information for
get:The simplest th
get:figures should 
get:numbered for re
get:departure of a 
get:segment at B fr
get:Ellipsis (...) 
get:(delayed).  An 
get:Comments appear
get:the departure o
get:the center of e
get:form, with sequ
get:fields such as 
get:in the interest
get:TCP A      
get:1.  CLOSED     
get:2.  SYN-SENT   
get:3.  ESTABLISHED
get:4.  ESTABLISHED
get:5.  ESTABLISHED
get:Basic 3
get:In line 2 of fi
get:indicating that
get:number 100.  In
get:received from T
get:B is now expect
get:occupied sequen
get:At line 4, TCP 
get:TCP B's SYN; an
get:sequence number
get:because the ACK
get:would wind up A
get:Transmission Cont
get:Functional Specif
get:Simultaneous in
get:figure 8.  Each
get:TCP A      
get:1.  CLOSED     
get:2.  SYN-SENT   
get:3.  SYN-RECEIVE
get:4.             
get:5.  SYN-RECEIVE
get:6.  ESTABLISHED
get:7.             
get:S
get:The principle r
get:duplicate conne
get:this, a special
get:receiving TCP i
get:SYN-RECEIVED), 
get:If the TCP is i
get:FIN-WAIT-1, FIN
get:aborts the conn
get:case under "hal
get:[Page 32]        
get:September 1981   
get:TCP A      
get:1.  CLOSED     
get:2.  SYN-SENT   
get:3.  (duplicate)
get:4.  SYN-SENT   
get:5.  SYN-SENT   
get:6.             
get:7.  SYN-SENT   
get:8.  ESTABLISHED
get:As a simple exa
get:figure 9.  At l
get:cannot tell tha
get:(line 4).  TCP 
get:RST (reset) wit
get:believable.  TC
get:When the origin
get:synchronization
get:before the RST,
get:sent in both di
get:Half-Open Conne
get:An established 
get:TCPs has closed
get:knowledge of th
get:become desynchr
get:memory.  Such c
get:attempt is made
get:connections are
get:mildly involved
get:If at site A th
get:Transmission Cont
get:Functional Specif
get:user at site B 
get:receiving a res
get:site B TCP that
get:Assume that two
get:another when a 
get:Depending on th
get:that some error
get:A is likely to 
get:point.  As a re
get:or try to SEND 
get:case, it receiv
get:local (A's) TCP
get:will send a seg
get:example shown i
get:re-open the con
get:TCP A      
get:1.  (CRASH)    
get:2.  CLOSED     
get:3.  SYN-SENT --
get:4.  (!!)     <-
get:5.  SYN-SENT --
get:6.  SYN-SENT   
get:7.  SYN-SENT --
get:When the SYN ar
get:and the incomin
get:acknowledgment 
get:100).  TCP A se
get:sent and, being
get:detected a half
get:[Page 34]        
get:September 1981   
get:continue to try
get:reduced to the 
get:An interesting 
get:tries to send d
get:This is illustr
get:TCP A from TCP 
get:exists, so TCP 
get:processes it an
get:TCP A    
get:1.  (CRASH)    
get:2.  (??)    <--
get:3.          -->
get:Active
get:In figure 12, w
get:waiting for SYN
get:into action.  A
get:generate a RST 
get:the reset and r
get:TCP A      
get:1.  LISTEN     
get:2.       ... <S
get:3.  (??) <-- <S
get:4.       --> <S
get:5.  LISTEN     
get:Old Duplic
get:Transmission Cont
get:Functional Specif
get:A variety of ot
get:by the followin
get:Reset Generatio
get:As a general ru
get:which apparentl
get:must not be sen
get:There are three: groups of states
get:1.  If the co
get:in response t
get:particular, S
get:by this means
get:If the incomi
get:sequence numb
get:reset has seq
get:of the sequen
get:The connectio
get:2.  If the co
get:SYN-SENT, SYN
get:something not
get:if an incomin
get:does not exac
get:connection, a
get:If our SYN ha
get:incoming segm
get:either raise 
get:the system) o
get:incoming segm
get:continue as i
get:cannot raise 
get:detected in t
get:terminated th
get:incoming segm
get:match the loc
get:must be sent.
get:If the incomi
get:sequence numb
get:reset has seq
get:of the sequen
get:The connectio
get:[Page 36]        
get:September 1981   
get:3.  If the co
get:FIN-WAIT-1, F
get:any unaccepta
get:unacceptible 
get:acknowledgmen
get:and an acknow
get:to be receive
get:If an incomin
get:precedence wh
get:and precedenc
get:connection go
get:number from t
get:Reset Processin
get:In all states e
get:by checking the
get:is in the windo
get:to an initial S
get:acknowledges th
get:The receiver of
get:receiver was in
get:in SYN-RECEIVED
get:then the receiv
get:aborts the conn
get:was in any othe
get:and goes to the
get:3.5.  Closing a C
get:CLOSE is an ope
get:notion of closi
get:interpretation,
get:the receiving s
get:in a simplex fa
get:until he is tol
get:could initiate 
get:RECEIVE until s
get:has CLOSED.  We
get:RECEIVEs are ou
get:can terminate h
get:buffers SENT be
get:data in return 
get:successfully to
get:TCP.  Users mus
get:the TCP says no
get:Transmission Cont
get:Functional Specif
get:There are essen:tially three cases
get:1) The user i
get:2) The remote
get:3) Both users
get:Case 1:  Local 
get:In this case,
get:outgoing segm
get:accepted by t
get:are allowed i
get:will be retra
get:both acknowle
get:can ACK this 
get:send its own 
get:Case 2:  TCP re
get:If an unsolic
get:can ACK it an
get:user will res
get:the other TCP
get:until its own
get:connection.  
get:the connectio
get:Case 3:  both u
get:A simultaneou
get:FIN segments 
get:have been pro
get:has received.
get:[Page 38]        
get:September 1981   
get:TCP A      
get:1.  ESTABLISHED
get:FIN-WAIT-1 
get:3.  FIN-WAIT-2 
get:4.             
get:TIME-WAIT  
get:5.  TIME-WAIT  
get:CLOSED     
get:TCP A      
get:1.  ESTABLISHED
get:2.  (Close)    
get:FIN-WAIT-1 
get:3.  CLOSING    
get:4.  TIME-WAIT  
get:(2 MSL)    
get:CLOSED     
get:Transmission Cont
get:Functional Specif
get:3.6.  Precedence 
get:The intent is t
get:with exactly th
get:higher of the p
get:The precedence 
get:defined in the 
get:specification t
get:the security pa
get:user group, and
get:A connection at
get:lower precedenc
get:a connection du
get:acknowledgment 
get:Note that TCP m
get:precedence will
get:segments and po
get:The security pa
get:(the values wou
get:non-secure envi
get:parameters, tho
get:3.7.  Data Commun
get:Once the connec
get:exchange of seg
get:(checksum test 
get:retransmission 
get:Duplicate segme
get:As discussed in
get:certain tests o
get:segments to ver
get:The sender of d
get:the variable SN
get:sequence number
get:keeps track of 
get:variable SND.UN
get:sent has been a
get:When the sender
get:SND.NXT.  When 
get:sends an acknow
get:[Page 40]        
get:September 1981   
get:acknowledgment 
get:these variables
get:The amount by w
get:data in the seg
get:segments must c
get:The CLOSE user 
get:flag in an inco
get:Retransmission 
get:Because of the 
get:internetwork sy
get:retransmission 
get:for determining
get:An Example Re
get:Measure the
get:particular 
get:covers that
get:segments re
get:Time (RTT).:  Next compute a Smoothed Round Trip Time (SRTT) as
get:SRTT = ( 
get:and based o:n this, compute the retransmission timeout (RTO) as
get:RTO = min
get:where UBOUN
get:LBOUND is a
get:a smoothing
get:factor (e.g
get:The Communicati
get:The objective o
get:to stimulate th
get:permit the rece
get:the currently k
get:This mechanism 
get:the end of urge
get:the receive seq
get:must tell the u
get:number catches 
get:Transmission Cont
get:Functional Specif
get:into "normal mo
get:is in "urgent m
get:The method empl
get:transmitted.  T
get:meaningful and 
get:the urgent poin
get:no urgent data 
get:To send an urge
get:octet.  If the 
get:the urgent info
get:Managing the Wi
get:The window sent
get:numbers the sen
get:prepared to acc
get:the currently a
get:Indicating a la
get:arrives than ca
get:in excessive re
get:network and the
get:transmission of
get:between each ne
get:The mechanisms 
get:subsequently ad
get:that much data.
get:discouraged.  T
get:shrink the wind
get:on the part of 
get:The sending TCP
get:least one octet
get:sending TCP mus
get:the window is z
get:interval when t
get:guarantee that 
get:window will be 
get:When the receiv
get:still send an a
get:and current win
get:The sending TCP
get:[Page 42]        
get:September 1981   
get:which fit the c
get:retransmission 
get:In a connection
get:be carried in a
get:number so there
get:order.  This is
get:information to 
get:the data receiv
get:the window info
get:acknowledgment 
get:equal or greate
get:The window mana
get:communication p
get:Window Manage
get:Allocating 
get:many small 
get:fewer large
get:One suggest
get:defer updat
get:least X per
get:connection 
get:Another sug
get:segments by
get:sending dat
get:data must b
get:Note that t
get:retransmiss
get:acknowledgm
get:window info
get:new window 
get:The segment
get:of transmit
get:segment con
get:is accepted
get:If the send
get:window is n
get:alternating
get:pauses in t
get:Transmission Cont
get:Functional Specif
get:result in b
get:big pair. A
get:mostly smal
get:The suggest
get:actively at
get:windows, si
get:to many sma
get:There are of co:urse two interfaces of concern
get:and the TCP/low
get:of the user/TCP
get:protocol module
get:in detail by th
get:case that the l
get:that TCPs might
get:User/TCP Interf
get:The following
get:at best, fict
get:facilities.  
get:implementatio
get:TCPs must pro
get:that all TCP 
get:hierarchy.  T
get:required of a
get:TCP User Comm
get:The followi
get:interface. 
get:function ca
get:meant to ru
get:The user co
get:TCP must pe
get:Individual 
get:may provide
get:single call
get:automatical
get:issued by t
get:[Page 44]        
get:September 1981   
get:In providin
get:not only ac
get:processes i:t serves.  The latter consists of
get:(a) gener
get:remote cl
get:(b) repli
get:various t
get:Format:  
get:[, timeou
get:-> local 
get:We assume
get:processes
get:to use th
get:implement
get:for the s
get:lower lev
get:result of
get:able to m
get:process c
get:If the ac
get:call to L
get:have eith
get:particula
get:for any c
get:by the su
get:A transmi
get:filled in
get:On an act
get:synchroni
get:The timeo
get:for all d
get:delivered
get:will abor
get:The TCP o
get:the users
get:Transmission Cont
get:Functional Specif
get:precedenc
get:or securi
get:the defau
get:TCP will 
get:security/
get:the prece
get:requested
get:The prece
get:requested
get:request, 
get:connectio
get:this prec
get:allowed t
get:or that a
get:A local c
get:The local
get:for the c
get:Format:  
get:count, PU
get:This call
get:to be sen
get:not been 
get:implement
get:automatic
get:authorize
get:If the PU
get:to the re
get:segment c
get:the data 
get:transmiss
get:If the UR
get:will have
get:the urgen
get:pointer i
get:been cons
get:is to sti
get:indicate 
get:[Page 46]        
get:September 1981   
get:data has 
get:TCP signa
get:of times 
get:urgent da
get:If no for
get:connectio
get:has becom
get:local soc
get:foreign s
get:foreign s
get:knowing t
get:However, 
get:becomes s
get:STATUS ca
get:implement
get:socket is
get:If a time
get:connectio
get:In the si
get:the sendi
get:or the ti
get:is both s
get:connectio
get:offers po
get:sophistic
get:the proce
get:furthermo
get:Multiple 
get:the TCP w
get:We have i
get:which a S
get:pseudo-in
get:return a 
get:immediate
get:been ackn
get:assume ev
get:close any
get:kind (syn
get:signals, 
get:with spec
get:In order 
get:indicatio
get:Transmission Cont
get:Functional Specif
get:buffer ad
get:the SEND 
get:indicatin
get:calling p
get:Format:  
get:count) ->
get:This comm
get:specified
get:calling p
get:error is 
get:In the si
get:calling p
get:error occ
get:A more so
get:RECEIVEs 
get:segments 
get:the cost 
get:notify th
get:If enough
get:the PUSH 
get:The buffe
get:a PUSH is
get:returned 
get:If there 
get:as it arr
get:should th
get:additiona
get:call to R
get:may now l
get:urgent po
get:in the sa
get:boundary 
get:To distin
get:care of t
get:return co
get:count ind
get:Alternati
get:[Page 48]        
get:September 1981   
get:allocate 
get:with the 
get:Format:  
get:This comm
get:the conne
get:authorize
get:Closing c
get:the sense
get:retransmi
get:serviced.
get:calls, fo
get:to the de
get:continue 
get:may be tr
get:means "I 
get:receive a
get:not well 
get:of all it
get:into ABOR
get:The user 
get:initiativ
get:(e.g., re
get:destinati
get:Because c
get:foreign T
get:short tim
get:replies t
get:Close als
get:Format:  
get:This is a
get:excluded 
get:typically
get:This comm
get:informati:on
get:local s
get:Transmission Cont
get:Functional Specif
get:foreign
get:local c
get:receive
get:send wi
get:connect
get:number 
get:number 
get:urgent 
get:precede
get:securit
get:and tra
get:Depending
get:implement
get:available
get:authorize
get:prevents 
get:connectio
get:Format:  
get:This comm
get:aborted, 
get:be sent t
get:Depending
get:indicatio
get:receive a
get:TCP-to-User M
get:It is assum
get:means for t
get:the TCP doe
get:to the user
get:an error me
get:relating to
get:other user 
get:The followi:ng information is provided
get:Local Con
get:Response 
get:Buffer Ad
get:Byte coun
get:Push flag
get:Urgent fl
get:[Page 50]        
get:September 1981   
get:TCP/Lower-Level
get:The TCP calls
get:receive infor
get:internetwork 
get:Protocol (IP)
get:If the lower 
get:of service an
get:for these par:ameters
get:Type of Ser:vice = Precedence: routine, Delay: normal, Throughput
get:normal, Rel:iability
get:Time to Liv
get:Note that
get:Here we e
get:be delive
get:If the lower 
get:feature) and 
get:route informa
get:so that the s
get:checksum be t
get:also importan
get:Any lower lev
get:destination a
get:the "TCP leng
get:of IP and to 
get:Transmission Cont
get:Functional Specif
get:3.9.  Event Proce
get:The processing 
get:implementation.
get:processing sequ
get:section only in
get:The activity of
get:The events that: occur can be cast into three categories
get:arriving segmen
get:processing the 
get:cases the proce
get:Events that o:ccur
get:Arriving Se
get:SEGMENT A
get:USER TIME
get:RETRANSMI
get:TIME-WAIT
get:The model of th
get:immediate retur
get:pseudo interrup
get:means cause a d
get:Error responses
get:commands refere:ncing connections that do not exist receive "error
get:connection not 
get:Please note in 
get:acknowledgment 
get:of the sequence
get:equal to (modul
get:[Page 52]        
get:September 1981   
get:A natural way t
get:imagine that th
get:that their cont
get:in the sequence
get:and processed i
get:When a segment 
get:the segment to 
get:to be consisten
get:Note that if no
get:Transmission Cont
get:Functional Specif
get:CLOSED STATE 
get:Create a ne
get:state infor
get:socket, pre
get:information
get:unspecified
get:parameters 
get:precedence 
get:"error:  pr:ecedence not allowed" or "error
get:not allowed
get:active and :the foreign socket is unspecified, return "error
get:foreign soc
get:specified, 
get:(ISS) is se
get:is sent.  S
get:state, and 
get:If the call
get:return "err:or
get:no room to :create a new connection, return "error
get:resources".
get:If active a
get:connection 
get:segment, se
get:state.  Dat
get:queued for 
get:urgent bit 
get:segments se
get:queue the r:equest, respond with "error
get:If Foreign :socket was not specified, then return "error
get:socket unsp
get:[Page 54]        
get:September 1981   
get:SYN-SENT STAT
get:SYN-RECEIVED 
get:ESTABLISHED S
get:FIN-WAIT-1 ST
get:FIN-WAIT-2 ST
get:CLOSE-WAIT ST
get:CLOSING STATE
get:LAST-ACK STAT
get:TIME-WAIT STA
get:Return "err:or
get:Transmission Cont
get:Functional Specif
get:CLOSED STATE 
get:If the user
get:"error:  co
get:Otherwise, :return "error
get:If the fore
get:from passiv
get:SND.UNA to 
get:associated 
get:transmissio
get:requested i
get:as a result
get:request, re:spond with "error
get:Foreign soc:ket was not specified, then return "error
get:socket unsp
get:SYN-SENT STAT
get:SYN-RECEIVED 
get:Queue the d
get:If no space: to queue, respond with "error
get:resources".
get:ESTABLISHED S
get:CLOSE-WAIT ST
get:Segmentize 
get:acknowledgm
get:insufficien:t space to remember this buffer, simply return "error
get:insufficien
get:If the urge
get:urgent poin
get:[Page 56]        
get:September 1981   
get:FIN-WAIT-1 ST
get:FIN-WAIT-2 ST
get:CLOSING STATE
get:LAST-ACK STAT
get:TIME-WAIT STA
get:Return "err:or
get:Transmission Cont
get:Functional Specif
get:CLOSED STATE 
get:If the user
get:"error:  co
get:Otherwise r:eturn "error
get:SYN-SENT STAT
get:SYN-RECEIVED 
get:Queue for p
get:is no room :to queue this request, respond with "error
get:insufficien
get:ESTABLISHED S
get:FIN-WAIT-1 ST
get:FIN-WAIT-2 ST
get:If insuffic
get:request, qu
get:remember th:e RECEIVE, respond with "error
get:resources".
get:Reassemble 
get:to user.  M
get:If RCV.UP i
get:user notify
get:When the TC
get:that fact m
get:acknowledgm
get:described b
get:[Page 58]        
get:September 1981   
get:CLOSE-WAIT ST
get:Since the r
get:satisfied b
get:user.  If n
get:"error:  co
get:text can be
get:CLOSING STATE
get:LAST-ACK STAT
get:TIME-WAIT STA
get:Return "err:or
get:Transmission Cont
get:Functional Specif
get:CLOSED STATE 
get:If the user
get:"error:  co
get:Otherwise, :return "error
get:Any outstan:ding RECEIVEs are returned with "error
get:responses. 
get:SYN-SENT STAT
get:Delete the :TCB and return "error
get:queued SEND
get:SYN-RECEIVED 
get:If no SENDs
get:then form a
get:otherwise q
get:ESTABLISHED S
get:Queue this 
get:form a FIN 
get:FIN-WAIT-1 ST
get:FIN-WAIT-2 ST
get:Strictly sp:eaking, this is an error and should receive a "error
get:connection 
get:acceptable,
get:FIN may be 
get:[Page 60]        
get:September 1981   
get:CLOSE-WAIT ST
get:Queue this 
get:segmentized
get:CLOSING STATE
get:LAST-ACK STAT
get:TIME-WAIT STA
get:Respond wit:h "error
get:Transmission Cont
get:Functional Specif
get:CLOSED STATE 
get:If the user
get:"error:  co
get:Otherwise r:eturn "error
get:Any outstan:ding RECEIVEs should be returned with "error
get:connection 
get:SYN-SENT STAT
get:All queued 
get:notificatio
get:SYN-RECEIVED 
get:ESTABLISHED S
get:FIN-WAIT-1 ST
get:FIN-WAIT-2 ST
get:CLOSE-WAIT ST
get:Send a rese:t segment
get:<SEQ=SND.
get:All queued 
get:notificatio
get:RST formed 
get:TCB, enter 
get:CLOSING STATE
get:LAST-ACK STAT
get:TIME-WAIT STA
get:Respond wit
get:[Page 62]        
get:September 1981   
get:CLOSED STATE 
get:If the user
get:"error:  co
get:Otherwise r:eturn "error
get:Return "sta
get:SYN-SENT STAT
get:Return "sta
get:SYN-RECEIVED 
get:Return "sta
get:ESTABLISHED S
get:Return "sta
get:FIN-WAIT-1 ST
get:Return "sta
get:FIN-WAIT-2 ST
get:Return "sta
get:CLOSE-WAIT ST
get:Return "sta
get:CLOSING STATE
get:Return "sta
get:LAST-ACK STAT
get:Return "sta
get:Transmission Cont
get:Functional Specif
get:TIME-WAIT STA
get:Return "sta
get:[Page 64]        
get:September 1981   
get:SEGMENT ARRIVES
get:If the state 
get:all data in
get:segment con
get:containing 
get:acknowledgm
get:reset seque
get:If the ACK 
get:<SEQ=0><A
get:If the ACK 
get:<SEQ=SEG.
get:If the state 
get:first check
get:An incomi
get:second chec
get:Any ackno
get:the LISTE
get:for any a
get:formatted: as follows
get:<SEQ=SE
get:third check
get:If the SY
get:security/
get:match the
get:<SEQ=SE
get:Transmission Cont
get:Functional Specif
get:If the SE
get:the user 
get:send a re
get:<SEQ=SE
get:If the SE
get:Set RCV.N
get:control o
get:should be: selected and a SYN segment sent of the form
get:<SEQ=IS
get:SND.NXT i
get:state sho
get:incoming 
get:in the SY
get:not be re
get:the forei
get:unspecifi
get:fourth othe
get:Any other
get:must have
get:processin
get:it could 
get:incarnati
get:but if yo
get:If the state 
get:first check
get:If the AC
get:If SEG.
get:the RST
get:<SEQ=
get:and dis
get:If SND.
get:second chec
get:[Page 66]        
get:September 1981   
get:If the RS
get:If the :ACK was acceptable then signal the user "error
get:connect
get:delete 
get:and ret
get:third check
get:If the se
get:match the
get:If ther
get:<SEQ=
get:Otherwi
get:<SEQ=
get:If there 
get:The pre
get:TCB, if
get:<SEQ=
get:If there 
get:If the 
get:in the 
get:the pre
get:allowed
get:<SEQ=
get:If the 
get:in the 
get:If a rese
get:fourth chec
get:This step
get:no ACK, a
get:If the SY
get:Transmission Cont
get:Functional Specif
get:are accep
get:SEG.SEQ. 
get:is an ACK
get:are there
get:If SND.UN
get:state to 
get:<SEQ=SN
get:and send 
get:transmiss
get:text in t
get:below whe
get:Otherwise
get:<SEQ=IS
get:and send 
get:segment, 
get:has been 
get:fifth, if n
get:segment and
get:[Page 68]        
get:September 1981   
get:first check s
get:SYN-RECEIVE
get:ESTABLISHED
get:FIN-WAIT-1 
get:FIN-WAIT-2 
get:CLOSE-WAIT 
get:CLOSING STA
get:LAST-ACK ST
get:TIME-WAIT S
get:Segments 
get:are used 
get:done in S
get:boundary 
get:processed
get:There are
get:segment
get:Segment R
get:Length  W
get:------- -
get:0     
get:0     
get:>0     
get:>0     
get:If the RC
get:special a
get:If an inc
get:should be
get:the segme:nt and return)
get:<SEQ=SN
get:After sen
get:and retur
get:Transmission Cont
get:Functional Specif
get:In the fo
get:segment t
get:One could
get:trimming 
get:SYN and F
get:begins at
get:numbers m
get:second check 
get:SYN-RECEIVE
get:If the RS
get:If this
get:came fr
get:LISTEN 
get:this co
get:from SY
get:the use
get:on the 
get:active 
get:and ret
get:ESTABLISHED
get:If the RS
get:should re
get:flushed. 
get:"connecti
get:TCB, and 
get:CLOSING STA
get:LAST-ACK ST
get:If the RS
get:TCB, and 
get:[Page 70]        
get:September 1981   
get:third check s
get:SYN-RECEIVE
get:If the se
get:exactly m
get:then send
get:ESTABLISHED
get:If the se
get:exactly m
get:then send
get:receive "
get:flushed. 
get:"connecti
get:TCB, and 
get:Note this c
get:a segment f
get:different s
get:current con
get:fourth, check
get:SYN-RECEIVE
get:ESTABLISHED
get:FIN-WAIT ST
get:FIN-WAIT ST
get:CLOSE-WAIT 
get:CLOSING STA
get:LAST-ACK ST
get:TIME-WAIT S
get:If the SY
get:outstandi
get:all segme
get:receive a
get:the CLOSE
get:If the SY
get:and an ac
get:number ch
get:Transmission Cont
get:Functional Specif
get:fifth check t
get:if the ACK 
get:if the ACK 
get:SYN-RECEI
get:If SND.
get:and con
get:If th
get:reset
get:<SE
get:and s
get:ESTABLISH
get:If SND.
get:Any seg
get:entirel
get:positiv
get:fully a
get:"ok" re
get:(SEG.AC
get:somethi
get:drop th
get:If SND.
get:updated
get:SND.WL2
get:SND.WL1
get:Note th
get:records
get:SND.WND
get:the las
get:prevent
get:[Page 72]        
get:September 1981   
get:FIN-WAIT-
get:In addi
get:our FIN
get:process
get:FIN-WAIT-
get:In addi
get:the ret
get:acknowl
get:CLOSE-WAI
get:Do the 
get:CLOSING S
get:In addi
get:the ACK
get:otherwi
get:LAST-ACK 
get:The onl
get:acknowl
get:delete 
get:TIME-WAIT
get:The onl
get:retrans
get:the 2 M
get:sixth, check 
get:ESTABLISHED
get:FIN-WAIT-1 
get:FIN-WAIT-2 
get:If the UR
get:the user 
get:pointer (
get:user has 
get:mode") fo
get:signal th
get:Transmission Cont
get:Functional Specif
get:CLOSE-WAIT 
get:CLOSING STA
get:LAST-ACK ST
get:This shou
get:remote si
get:seventh, proc
get:ESTABLISHED
get:FIN-WAIT-1 
get:FIN-WAIT-2 
get:Once in t
get:text to u
get:into buff
get:empty.  I
get:the user 
get:has been 
get:When the 
get:user it m
get:Once the 
get:RCV.NXT o
get:apporopri
get:RCV.NXT a
get:Please no
get:Send an a:cknowledgment of the form
get:<SEQ=SN
get:This ackn
get:transmitt
get:[Page 74]        
get:September 1981   
get:CLOSE-WAIT 
get:CLOSING STA
get:LAST-ACK ST
get:TIME-WAIT S
get:This shou
get:remote si
get:eighth, check
get:Do not proc
get:since the S
get:If the FIN 
get:return any 
get:over the FI
get:FIN implies
get:SYN-RECEI
get:ESTABLISH
get:Enter t
get:FIN-WAIT-
get:If our 
get:enter T
get:timers;
get:FIN-WAIT-
get:Enter t
get:off the
get:CLOSE-WAI
get:Remain 
get:CLOSING S
get:Remain 
get:LAST-ACK 
get:Remain 
get:Transmission Cont
get:Functional Specif
get:TIME-WAIT
get:Remain 
get:timeout
get:[Page 76]        
get:September 1981   
get:For any state
get:the user "err:or
get:and for any o
get:state and ret
get:RETRANSMISSION 
get:For any state
get:the retransmi
get:retransmissio
get:TIME-WAIT TIMEO
get:If the time-w
get:enter the CLO
get:Transmission Cont
get:[Page 78]        
get:September 1981   
get:BBN Rep
get:a Host 
get:host an
get:A contr
get:indicat
get:specifi
get:is expe
get:previou
get:The uni
get:ARPANET
get:A unit 
get:IMPs.  
get:A logic
get:A messa
get:network
get:Destination Addre
get:The des
get:identif
get:A contr
get:indicat
get:occupyi
get:A porti
get:fragmen
get:A file 
get:Transmission Cont
get:Control
get:fragmen
get:A compu
get:from th
get:An Inte
get:by the 
get:The Int
get:ARPANET
get:A sourc
get:internet datagram
get:The uni
get:higher 
get:internet fragment
get:A porti
get:header.
get:Interne
get:The Ini
get:number 
get:The Ini
get:on a co
get:based p
get:The Ini
get:used by
get:Control
get:data.  
get:on an A
get:[Page 80]        
get:September 1981   
get:This is
get:data re
get:sequenc
get:of the 
get:The uni
get:An impl
get:procedu
get:Maximum
get:the int
get:An eigh
get:An Opti
get:may be 
get:primari
get:timesta
get:options
get:A packa
get:logical
get:logical
get:The por
get:output 
get:A progr
get:the poi
get:A contr
get:this se
get:receivi
get:receive
get:Transmission Cont
get:receive
get:receive
get:receive next sequ
get:This is
get:receive
get:This re
get:is will
get:segment
get:RCV.NXT
get:Segment
get:range a
get:A contr
get:that th
get:interac
get:sequenc
get:segment
get:it.  In
get:rise to
get:Real Ti:me Protocol
get:of time
get:segment
get:segment
get:segment
get:segment
get:segment
get:[Page 82]        
get:September 1981   
get:segment
get:A logic
get:unit of
get:segment acknowled
get:The seq
get:arrivin
get:The amo
get:includi
get:The num
get:This is
get:use on 
get:initial
get:each oc
get:This re
get:(receiv
get:window 
get:receivi
get:be emit
get:SND.UNA
get:between
get:send se
get:left se
get:send ur
get:segment
get:segment
get:Transmission Cont
get:send wi
get:An addr
get:is, the
get:The sou
get:A contr
get:number,
get:where t
get:Transmi
get:the sta
get:The pre
get:Transmi:ssion Control Protocol
get:reliabl
get:Type of
get:An Inte
get:for thi
get:A contr
get:indicat
get:urgent 
get:sequenc
get:pointer
get:A contr
get:field c
get:indicat
get:urgent 
get:[Page 84]        
get:September 1981   
get:[1]  Cerf, V., an
get:Intercommuni
get:Vol. COM-22,
get:[2]  Postel, J. (
get:Protocol Spe
get:Institute, S
get:[3]  Dalal, Y. an
get:Protocols", 
get:December 197
get:[4]  Postel, J., 
get:Institute, S
get:aRFC
get:aDe
get:aI
get:aSeptember 1981   
get:aPREFACE .....
get:a1.  INTRODUCTION 
get:a1.1  Motivation
get:a1.2  Scope ....
get:a1.3  About This
get:a1.4  Interfaces
get:a1.5  Operation 
get:a2.  PHILOSOPHY ..
get:a2.1  Elements o
get:a2.2  Model of O
get:a2.3  The Host E
get:a2.4  Interfaces
get:a2.5  Relation t
get:a2.6  Reliable C
get:a2.7  Connection
get:a2.8  Data Commu
get:a2.9  Precedence
get:a2.10 Robustness
get:a3.  FUNCTIONAL SP
get:a3.1  Header For
get:a3.2  Terminolog
get:a3.3  Sequence N
get:a3.4  Establishi
get:a3.5  Closing a 
get:a3.6  Precedence
get:a3.7  Data Commu
get:a3.8  Interfaces
get:a3.9  Event Proc
get:aGLOSSARY ........
get:aREFERENCES ......
get:aTransmission Cont
get:a[Page ii]        
get:aSeptember 1981   
get:aThis document des
get:a(TCP).  There hav
get:aspecification on 
get:adraws heavily fro
get:aboth in terms of 
get:aseveral details a
get:aand redescribes t
get:aRFC
get:aReplaces: RFC 761
get:aIENs:  129, 124, 
get:a55, 44, 40, 27, 2
get:aThe Transmission 
get:areliable host-to-
get:acommunication net
get:aThis document des
get:aTransmission Cont
get:ainterface to prog
get:aComputer commun
get:arole in militar
get:adocument focuse
get:acommunication r
get:acommunication u
get:acongestion, but
get:agovernment sect
get:aAs strategic an
get:adeveloped and d
get:ainterconnecting
get:acommunication p
get:aapplications.  
get:aDeputy Undersec
get:adeclared the Tr
get:abe a basis for 
get:astandardization
get:aTCP is a connec
get:afit into a laye
get:aapplications.  
get:acommunication b
get:adistinct but in
get:aassumptions are
get:aprotocols below
get:apotentially unr
get:aprotocols.  In 
get:awide spectrum o
get:aconnections to 
get:aTransmission Cont
get:aTCP is based on
get:aTCP fits into a
get:aInternet Protoc
get:areceive variabl
get:adatagram "envel
get:aaddressing sour
get:ainternet protoc
get:athe TCP segment
get:amultiple networ
get:aalso carries in
get:aand compartment
get:acommunicated en
get:aMuch of this do
get:awhich are co-re
get:acomputer.  Some
get:afront-end compu
get:aas well as netw
get:aan interface to
get:aimplementable e
get:ahost-to-front e
get:aThe TCP is inte
get:acommunication s
get:aintended to be 
get:a1.3.  About this 
get:aThis document r
get:aany TCP impleme
get:aprotocols and i
get:a[Page 2]         
get:aSeptember 1981   
get:asection offers 
get:aoperation.  Sec
get:adesign.  Sectio
get:arequired of TCP
get:auser calls, err
get:aThe TCP interfa
get:athe other side 
get:aThe interface b
get:aillustrated in 
get:acalls much like
get:aapplication pro
get:acalls to open a
get:aestablished con
get:aasynchronously 
get:aconsiderable fr
get:ainterfaces whic
get:aenvironment, a 
get:ainterface for a
get:aThe interface b
get:aunspecified exc
get:atwo levels can 
get:aTypically, one 
get:ainterface.  TCP
get:ainterconnected 
get:athroughout this
get:aAs noted above,
get:asecurable logic
get:aprocesses.  To 
get:acommunication s:ystem requires facilities in the following areas
get:aBasic Data Tr
get:aPrecedence an
get:aThe basic opera
get:athe following p
get:aTransmission Cont
get:aBasic Data Tran:sfer
get:aThe TCP is ab
get:adirection bet
get:asegments for 
get:athe TCPs deci
get:aSometimes use
get:asubmitted to 
get:afunction is d
get:aactually tran
get:apushed throug
get:apromptly forw
get:aThe exact pus
get:athe push func
get:aReliability
get:aThe TCP must 
get:adelivered out
get:ais achieved b
get:atransmitted, 
get:areceiving TCP
get:ainterval, the
get:anumbers are u
get:aout of order 
get:aadding a chec
get:areceiver, and
get:aAs long as th
get:asystem does n
get:aerrors will a
get:ainternet comm
get:aFlow Control
get:aTCP provides 
get:asent by the s
get:aevery ACK ind
get:athe last segm
get:aallowed numbe
get:areceiving fur
get:a[Page 4]         
get:aSeptember 1981   
get:aMultiplexing
get:aTo allow for 
get:acommunication
get:aaddresses or 
get:aand host addr
get:aa socket.  A 
get:aThat is, a so
get:aThe binding o
get:aHost.  Howeve
get:a(e.g., a "log
get:amade known to
get:athrough the k
get:aaddresses of 
get:aConnections
get:aThe reliabili
get:athat TCPs ini
get:aeach data str
get:asockets, sequ
get:aEach connecti
get:aidentifying i
get:aWhen two proc
get:aestablish a c
get:aside).  When 
get:aterminated or
get:aSince connect
get:aover the unre
get:amechanism wit
get:aerroneous ini
get:aPrecedence and :Security
get:aThe users of 
get:acommunication
get:athese feature
get:aTransmission Cont
get:a[Page 6]         
get:aSeptember 1981   
get:a2.1.  Elements of
get:aThe internetwor
get:awhich are in tu
get:athat the networ
get:alarge networks 
get:apacket switchin
get:aconsume message
get:anetworks, the g
get:acommunication s
get:aconnections bet
get:aThe term packet
get:atransaction bet
get:aexchanged withi
get:aHosts are compu
get:anetwork's point
get:aProcesses are v
get:aaccordance with
get:ain execution). 
get:aviewed as commu
get:aThus, all commu
get:aSince a process
get:astreams between
get:athat each proce
get:acommunicates wi
get:a2.2.  Model of Op
get:aProcesses trans
get:adata as argumen
get:asegments and ca
get:athe destination
get:ainto the receiv
get:aTCPs include co
get:aensure reliable
get:aThe model of in
get:aprotocol module
get:ato the local ne
get:ainside internet
get:ainternet module
get:athrough the loc
get:aThe packet swit
get:aTransmission Cont
get:aother operation
get:adestination int
get:aAt a gateway be
get:afrom its local 
get:athe internet da
get:athen "wrapped" 
get:arouted to the n
get:aA gateway is pe
get:ainternet datagr
get:athrough the nex
get:ainternet datagr
get:afurther broken 
get:ainternet datagr
get:ainternet module
get:aA destination i
get:a(after reassemb
get:adestination TCP
get:aThis simple mod
get:aimportant featu
get:ato the gateway 
get:aservice paramet
get:aIncluded in the
get:adatagram.  Data
get:ahost and gatewa
get:aproperly segreg
get:a2.3.  The Host En
get:aThe TCP is assu
get:aaccess the TCP 
get:amay call on oth
get:adata structures
get:acontrolled by a
get:anetwork device 
get:adatagram protoc
get:aThe mechanisms 
get:afront-end proce
get:ahost-to-front-e
get:athe type of TCP
get:a[Page 8]         
get:aSeptember 1981   
get:aThe TCP/user in
get:ato OPEN or CLOS
get:aSTATUS about a 
get:aprograms on the
get:afrom, and close
get:aThe TCP/interne
get:adatagrams addre
get:asystem.  These 
get:aservice, preced
get:a2.5.  Relation to
get:aThe following d
get:ahierarchy
get:a+------+ +
get:a|Telnet| |
get:a+------+ +
get:a|   
get:a+----
get:a| TCP
get:a+----
get:a| 
get:a+----
get:a|    
get:a+----
get:a+--
get:a|  
get:a+--
get:aIt is expected 
get:aprotocols effic
get:aprotocols like 
get:a2.6.  Reliable Co
get:aA stream of dat
get:aorder at the de
get:aTransmission Cont
get:aTransmission is
get:aacknowledgments
get:asequence number
get:asegment is tran
get:asequence number
get:ais the sequence
get:atransmissions i
get:asegment contain
get:astarts a timer;
get:asegment is dele
get:areceived before
get:aAn acknowledgme
get:adelivered to th
get:athe responsibil
get:aTo govern the f
get:aemployed.  The 
get:aThis window spe
get:aacknowledgment 
get:a2.7.  Connection 
get:aTo identify the
get:aprovides a port
get:aindependently b
get:aunique addresse
get:aidentifying the
get:awill be unique 
get:aA connection is
get:alocal socket ma
get:asockets.  A con
get:athat is, it is 
get:aTCPs are free t
get:aHowever, severa
get:aThere must be w
get:athe "appropriat
get:amay "own" ports
get:athe ports they 
get:aissue, but we e
get:auniquely alloca
get:aassociating the
get:aA connection is
get:aforeign socket 
get:a[Page 10]        
get:aSeptember 1981   
get:aconnection name
get:asubsequent call
get:aabout a connect
get:ais a data struc
get:aimplementation 
get:apointer to the 
get:awhether the con
get:abe passively wa
get:aA passive OPEN 
get:aconnection requ
get:aOften the proce
get:arequest from an
get:ais used to deno
get:aare allowed onl
get:aA service proce
get:aprocesses would
get:aforeign socket.
get:arequested a con
get:alocal socket we
get:aWell-known sock
get:aa socket addres
get:a"Telnet-Server"
get:asocket, and oth
get:aEntry, Text Gen
get:abeing for test 
get:aaccess to a "Lo
get:aat which a newl
get:awell-known sock
get:aof sockets to s
get:aProcesses can i
get:afrom other proc
get:abeen establishe
get:aother at the sa
get:ais critical for
get:acomponents act 
get:aThere are two p
get:apassive OPENs a
get:alocal passive O
get:acase, the match
get:aOPENs has left 
get:aforeign socket 
get:aOther possibili
get:aTransmission Cont
get:aIf there are se
get:asame local sock
get:awith the specif
get:aTCB exists, bef
get:aThe procedures 
get:acontrol flag an
get:aexchange has be
get:aA connection is
get:acontaining a SY
get:acommand.  The m
get:aconnection has 
get:awhen sequence n
get:aThe clearing of
get:ain this case ca
get:a2.8.  Data Commun
get:aThe data that f
get:aoctets.  The se
get:ain that call (a
get:athrough to the 
get:aA sending TCP i
get:asend that data 
get:afunction is sig
get:areceiving TCP s
get:athe sending TCP
get:aThere is no nec
get:aboundaries.  Th
get:asingle SEND cal
get:aThe purpose of 
get:afrom the sendin
get:arecord service.
get:aThere is a coup
get:aof data that cr
get:aassociated with
get:abuffer is retur
get:anot filled.  If
get:aPUSH is seen, t
get:aTCP also provid
get:aat some point f
get:a[Page 12]        
get:aSeptember 1981   
get:acurrently readi
get:adefine what the
get:aurgent data, bu
get:atake action to 
get:a2.9.  Precedence 
get:aThe TCP makes u
get:asecurity option
get:abasis to TCP us
get:aa multilevel se
get:ause only, and o
get:acompartment.  C
get:ausers may be li
get:aTCP modules whi
get:aproperly mark o
get:aprecedence.  Su
get:ahigher level pr
get:athem to specify
get:aprecedence of c
get:a2.10.  Robustness
get:aTCP implementat:ions will follow a general principle of robustness
get:aconservative in
get:aTransmission Cont
get:a[Page 14]        
get:aSeptember 1981   
get:a3.1.  Header Form
get:aTCP segments ar
get:aheader carries 
get:adestination hos
get:aheader, supplyi
get:adivision allows
get:aTCP Header Form
get:a0            
get:a0 1 2 3 4 5 6
get:a+-+-+-+-+-+-+-
get:a|          Sou
get:a+-+-+-+-+-+-+-
get:a|             
get:a+-+-+-+-+-+-+-
get:a|             
get:a+-+-+-+-+-+-+-
get:a|  Data |     
get:a| Offset| Rese
get:a|       |     
get:a+-+-+-+-+-+-+-
get:a|           Ch
get:a+-+-+-+-+-+-+-
get:a|             
get:a+-+-+-+-+-+-+-
get:a|             
get:a+-+-+-+-+-+-+-
get:aNote th
get:aSource Port:  1
get:aThe source po
get:aDestination Por:t
get:aThe destinati
get:aTransmission Cont
get:aFunctional Specif
get:aSequence Number:
get:aThe sequence 
get:awhen SYN is p
get:ainitial seque
get:aAcknowledgment :Number
get:aIf the ACK co
get:anext sequence
get:areceive.  Onc
get:aData Offset:  4
get:aThe number of
get:athe data begi
get:aintegral numb
get:aReserved:  6 bi
get:aReserved for 
get:aControl Bits:  :6 bits (from left to right)
get:aURG:  Urgent 
get:aACK:  Acknowl
get:aPSH:  Push Fu
get:aRST:  Reset t
get:aSYN:  Synchro
get:aFIN:  No more
get:aWindow:  16 bit
get:aThe number of
get:aacknowledgmen
get:aChecksum:  16 b
get:aThe checksum 
get:acomplement su
get:asegment conta
get:achecksummed, 
get:aform a 16 bit
get:atransmitted a
get:athe checksum 
get:aThe checksum 
get:a[Page 16]        
get:aSeptember 1981   
get:aprefixed to t
get:aAddress, the 
get:aThis gives th
get:ainformation i
get:aacross the TC
get:acalls by the 
get:aThe TCP Len
get:aoctets (thi
get:acomputed), 
get:aUrgent Pointer:
get:aThis field co
get:apositive offs
get:aurgent pointe
get:athe urgent da
get:athe URG contr
get:aOptions:  varia
get:aOptions may o
get:amultiple of 8
get:achecksum.  An
get:acases for the: format of an option
get:aCase 1:  A 
get:aCase 2:  An
get:ath
get:aThe option-le
get:aoption-length
get:aNote that the
get:afield might i
get:aEnd-of-Option
get:aA TCP must im
get:aTransmission Cont
get:aFunctional Specif
get:aCurrently def:ined options include (kind indicated in octal)
get:aKind     Le
get:a----     --
get:a0         
get:a1         
get:a2         
get:aSpecific Opti
get:aEnd of Opti
get:a+--------
get:a|00000000
get:a+--------
get:aThis opti
get:amight not
get:athe Data 
get:anot the e
get:athe optio
get:aNo-Operatio
get:a+--------
get:a|00000001
get:a+--------
get:aThis opti
get:aalign the
get:aThere is 
get:areceivers
get:anot begin
get:aMaximum Seg
get:a+--------
get:a|00000010
get:a+--------
get:aKind=2  
get:a[Page 18]        
get:aSeptember 1981   
get:aMaximum S:egment Size Option Data
get:aIf this
get:areceive
get:aThis fi
get:a(i.e., 
get:aoption 
get:aPadding:  varia
get:aThe TCP heade
get:aand data begi
get:a3.2.  Terminology
get:aBefore we can d
get:ato introduce so
get:aconnection requ
get:aof these variab
get:aTransmission Co
get:aTCB are the loc
get:aprecedence of t
get:abuffers, pointe
get:aIn addition sev
get:asequence number
get:aSend Sequence
get:aSND.UNA - s
get:aSND.NXT - s
get:aSND.WND - s
get:aSND.UP  - s
get:aSND.WL1 - s
get:aSND.WL2 - s
get:au
get:aISS     - i
get:aReceive Seque
get:aRCV.NXT - r
get:aRCV.WND - r
get:aRCV.UP  - r
get:aIRS     - i
get:aTransmission Cont
get:aFunctional Specif
get:aThe following d
get:athe sequence sp
get:aSend Sequence S
get:a---
get:a1 - old s
get:a2 - seque
get:a3 - seque
get:a4 - futur
get:aThe send window
get:aReceive Sequenc
get:a1 - old s
get:a2 - seque
get:a3 - futur
get:aThe receive win
get:aThere are also 
get:atake their valu
get:a[Page 20]        
get:aSeptember 1981   
get:aCurrent Segme
get:aSEG.SEQ - s
get:aSEG.ACK - s
get:aSEG.LEN - s
get:aSEG.WND - s
get:aSEG.UP  - s
get:aSEG.PRC - s
get:aA connection pr
get:alifetime.  The :states are
get:aESTABLISHED, FI
get:aTIME-WAIT, and 
get:abecause it repr
get:ano connection. : Briefly the meanings of the states are
get:aLISTEN - repr
get:aTCP and port.
get:aSYN-SENT - re
get:aafter having 
get:aSYN-RECEIVED 
get:arequest ackno
get:aconnection re
get:aESTABLISHED -
get:adelivered to 
get:aof the connec
get:aFIN-WAIT-1 - 
get:afrom the remo
get:atermination r
get:aFIN-WAIT-2 - 
get:afrom the remo
get:aCLOSE-WAIT - 
get:afrom the loca
get:aCLOSING - rep
get:aacknowledgmen
get:aLAST-ACK - re
get:aconnection te
get:a(which includ
get:aTransmission Cont
get:aFunctional Specif
get:aTIME-WAIT - r
get:athe remote TC
get:atermination r
get:aCLOSED - repr
get:aA TCP connectio
get:aevents.  The ev
get:aABORT, and STAT
get:acontaining the 
get:aThe state diagr
get:awith the causin
get:aerror condition
get:achanges.  In a 
get:athe reaction of
get:aNOTE BENE:  thi
get:athe total speci
get:a[Page 22]        
get:aSeptember 1981   
get:a+---------+     
get:a|         |<----
get:a|   SYN   |     
get:a|   RCVD  |<----
get:a|         |     
get:a|         |-----
get:a+---------+   rc
get:a|           --
get:a|             
get:a|             
get:a|  CLOSE      
get:a| -------     
get:a| snd FIN     
get:a|             
get:aV             
get:a+---------+     
get:a|  FIN    |<----
get:a| WAIT-1  |-----
get:a+---------+     
get:a| rcv ACK of F
get:a| ------------
get:aV        x    
get:a+---------+     
get:a|FINWAIT-2|     
get:a+---------+     
get:a|             
get:a|  rcv FIN    
get:a|  -------    
get:a\ snd ACK    
get:a------------
get:aTransmission Cont
get:aFunctional Specif
get:a3.3.  Sequence Nu
get:aA fundamental n
get:aover a TCP conn
get:asequenced, each
get:amechanism emplo
get:anumber X indica
get:areceived.  This
get:adetection in th
get:awithin a segmen
get:athe header is t
get:anumbered consec
get:aIt is essential
get:afinite, though 
get:aSince the space
get:anumbers must be
get:apreserves the r
get:a2**32 - 1 to 0 
get:aarithmetic, so 
get:acomparison of s
get:a(modulo 2**32).
get:aThe typical kin
get:aperform include:
get:a(a)  Determin
get:anumber s
get:a(b)  Determin
get:ahave bee
get:aretransm
get:a(c)  Determin
get:awhich ar
get:areceive 
get:a[Page 24]        
get:aSeptember 1981   
get:aIn response to 
get:afollowing compa
get:aSND.UNA = old
get:aSND.NXT = nex
get:aSEG.ACK = ack
get:anum
get:aSEG.SEQ = fir
get:aSEG.LEN = the
get:a(co
get:aSEG.SEQ+SEG.L
get:aA new acknowled
get:athe inequality :below holds
get:aSND.UNA < SEG
get:aA segment on th
get:aof its sequence
get:aacknowledgment 
get:aWhen data is re:ceived the following comparisons are needed
get:aRCV.NXT = nex
get:ais the le
get:aRCV.NXT+RCV.W
get:asegment, 
get:aSEG.SEQ = fir
get:aSEG.SEQ+SEG.L
get:aA segment is ju
get:aRCV.NXT =< SE
get:aRCV.NXT =< SE
get:aTransmission Cont
get:aFunctional Specif
get:aThe first part 
get:asegment falls i
get:aif the end of t
get:aeither part of 
get:aActually, it is
get:awindows and zer
get:aacceptability o:f an incoming segment
get:aSegment Recei
get:aLength  Windo
get:a------- -----
get:a0       0 
get:a0      >0 
get:a>0       0 
get:a>0      >0 
get:aNote that when 
get:aacceptable exce
get:amaintain a zero
get:aACKs.  However,
get:aprocess the RST
get:aWe have taken a
get:acontrol informa
get:asome control fl
get:aand acknowledge
get:acontrol will be
get:acarried in the 
get:afor implicitly 
get:aare the only co
get:aare used only a
get:apurposes, the S
get:aoctet of the se
get:ato occur after 
get:aoccurs.  The se
get:aspace occupying
get:asequence number
get:a[Page 26]        
get:aSeptember 1981   
get:aInitial Sequenc
get:aThe protocol pl
get:aused over and o
get:asockets.  New i
get:aincarnations of
get:a-- "how does th
get:aincarnations of
get:aconnection is b
get:aconnection brea
get:aTo avoid confus
get:aconnection from
get:abe present in t
get:aassure this, ev
get:asequence number
get:aan initial sequ
get:anew 32 bit ISN.
get:abit clock whose
get:amicroseconds.  
get:aSince we assume
get:athe Maximum Seg
get:ahours we can re
get:aFor each connec
get:asequence number
get:athe data sendin
get:alearned during 
get:aFor a connectio
get:asynchronize on 
get:aan exchange of 
get:acalled "SYN" (f
get:ashorthand, segm
get:aHence, the solu
get:ainitial sequenc
get:aThe synchroniza
get:asequence number
get:afrom the other 
get:ainitial sequenc
get:a1) A --> B  S
get:a2) A <-- B  A
get:a3) A <-- B  S
get:a4) A --> B  A
get:aTransmission Cont
get:aFunctional Specif
get:aBecause steps 2
get:acalled the thre
get:aA three way han
get:atied to a globa
get:amechanisms for 
get:ano way of knowi
get:aunless it remem
get:a(which is not a
get:averify this SYN
get:aclock-driven sc
get:aKnowing When to
get:aTo be sure that
get:asequence number
get:athe network, th
get:a(MSL) before as
get:arecovering from
get:alost.  For this
get:ais an engineeri
get:ait is desirable
get:asense, yet reta
get:anot wait at all
get:athan those rece
get:aThe TCP Quiet T
get:aThis specific
get:aretaining any
get:aeach active (
get:aTCP segments 
get:ain the intern
get:aparagraphs be
get:aTCP implement
get:aat the risk o
get:adata rejected
get:aTCPs consume 
get:aentered into 
get:aduplicate det
get:arelies on the
get:athe extent th
get:avalues before
get:abeen delivere
get:acopies of the
get:asuch an assum
get:a[Page 28]        
get:aSeptember 1981   
get:aassigned the 
get:aat the receiv
get:athat each seg
get:aas there are 
get:aUnder normal 
get:ato emit and t
get:amistakenly us
get:abeen acknowle
get:adata is drain
get:avery large to
get:acause trouble
get:ato use up 2**
get:alifetime in t
get:athis is deeme
get:arates escalat
get:acycle time is
get:awithin reason
get:aThe basic dup
get:adefeated, how
get:asequence numb
get:athe TCP were 
get:aupon crashing
get:aconnection (p
get:apackets with 
get:apackets still
get:aincarnation o
get:aabout the seq
get:aspecification
get:abefore emitti
get:asegments from
get:aEven hosts wh
get:ainitial seque
get:a(i.e., even i
get:anumber for ea
get:aSuppose, for 
get:asequence numb
get:aand that even
get:atakes on a va
get:asegment sent 
get:aat this insta
get:aincarnation o
get:aS1 = ISN(t) -
get:aconnection!  
get:aTransmission Cont
get:aFunctional Specif
get:aduplicates in
get:aof S1 may arr
get:athe new incar
get:aThe problem i
get:acrashed nor d
get:athe system fr
get:aOne way to de
get:asegments for 
get:atime" specifi
get:awilling to ri
get:adestination m
get:aImplementors 
get:aconnection by
get:ainformally im
get:aObviously, ev
get:anecessary aft
get:aTo summarize:
get:anumbers in th
get:a"busy" or "in
get:ablock of spac
get:asegment, if a
get:asequence numb
get:athe previous 
get:anumber overla
get:a3.4.  Establishin
get:aThe "three-way 
get:aconnection.  Th
get:aresponded to by
get:asimultaneously 
get:aoccurs, each TC
get:aacknowledgment 
get:aan old duplicat
get:arecipient, that
get:aProper use of "
get:aSeveral example
get:aexamples do not
get:asegments, this 
get:adoesn't deliver
get:avalid (i.e., th
get:aconnection reac
get:areduces the pos
get:a[Page 30]        
get:aSeptember 1981   
get:aimplementation 
get:ainformation for
get:aThe simplest th
get:afigures should 
get:anumbered for re
get:adeparture of a 
get:asegment at B fr
get:aEllipsis (...) 
get:a(delayed).  An 
get:aComments appear
get:athe departure o
get:athe center of e
get:aform, with sequ
get:afields such as 
get:ain the interest
get:aTCP A      
get:a1.  CLOSED     
get:a2.  SYN-SENT   
get:a3.  ESTABLISHED
get:a4.  ESTABLISHED
get:a5.  ESTABLISHED
get:aBasic 3
get:aIn line 2 of fi
get:aindicating that
get:anumber 100.  In
get:areceived from T
get:aB is now expect
get:aoccupied sequen
get:aAt line 4, TCP 
get:aTCP B's SYN; an
get:asequence number
get:abecause the ACK
get:awould wind up A
get:aTransmission Cont
get:aFunctional Specif
get:aSimultaneous in
get:afigure 8.  Each
get:aTCP A      
get:a1.  CLOSED     
get:a2.  SYN-SENT   
get:a3.  SYN-RECEIVE
get:a4.             
get:a5.  SYN-RECEIVE
get:a6.  ESTABLISHED
get:a7.             
get:aS
get:aThe principle r
get:aduplicate conne
get:athis, a special
get:areceiving TCP i
get:aSYN-RECEIVED), 
get:aIf the TCP is i
get:aFIN-WAIT-1, FIN
get:aaborts the conn
get:acase under "hal
get:a[Page 32]        
get:aSeptember 1981   
get:aTCP A      
get:a1.  CLOSED     
get:a2.  SYN-SENT   
get:a3.  (duplicate)
get:a4.  SYN-SENT   
get:a5.  SYN-SENT   
get:a6.             
get:a7.  SYN-SENT   
get:a8.  ESTABLISHED
get:aAs a simple exa
get:afigure 9.  At l
get:acannot tell tha
get:a(line 4).  TCP 
get:aRST (reset) wit
get:abelievable.  TC
get:aWhen the origin
get:asynchronization
get:abefore the RST,
get:asent in both di
get:aHalf-Open Conne
get:aAn established 
get:aTCPs has closed
get:aknowledge of th
get:abecome desynchr
get:amemory.  Such c
get:aattempt is made
get:aconnections are
get:amildly involved
get:aIf at site A th
get:aTransmission Cont
get:aFunctional Specif
get:auser at site B 
get:areceiving a res
get:asite B TCP that
get:aAssume that two
get:aanother when a 
get:aDepending on th
get:athat some error
get:aA is likely to 
get:apoint.  As a re
get:aor try to SEND 
get:acase, it receiv
get:alocal (A's) TCP
get:awill send a seg
get:aexample shown i
get:are-open the con
get:aTCP A      
get:a1.  (CRASH)    
get:a2.  CLOSED     
get:a3.  SYN-SENT --
get:a4.  (!!)     <-
get:a5.  SYN-SENT --
get:a6.  SYN-SENT   
get:a7.  SYN-SENT --
get:aWhen the SYN ar
get:aand the incomin
get:aacknowledgment 
get:a100).  TCP A se
get:asent and, being
get:adetected a half
get:a[Page 34]        
get:aSeptember 1981   
get:acontinue to try
get:areduced to the 
get:aAn interesting 
get:atries to send d
get:aThis is illustr
get:aTCP A from TCP 
get:aexists, so TCP 
get:aprocesses it an
get:aTCP A    
get:a1.  (CRASH)    
get:a2.  (??)    <--
get:a3.          -->
get:aActive
get:aIn figure 12, w
get:awaiting for SYN
get:ainto action.  A
get:agenerate a RST 
get:athe reset and r
get:aTCP A      
get:a1.  LISTEN     
get:a2.       ... <S
get:a3.  (??) <-- <S
get:a4.       --> <S
get:a5.  LISTEN     
get:aOld Duplic
get:aTransmission Cont
get:aFunctional Specif
get:aA variety of ot
get:aby the followin
get:aReset Generatio
get:aAs a general ru
get:awhich apparentl
get:amust not be sen
get:aThere are three: groups of states
get:a1.  If the co
get:ain response t
get:aparticular, S
get:aby this means
get:aIf the incomi
get:asequence numb
get:areset has seq
get:aof the sequen
get:aThe connectio
get:a2.  If the co
get:aSYN-SENT, SYN
get:asomething not
get:aif an incomin
get:adoes not exac
get:aconnection, a
get:aIf our SYN ha
get:aincoming segm
get:aeither raise 
get:athe system) o
get:aincoming segm
get:acontinue as i
get:acannot raise 
get:adetected in t
get:aterminated th
get:aincoming segm
get:amatch the loc
get:amust be sent.
get:aIf the incomi
get:asequence numb
get:areset has seq
get:aof the sequen
get:aThe connectio
get:a[Page 36]        
get:aSeptember 1981   
get:a3.  If the co
get:aFIN-WAIT-1, F
get:aany unaccepta
get:aunacceptible 
get:aacknowledgmen
get:aand an acknow
get:ato be receive
get:aIf an incomin
get:aprecedence wh
get:aand precedenc
get:aconnection go
get:anumber from t
get:aReset Processin
get:aIn all states e
get:aby checking the
get:ais in the windo
get:ato an initial S
get:aacknowledges th
get:aThe receiver of
get:areceiver was in
get:ain SYN-RECEIVED
get:athen the receiv
get:aaborts the conn
get:awas in any othe
get:aand goes to the
get:a3.5.  Closing a C
get:aCLOSE is an ope
get:anotion of closi
get:ainterpretation,
get:athe receiving s
get:ain a simplex fa
get:auntil he is tol
get:acould initiate 
get:aRECEIVE until s
get:ahas CLOSED.  We
get:aRECEIVEs are ou
get:acan terminate h
get:abuffers SENT be
get:adata in return 
get:asuccessfully to
get:aTCP.  Users mus
get:athe TCP says no
get:aTransmission Cont
get:aFunctional Specif
get:aThere are essen:tially three cases
get:a1) The user i
get:a2) The remote
get:a3) Both users
get:aCase 1:  Local 
get:aIn this case,
get:aoutgoing segm
get:aaccepted by t
get:aare allowed i
get:awill be retra
get:aboth acknowle
get:acan ACK this 
get:asend its own 
get:aCase 2:  TCP re
get:aIf an unsolic
get:acan ACK it an
get:auser will res
get:athe other TCP
get:auntil its own
get:aconnection.  
get:athe connectio
get:aCase 3:  both u
get:aA simultaneou
get:aFIN segments 
get:ahave been pro
get:ahas received.
get:a[Page 38]        
get:aSeptember 1981   
get:aTCP A      
get:a1.  ESTABLISHED
get:aFIN-WAIT-1 
get:a3.  FIN-WAIT-2 
get:a4.             
get:aTIME-WAIT  
get:a5.  TIME-WAIT  
get:aCLOSED     
get:aTCP A      
get:a1.  ESTABLISHED
get:a2.  (Close)    
get:aFIN-WAIT-1 
get:a3.  CLOSING    
get:a4.  TIME-WAIT  
get:a(2 MSL)    
get:aCLOSED     
get:aTransmission Cont
get:aFunctional Specif
get:a3.6.  Precedence 
get:aThe intent is t
get:awith exactly th
get:ahigher of the p
get:aThe precedence 
get:adefined in the 
get:aspecification t
get:athe security pa
get:auser group, and
get:aA connection at
get:alower precedenc
get:aa connection du
get:aacknowledgment 
get:aNote that TCP m
get:aprecedence will
get:asegments and po
get:aThe security pa
get:a(the values wou
get:anon-secure envi
get:aparameters, tho
get:a3.7.  Data Commun
get:aOnce the connec
get:aexchange of seg
get:a(checksum test 
get:aretransmission 
get:aDuplicate segme
get:aAs discussed in
get:acertain tests o
get:asegments to ver
get:aThe sender of d
get:athe variable SN
get:asequence number
get:akeeps track of 
get:avariable SND.UN
get:asent has been a
get:aWhen the sender
get:aSND.NXT.  When 
get:asends an acknow
get:a[Page 40]        
get:aSeptember 1981   
get:aacknowledgment 
get:athese variables
get:aThe amount by w
get:adata in the seg
get:asegments must c
get:aThe CLOSE user 
get:aflag in an inco
get:aRetransmission 
get:aBecause of the 
get:ainternetwork sy
get:aretransmission 
get:afor determining
get:aAn Example Re
get:aMeasure the
get:aparticular 
get:acovers that
get:asegments re
get:aTime (RTT).:  Next compute a Smoothed Round Trip Time (SRTT) as
get:aSRTT = ( 
get:aand based o:n this, compute the retransmission timeout (RTO) as
get:aRTO = min
get:awhere UBOUN
get:aLBOUND is a
get:aa smoothing
get:afactor (e.g
get:aThe Communicati
get:aThe objective o
get:ato stimulate th
get:apermit the rece
get:athe currently k
get:aThis mechanism 
get:athe end of urge
get:athe receive seq
get:amust tell the u
get:anumber catches 
get:aTransmission Cont
get:aFunctional Specif
get:ainto "normal mo
get:ais in "urgent m
get:aThe method empl
get:atransmitted.  T
get:ameaningful and 
get:athe urgent poin
get:ano urgent data 
get:aTo send an urge
get:aoctet.  If the 
get:athe urgent info
get:aManaging the Wi
get:aThe window sent
get:anumbers the sen
get:aprepared to acc
get:athe currently a
get:aIndicating a la
get:aarrives than ca
get:ain excessive re
get:anetwork and the
get:atransmission of
get:abetween each ne
get:aThe mechanisms 
get:asubsequently ad
get:athat much data.
get:adiscouraged.  T
get:ashrink the wind
get:aon the part of 
get:aThe sending TCP
get:aleast one octet
get:asending TCP mus
get:athe window is z
get:ainterval when t
get:aguarantee that 
get:awindow will be 
get:aWhen the receiv
get:astill send an a
get:aand current win
get:aThe sending TCP
get:a[Page 42]        
get:aSeptember 1981   
get:awhich fit the c
get:aretransmission 
get:aIn a connection
get:abe carried in a
get:anumber so there
get:aorder.  This is
get:ainformation to 
get:athe data receiv
get:athe window info
get:aacknowledgment 
get:aequal or greate
get:aThe window mana
get:acommunication p
get:aWindow Manage
get:aAllocating 
get:amany small 
get:afewer large
get:aOne suggest
get:adefer updat
get:aleast X per
get:aconnection 
get:aAnother sug
get:asegments by
get:asending dat
get:adata must b
get:aNote that t
get:aretransmiss
get:aacknowledgm
get:awindow info
get:anew window 
get:aThe segment
get:aof transmit
get:asegment con
get:ais accepted
get:aIf the send
get:awindow is n
get:aalternating
get:apauses in t
get:aTransmission Cont
get:aFunctional Specif
get:aresult in b
get:abig pair. A
get:amostly smal
get:aThe suggest
get:aactively at
get:awindows, si
get:ato many sma
get:aThere are of co:urse two interfaces of concern
get:aand the TCP/low
get:aof the user/TCP
get:aprotocol module
get:ain detail by th
get:acase that the l
get:athat TCPs might
get:aUser/TCP Interf
get:aThe following
get:aat best, fict
get:afacilities.  
get:aimplementatio
get:aTCPs must pro
get:athat all TCP 
get:ahierarchy.  T
get:arequired of a
get:aTCP User Comm
get:aThe followi
get:ainterface. 
get:afunction ca
get:ameant to ru
get:aThe user co
get:aTCP must pe
get:aIndividual 
get:amay provide
get:asingle call
get:aautomatical
get:aissued by t
get:a[Page 44]        
get:aSeptember 1981   
get:aIn providin
get:anot only ac
get:aprocesses i:t serves.  The latter consists of
get:a(a) gener
get:aremote cl
get:a(b) repli
get:avarious t
get:aFormat:  
get:a[, timeou
get:a-> local 
get:aWe assume
get:aprocesses
get:ato use th
get:aimplement
get:afor the s
get:alower lev
get:aresult of
get:aable to m
get:aprocess c
get:aIf the ac
get:acall to L
get:ahave eith
get:aparticula
get:afor any c
get:aby the su
get:aA transmi
get:afilled in
get:aOn an act
get:asynchroni
get:aThe timeo
get:afor all d
get:adelivered
get:awill abor
get:aThe TCP o
get:athe users
get:aTransmission Cont
get:aFunctional Specif
get:aprecedenc
get:aor securi
get:athe defau
get:aTCP will 
get:asecurity/
get:athe prece
get:arequested
get:aThe prece
get:arequested
get:arequest, 
get:aconnectio
get:athis prec
get:aallowed t
get:aor that a
get:aA local c
get:aThe local
get:afor the c
get:aFormat:  
get:acount, PU
get:aThis call
get:ato be sen
get:anot been 
get:aimplement
get:aautomatic
get:aauthorize
get:aIf the PU
get:ato the re
get:asegment c
get:athe data 
get:atransmiss
get:aIf the UR
get:awill have
get:athe urgen
get:apointer i
get:abeen cons
get:ais to sti
get:aindicate 
get:a[Page 46]        
get:aSeptember 1981   
get:adata has 
get:aTCP signa
get:aof times 
get:aurgent da
get:aIf no for
get:aconnectio
get:ahas becom
get:alocal soc
get:aforeign s
get:aforeign s
get:aknowing t
get:aHowever, 
get:abecomes s
get:aSTATUS ca
get:aimplement
get:asocket is
get:aIf a time
get:aconnectio
get:aIn the si
get:athe sendi
get:aor the ti
get:ais both s
get:aconnectio
get:aoffers po
get:asophistic
get:athe proce
get:afurthermo
get:aMultiple 
get:athe TCP w
get:aWe have i
get:awhich a S
get:apseudo-in
get:areturn a 
get:aimmediate
get:abeen ackn
get:aassume ev
get:aclose any
get:akind (syn
get:asignals, 
get:awith spec
get:aIn order 
get:aindicatio
get:aTransmission Cont
get:aFunctional Specif
get:abuffer ad
get:athe SEND 
get:aindicatin
get:acalling p
get:aFormat:  
get:acount) ->
get:aThis comm
get:aspecified
get:acalling p
get:aerror is 
get:aIn the si
get:acalling p
get:aerror occ
get:aA more so
get:aRECEIVEs 
get:asegments 
get:athe cost 
get:anotify th
get:aIf enough
get:athe PUSH 
get:aThe buffe
get:aa PUSH is
get:areturned 
get:aIf there 
get:aas it arr
get:ashould th
get:aadditiona
get:acall to R
get:amay now l
get:aurgent po
get:ain the sa
get:aboundary 
get:aTo distin
get:acare of t
get:areturn co
get:acount ind
get:aAlternati
get:a[Page 48]        
get:aSeptember 1981   
get:aallocate 
get:awith the 
get:aFormat:  
get:aThis comm
get:athe conne
get:aauthorize
get:aClosing c
get:athe sense
get:aretransmi
get:aserviced.
get:acalls, fo
get:ato the de
get:acontinue 
get:amay be tr
get:ameans "I 
get:areceive a
get:anot well 
get:aof all it
get:ainto ABOR
get:aThe user 
get:ainitiativ
get:a(e.g., re
get:adestinati
get:aBecause c
get:aforeign T
get:ashort tim
get:areplies t
get:aClose als
get:aFormat:  
get:aThis is a
get:aexcluded 
get:atypically
get:aThis comm
get:ainformati:on
get:alocal s
get:aTransmission Cont
get:aFunctional Specif
get:aforeign
get:alocal c
get:areceive
get:asend wi
get:aconnect
get:anumber 
get:anumber 
get:aurgent 
get:aprecede
get:asecurit
get:aand tra
get:aDepending
get:aimplement
get:aavailable
get:aauthorize
get:aprevents 
get:aconnectio
get:aFormat:  
get:aThis comm
get:aaborted, 
get:abe sent t
get:aDepending
get:aindicatio
get:areceive a
get:aTCP-to-User M
get:aIt is assum
get:ameans for t
get:athe TCP doe
get:ato the user
get:aan error me
get:arelating to
get:aother user 
get:aThe followi:ng information is provided
get:aLocal Con
get:aResponse 
get:aBuffer Ad
get:aByte coun
get:aPush flag
get:aUrgent fl
get:a[Page 50]        
get:aSeptember 1981   
get:aTCP/Lower-Level
get:aThe TCP calls
get:areceive infor
get:ainternetwork 
get:aProtocol (IP)
get:aIf the lower 
get:aof service an
get:afor these par:ameters
get:aType of Ser:vice = Precedence: routine, Delay: normal, Throughput
get:anormal, Rel:iability
get:aTime to Liv
get:aNote that
get:aHere we e
get:abe delive
get:aIf the lower 
get:afeature) and 
get:aroute informa
get:aso that the s
get:achecksum be t
get:aalso importan
get:aAny lower lev
get:adestination a
get:athe "TCP leng
get:aof IP and to 
get:aTransmission Cont
get:aFunctional Specif
get:a3.9.  Event Proce
get:aThe processing 
get:aimplementation.
get:aprocessing sequ
get:asection only in
get:aThe activity of
get:aThe events that: occur can be cast into three categories
get:aarriving segmen
get:aprocessing the 
get:acases the proce
get:aEvents that o:ccur
get:aArriving Se
get:aSEGMENT A
get:aUSER TIME
get:aRETRANSMI
get:aTIME-WAIT
get:aThe model of th
get:aimmediate retur
get:apseudo interrup
get:ameans cause a d
get:aError responses
get:acommands refere:ncing connections that do not exist receive "error
get:aconnection not 
get:aPlease note in 
get:aacknowledgment 
get:aof the sequence
get:aequal to (modul
get:a[Page 52]        
get:aSeptember 1981   
get:aA natural way t
get:aimagine that th
get:athat their cont
get:ain the sequence
get:aand processed i
get:aWhen a segment 
get:athe segment to 
get:ato be consisten
get:aNote that if no
get:aTransmission Cont
get:aFunctional Specif
get:aCLOSED STATE 
get:aCreate a ne
get:astate infor
get:asocket, pre
get:ainformation
get:aunspecified
get:aparameters 
get:aprecedence 
get:a"error:  pr:ecedence not allowed" or "error
get:anot allowed
get:aactive and :the foreign socket is unspecified, return "error
get:aforeign soc
get:aspecified, 
get:a(ISS) is se
get:ais sent.  S
get:astate, and 
get:aIf the call
get:areturn "err:or
get:ano room to :create a new connection, return "error
get:aresources".
get:aIf active a
get:aconnection 
get:asegment, se
get:astate.  Dat
get:aqueued for 
get:aurgent bit 
get:asegments se
get:aqueue the r:equest, respond with "error
get:aIf Foreign :socket was not specified, then return "error
get:asocket unsp
get:a[Page 54]        
get:aSeptember 1981   
get:aSYN-SENT STAT
get:aSYN-RECEIVED 
get:aESTABLISHED S
get:aFIN-WAIT-1 ST
get:aFIN-WAIT-2 ST
get:aCLOSE-WAIT ST
get:aCLOSING STATE
get:aLAST-ACK STAT
get:aTIME-WAIT STA
get:aReturn "err:or
get:aTransmission Cont
get:aFunctional Specif
get:aCLOSED STATE 
get:aIf the user
get:a"error:  co
get:aOtherwise, :return "error
get:aIf the fore
get:afrom passiv
get:aSND.UNA to 
get:aassociated 
get:atransmissio
get:arequested i
get:aas a result
get:arequest, re:spond with "error
get:aForeign soc:ket was not specified, then return "error
get:asocket unsp
get:aSYN-SENT STAT
get:aSYN-RECEIVED 
get:aQueue the d
get:aIf no space: to queue, respond with "error
get:aresources".
get:aESTABLISHED S
get:aCLOSE-WAIT ST
get:aSegmentize 
get:aacknowledgm
get:ainsufficien:t space to remember this buffer, simply return "error
get:ainsufficien
get:aIf the urge
get:aurgent poin
get:a[Page 56]        
get:aSeptember 1981   
get:aFIN-WAIT-1 ST
get:aFIN-WAIT-2 ST
get:aCLOSING STATE
get:aLAST-ACK STAT
get:aTIME-WAIT STA
get:aReturn "err:or
get:aTransmission Cont
get:aFunctional Specif
get:aCLOSED STATE 
get:aIf the user
get:a"error:  co
get:aOtherwise r:eturn "error
get:aSYN-SENT STAT
get:aSYN-RECEIVED 
get:aQueue for p
get:ais no room :to queue this request, respond with "error
get:ainsufficien
get:aESTABLISHED S
get:aFIN-WAIT-1 ST
get:aFIN-WAIT-2 ST
get:aIf insuffic
get:arequest, qu
get:aremember th:e RECEIVE, respond with "error
get:aresources".
get:aReassemble 
get:ato user.  M
get:aIf RCV.UP i
get:auser notify
get:aWhen the TC
get:athat fact m
get:aacknowledgm
get:adescribed b
get:a[Page 58]        
get:aSeptember 1981   
get:aCLOSE-WAIT ST
get:aSince the r
get:asatisfied b
get:auser.  If n
get:a"error:  co
get:atext can be
get:aCLOSING STATE
get:aLAST-ACK STAT
get:aTIME-WAIT STA
get:aReturn "err:or
get:aTransmission Cont
get:aFunctional Specif
get:aCLOSED STATE 
get:aIf the user
get:a"error:  co
get:aOtherwise, :return "error
get:aAny outstan:ding RECEIVEs are returned with "error
get:aresponses. 
get:aSYN-SENT STAT
get:aDelete the :TCB and return "error
get:aqueued SEND
get:aSYN-RECEIVED 
get:aIf no SENDs
get:athen form a
get:aotherwise q
get:aESTABLISHED S
get:aQueue this 
get:aform a FIN 
get:aFIN-WAIT-1 ST
get:aFIN-WAIT-2 ST
get:aStrictly sp:eaking, this is an error and should receive a "error
get:aconnection 
get:aacceptable,
get:aFIN may be 
get:a[Page 60]        
get:aSeptember 1981   
get:aCLOSE-WAIT ST
get:aQueue this 
get:asegmentized
get:aCLOSING STATE
get:aLAST-ACK STAT
get:aTIME-WAIT STA
get:aRespond wit:h "error
get:aTransmission Cont
get:aFunctional Specif
get:aCLOSED STATE 
get:aIf the user
get:a"error:  co
get:aOtherwise r:eturn "error
get:aAny outstan:ding RECEIVEs should be returned with "error
get:aconnection 
get:aSYN-SENT STAT
get:aAll queued 
get:anotificatio
get:aSYN-RECEIVED 
get:aESTABLISHED S
get:aFIN-WAIT-1 ST
get:aFIN-WAIT-2 ST
get:aCLOSE-WAIT ST
get:aSend a rese:t segment
get:a<SEQ=SND.
get:aAll queued 
get:anotificatio
get:aRST formed 
get:aTCB, enter 
get:aCLOSING STATE
get:aLAST-ACK STAT
get:aTIME-WAIT STA
get:aRespond wit
get:a[Page 62]        
get:aSeptember 1981   
get:aCLOSED STATE 
get:aIf the user
get:a"error:  co
get:aOtherwise r:eturn "error
get:aReturn "sta
get:aSYN-SENT STAT
get:aReturn "sta
get:aSYN-RECEIVED 
get:aReturn "sta
get:aESTABLISHED S
get:aReturn "sta
get:aFIN-WAIT-1 ST
get:aReturn "sta
get:aFIN-WAIT-2 ST
get:aReturn "sta
get:aCLOSE-WAIT ST
get:aReturn "sta
get:aCLOSING STATE
get:aReturn "sta
get:aLAST-ACK STAT
get:aReturn "sta
get:aTransmission Cont
get:aFunctional Specif
get:aTIME-WAIT STA
get:aReturn "sta
get:a[Page 64]        
get:aSeptember 1981   
get:aSEGMENT ARRIVES
get:aIf the state 
get:aall data in
get:asegment con
get:acontaining 
get:aacknowledgm
get:areset seque
get:aIf the ACK 
get:a<SEQ=0><A
get:aIf the ACK 
get:a<SEQ=SEG.
get:aIf the state 
get:afirst check
get:aAn incomi
get:asecond chec
get:aAny ackno
get:athe LISTE
get:afor any a
get:aformatted: as follows
get:a<SEQ=SE
get:athird check
get:aIf the SY
get:asecurity/
get:amatch the
get:a<SEQ=SE
get:aTransmission Cont
get:aFunctional Specif
get:aIf the SE
get:athe user 
get:asend a re
get:a<SEQ=SE
get:aIf the SE
get:aSet RCV.N
get:acontrol o
get:ashould be: selected and a SYN segment sent of the form
get:a<SEQ=IS
get:aSND.NXT i
get:astate sho
get:aincoming 
get:ain the SY
get:anot be re
get:athe forei
get:aunspecifi
get:afourth othe
get:aAny other
get:amust have
get:aprocessin
get:ait could 
get:aincarnati
get:abut if yo
get:aIf the state 
get:afirst check
get:aIf the AC
get:aIf SEG.
get:athe RST
get:a<SEQ=
get:aand dis
get:aIf SND.
get:asecond chec
get:a[Page 66]        
get:aSeptember 1981   
get:aIf the RS
get:aIf the :ACK was acceptable then signal the user "error
get:aconnect
get:adelete 
get:aand ret
get:athird check
get:aIf the se
get:amatch the
get:aIf ther
get:a<SEQ=
get:aOtherwi
get:a<SEQ=
get:aIf there 
get:aThe pre
get:aTCB, if
get:a<SEQ=
get:aIf there 
get:aIf the 
get:ain the 
get:athe pre
get:aallowed
get:a<SEQ=
get:aIf the 
get:ain the 
get:aIf a rese
get:afourth chec
get:aThis step
get:ano ACK, a
get:aIf the SY
get:aTransmission Cont
get:aFunctional Specif
get:aare accep
get:aSEG.SEQ. 
get:ais an ACK
get:aare there
get:aIf SND.UN
get:astate to 
get:a<SEQ=SN
get:aand send 
get:atransmiss
get:atext in t
get:abelow whe
get:aOtherwise
get:a<SEQ=IS
get:aand send 
get:asegment, 
get:ahas been 
get:afifth, if n
get:asegment and
get:a[Page 68]        
get:aSeptember 1981   
get:afirst check s
get:aSYN-RECEIVE
get:aESTABLISHED
get:aFIN-WAIT-1 
get:aFIN-WAIT-2 
get:aCLOSE-WAIT 
get:aCLOSING STA
get:aLAST-ACK ST
get:aTIME-WAIT S
get:aSegments 
get:aare used 
get:adone in S
get:aboundary 
get:aprocessed
get:aThere are
get:asegment
get:aSegment R
get:aLength  W
get:a------- -
get:a0     
get:a0     
get:a>0     
get:a>0     
get:aIf the RC
get:aspecial a
get:aIf an inc
get:ashould be
get:athe segme:nt and return)
get:a<SEQ=SN
get:aAfter sen
get:aand retur
get:aTransmission Cont
get:aFunctional Specif
get:aIn the fo
get:asegment t
get:aOne could
get:atrimming 
get:aSYN and F
get:abegins at
get:anumbers m
get:asecond check 
get:aSYN-RECEIVE
get:aIf the RS
get:aIf this
get:acame fr
get:aLISTEN 
get:athis co
get:afrom SY
get:athe use
get:aon the 
get:aactive 
get:aand ret
get:aESTABLISHED
get:aIf the RS
get:ashould re
get:aflushed. 
get:a"connecti
get:aTCB, and 
get:aCLOSING STA
get:aLAST-ACK ST
get:aIf the RS
get:aTCB, and 
get:a[Page 70]        
get:aSeptember 1981   
get:athird check s
get:aSYN-RECEIVE
get:aIf the se
get:aexactly m
get:athen send
get:aESTABLISHED
get:aIf the se
get:aexactly m
get:athen send
get:areceive "
get:aflushed. 
get:a"connecti
get:aTCB, and 
get:aNote this c
get:aa segment f
get:adifferent s
get:acurrent con
get:afourth, check
get:aSYN-RECEIVE
get:aESTABLISHED
get:aFIN-WAIT ST
get:aFIN-WAIT ST
get:aCLOSE-WAIT 
get:aCLOSING STA
get:aLAST-ACK ST
get:aTIME-WAIT S
get:aIf the SY
get:aoutstandi
get:aall segme
get:areceive a
get:athe CLOSE
get:aIf the SY
get:aand an ac
get:anumber ch
get:aTransmission Cont
get:aFunctional Specif
get:afifth check t
get:aif the ACK 
get:aif the ACK 
get:aSYN-RECEI
get:aIf SND.
get:aand con
get:aIf th
get:areset
get:a<SE
get:aand s
get:aESTABLISH
get:aIf SND.
get:aAny seg
get:aentirel
get:apositiv
get:afully a
get:a"ok" re
get:a(SEG.AC
get:asomethi
get:adrop th
get:aIf SND.
get:aupdated
get:aSND.WL2
get:aSND.WL1
get:aNote th
get:arecords
get:aSND.WND
get:athe las
get:aprevent
get:a[Page 72]        
get:aSeptember 1981   
get:aFIN-WAIT-
get:aIn addi
get:aour FIN
get:aprocess
get:aFIN-WAIT-
get:aIn addi
get:athe ret
get:aacknowl
get:aCLOSE-WAI
get:aDo the 
get:aCLOSING S
get:aIn addi
get:athe ACK
get:aotherwi
get:aLAST-ACK 
get:aThe onl
get:aacknowl
get:adelete 
get:aTIME-WAIT
get:aThe onl
get:aretrans
get:athe 2 M
get:asixth, check 
get:aESTABLISHED
get:aFIN-WAIT-1 
get:aFIN-WAIT-2 
get:aIf the UR
get:athe user 
get:apointer (
get:auser has 
get:amode") fo
get:asignal th
get:aTransmission Cont
get:aFunctional Specif
get:aCLOSE-WAIT 
get:aCLOSING STA
get:aLAST-ACK ST
get:aThis shou
get:aremote si
get:aseventh, proc
get:aESTABLISHED
get:aFIN-WAIT-1 
get:aFIN-WAIT-2 
get:aOnce in t
get:atext to u
get:ainto buff
get:aempty.  I
get:athe user 
get:ahas been 
get:aWhen the 
get:auser it m
get:aOnce the 
get:aRCV.NXT o
get:aapporopri
get:aRCV.NXT a
get:aPlease no
get:aSend an a:cknowledgment of the form
get:a<SEQ=SN
get:aThis ackn
get:atransmitt
get:a[Page 74]        
get:aSeptember 1981   
get:aCLOSE-WAIT 
get:aCLOSING STA
get:aLAST-ACK ST
get:aTIME-WAIT S
get:aThis shou
get:aremote si
get:aeighth, check
get:aDo not proc
get:asince the S
get:aIf the FIN 
get:areturn any 
get:aover the FI
get:aFIN implies
get:aSYN-RECEI
get:aESTABLISH
get:aEnter t
get:aFIN-WAIT-
get:aIf our 
get:aenter T
get:atimers;
get:aFIN-WAIT-
get:aEnter t
get:aoff the
get:aCLOSE-WAI
get:aRemain 
get:aCLOSING S
get:aRemain 
get:aLAST-ACK 
get:aRemain 
get:aTransmission Cont
get:aFunctional Specif
get:aTIME-WAIT
get:aRemain 
get:atimeout
get:a[Page 76]        
get:aSeptember 1981   
get:aFor any state
get:athe user "err:or
get:aand for any o
get:astate and ret
get:aRETRANSMISSION 
get:aFor any state
get:athe retransmi
get:aretransmissio
get:aTIME-WAIT TIMEO
get:aIf the time-w
get:aenter the CLO
get:aTransmission Cont
get:a[Page 78]        
get:aSeptember 1981   
get:aBBN Rep
get:aa Host 
get:ahost an
get:aA contr
get:aindicat
get:aspecifi
get:ais expe
get:apreviou
get:aThe uni
get:aARPANET
get:aA unit 
get:aIMPs.  
get:aA logic
get:aA messa
get:anetwork
get:aDestination Addre
get:aThe des
get:aidentif
get:aA contr
get:aindicat
get:aoccupyi
get:aA porti
get:afragmen
get:aA file 
get:aTransmission Cont
get:aControl
get:afragmen
get:aA compu
get:afrom th
get:aAn Inte
get:aby the 
get:aThe Int
get:aARPANET
get:aA sourc
get:ainternet datagram
get:aThe uni
get:ahigher 
get:ainternet fragment
get:aA porti
get:aheader.
get:aInterne
get:aThe Ini
get:anumber 
get:aThe Ini
get:aon a co
get:abased p
get:aThe Ini
get:aused by
get:aControl
get:adata.  
get:aon an A
get:a[Page 80]        
get:aSeptember 1981   
get:aThis is
get:adata re
get:asequenc
get:aof the 
get:aThe uni
get:aAn impl
get:aprocedu
get:aMaximum
get:athe int
get:aAn eigh
get:aAn Opti
get:amay be 
get:aprimari
get:atimesta
get:aoptions
get:aA packa
get:alogical
get:alogical
get:aThe por
get:aoutput 
get:aA progr
get:athe poi
get:aA contr
get:athis se
get:areceivi
get:areceive
get:aTransmission Cont
get:areceive
get:areceive
get:areceive next sequ
get:aThis is
get:areceive
get:aThis re
get:ais will
get:asegment
get:aRCV.NXT
get:aSegment
get:arange a
get:aA contr
get:athat th
get:ainterac
get:asequenc
get:asegment
get:ait.  In
get:arise to
get:aReal Ti:me Protocol
get:aof time
get:asegment
get:asegment
get:asegment
get:asegment
get:asegment
get:a[Page 82]        
get:aSeptember 1981   
get:asegment
get:aA logic
get:aunit of
get:asegment acknowled
get:aThe seq
get:aarrivin
get:aThe amo
get:aincludi
get:aThe num
get:aThis is
get:ause on 
get:ainitial
get:aeach oc
get:aThis re
get:a(receiv
get:awindow 
get:areceivi
get:abe emit
get:aSND.UNA
get:abetween
get:asend se
get:aleft se
get:asend ur
get:asegment
get:asegment
get:aTransmission Cont
get:asend wi
get:aAn addr
get:ais, the
get:aThe sou
get:aA contr
get:anumber,
get:awhere t
get:aTransmi
get:athe sta
get:aThe pre
get:aTransmi:ssion Control Protocol
get:areliabl
get:aType of
get:aAn Inte
get:afor thi
get:aA contr
get:aindicat
get:aurgent 
get:asequenc
get:apointer
get:aA contr
get:afield c
get:aindicat
get:aurgent 
get:a[Page 84]        
get:aSeptember 1981   
get:a[1]  Cerf, V., an
get:aIntercommuni
get:aVol. COM-22,
get:a[2]  Postel, J. (
get:aProtocol Spe
get:aInstitute, S
get:a[3]  Dalal, Y. an
get:aProtocols", 
get:aDecember 197
get:a[4]  Postel, J., 
get:aInstitute, S
get:bRFC
get:bDe
get:bI
get:bSeptember 1981   
get:bPREFACE .....
get:b1.  INTRODUCTION 
get:b1.1  Motivation
get:b1.2  Scope ....
get:b1.3  About This
get:b1.4  Interfaces
get:b1.5  Operation 
get:b2.  PHILOSOPHY ..
get:b2.1  Elements o
get:b2.2  Model of O
get:b2.3  The Host E
get:b2.4  Interfaces
get:b2.5  Relation t
get:b2.6  Reliable C
get:b2.7  Connection
get:b2.8  Data Commu
get:b2.9  Precedence
get:b2.10 Robustness
get:b3.  FUNCTIONAL SP
get:b3.1  Header For
get:b3.2  Terminolog
get:b3.3  Sequence N
get:b3.4  Establishi
get:b3.5  Closing a 
get:b3.6  Precedence
get:b3.7  Data Commu
get:b3.8  Interfaces
get:b3.9  Event Proc
get:bGLOSSARY ........
get:bREFERENCES ......
get:bTransmission Cont
get:b[Page ii]        
get:bSeptember 1981   
get:bThis document des
get:b(TCP).  There hav
get:bspecification on 
get:bdraws heavily fro
get:bboth in terms of 
get:bseveral details a
get:band redescribes t
get:bRFC
get:bReplaces: RFC 761
get:bIENs:  129, 124, 
get:b55, 44, 40, 27, 2
get:bThe Transmission 
get:breliable host-to-
get:bcommunication net
get:bThis document des
get:bTransmission Cont
get:binterface to prog
get:bComputer commun
get:brole in militar
get:bdocument focuse
get:bcommunication r
get:bcommunication u
get:bcongestion, but
get:bgovernment sect
get:bAs strategic an
get:bdeveloped and d
get:binterconnecting
get:bcommunication p
get:bapplications.  
get:bDeputy Undersec
get:bdeclared the Tr
get:bbe a basis for 
get:bstandardization
get:bTCP is a connec
get:bfit into a laye
get:bapplications.  
get:bcommunication b
get:bdistinct but in
get:bassumptions are
get:bprotocols below
get:bpotentially unr
get:bprotocols.  In 
get:bwide spectrum o
get:bconnections to 
get:bTransmission Cont
get:bTCP is based on
get:bTCP fits into a
get:bInternet Protoc
get:breceive variabl
get:bdatagram "envel
get:baddressing sour
get:binternet protoc
get:bthe TCP segment
get:bmultiple networ
get:balso carries in
get:band compartment
get:bcommunicated en
get:bMuch of this do
get:bwhich are co-re
get:bcomputer.  Some
get:bfront-end compu
get:bas well as netw
get:ban interface to
get:bimplementable e
get:bhost-to-front e
get:bThe TCP is inte
get:bcommunication s
get:bintended to be 
get:b1.3.  About this 
get:bThis document r
get:bany TCP impleme
get:bprotocols and i
get:b[Page 2]         
get:bSeptember 1981   
get:bsection offers 
get:boperation.  Sec
get:bdesign.  Sectio
get:brequired of TCP
get:buser calls, err
get:bThe TCP interfa
get:bthe other side 
get:bThe interface b
get:billustrated in 
get:bcalls much like
get:bapplication pro
get:bcalls to open a
get:bestablished con
get:basynchronously 
get:bconsiderable fr
get:binterfaces whic
get:benvironment, a 
get:binterface for a
get:bThe interface b
get:bunspecified exc
get:btwo levels can 
get:bTypically, one 
get:binterface.  TCP
get:binterconnected 
get:bthroughout this
get:bAs noted above,
get:bsecurable logic
get:bprocesses.  To 
get:bcommunication s:ystem requires facilities in the following areas
get:bBasic Data Tr
get:bPrecedence an
get:bThe basic opera
get:bthe following p
get:bTransmission Cont
get:bBasic Data Tran:sfer
get:bThe TCP is ab
get:bdirection bet
get:bsegments for 
get:bthe TCPs deci
get:bSometimes use
get:bsubmitted to 
get:bfunction is d
get:bactually tran
get:bpushed throug
get:bpromptly forw
get:bThe exact pus
get:bthe push func
get:bReliability
get:bThe TCP must 
get:bdelivered out
get:bis achieved b
get:btransmitted, 
get:breceiving TCP
get:binterval, the
get:bnumbers are u
get:bout of order 
get:badding a chec
get:breceiver, and
get:bAs long as th
get:bsystem does n
get:berrors will a
get:binternet comm
get:bFlow Control
get:bTCP provides 
get:bsent by the s
get:bevery ACK ind
get:bthe last segm
get:ballowed numbe
get:breceiving fur
get:b[Page 4]         
get:bSeptember 1981   
get:bMultiplexing
get:bTo allow for 
get:bcommunication
get:baddresses or 
get:band host addr
get:ba socket.  A 
get:bThat is, a so
get:bThe binding o
get:bHost.  Howeve
get:b(e.g., a "log
get:bmade known to
get:bthrough the k
get:baddresses of 
get:bConnections
get:bThe reliabili
get:bthat TCPs ini
get:beach data str
get:bsockets, sequ
get:bEach connecti
get:bidentifying i
get:bWhen two proc
get:bestablish a c
get:bside).  When 
get:bterminated or
get:bSince connect
get:bover the unre
get:bmechanism wit
get:berroneous ini
get:bPrecedence and :Security
get:bThe users of 
get:bcommunication
get:bthese feature
get:bTransmission Cont
get:b[Page 6]         
get:bSeptember 1981   
get:b2.1.  Elements of
get:bThe internetwor
get:bwhich are in tu
get:bthat the networ
get:blarge networks 
get:bpacket switchin
get:bconsume message
get:bnetworks, the g
get:bcommunication s
get:bconnections bet
get:bThe term packet
get:btransaction bet
get:bexchanged withi
get:bHosts are compu
get:bnetwork's point
get:bProcesses are v
get:baccordance with
get:bin execution). 
get:bviewed as commu
get:bThus, all commu
get:bSince a process
get:bstreams between
get:bthat each proce
get:bcommunicates wi
get:b2.2.  Model of Op
get:bProcesses trans
get:bdata as argumen
get:bsegments and ca
get:bthe destination
get:binto the receiv
get:bTCPs include co
get:bensure reliable
get:bThe model of in
get:bprotocol module
get:bto the local ne
get:binside internet
get:binternet module
get:bthrough the loc
get:bThe packet swit
get:bTransmission Cont
get:bother operation
get:bdestination int
get:bAt a gateway be
get:bfrom its local 
get:bthe internet da
get:bthen "wrapped" 
get:brouted to the n
get:bA gateway is pe
get:binternet datagr
get:bthrough the nex
get:binternet datagr
get:bfurther broken 
get:binternet datagr
get:binternet module
get:bA destination i
get:b(after reassemb
get:bdestination TCP
get:bThis simple mod
get:bimportant featu
get:bto the gateway 
get:bservice paramet
get:bIncluded in the
get:bdatagram.  Data
get:bhost and gatewa
get:bproperly segreg
get:b2.3.  The Host En
get:bThe TCP is assu
get:baccess the TCP 
get:bmay call on oth
get:bdata structures
get:bcontrolled by a
get:bnetwork device 
get:bdatagram protoc
get:bThe mechanisms 
get:bfront-end proce
get:bhost-to-front-e
get:bthe type of TCP
get:b[Page 8]         
get:bSeptember 1981   
get:bThe TCP/user in
get:bto OPEN or CLOS
get:bSTATUS about a 
get:bprograms on the
get:bfrom, and close
get:bThe TCP/interne
get:bdatagrams addre
get:bsystem.  These 
get:bservice, preced
get:b2.5.  Relation to
get:bThe following d
get:bhierarchy
get:b+------+ +
get:b|Telnet| |
get:b+------+ +
get:b|   
get:b+----
get:b| TCP
get:b+----
get:b| 
get:b+----
get:b|    
get:b+----
get:b+--
get:b|  
get:b+--
get:bIt is expected 
get:bprotocols effic
get:bprotocols like 
get:b2.6.  Reliable Co
get:bA stream of dat
get:border at the de
get:bTransmission Cont
get:bTransmission is
get:backnowledgments
get:bsequence number
get:bsegment is tran
get:bsequence number
get:bis the sequence
get:btransmissions i
get:bsegment contain
get:bstarts a timer;
get:bsegment is dele
get:breceived before
get:bAn acknowledgme
get:bdelivered to th
get:bthe responsibil
get:bTo govern the f
get:bemployed.  The 
get:bThis window spe
get:backnowledgment 
get:b2.7.  Connection 
get:bTo identify the
get:bprovides a port
get:bindependently b
get:bunique addresse
get:bidentifying the
get:bwill be unique 
get:bA connection is
get:blocal socket ma
get:bsockets.  A con
get:bthat is, it is 
get:bTCPs are free t
get:bHowever, severa
get:bThere must be w
get:bthe "appropriat
get:bmay "own" ports
get:bthe ports they 
get:bissue, but we e
get:buniquely alloca
get:bassociating the
get:bA connection is
get:bforeign socket 
get:b[Page 10]        
get:bSeptember 1981   
get:bconnection name
get:bsubsequent call
get:babout a connect
get:bis a data struc
get:bimplementation 
get:bpointer to the 
get:bwhether the con
get:bbe passively wa
get:bA passive OPEN 
get:bconnection requ
get:bOften the proce
get:brequest from an
get:bis used to deno
get:bare allowed onl
get:bA service proce
get:bprocesses would
get:bforeign socket.
get:brequested a con
get:blocal socket we
get:bWell-known sock
get:ba socket addres
get:b"Telnet-Server"
get:bsocket, and oth
get:bEntry, Text Gen
get:bbeing for test 
get:baccess to a "Lo
get:bat which a newl
get:bwell-known sock
get:bof sockets to s
get:bProcesses can i
get:bfrom other proc
get:bbeen establishe
get:bother at the sa
get:bis critical for
get:bcomponents act 
get:bThere are two p
get:bpassive OPENs a
get:blocal passive O
get:bcase, the match
get:bOPENs has left 
get:bforeign socket 
get:bOther possibili
get:bTransmission Cont
get:bIf there are se
get:bsame local sock
get:bwith the specif
get:bTCB exists, bef
get:bThe procedures 
get:bcontrol flag an
get:bexchange has be
get:bA connection is
get:bcontaining a SY
get:bcommand.  The m
get:bconnection has 
get:bwhen sequence n
get:bThe clearing of
get:bin this case ca
get:b2.8.  Data Commun
get:bThe data that f
get:boctets.  The se
get:bin that call (a
get:bthrough to the 
get:bA sending TCP i
get:bsend that data 
get:bfunction is sig
get:breceiving TCP s
get:bthe sending TCP
get:bThere is no nec
get:bboundaries.  Th
get:bsingle SEND cal
get:bThe purpose of 
get:bfrom the sendin
get:brecord service.
get:bThere is a coup
get:bof data that cr
get:bassociated with
get:bbuffer is retur
get:bnot filled.  If
get:bPUSH is seen, t
get:bTCP also provid
get:bat some point f
get:b[Page 12]        
get:bSeptember 1981   
get:bcurrently readi
get:bdefine what the
get:burgent data, bu
get:btake action to 
get:b2.9.  Precedence 
get:bThe TCP makes u
get:bsecurity option
get:bbasis to TCP us
get:ba multilevel se
get:buse only, and o
get:bcompartment.  C
get:busers may be li
get:bTCP modules whi
get:bproperly mark o
get:bprecedence.  Su
get:bhigher level pr
get:bthem to specify
get:bprecedence of c
get:b2.10.  Robustness
get:bTCP implementat:ions will follow a general principle of robustness
get:bconservative in
get:bTransmission Cont
get:b[Page 14]        
get:bSeptember 1981   
get:b3.1.  Header Form
get:bTCP segments ar
get:bheader carries 
get:bdestination hos
get:bheader, supplyi
get:bdivision allows
get:bTCP Header Form
get:b0            
get:b0 1 2 3 4 5 6
get:b+-+-+-+-+-+-+-
get:b|          Sou
get:b+-+-+-+-+-+-+-
get:b|             
get:b+-+-+-+-+-+-+-
get:b|             
get:b+-+-+-+-+-+-+-
get:b|  Data |     
get:b| Offset| Rese
get:b|       |     
get:b+-+-+-+-+-+-+-
get:b|           Ch
get:b+-+-+-+-+-+-+-
get:b|             
get:b+-+-+-+-+-+-+-
get:b|             
get:b+-+-+-+-+-+-+-
get:bNote th
get:bSource Port:  1
get:bThe source po
get:bDestination Por:t
get:bThe destinati
get:bTransmission Cont
get:bFunctional Specif
get:bSequence Number:
get:bThe sequence 
get:bwhen SYN is p
get:binitial seque
get:bAcknowledgment :Number
get:bIf the ACK co
get:bnext sequence
get:breceive.  Onc
get:bData Offset:  4
get:bThe number of
get:bthe data begi
get:bintegral numb
get:bReserved:  6 bi
get:bReserved for 
get:bControl Bits:  :6 bits (from left to right)
get:bURG:  Urgent 
get:bACK:  Acknowl
get:bPSH:  Push Fu
get:bRST:  Reset t
get:bSYN:  Synchro
get:bFIN:  No more
get:bWindow:  16 bit
get:bThe number of
get:backnowledgmen
get:bChecksum:  16 b
get:bThe checksum 
get:bcomplement su
get:bsegment conta
get:bchecksummed, 
get:bform a 16 bit
get:btransmitted a
get:bthe checksum 
get:bThe checksum 
get:b[Page 16]        
get:bSeptember 1981   
get:bprefixed to t
get:bAddress, the 
get:bThis gives th
get:binformation i
get:bacross the TC
get:bcalls by the 
get:bThe TCP Len
get:boctets (thi
get:bcomputed), 
get:bUrgent Pointer:
get:bThis field co
get:bpositive offs
get:burgent pointe
get:bthe urgent da
get:bthe URG contr
get:bOptions:  varia
get:bOptions may o
get:bmultiple of 8
get:bchecksum.  An
get:bcases for the: format of an option
get:bCase 1:  A 
get:bCase 2:  An
get:bth
get:bThe option-le
get:boption-length
get:bNote that the
get:bfield might i
get:bEnd-of-Option
get:bA TCP must im
get:bTransmission Cont
get:bFunctional Specif
get:bCurrently def:ined options include (kind indicated in octal)
get:bKind     Le
get:b----     --
get:b0         
get:b1         
get:b2         
get:bSpecific Opti
get:bEnd of Opti
get:b+--------
get:b|00000000
get:b+--------
get:bThis opti
get:bmight not
get:bthe Data 
get:bnot the e
get:bthe optio
get:bNo-Operatio
get:b+--------
get:b|00000001
get:b+--------
get:bThis opti
get:balign the
get:bThere is 
get:breceivers
get:bnot begin
get:bMaximum Seg
get:b+--------
get:b|00000010
get:b+--------
get:bKind=2  
get:b[Page 18]        
get:bSeptember 1981   
get:bMaximum S:egment Size Option Data
get:bIf this
get:breceive
get:bThis fi
get:b(i.e., 
get:boption 
get:bPadding:  varia
get:bThe TCP heade
get:band data begi
get:b3.2.  Terminology
get:bBefore we can d
get:bto introduce so
get:bconnection requ
get:bof these variab
get:bTransmission Co
get:bTCB are the loc
get:bprecedence of t
get:bbuffers, pointe
get:bIn addition sev
get:bsequence number
get:bSend Sequence
get:bSND.UNA - s
get:bSND.NXT - s
get:bSND.WND - s
get:bSND.UP  - s
get:bSND.WL1 - s
get:bSND.WL2 - s
get:bu
get:bISS     - i
get:bReceive Seque
get:bRCV.NXT - r
get:bRCV.WND - r
get:bRCV.UP  - r
get:bIRS     - i
get:bTransmission Cont
get:bFunctional Specif
get:bThe following d
get:bthe sequence sp
get:bSend Sequence S
get:b---
get:b1 - old s
get:b2 - seque
get:b3 - seque
get:b4 - futur
get:bThe send window
get:bReceive Sequenc
get:b1 - old s
get:b2 - seque
get:b3 - futur
get:bThe receive win
get:bThere are also 
get:btake their valu
get:b[Page 20]        
get:bSeptember 1981   
get:bCurrent Segme
get:bSEG.SEQ - s
get:bSEG.ACK - s
get:bSEG.LEN - s
get:bSEG.WND - s
get:bSEG.UP  - s
get:bSEG.PRC - s
get:bA connection pr
get:blifetime.  The :states are
get:bESTABLISHED, FI
get:bTIME-WAIT, and 
get:bbecause it repr
get:bno connection. : Briefly the meanings of the states are
get:bLISTEN - repr
get:bTCP and port.
get:bSYN-SENT - re
get:bafter having 
get:bSYN-RECEIVED 
get:brequest ackno
get:bconnection re
get:bESTABLISHED -
get:bdelivered to 
get:bof the connec
get:bFIN-WAIT-1 - 
get:bfrom the remo
get:btermination r
get:bFIN-WAIT-2 - 
get:bfrom the remo
get:bCLOSE-WAIT - 
get:bfrom the loca
get:bCLOSING - rep
get:backnowledgmen
get:bLAST-ACK - re
get:bconnection te
get:b(which includ
get:bTransmission Cont
get:bFunctional Specif
get:bTIME-WAIT - r
get:bthe remote TC
get:btermination r
get:bCLOSED - repr
get:bA TCP connectio
get:bevents.  The ev
get:bABORT, and STAT
get:bcontaining the 
get:bThe state diagr
get:bwith the causin
get:berror condition
get:bchanges.  In a 
get:bthe reaction of
get:bNOTE BENE:  thi
get:bthe total speci
get:b[Page 22]        
get:bSeptember 1981   
get:b+---------+     
get:b|         |<----
get:b|   SYN   |     
get:b|   RCVD  |<----
get:b|         |     
get:b|         |-----
get:b+---------+   rc
get:b|           --
get:b|             
get:b|             
get:b|  CLOSE      
get:b| -------     
get:b| snd FIN     
get:b|             
get:bV             
get:b+---------+     
get:b|  FIN    |<----
get:b| WAIT-1  |-----
get:b+---------+     
get:b| rcv ACK of F
get:b| ------------
get:bV        x    
get:b+---------+     
get:b|FINWAIT-2|     
get:b+---------+     
get:b|             
get:b|  rcv FIN    
get:b|  -------    
get:b\ snd ACK    
get:b------------
get:bTransmission Cont
get:bFunctional Specif
get:b3.3.  Sequence Nu
get:bA fundamental n
get:bover a TCP conn
get:bsequenced, each
get:bmechanism emplo
get:bnumber X indica
get:breceived.  This
get:bdetection in th
get:bwithin a segmen
get:bthe header is t
get:bnumbered consec
get:bIt is essential
get:bfinite, though 
get:bSince the space
get:bnumbers must be
get:bpreserves the r
get:b2**32 - 1 to 0 
get:barithmetic, so 
get:bcomparison of s
get:b(modulo 2**32).
get:bThe typical kin
get:bperform include:
get:b(a)  Determin
get:bnumber s
get:b(b)  Determin
get:bhave bee
get:bretransm
get:b(c)  Determin
get:bwhich ar
get:breceive 
get:b[Page 24]        
get:bSeptember 1981   
get:bIn response to 
get:bfollowing compa
get:bSND.UNA = old
get:bSND.NXT = nex
get:bSEG.ACK = ack
get:bnum
get:bSEG.SEQ = fir
get:bSEG.LEN = the
get:b(co
get:bSEG.SEQ+SEG.L
get:bA new acknowled
get:bthe inequality :below holds
get:bSND.UNA < SEG
get:bA segment on th
get:bof its sequence
get:backnowledgment 
get:bWhen data is re:ceived the following comparisons are needed
get:bRCV.NXT = nex
get:bis the le
get:bRCV.NXT+RCV.W
get:bsegment, 
get:bSEG.SEQ = fir
get:bSEG.SEQ+SEG.L
get:bA segment is ju
get:bRCV.NXT =< SE
get:bRCV.NXT =< SE
get:bTransmission Cont
get:bFunctional Specif
get:bThe first part 
get:bsegment falls i
get:bif the end of t
get:beither part of 
get:bActually, it is
get:bwindows and zer
get:bacceptability o:f an incoming segment
get:bSegment Recei
get:bLength  Windo
get:b------- -----
get:b0       0 
get:b0      >0 
get:b>0       0 
get:b>0      >0 
get:bNote that when 
get:bacceptable exce
get:bmaintain a zero
get:bACKs.  However,
get:bprocess the RST
get:bWe have taken a
get:bcontrol informa
get:bsome control fl
get:band acknowledge
get:bcontrol will be
get:bcarried in the 
get:bfor implicitly 
get:bare the only co
get:bare used only a
get:bpurposes, the S
get:boctet of the se
get:bto occur after 
get:boccurs.  The se
get:bspace occupying
get:bsequence number
get:b[Page 26]        
get:bSeptember 1981   
get:bInitial Sequenc
get:bThe protocol pl
get:bused over and o
get:bsockets.  New i
get:bincarnations of
get:b-- "how does th
get:bincarnations of
get:bconnection is b
get:bconnection brea
get:bTo avoid confus
get:bconnection from
get:bbe present in t
get:bassure this, ev
get:bsequence number
get:ban initial sequ
get:bnew 32 bit ISN.
get:bbit clock whose
get:bmicroseconds.  
get:bSince we assume
get:bthe Maximum Seg
get:bhours we can re
get:bFor each connec
get:bsequence number
get:bthe data sendin
get:blearned during 
get:bFor a connectio
get:bsynchronize on 
get:ban exchange of 
get:bcalled "SYN" (f
get:bshorthand, segm
get:bHence, the solu
get:binitial sequenc
get:bThe synchroniza
get:bsequence number
get:bfrom the other 
get:binitial sequenc
get:b1) A --> B  S
get:b2) A <-- B  A
get:b3) A <-- B  S
get:b4) A --> B  A
get:bTransmission Cont
get:bFunctional Specif
get:bBecause steps 2
get:bcalled the thre
get:bA three way han
get:btied to a globa
get:bmechanisms for 
get:bno way of knowi
get:bunless it remem
get:b(which is not a
get:bverify this SYN
get:bclock-driven sc
get:bKnowing When to
get:bTo be sure that
get:bsequence number
get:bthe network, th
get:b(MSL) before as
get:brecovering from
get:blost.  For this
get:bis an engineeri
get:bit is desirable
get:bsense, yet reta
get:bnot wait at all
get:bthan those rece
get:bThe TCP Quiet T
get:bThis specific
get:bretaining any
get:beach active (
get:bTCP segments 
get:bin the intern
get:bparagraphs be
get:bTCP implement
get:bat the risk o
get:bdata rejected
get:bTCPs consume 
get:bentered into 
get:bduplicate det
get:brelies on the
get:bthe extent th
get:bvalues before
get:bbeen delivere
get:bcopies of the
get:bsuch an assum
get:b[Page 28]        
get:bSeptember 1981   
get:bassigned the 
get:bat the receiv
get:bthat each seg
get:bas there are 
get:bUnder normal 
get:bto emit and t
get:bmistakenly us
get:bbeen acknowle
get:bdata is drain
get:bvery large to
get:bcause trouble
get:bto use up 2**
get:blifetime in t
get:bthis is deeme
get:brates escalat
get:bcycle time is
get:bwithin reason
get:bThe basic dup
get:bdefeated, how
get:bsequence numb
get:bthe TCP were 
get:bupon crashing
get:bconnection (p
get:bpackets with 
get:bpackets still
get:bincarnation o
get:babout the seq
get:bspecification
get:bbefore emitti
get:bsegments from
get:bEven hosts wh
get:binitial seque
get:b(i.e., even i
get:bnumber for ea
get:bSuppose, for 
get:bsequence numb
get:band that even
get:btakes on a va
get:bsegment sent 
get:bat this insta
get:bincarnation o
get:bS1 = ISN(t) -
get:bconnection!  
get:bTransmission Cont
get:bFunctional Specif
get:bduplicates in
get:bof S1 may arr
get:bthe new incar
get:bThe problem i
get:bcrashed nor d
get:bthe system fr
get:bOne way to de
get:bsegments for 
get:btime" specifi
get:bwilling to ri
get:bdestination m
get:bImplementors 
get:bconnection by
get:binformally im
get:bObviously, ev
get:bnecessary aft
get:bTo summarize:
get:bnumbers in th
get:b"busy" or "in
get:bblock of spac
get:bsegment, if a
get:bsequence numb
get:bthe previous 
get:bnumber overla
get:b3.4.  Establishin
get:bThe "three-way 
get:bconnection.  Th
get:bresponded to by
get:bsimultaneously 
get:boccurs, each TC
get:backnowledgment 
get:ban old duplicat
get:brecipient, that
get:bProper use of "
get:bSeveral example
get:bexamples do not
get:bsegments, this 
get:bdoesn't deliver
get:bvalid (i.e., th
get:bconnection reac
get:breduces the pos
get:b[Page 30]        
get:bSeptember 1981   
get:bimplementation 
get:binformation for
get:bThe simplest th
get:bfigures should 
get:bnumbered for re
get:bdeparture of a 
get:bsegment at B fr
get:bEllipsis (...) 
get:b(delayed).  An 
get:bComments appear
get:bthe departure o
get:bthe center of e
get:bform, with sequ
get:bfields such as 
get:bin the interest
get:bTCP A      
get:b1.  CLOSED     
get:b2.  SYN-SENT   
get:b3.  ESTABLISHED
get:b4.  ESTABLISHED
get:b5.  ESTABLISHED
get:bBasic 3
get:bIn line 2 of fi
get:bindicating that
get:bnumber 100.  In
get:breceived from T
get:bB is now expect
get:boccupied sequen
get:bAt line 4, TCP 
get:bTCP B's SYN; an
get:bsequence number
get:bbecause the ACK
get:bwould wind up A
get:bTransmission Cont
get:bFunctional Specif
get:bSimultaneous in
get:bfigure 8.  Each
get:bTCP A      
get:b1.  CLOSED     
get:b2.  SYN-SENT   
get:b3.  SYN-RECEIVE
get:b4.             
get:b5.  SYN-RECEIVE
get:b6.  ESTABLISHED
get:b7.             
get:bS
get:bThe principle r
get:bduplicate conne
get:bthis, a special
get:breceiving TCP i
get:bSYN-RECEIVED), 
get:bIf the TCP is i
get:bFIN-WAIT-1, FIN
get:baborts the conn
get:bcase under "hal
get:b[Page 32]        
get:bSeptember 1981   
get:bTCP A      
get:b1.  CLOSED     
get:b2.  SYN-SENT   
get:b3.  (duplicate)
get:b4.  SYN-SENT   
get:b5.  SYN-SENT   
get:b6.             
get:b7.  SYN-SENT   
get:b8.  ESTABLISHED
get:bAs a simple exa
get:bfigure 9.  At l
get:bcannot tell tha
get:b(line 4).  TCP 
get:bRST (reset) wit
get:bbelievable.  TC
get:bWhen the origin
get:bsynchronization
get:bbefore the RST,
get:bsent in both di
get:bHalf-Open Conne
get:bAn established 
get:bTCPs has closed
get:bknowledge of th
get:bbecome desynchr
get:bmemory.  Such c
get:battempt is made
get:bconnections are
get:bmildly involved
get:bIf at site A th
get:bTransmission Cont
get:bFunctional Specif
get:buser at site B 
get:breceiving a res
get:bsite B TCP that
get:bAssume that two
get:banother when a 
get:bDepending on th
get:bthat some error
get:bA is likely to 
get:bpoint.  As a re
get:bor try to SEND 
get:bcase, it receiv
get:blocal (A's) TCP
get:bwill send a seg
get:bexample shown i
get:bre-open the con
get:bTCP A      
get:b1.  (CRASH)    
get:b2.  CLOSED     
get:b3.  SYN-SENT --
get:b4.  (!!)     <-
get:b5.  SYN-SENT --
get:b6.  SYN-SENT   
get:b7.  SYN-SENT --
get:bWhen the SYN ar
get:band the incomin
get:backnowledgment 
get:b100).  TCP A se
get:bsent and, being
get:bdetected a half
get:b[Page 34]        
get:bSeptember 1981   
get:bcontinue to try
get:breduced to the 
get:bAn interesting 
get:btries to send d
get:bThis is illustr
get:bTCP A from TCP 
get:bexists, so TCP 
get:bprocesses it an
get:bTCP A    
get:b1.  (CRASH)    
get:b2.  (??)    <--
get:b3.          -->
get:bActive
get:bIn figure 12, w
get:bwaiting for SYN
get:binto action.  A
get:bgenerate a RST 
get:bthe reset and r
get:bTCP A      
get:b1.  LISTEN     
get:b2.       ... <S
get:b3.  (??) <-- <S
get:b4.       --> <S
get:b5.  LISTEN     
get:bOld Duplic
get:bTransmission Cont
get:bFunctional Specif
get:bA variety of ot
get:bby the followin
get:bReset Generatio
get:bAs a general ru
get:bwhich apparentl
get:bmust not be sen
get:bThere are three: groups of states
get:b1.  If the co
get:bin response t
get:bparticular, S
get:bby this means
get:bIf the incomi
get:bsequence numb
get:breset has seq
get:bof the sequen
get:bThe connectio
get:b2.  If the co
get:bSYN-SENT, SYN
get:bsomething not
get:bif an incomin
get:bdoes not exac
get:bconnection, a
get:bIf our SYN ha
get:bincoming segm
get:beither raise 
get:bthe system) o
get:bincoming segm
get:bcontinue as i
get:bcannot raise 
get:bdetected in t
get:bterminated th
get:bincoming segm
get:bmatch the loc
get:bmust be sent.
get:bIf the incomi
get:bsequence numb
get:breset has seq
get:bof the sequen
get:bThe connectio
get:b[Page 36]        
get:bSeptember 1981   
get:b3.  If the co
get:bFIN-WAIT-1, F
get:bany unaccepta
get:bunacceptible 
get:backnowledgmen
get:band an acknow
get:bto be receive
get:bIf an incomin
get:bprecedence wh
get:band precedenc
get:bconnection go
get:bnumber from t
get:bReset Processin
get:bIn all states e
get:bby checking the
get:bis in the windo
get:bto an initial S
get:backnowledges th
get:bThe receiver of
get:breceiver was in
get:bin SYN-RECEIVED
get:bthen the receiv
get:baborts the conn
get:bwas in any othe
get:band goes to the
get:b3.5.  Closing a C
get:bCLOSE is an ope
get:bnotion of closi
get:binterpretation,
get:bthe receiving s
get:bin a simplex fa
get:buntil he is tol
get:bcould initiate 
get:bRECEIVE until s
get:bhas CLOSED.  We
get:bRECEIVEs are ou
get:bcan terminate h
get:bbuffers SENT be
get:bdata in return 
get:bsuccessfully to
get:bTCP.  Users mus
get:bthe TCP says no
get:bTransmission Cont
get:bFunctional Specif
get:bThere are essen:tially three cases
get:b1) The user i
get:b2) The remote
get:b3) Both users
get:bCase 1:  Local 
get:bIn this case,
get:boutgoing segm
get:baccepted by t
get:bare allowed i
get:bwill be retra
get:bboth acknowle
get:bcan ACK this 
get:bsend its own 
get:bCase 2:  TCP re
get:bIf an unsolic
get:bcan ACK it an
get:buser will res
get:bthe other TCP
get:buntil its own
get:bconnection.  
get:bthe connectio
get:bCase 3:  both u
get:bA simultaneou
get:bFIN segments 
get:bhave been pro
get:bhas received.
get:b[Page 38]        
get:bSeptember 1981   
get:bTCP A      
get:b1.  ESTABLISHED
get:bFIN-WAIT-1 
get:b3.  FIN-WAIT-2 
get:b4.             
get:bTIME-WAIT  
get:b5.  TIME-WAIT  
get:bCLOSED     
get:bTCP A      
get:b1.  ESTABLISHED
get:b2.  (Close)    
get:bFIN-WAIT-1 
get:b3.  CLOSING    
get:b4.  TIME-WAIT  
get:b(2 MSL)    
get:bCLOSED     
get:bTransmission Cont
get:bFunctional Specif
get:b3.6.  Precedence 
get:bThe intent is t
get:bwith exactly th
get:bhigher of the p
get:bThe precedence 
get:bdefined in the 
get:bspecification t
get:bthe security pa
get:buser group, and
get:bA connection at
get:blower precedenc
get:ba connection du
get:backnowledgment 
get:bNote that TCP m
get:bprecedence will
get:bsegments and po
get:bThe security pa
get:b(the values wou
get:bnon-secure envi
get:bparameters, tho
get:b3.7.  Data Commun
get:bOnce the connec
get:bexchange of seg
get:b(checksum test 
get:bretransmission 
get:bDuplicate segme
get:bAs discussed in
get:bcertain tests o
get:bsegments to ver
get:bThe sender of d
get:bthe variable SN
get:bsequence number
get:bkeeps track of 
get:bvariable SND.UN
get:bsent has been a
get:bWhen the sender
get:bSND.NXT.  When 
get:bsends an acknow
get:b[Page 40]        
get:bSeptember 1981   
get:backnowledgment 
get:bthese variables
get:bThe amount by w
get:bdata in the seg
get:bsegments must c
get:bThe CLOSE user 
get:bflag in an inco
get:bRetransmission 
get:bBecause of the 
get:binternetwork sy
get:bretransmission 
get:bfor determining
get:bAn Example Re
get:bMeasure the
get:bparticular 
get:bcovers that
get:bsegments re
get:bTime (RTT).:  Next compute a Smoothed Round Trip Time (SRTT) as
get:bSRTT = ( 
get:band based o:n this, compute the retransmission timeout (RTO) as
get:bRTO = min
get:bwhere UBOUN
get:bLBOUND is a
get:ba smoothing
get:bfactor (e.g
get:bThe Communicati
get:bThe objective o
get:bto stimulate th
get:bpermit the rece
get:bthe currently k
get:bThis mechanism 
get:bthe end of urge
get:bthe receive seq
get:bmust tell the u
get:bnumber catches 
get:bTransmission Cont
get:bFunctional Specif
get:binto "normal mo
get:bis in "urgent m
get:bThe method empl
get:btransmitted.  T
get:bmeaningful and 
get:bthe urgent poin
get:bno urgent data 
get:bTo send an urge
get:boctet.  If the 
get:bthe urgent info
get:bManaging the Wi
get:bThe window sent
get:bnumbers the sen
get:bprepared to acc
get:bthe currently a
get:bIndicating a la
get:barrives than ca
get:bin excessive re
get:bnetwork and the
get:btransmission of
get:bbetween each ne
get:bThe mechanisms 
get:bsubsequently ad
get:bthat much data.
get:bdiscouraged.  T
get:bshrink the wind
get:bon the part of 
get:bThe sending TCP
get:bleast one octet
get:bsending TCP mus
get:bthe window is z
get:binterval when t
get:bguarantee that 
get:bwindow will be 
get:bWhen the receiv
get:bstill send an a
get:band current win
get:bThe sending TCP
get:b[Page 42]        
get:bSeptember 1981   
get:bwhich fit the c
get:bretransmission 
get:bIn a connection
get:bbe carried in a
get:bnumber so there
get:border.  This is
get:binformation to 
get:bthe data receiv
get:bthe window info
get:backnowledgment 
get:bequal or greate
get:bThe window mana
get:bcommunication p
get:bWindow Manage
get:bAllocating 
get:bmany small 
get:bfewer large
get:bOne suggest
get:bdefer updat
get:bleast X per
get:bconnection 
get:bAnother sug
get:bsegments by
get:bsending dat
get:bdata must b
get:bNote that t
get:bretransmiss
get:backnowledgm
get:bwindow info
get:bnew window 
get:bThe segment
get:bof transmit
get:bsegment con
get:bis accepted
get:bIf the send
get:bwindow is n
get:balternating
get:bpauses in t
get:bTransmission Cont
get:bFunctional Specif
get:bresult in b
get:bbig pair. A
get:bmostly smal
get:bThe suggest
get:bactively at
get:bwindows, si
get:bto many sma
get:bThere are of co:urse two interfaces of concern
get:band the TCP/low
get:bof the user/TCP
get:bprotocol module
get:bin detail by th
get:bcase that the l
get:bthat TCPs might
get:bUser/TCP Interf
get:bThe following
get:bat best, fict
get:bfacilities.  
get:bimplementatio
get:bTCPs must pro
get:bthat all TCP 
get:bhierarchy.  T
get:brequired of a
get:bTCP User Comm
get:bThe followi
get:binterface. 
get:bfunction ca
get:bmeant to ru
get:bThe user co
get:bTCP must pe
get:bIndividual 
get:bmay provide
get:bsingle call
get:bautomatical
get:bissued by t
get:b[Page 44]        
get:bSeptember 1981   
get:bIn providin
get:bnot only ac
get:bprocesses i:t serves.  The latter consists of
get:b(a) gener
get:bremote cl
get:b(b) repli
get:bvarious t
get:bFormat:  
get:b[, timeou
get:b-> local 
get:bWe assume
get:bprocesses
get:bto use th
get:bimplement
get:bfor the s
get:blower lev
get:bresult of
get:bable to m
get:bprocess c
get:bIf the ac
get:bcall to L
get:bhave eith
get:bparticula
get:bfor any c
get:bby the su
get:bA transmi
get:bfilled in
get:bOn an act
get:bsynchroni
get:bThe timeo
get:bfor all d
get:bdelivered
get:bwill abor
get:bThe TCP o
get:bthe users
get:bTransmission Cont
get:bFunctional Specif
get:bprecedenc
get:bor securi
get:bthe defau
get:bTCP will 
get:bsecurity/
get:bthe prece
get:brequested
get:bThe prece
get:brequested
get:brequest, 
get:bconnectio
get:bthis prec
get:ballowed t
get:bor that a
get:bA local c
get:bThe local
get:bfor the c
get:bFormat:  
get:bcount, PU
get:bThis call
get:bto be sen
get:bnot been 
get:bimplement
get:bautomatic
get:bauthorize
get:bIf the PU
get:bto the re
get:bsegment c
get:bthe data 
get:btransmiss
get:bIf the UR
get:bwill have
get:bthe urgen
get:bpointer i
get:bbeen cons
get:bis to sti
get:bindicate 
get:b[Page 46]        
get:bSeptember 1981   
get:bdata has 
get:bTCP signa
get:bof times 
get:burgent da
get:bIf no for
get:bconnectio
get:bhas becom
get:blocal soc
get:bforeign s
get:bforeign s
get:bknowing t
get:bHowever, 
get:bbecomes s
get:bSTATUS ca
get:bimplement
get:bsocket is
get:bIf a time
get:bconnectio
get:bIn the si
get:bthe sendi
get:bor the ti
get:bis both s
get:bconnectio
get:boffers po
get:bsophistic
get:bthe proce
get:bfurthermo
get:bMultiple 
get:bthe TCP w
get:bWe have i
get:bwhich a S
get:bpseudo-in
get:breturn a 
get:bimmediate
get:bbeen ackn
get:bassume ev
get:bclose any
get:bkind (syn
get:bsignals, 
get:bwith spec
get:bIn order 
get:bindicatio
get:bTransmission Cont
get:bFunctional Specif
get:bbuffer ad
get:bthe SEND 
get:bindicatin
get:bcalling p
get:bFormat:  
get:bcount) ->
get:bThis comm
get:bspecified
get:bcalling p
get:berror is 
get:bIn the si
get:bcalling p
get:berror occ
get:bA more so
get:bRECEIVEs 
get:bsegments 
get:bthe cost 
get:bnotify th
get:bIf enough
get:bthe PUSH 
get:bThe buffe
get:ba PUSH is
get:breturned 
get:bIf there 
get:bas it arr
get:bshould th
get:badditiona
get:bcall to R
get:bmay now l
get:burgent po
get:bin the sa
get:bboundary 
get:bTo distin
get:bcare of t
get:breturn co
get:bcount ind
get:bAlternati
get:b[Page 48]        
get:bSeptember 1981   
get:ballocate 
get:bwith the 
get:bFormat:  
get:bThis comm
get:bthe conne
get:bauthorize
get:bClosing c
get:bthe sense
get:bretransmi
get:bserviced.
get:bcalls, fo
get:bto the de
get:bcontinue 
get:bmay be tr
get:bmeans "I 
get:breceive a
get:bnot well 
get:bof all it
get:binto ABOR
get:bThe user 
get:binitiativ
get:b(e.g., re
get:bdestinati
get:bBecause c
get:bforeign T
get:bshort tim
get:breplies t
get:bClose als
get:bFormat:  
get:bThis is a
get:bexcluded 
get:btypically
get:bThis comm
get:binformati:on
get:blocal s
get:bTransmission Cont
get:bFunctional Specif
get:bforeign
get:blocal c
get:breceive
get:bsend wi
get:bconnect
get:bnumber 
get:bnumber 
get:burgent 
get:bprecede
get:bsecurit
get:band tra
get:bDepending
get:bimplement
get:bavailable
get:bauthorize
get:bprevents 
get:bconnectio
get:bFormat:  
get:bThis comm
get:baborted, 
get:bbe sent t
get:bDepending
get:bindicatio
get:breceive a
get:bTCP-to-User M
get:bIt is assum
get:bmeans for t
get:bthe TCP doe
get:bto the user
get:ban error me
get:brelating to
get:bother user 
get:bThe followi:ng information is provided
get:bLocal Con
get:bResponse 
get:bBuffer Ad
get:bByte coun
get:bPush flag
get:bUrgent fl
get:b[Page 50]        
get:bSeptember 1981   
get:bTCP/Lower-Level
get:bThe TCP calls
get:breceive infor
get:binternetwork 
get:bProtocol (IP)
get:bIf the lower 
get:bof service an
get:bfor these par:ameters
get:bType of Ser:vice = Precedence: routine, Delay: normal, Throughput
get:bnormal, Rel:iability
get:bTime to Liv
get:bNote that
get:bHere we e
get:bbe delive
get:bIf the lower 
get:bfeature) and 
get:broute informa
get:bso that the s
get:bchecksum be t
get:balso importan
get:bAny lower lev
get:bdestination a
get:bthe "TCP leng
get:bof IP and to 
get:bTransmission Cont
get:bFunctional Specif
get:b3.9.  Event Proce
get:bThe processing 
get:bimplementation.
get:bprocessing sequ
get:bsection only in
get:bThe activity of
get:bThe events that: occur can be cast into three categories
get:barriving segmen
get:bprocessing the 
get:bcases the proce
get:bEvents that o:ccur
get:bArriving Se
get:bSEGMENT A
get:bUSER TIME
get:bRETRANSMI
get:bTIME-WAIT
get:bThe model of th
get:bimmediate retur
get:bpseudo interrup
get:bmeans cause a d
get:bError responses
get:bcommands refere:ncing connections that do not exist receive "error
get:bconnection not 
get:bPlease note in 
get:backnowledgment 
get:bof the sequence
get:bequal to (modul
get:b[Page 52]        
get:bSeptember 1981   
get:bA natural way t
get:bimagine that th
get:bthat their cont
get:bin the sequence
get:band processed i
get:bWhen a segment 
get:bthe segment to 
get:bto be consisten
get:bNote that if no
get:bTransmission Cont
get:bFunctional Specif
get:bCLOSED STATE 
get:bCreate a ne
get:bstate infor
get:bsocket, pre
get:binformation
get:bunspecified
get:bparameters 
get:bprecedence 
get:b"error:  pr:ecedence not allowed" or "error
get:bnot allowed
get:bactive and :the foreign socket is unspecified, return "error
get:bforeign soc
get:bspecified, 
get:b(ISS) is se
get:bis sent.  S
get:bstate, and 
get:bIf the call
get:breturn "err:or
get:bno room to :create a new connection, return "error
get:bresources".
get:bIf active a
get:bconnection 
get:bsegment, se
get:bstate.  Dat
get:bqueued for 
get:burgent bit 
get:bsegments se
get:bqueue the r:equest, respond with "error
get:bIf Foreign :socket was not specified, then return "error
get:bsocket unsp
get:b[Page 54]        
get:bSeptember 1981   
get:bSYN-SENT STAT
get:bSYN-RECEIVED 
get:bESTABLISHED S
get:bFIN-WAIT-1 ST
get:bFIN-WAIT-2 ST
get:bCLOSE-WAIT ST
get:bCLOSING STATE
get:bLAST-ACK STAT
get:bTIME-WAIT STA
get:bReturn "err:or
get:bTransmission Cont
get:bFunctional Specif
get:bCLOSED STATE 
get:bIf the user
get:b"error:  co
get:bOtherwise, :return "error
get:bIf the fore
get:bfrom passiv
get:bSND.UNA to 
get:bassociated 
get:btransmissio
get:brequested i
get:bas a result
get:brequest, re:spond with "error
get:bForeign soc:ket was not specified, then return "error
get:bsocket unsp
get:bSYN-SENT STAT
get:bSYN-RECEIVED 
get:bQueue the d
get:bIf no space: to queue, respond with "error
get:bresources".
get:bESTABLISHED S
get:bCLOSE-WAIT ST
get:bSegmentize 
get:backnowledgm
get:binsufficien:t space to remember this buffer, simply return "error
get:binsufficien
get:bIf the urge
get:burgent poin
get:b[Page 56]        
get:bSeptember 1981   
get:bFIN-WAIT-1 ST
get:bFIN-WAIT-2 ST
get:bCLOSING STATE
get:bLAST-ACK STAT
get:bTIME-WAIT STA
get:bReturn "err:or
get:bTransmission Cont
get:bFunctional Specif
get:bCLOSED STATE 
get:bIf the user
get:b"error:  co
get:bOtherwise r:eturn "error
get:bSYN-SENT STAT
get:bSYN-RECEIVED 
get:bQueue for p
get:bis no room :to queue this request, respond with "error
get:binsufficien
get:bESTABLISHED S
get:bFIN-WAIT-1 ST
get:bFIN-WAIT-2 ST
get:bIf insuffic
get:brequest, qu
get:bremember th:e RECEIVE, respond with "error
get:bresources".
get:bReassemble 
get:bto user.  M
get:bIf RCV.UP i
get:buser notify
get:bWhen the TC
get:bthat fact m
get:backnowledgm
get:bdescribed b
get:b[Page 58]        
get:bSeptember 1981   
get:bCLOSE-WAIT ST
get:bSince the r
get:bsatisfied b
get:buser.  If n
get:b"error:  co
get:btext can be
get:bCLOSING STATE
get:bLAST-ACK STAT
get:bTIME-WAIT STA
get:bReturn "err:or
get:bTransmission Cont
get:bFunctional Specif
get:bCLOSED STATE 
get:bIf the user
get:b"error:  co
get:bOtherwise, :return "error
get:bAny outstan:ding RECEIVEs are returned with "error
get:bresponses. 
get:bSYN-SENT STAT
get:bDelete the :TCB and return "error
get:bqueued SEND
get:bSYN-RECEIVED 
get:bIf no SENDs
get:bthen form a
get:botherwise q
get:bESTABLISHED S
get:bQueue this 
get:bform a FIN 
get:bFIN-WAIT-1 ST
get:bFIN-WAIT-2 ST
get:bStrictly sp:eaking, this is an error and should receive a "error
get:bconnection 
get:bacceptable,
get:bFIN may be 
get:b[Page 60]        
get:bSeptember 1981   
get:bCLOSE-WAIT ST
get:bQueue this 
get:bsegmentized
get:bCLOSING STATE
get:bLAST-ACK STAT
get:bTIME-WAIT STA
get:bRespond wit:h "error
get:bTransmission Cont
get:bFunctional Specif
get:bCLOSED STATE 
get:bIf the user
get:b"error:  co
get:bOtherwise r:eturn "error
get:bAny outstan:ding RECEIVEs should be returned with "error
get:bconnection 
get:bSYN-SENT STAT
get:bAll queued 
get:bnotificatio
get:bSYN-RECEIVED 
get:bESTABLISHED S
get:bFIN-WAIT-1 ST
get:bFIN-WAIT-2 ST
get:bCLOSE-WAIT ST
get:bSend a rese:t segment
get:b<SEQ=SND.
get:bAll queued 
get:bnotificatio
get:bRST formed 
get:bTCB, enter 
get:bCLOSING STATE
get:bLAST-ACK STAT
get:bTIME-WAIT STA
get:bRespond wit
get:b[Page 62]        
get:bSeptember 1981   
get:bCLOSED STATE 
get:bIf the user
get:b"error:  co
get:bOtherwise r:eturn "error
get:bReturn "sta
get:bSYN-SENT STAT
get:bReturn "sta
get:bSYN-RECEIVED 
get:bReturn "sta
get:bESTABLISHED S
get:bReturn "sta
get:bFIN-WAIT-1 ST
get:bReturn "sta
get:bFIN-WAIT-2 ST
get:bReturn "sta
get:bCLOSE-WAIT ST
get:bReturn "sta
get:bCLOSING STATE
get:bReturn "sta
get:bLAST-ACK STAT
get:bReturn "sta
get:bTransmission Cont
get:bFunctional Specif
get:bTIME-WAIT STA
get:bReturn "sta
get:b[Page 64]        
get:bSeptember 1981   
get:bSEGMENT ARRIVES
get:bIf the state 
get:ball data in
get:bsegment con
get:bcontaining 
get:backnowledgm
get:breset seque
get:bIf the ACK 
get:b<SEQ=0><A
get:bIf the ACK 
get:b<SEQ=SEG.
get:bIf the state 
get:bfirst check
get:bAn incomi
get:bsecond chec
get:bAny ackno
get:bthe LISTE
get:bfor any a
get:bformatted: as follows
get:b<SEQ=SE
get:bthird check
get:bIf the SY
get:bsecurity/
get:bmatch the
get:b<SEQ=SE
get:bTransmission Cont
get:bFunctional Specif
get:bIf the SE
get:bthe user 
get:bsend a re
get:b<SEQ=SE
get:bIf the SE
get:bSet RCV.N
get:bcontrol o
get:bshould be: selected and a SYN segment sent of the form
get:b<SEQ=IS
get:bSND.NXT i
get:bstate sho
get:bincoming 
get:bin the SY
get:bnot be re
get:bthe forei
get:bunspecifi
get:bfourth othe
get:bAny other
get:bmust have
get:bprocessin
get:bit could 
get:bincarnati
get:bbut if yo
get:bIf the state 
get:bfirst check
get:bIf the AC
get:bIf SEG.
get:bthe RST
get:b<SEQ=
get:band dis
get:bIf SND.
get:bsecond chec
get:b[Page 66]        
get:bSeptember 1981   
get:bIf the RS
get:bIf the :ACK was acceptable then signal the user "error
get:bconnect
get:bdelete 
get:band ret
get:bthird check
get:bIf the se
get:bmatch the
get:bIf ther
get:b<SEQ=
get:bOtherwi
get:b<SEQ=
get:bIf there 
get:bThe pre
get:bTCB, if
get:b<SEQ=
get:bIf there 
get:bIf the 
get:bin the 
get:bthe pre
get:ballowed
get:b<SEQ=
get:bIf the 
get:bin the 
get:bIf a rese
get:bfourth chec
get:bThis step
get:bno ACK, a
get:bIf the SY
get:bTransmission Cont
get:bFunctional Specif
get:bare accep
get:bSEG.SEQ. 
get:bis an ACK
get:bare there
get:bIf SND.UN
get:bstate to 
get:b<SEQ=SN
get:band send 
get:btransmiss
get:btext in t
get:bbelow whe
get:bOtherwise
get:b<SEQ=IS
get:band send 
get:bsegment, 
get:bhas been 
get:bfifth, if n
get:bsegment and
get:b[Page 68]        
get:bSeptember 1981   
get:bfirst check s
get:bSYN-RECEIVE
get:bESTABLISHED
get:bFIN-WAIT-1 
get:bFIN-WAIT-2 
get:bCLOSE-WAIT 
get:bCLOSING STA
get:bLAST-ACK ST
get:bTIME-WAIT S
get:bSegments 
get:bare used 
get:bdone in S
get:bboundary 
get:bprocessed
get:bThere are
get:bsegment
get:bSegment R
get:bLength  W
get:b------- -
get:b0     
get:b0     
get:b>0     
get:b>0     
get:bIf the RC
get:bspecial a
get:bIf an inc
get:bshould be
get:bthe segme:nt and return)
get:b<SEQ=SN
get:bAfter sen
get:band retur
get:bTransmission Cont
get:bFunctional Specif
get:bIn the fo
get:bsegment t
get:bOne could
get:btrimming 
get:bSYN and F
get:bbegins at
get:bnumbers m
get:bsecond check 
get:bSYN-RECEIVE
get:bIf the RS
get:bIf this
get:bcame fr
get:bLISTEN 
get:bthis co
get:bfrom SY
get:bthe use
get:bon the 
get:bactive 
get:band ret
get:bESTABLISHED
get:bIf the RS
get:bshould re
get:bflushed. 
get:b"connecti
get:bTCB, and 
get:bCLOSING STA
get:bLAST-ACK ST
get:bIf the RS
get:bTCB, and 
get:b[Page 70]        
get:bSeptember 1981   
get:bthird check s
get:bSYN-RECEIVE
get:bIf the se
get:bexactly m
get:bthen send
get:bESTABLISHED
get:bIf the se
get:bexactly m
get:bthen send
get:breceive "
get:bflushed. 
get:b"connecti
get:bTCB, and 
get:bNote this c
get:ba segment f
get:bdifferent s
get:bcurrent con
get:bfourth, check
get:bSYN-RECEIVE
get:bESTABLISHED
get:bFIN-WAIT ST
get:bFIN-WAIT ST
get:bCLOSE-WAIT 
get:bCLOSING STA
get:bLAST-ACK ST
get:bTIME-WAIT S
get:bIf the SY
get:boutstandi
get:ball segme
get:breceive a
get:bthe CLOSE
get:bIf the SY
get:band an ac
get:bnumber ch
get:bTransmission Cont
get:bFunctional Specif
get:bfifth check t
get:bif the ACK 
get:bif the ACK 
get:bSYN-RECEI
get:bIf SND.
get:band con
get:bIf th
get:breset
get:b<SE
get:band s
get:bESTABLISH
get:bIf SND.
get:bAny seg
get:bentirel
get:bpositiv
get:bfully a
get:b"ok" re
get:b(SEG.AC
get:bsomethi
get:bdrop th
get:bIf SND.
get:bupdated
get:bSND.WL2
get:bSND.WL1
get:bNote th
get:brecords
get:bSND.WND
get:bthe las
get:bprevent
get:b[Page 72]        
get:bSeptember 1981   
get:bFIN-WAIT-
get:bIn addi
get:bour FIN
get:bprocess
get:bFIN-WAIT-
get:bIn addi
get:bthe ret
get:backnowl
get:bCLOSE-WAI
get:bDo the 
get:bCLOSING S
get:bIn addi
get:bthe ACK
get:botherwi
get:bLAST-ACK 
get:bThe onl
get:backnowl
get:bdelete 
get:bTIME-WAIT
get:bThe onl
get:bretrans
get:bthe 2 M
get:bsixth, check 
get:bESTABLISHED
get:bFIN-WAIT-1 
get:bFIN-WAIT-2 
get:bIf the UR
get:bthe user 
get:bpointer (
get:buser has 
get:bmode") fo
get:bsignal th
get:bTransmission Cont
get:bFunctional Specif
get:bCLOSE-WAIT 
get:bCLOSING STA
get:bLAST-ACK ST
get:bThis shou
get:bremote si
get:bseventh, proc
get:bESTABLISHED
get:bFIN-WAIT-1 
get:bFIN-WAIT-2 
get:bOnce in t
get:btext to u
get:binto buff
get:bempty.  I
get:bthe user 
get:bhas been 
get:bWhen the 
get:buser it m
get:bOnce the 
get:bRCV.NXT o
get:bapporopri
get:bRCV.NXT a
get:bPlease no
get:bSend an a:cknowledgment of the form
get:b<SEQ=SN
get:bThis ackn
get:btransmitt
get:b[Page 74]        
get:bSeptember 1981   
get:bCLOSE-WAIT 
get:bCLOSING STA
get:bLAST-ACK ST
get:bTIME-WAIT S
get:bThis shou
get:bremote si
get:beighth, check
get:bDo not proc
get:bsince the S
get:bIf the FIN 
get:breturn any 
get:bover the FI
get:bFIN implies
get:bSYN-RECEI
get:bESTABLISH
get:bEnter t
get:bFIN-WAIT-
get:bIf our 
get:benter T
get:btimers;
get:bFIN-WAIT-
get:bEnter t
get:boff the
get:bCLOSE-WAI
get:bRemain 
get:bCLOSING S
get:bRemain 
get:bLAST-ACK 
get:bRemain 
get:bTransmission Cont
get:bFunctional Specif
get:bTIME-WAIT
get:bRemain 
get:btimeout
get:b[Page 76]        
get:bSeptember 1981   
get:bFor any state
get:bthe user "err:or
get:band for any o
get:bstate and ret
get:bRETRANSMISSION 
get:bFor any state
get:bthe retransmi
get:bretransmissio
get:bTIME-WAIT TIMEO
get:bIf the time-w
get:benter the CLO
get:bTransmission Cont
get:b[Page 78]        
get:bSeptember 1981   
get:bBBN Rep
get:ba Host 
get:bhost an
get:bA contr
get:bindicat
get:bspecifi
get:bis expe
get:bpreviou
get:bThe uni
get:bARPANET
get:bA unit 
get:bIMPs.  
get:bA logic
get:bA messa
get:bnetwork
get:bDestination Addre
get:bThe des
get:bidentif
get:bA contr
get:bindicat
get:boccupyi
get:bA porti
get:bfragmen
get:bA file 
get:bTransmission Cont
get:bControl
get:bfragmen
get:bA compu
get:bfrom th
get:bAn Inte
get:bby the 
get:bThe Int
get:bARPANET
get:bA sourc
get:binternet datagram
get:bThe uni
get:bhigher 
get:binternet fragment
get:bA porti
get:bheader.
get:bInterne
get:bThe Ini
get:bnumber 
get:bThe Ini
get:bon a co
get:bbased p
get:bThe Ini
get:bused by
get:bControl
get:bdata.  
get:bon an A
get:b[Page 80]        
get:bSeptember 1981   
get:bThis is
get:bdata re
get:bsequenc
get:bof the 
get:bThe uni
get:bAn impl
get:bprocedu
get:bMaximum
get:bthe int
get:bAn eigh
get:bAn Opti
get:bmay be 
get:bprimari
get:btimesta
get:boptions
get:bA packa
get:blogical
get:blogical
get:bThe por
get:boutput 
get:bA progr
get:bthe poi
get:bA contr
get:bthis se
get:breceivi
get:breceive
get:bTransmission Cont
get:breceive
get:breceive
get:breceive next sequ
get:bThis is
get:breceive
get:bThis re
get:bis will
get:bsegment
get:bRCV.NXT
get:bSegment
get:brange a
get:bA contr
get:bthat th
get:binterac
get:bsequenc
get:bsegment
get:bit.  In
get:brise to
get:bReal Ti:me Protocol
get:bof time
get:bsegment
get:bsegment
get:bsegment
get:bsegment
get:bsegment
get:b[Page 82]        
get:bSeptember 1981   
get:bsegment
get:bA logic
get:bunit of
get:bsegment acknowled
get:bThe seq
get:barrivin
get:bThe amo
get:bincludi
get:bThe num
get:bThis is
get:buse on 
get:binitial
get:beach oc
get:bThis re
get:b(receiv
get:bwindow 
get:breceivi
get:bbe emit
get:bSND.UNA
get:bbetween
get:bsend se
get:bleft se
get:bsend ur
get:bsegment
get:bsegment
get:bTransmission Cont
get:bsend wi
get:bAn addr
get:bis, the
get:bThe sou
get:bA contr
get:bnumber,
get:bwhere t
get:bTransmi
get:bthe sta
get:bThe pre
get:bTransmi:ssion Control Protocol
get:breliabl
get:bType of
get:bAn Inte
get:bfor thi
get:bA contr
get:bindicat
get:burgent 
get:bsequenc
get:bpointer
get:bA contr
get:bfield c
get:bindicat
get:burgent 
get:b[Page 84]        
get:bSeptember 1981   
get:b[1]  Cerf, V., an
get:bIntercommuni
get:bVol. COM-22,
get:b[2]  Postel, J. (
get:bProtocol Spe
get:bInstitute, S
get:b[3]  Dalal, Y. an
get:bProtocols", 
get:bDecember 197
get:b[4]  Postel, J., 
get:bInstitute, S
get:baRFC
get:baDe
get:baI
get:baSeptember 1981   
get:baPREFACE .....
get:ba1.  INTRODUCTION 
get:ba1.1  Motivation
get:ba1.2  Scope ....
get:ba1.3  About This
get:ba1.4  Interfaces
get:ba1.5  Operation 
get:ba2.  PHILOSOPHY ..
get:ba2.1  Elements o
get:ba2.2  Model of O
get:ba2.3  The Host E
get:ba2.4  Interfaces
get:ba2.5  Relation t
get:ba2.6  Reliable C
get:ba2.7  Connection
get:ba2.8  Data Commu
get:ba2.9  Precedence
get:ba2.10 Robustness
get:ba3.  FUNCTIONAL SP
get:ba3.1  Header For
get:ba3.2  Terminolog
get:ba3.3  Sequence N
get:ba3.4  Establishi
get:ba3.5  Closing a 
get:ba3.6  Precedence
get:ba3.7  Data Commu
get:ba3.8  Interfaces
get:ba3.9  Event Proc
get:baGLOSSARY ........
get:baREFERENCES ......
get:baTransmission Cont
get:ba[Page ii]        
get:baSeptember 1981   
get:baThis document des
get:ba(TCP).  There hav
get:baspecification on 
get:badraws heavily fro
get:baboth in terms of 
get:baseveral details a
get:baand redescribes t
get:baRFC
get:baReplaces: RFC 761
get:baIENs:  129, 124, 
get:ba55, 44, 40, 27, 2
get:baThe Transmission 
get:bareliable host-to-
get:bacommunication net
get:baThis document des
get:baTransmission Cont
get:bainterface to prog
get:baComputer commun
get:barole in militar
get:badocument focuse
get:bacommunication r
get:bacommunication u
get:bacongestion, but
get:bagovernment sect
get:baAs strategic an
get:badeveloped and d
get:bainterconnecting
get:bacommunication p
get:baapplications.  
get:baDeputy Undersec
get:badeclared the Tr
get:babe a basis for 
get:bastandardization
get:baTCP is a connec
get:bafit into a laye
get:baapplications.  
get:bacommunication b
get:badistinct but in
get:baassumptions are
get:baprotocols below
get:bapotentially unr
get:baprotocols.  In 
get:bawide spectrum o
get:baconnections to 
get:baTransmission Cont
get:baTCP is based on
get:baTCP fits into a
get:baInternet Protoc
get:bareceive variabl
get:badatagram "envel
get:baaddressing sour
get:bainternet protoc
get:bathe TCP segment
get:bamultiple networ
get:baalso carries in
get:baand compartment
get:bacommunicated en
get:baMuch of this do
get:bawhich are co-re
get:bacomputer.  Some
get:bafront-end compu
get:baas well as netw
get:baan interface to
get:baimplementable e
get:bahost-to-front e
get:baThe TCP is inte
get:bacommunication s
get:baintended to be 
get:ba1.3.  About this 
get:baThis document r
get:baany TCP impleme
get:baprotocols and i
get:ba[Page 2]         
get:baSeptember 1981   
get:basection offers 
get:baoperation.  Sec
get:badesign.  Sectio
get:barequired of TCP
get:bauser calls, err
get:baThe TCP interfa
get:bathe other side 
get:baThe interface b
get:baillustrated in 
get:bacalls much like
get:baapplication pro
get:bacalls to open a
get:baestablished con
get:baasynchronously 
get:baconsiderable fr
get:bainterfaces whic
get:baenvironment, a 
get:bainterface for a
get:baThe interface b
get:baunspecified exc
get:batwo levels can 
get:baTypically, one 
get:bainterface.  TCP
get:bainterconnected 
get:bathroughout this
get:baAs noted above,
get:basecurable logic
get:baprocesses.  To 
get:bacommunication s:ystem requires facilities in the following areas
get:baBasic Data Tr
get:baPrecedence an
get:baThe basic opera
get:bathe following p
get:baTransmission Cont
get:baBasic Data Tran:sfer
get:baThe TCP is ab
get:badirection bet
get:basegments for 
get:bathe TCPs deci
get:baSometimes use
get:basubmitted to 
get:bafunction is d
get:baactually tran
get:bapushed throug
get:bapromptly forw
get:baThe exact pus
get:bathe push func
get:baReliability
get:baThe TCP must 
get:badelivered out
get:bais achieved b
get:batransmitted, 
get:bareceiving TCP
get:bainterval, the
get:banumbers are u
get:baout of order 
get:baadding a chec
get:bareceiver, and
get:baAs long as th
get:basystem does n
get:baerrors will a
get:bainternet comm
get:baFlow Control
get:baTCP provides 
get:basent by the s
get:baevery ACK ind
get:bathe last segm
get:baallowed numbe
get:bareceiving fur
get:ba[Page 4]         
get:baSeptember 1981   
get:baMultiplexing
get:baTo allow for 
get:bacommunication
get:baaddresses or 
get:baand host addr
get:baa socket.  A 
get:baThat is, a so
get:baThe binding o
get:baHost.  Howeve
get:ba(e.g., a "log
get:bamade known to
get:bathrough the k
get:baaddresses of 
get:baConnections
get:baThe reliabili
get:bathat TCPs ini
get:baeach data str
get:basockets, sequ
get:baEach connecti
get:baidentifying i
get:baWhen two proc
get:baestablish a c
get:baside).  When 
get:baterminated or
get:baSince connect
get:baover the unre
get:bamechanism wit
get:baerroneous ini
get:baPrecedence and :Security
get:baThe users of 
get:bacommunication
get:bathese feature
get:baTransmission Cont
get:ba[Page 6]         
get:baSeptember 1981   
get:ba2.1.  Elements of
get:baThe internetwor
get:bawhich are in tu
get:bathat the networ
get:balarge networks 
get:bapacket switchin
get:baconsume message
get:banetworks, the g
get:bacommunication s
get:baconnections bet
get:baThe term packet
get:batransaction bet
get:baexchanged withi
get:baHosts are compu
get:banetwork's point
get:baProcesses are v
get:baaccordance with
get:bain execution). 
get:baviewed as commu
get:baThus, all commu
get:baSince a process
get:bastreams between
get:bathat each proce
get:bacommunicates wi
get:ba2.2.  Model of Op
get:baProcesses trans
get:badata as argumen
get:basegments and ca
get:bathe destination
get:bainto the receiv
get:baTCPs include co
get:baensure reliable
get:baThe model of in
get:baprotocol module
get:bato the local ne
get:bainside internet
get:bainternet module
get:bathrough the loc
get:baThe packet swit
get:baTransmission Cont
get:baother operation
get:badestination int
get:baAt a gateway be
get:bafrom its local 
get:bathe internet da
get:bathen "wrapped" 
get:barouted to the n
get:baA gateway is pe
get:bainternet datagr
get:bathrough the nex
get:bainternet datagr
get:bafurther broken 
get:bainternet datagr
get:bainternet module
get:baA destination i
get:ba(after reassemb
get:badestination TCP
get:baThis simple mod
get:baimportant featu
get:bato the gateway 
get:baservice paramet
get:baIncluded in the
get:badatagram.  Data
get:bahost and gatewa
get:baproperly segreg
get:ba2.3.  The Host En
get:baThe TCP is assu
get:baaccess the TCP 
get:bamay call on oth
get:badata structures
get:bacontrolled by a
get:banetwork device 
get:badatagram protoc
get:baThe mechanisms 
get:bafront-end proce
get:bahost-to-front-e
get:bathe type of TCP
get:ba[Page 8]         
get:baSeptember 1981   
get:baThe TCP/user in
get:bato OPEN or CLOS
get:baSTATUS about a 
get:baprograms on the
get:bafrom, and close
get:baThe TCP/interne
get:badatagrams addre
get:basystem.  These 
get:baservice, preced
get:ba2.5.  Relation to
get:baThe following d
get:bahierarchy
get:ba+------+ +
get:ba|Telnet| |
get:ba+------+ +
get:ba|   
get:ba+----
get:ba| TCP
get:ba+----
get:ba| 
get:ba+----
get:ba|    
get:ba+----
get:ba+--
get:ba|  
get:ba+--
get:baIt is expected 
get:baprotocols effic
get:baprotocols like 
get:ba2.6.  Reliable Co
get:baA stream of dat
get:baorder at the de
get:baTransmission Cont
get:baTransmission is
get:baacknowledgments
get:basequence number
get:basegment is tran
get:basequence number
get:bais the sequence
get:batransmissions i
get:basegment contain
get:bastarts a timer;
get:basegment is dele
get:bareceived before
get:baAn acknowledgme
get:badelivered to th
get:bathe responsibil
get:baTo govern the f
get:baemployed.  The 
get:baThis window spe
get:baacknowledgment 
get:ba2.7.  Connection 
get:baTo identify the
get:baprovides a port
get:baindependently b
get:baunique addresse
get:baidentifying the
get:bawill be unique 
get:baA connection is
get:balocal socket ma
get:basockets.  A con
get:bathat is, it is 
get:baTCPs are free t
get:baHowever, severa
get:baThere must be w
get:bathe "appropriat
get:bamay "own" ports
get:bathe ports they 
get:baissue, but we e
get:bauniquely alloca
get:baassociating the
get:baA connection is
get:baforeign socket 
get:ba[Page 10]        
get:baSeptember 1981   
get:baconnection name
get:basubsequent call
get:baabout a connect
get:bais a data struc
get:baimplementation 
get:bapointer to the 
get:bawhether the con
get:babe passively wa
get:baA passive OPEN 
get:baconnection requ
get:baOften the proce
get:barequest from an
get:bais used to deno
get:baare allowed onl
get:baA service proce
get:baprocesses would
get:baforeign socket.
get:barequested a con
get:balocal socket we
get:baWell-known sock
get:baa socket addres
get:ba"Telnet-Server"
get:basocket, and oth
get:baEntry, Text Gen
get:babeing for test 
get:baaccess to a "Lo
get:baat which a newl
get:bawell-known sock
get:baof sockets to s
get:baProcesses can i
get:bafrom other proc
get:babeen establishe
get:baother at the sa
get:bais critical for
get:bacomponents act 
get:baThere are two p
get:bapassive OPENs a
get:balocal passive O
get:bacase, the match
get:baOPENs has left 
get:baforeign socket 
get:baOther possibili
get:baTransmission Cont
get:baIf there are se
get:basame local sock
get:bawith the specif
get:baTCB exists, bef
get:baThe procedures 
get:bacontrol flag an
get:baexchange has be
get:baA connection is
get:bacontaining a SY
get:bacommand.  The m
get:baconnection has 
get:bawhen sequence n
get:baThe clearing of
get:bain this case ca
get:ba2.8.  Data Commun
get:baThe data that f
get:baoctets.  The se
get:bain that call (a
get:bathrough to the 
get:baA sending TCP i
get:basend that data 
get:bafunction is sig
get:bareceiving TCP s
get:bathe sending TCP
get:baThere is no nec
get:baboundaries.  Th
get:basingle SEND cal
get:baThe purpose of 
get:bafrom the sendin
get:barecord service.
get:baThere is a coup
get:baof data that cr
get:baassociated with
get:babuffer is retur
get:banot filled.  If
get:baPUSH is seen, t
get:baTCP also provid
get:baat some point f
get:ba[Page 12]        
get:baSeptember 1981   
get:bacurrently readi
get:badefine what the
get:baurgent data, bu
get:batake action to 
get:ba2.9.  Precedence 
get:baThe TCP makes u
get:basecurity option
get:babasis to TCP us
get:baa multilevel se
get:bause only, and o
get:bacompartment.  C
get:bausers may be li
get:baTCP modules whi
get:baproperly mark o
get:baprecedence.  Su
get:bahigher level pr
get:bathem to specify
get:baprecedence of c
get:ba2.10.  Robustness
get:baTCP implementat:ions will follow a general principle of robustness
get:baconservative in
get:baTransmission Cont
get:ba[Page 14]        
get:baSeptember 1981   
get:ba3.1.  Header Form
get:baTCP segments ar
get:baheader carries 
get:badestination hos
get:baheader, supplyi
get:badivision allows
get:baTCP Header Form
get:ba0            
get:ba0 1 2 3 4 5 6
get:ba+-+-+-+-+-+-+-
get:ba|          Sou
get:ba+-+-+-+-+-+-+-
get:ba|             
get:ba+-+-+-+-+-+-+-
get:ba|             
get:ba+-+-+-+-+-+-+-
get:ba|  Data |     
get:ba| Offset| Rese
get:ba|       |     
get:ba+-+-+-+-+-+-+-
get:ba|           Ch
get:ba+-+-+-+-+-+-+-
get:ba|             
get:ba+-+-+-+-+-+-+-
get:ba|             
get:ba+-+-+-+-+-+-+-
get:baNote th
get:baSource Port:  1
get:baThe source po
get:baDestination Por:t
get:baThe destinati
get:baTransmission Cont
get:baFunctional Specif
get:baSequence Number:
get:baThe sequence 
get:bawhen SYN is p
get:bainitial seque
get:baAcknowledgment :Number
get:baIf the ACK co
get:banext sequence
get:bareceive.  Onc
get:baData Offset:  4
get:baThe number of
get:bathe data begi
get:baintegral numb
get:baReserved:  6 bi
get:baReserved for 
get:baControl Bits:  :6 bits (from left to right)
get:baURG:  Urgent 
get:baACK:  Acknowl
get:baPSH:  Push Fu
get:baRST:  Reset t
get:baSYN:  Synchro
get:baFIN:  No more
get:baWindow:  16 bit
get:baThe number of
get:baacknowledgmen
get:baChecksum:  16 b
get:baThe checksum 
get:bacomplement su
get:basegment conta
get:bachecksummed, 
get:baform a 16 bit
get:batransmitted a
get:bathe checksum 
get:baThe checksum 
get:ba[Page 16]        
get:baSeptember 1981   
get:baprefixed to t
get:baAddress, the 
get:baThis gives th
get:bainformation i
get:baacross the TC
get:bacalls by the 
get:baThe TCP Len
get:baoctets (thi
get:bacomputed), 
get:baUrgent Pointer:
get:baThis field co
get:bapositive offs
get:baurgent pointe
get:bathe urgent da
get:bathe URG contr
get:baOptions:  varia
get:baOptions may o
get:bamultiple of 8
get:bachecksum.  An
get:bacases for the: format of an option
get:baCase 1:  A 
get:baCase 2:  An
get:bath
get:baThe option-le
get:baoption-length
get:baNote that the
get:bafield might i
get:baEnd-of-Option
get:baA TCP must im
get:baTransmission Cont
get:baFunctional Specif
get:baCurrently def:ined options include (kind indicated in octal)
get:baKind     Le
get:ba----     --
get:ba0         
get:ba1         
get:ba2         
get:baSpecific Opti
get:baEnd of Opti
get:ba+--------
get:ba|00000000
get:ba+--------
get:baThis opti
get:bamight not
get:bathe Data 
get:banot the e
get:bathe optio
get:baNo-Operatio
get:ba+--------
get:ba|00000001
get:ba+--------
get:baThis opti
get:baalign the
get:baThere is 
get:bareceivers
get:banot begin
get:baMaximum Seg
get:ba+--------
get:ba|00000010
get:ba+--------
get:baKind=2  
get:ba[Page 18]        
get:baSeptember 1981   
get:baMaximum S:egment Size Option Data
get:baIf this
get:bareceive
get:baThis fi
get:ba(i.e., 
get:baoption 
get:baPadding:  varia
get:baThe TCP heade
get:baand data begi
get:ba3.2.  Terminology
get:baBefore we can d
get:bato introduce so
get:baconnection requ
get:baof these variab
get:baTransmission Co
get:baTCB are the loc
get:baprecedence of t
get:babuffers, pointe
get:baIn addition sev
get:basequence number
get:baSend Sequence
get:baSND.UNA - s
get:baSND.NXT - s
get:baSND.WND - s
get:baSND.UP  - s
get:baSND.WL1 - s
get:baSND.WL2 - s
get:bau
get:baISS     - i
get:baReceive Seque
get:baRCV.NXT - r
get:baRCV.WND - r
get:baRCV.UP  - r
get:baIRS     - i
get:baTransmission Cont
get:baFunctional Specif
get:baThe following d
get:bathe sequence sp
get:baSend Sequence S
get:ba---
get:ba1 - old s
get:ba2 - seque
get:ba3 - seque
get:ba4 - futur
get:baThe send window
get:baReceive Sequenc
get:ba1 - old s
get:ba2 - seque
get:ba3 - futur
get:baThe receive win
get:baThere are also 
get:batake their valu
get:ba[Page 20]        
get:baSeptember 1981   
get:baCurrent Segme
get:baSEG.SEQ - s
get:baSEG.ACK - s
get:baSEG.LEN - s
get:baSEG.WND - s
get:baSEG.UP  - s
get:baSEG.PRC - s
get:baA connection pr
get:balifetime.  The :states are
get:baESTABLISHED, FI
get:baTIME-WAIT, and 
get:babecause it repr
get:bano connection. : Briefly the meanings of the states are
get:baLISTEN - repr
get:baTCP and port.
get:baSYN-SENT - re
get:baafter having 
get:baSYN-RECEIVED 
get:barequest ackno
get:baconnection re
get:baESTABLISHED -
get:badelivered to 
get:baof the connec
get:baFIN-WAIT-1 - 
get:bafrom the remo
get:batermination r
get:baFIN-WAIT-2 - 
get:bafrom the remo
get:baCLOSE-WAIT - 
get:bafrom the loca
get:baCLOSING - rep
get:baacknowledgmen
get:baLAST-ACK - re
get:baconnection te
get:ba(which includ
get:baTransmission Cont
get:baFunctional Specif
get:baTIME-WAIT - r
get:bathe remote TC
get:batermination r
get:baCLOSED - repr
get:baA TCP connectio
get:baevents.  The ev
get:baABORT, and STAT
get:bacontaining the 
get:baThe state diagr
get:bawith the causin
get:baerror condition
get:bachanges.  In a 
get:bathe reaction of
get:baNOTE BENE:  thi
get:bathe total speci
get:ba[Page 22]        
get:baSeptember 1981   
get:ba+---------+     
get:ba|         |<----
get:ba|   SYN   |     
get:ba|   RCVD  |<----
get:ba|         |     
get:ba|         |-----
get:ba+---------+   rc
get:ba|           --
get:ba|             
get:ba|             
get:ba|  CLOSE      
get:ba| -------     
get:ba| snd FIN     
get:ba|             
get:baV             
get:ba+---------+     
get:ba|  FIN    |<----
get:ba| WAIT-1  |-----
get:ba+---------+     
get:ba| rcv ACK of F
get:ba| ------------
get:baV        x    
get:ba+---------+     
get:ba|FINWAIT-2|     
get:ba+---------+     
get:ba|             
get:ba|  rcv FIN    
get:ba|  -------    
get:ba\ snd ACK    
get:ba------------
get:baTransmission Cont
get:baFunctional Specif
get:ba3.3.  Sequence Nu
get:baA fundamental n
get:baover a TCP conn
get:basequenced, each
get:bamechanism emplo
get:banumber X indica
get:bareceived.  This
get:badetection in th
get:bawithin a segmen
get:bathe header is t
get:banumbered consec
get:baIt is essential
get:bafinite, though 
get:baSince the space
get:banumbers must be
get:bapreserves the r
get:ba2**32 - 1 to 0 
get:baarithmetic, so 
get:bacomparison of s
get:ba(modulo 2**32).
get:baThe typical kin
get:baperform include:
get:ba(a)  Determin
get:banumber s
get:ba(b)  Determin
get:bahave bee
get:baretransm
get:ba(c)  Determin
get:bawhich ar
get:bareceive 
get:ba[Page 24]        
get:baSeptember 1981   
get:baIn response to 
get:bafollowing compa
get:baSND.UNA = old
get:baSND.NXT = nex
get:baSEG.ACK = ack
get:banum
get:baSEG.SEQ = fir
get:baSEG.LEN = the
get:ba(co
get:baSEG.SEQ+SEG.L
get:baA new acknowled
get:bathe inequality :below holds
get:baSND.UNA < SEG
get:baA segment on th
get:baof its sequence
get:baacknowledgment 
get:baWhen data is re:ceived the following comparisons are needed
get:baRCV.NXT = nex
get:bais the le
get:baRCV.NXT+RCV.W
get:basegment, 
get:baSEG.SEQ = fir
get:baSEG.SEQ+SEG.L
get:baA segment is ju
get:baRCV.NXT =< SE
get:baRCV.NXT =< SE
get:baTransmission Cont
get:baFunctional Specif
get:baThe first part 
get:basegment falls i
get:baif the end of t
get:baeither part of 
get:baActually, it is
get:bawindows and zer
get:baacceptability o:f an incoming segment
get:baSegment Recei
get:baLength  Windo
get:ba------- -----
get:ba0       0 
get:ba0      >0 
get:ba>0       0 
get:ba>0      >0 
get:baNote that when 
get:baacceptable exce
get:bamaintain a zero
get:baACKs.  However,
get:baprocess the RST
get:baWe have taken a
get:bacontrol informa
get:basome control fl
get:baand acknowledge
get:bacontrol will be
get:bacarried in the 
get:bafor implicitly 
get:baare the only co
get:baare used only a
get:bapurposes, the S
get:baoctet of the se
get:bato occur after 
get:baoccurs.  The se
get:baspace occupying
get:basequence number
get:ba[Page 26]        
get:baSeptember 1981   
get:baInitial Sequenc
get:baThe protocol pl
get:baused over and o
get:basockets.  New i
get:baincarnations of
get:ba-- "how does th
get:baincarnations of
get:baconnection is b
get:baconnection brea
get:baTo avoid confus
get:baconnection from
get:babe present in t
get:baassure this, ev
get:basequence number
get:baan initial sequ
get:banew 32 bit ISN.
get:babit clock whose
get:bamicroseconds.  
get:baSince we assume
get:bathe Maximum Seg
get:bahours we can re
get:baFor each connec
get:basequence number
get:bathe data sendin
get:balearned during 
get:baFor a connectio
get:basynchronize on 
get:baan exchange of 
get:bacalled "SYN" (f
get:bashorthand, segm
get:baHence, the solu
get:bainitial sequenc
get:baThe synchroniza
get:basequence number
get:bafrom the other 
get:bainitial sequenc
get:ba1) A --> B  S
get:ba2) A <-- B  A
get:ba3) A <-- B  S
get:ba4) A --> B  A
get:baTransmission Cont
get:baFunctional Specif
get:baBecause steps 2
get:bacalled the thre
get:baA three way han
get:batied to a globa
get:bamechanisms for 
get:bano way of knowi
get:baunless it remem
get:ba(which is not a
get:baverify this SYN
get:baclock-driven sc
get:baKnowing When to
get:baTo be sure that
get:basequence number
get:bathe network, th
get:ba(MSL) before as
get:barecovering from
get:balost.  For this
get:bais an engineeri
get:bait is desirable
get:basense, yet reta
get:banot wait at all
get:bathan those rece
get:baThe TCP Quiet T
get:baThis specific
get:baretaining any
get:baeach active (
get:baTCP segments 
get:bain the intern
get:baparagraphs be
get:baTCP implement
get:baat the risk o
get:badata rejected
get:baTCPs consume 
get:baentered into 
get:baduplicate det
get:barelies on the
get:bathe extent th
get:bavalues before
get:babeen delivere
get:bacopies of the
get:basuch an assum
get:ba[Page 28]        
get:baSeptember 1981   
get:baassigned the 
get:baat the receiv
get:bathat each seg
get:baas there are 
get:baUnder normal 
get:bato emit and t
get:bamistakenly us
get:babeen acknowle
get:badata is drain
get:bavery large to
get:bacause trouble
get:bato use up 2**
get:balifetime in t
get:bathis is deeme
get:barates escalat
get:bacycle time is
get:bawithin reason
get:baThe basic dup
get:badefeated, how
get:basequence numb
get:bathe TCP were 
get:baupon crashing
get:baconnection (p
get:bapackets with 
get:bapackets still
get:baincarnation o
get:baabout the seq
get:baspecification
get:babefore emitti
get:basegments from
get:baEven hosts wh
get:bainitial seque
get:ba(i.e., even i
get:banumber for ea
get:baSuppose, for 
get:basequence numb
get:baand that even
get:batakes on a va
get:basegment sent 
get:baat this insta
get:baincarnation o
get:baS1 = ISN(t) -
get:baconnection!  
get:baTransmission Cont
get:baFunctional Specif
get:baduplicates in
get:baof S1 may arr
get:bathe new incar
get:baThe problem i
get:bacrashed nor d
get:bathe system fr
get:baOne way to de
get:basegments for 
get:batime" specifi
get:bawilling to ri
get:badestination m
get:baImplementors 
get:baconnection by
get:bainformally im
get:baObviously, ev
get:banecessary aft
get:baTo summarize:
get:banumbers in th
get:ba"busy" or "in
get:bablock of spac
get:basegment, if a
get:basequence numb
get:bathe previous 
get:banumber overla
get:ba3.4.  Establishin
get:baThe "three-way 
get:baconnection.  Th
get:baresponded to by
get:basimultaneously 
get:baoccurs, each TC
get:baacknowledgment 
get:baan old duplicat
get:barecipient, that
get:baProper use of "
get:baSeveral example
get:baexamples do not
get:basegments, this 
get:badoesn't deliver
get:bavalid (i.e., th
get:baconnection reac
get:bareduces the pos
get:ba[Page 30]        
get:baSeptember 1981   
get:baimplementation 
get:bainformation for
get:baThe simplest th
get:bafigures should 
get:banumbered for re
get:badeparture of a 
get:basegment at B fr
get:baEllipsis (...) 
get:ba(delayed).  An 
get:baComments appear
get:bathe departure o
get:bathe center of e
get:baform, with sequ
get:bafields such as 
get:bain the interest
get:baTCP A      
get:ba1.  CLOSED     
get:ba2.  SYN-SENT   
get:ba3.  ESTABLISHED
get:ba4.  ESTABLISHED
get:ba5.  ESTABLISHED
get:baBasic 3
get:baIn line 2 of fi
get:baindicating that
get:banumber 100.  In
get:bareceived from T
get:baB is now expect
get:baoccupied sequen
get:baAt line 4, TCP 
get:baTCP B's SYN; an
get:basequence number
get:babecause the ACK
get:bawould wind up A
get:baTransmission Cont
get:baFunctional Specif
get:baSimultaneous in
get:bafigure 8.  Each
get:baTCP A      
get:ba1.  CLOSED     
get:ba2.  SYN-SENT   
get:ba3.  SYN-RECEIVE
get:ba4.             
get:ba5.  SYN-RECEIVE
get:ba6.  ESTABLISHED
get:ba7.             
get:baS
get:baThe principle r
get:baduplicate conne
get:bathis, a special
get:bareceiving TCP i
get:baSYN-RECEIVED), 
get:baIf the TCP is i
get:baFIN-WAIT-1, FIN
get:baaborts the conn
get:bacase under "hal
get:ba[Page 32]        
get:baSeptember 1981   
get:baTCP A      
get:ba1.  CLOSED     
get:ba2.  SYN-SENT   
get:ba3.  (duplicate)
get:ba4.  SYN-SENT   
get:ba5.  SYN-SENT   
get:ba6.             
get:ba7.  SYN-SENT   
get:ba8.  ESTABLISHED
get:baAs a simple exa
get:bafigure 9.  At l
get:bacannot tell tha
get:ba(line 4).  TCP 
get:baRST (reset) wit
get:babelievable.  TC
get:baWhen the origin
get:basynchronization
get:babefore the RST,
get:basent in both di
get:baHalf-Open Conne
get:baAn established 
get:baTCPs has closed
get:baknowledge of th
get:babecome desynchr
get:bamemory.  Such c
get:baattempt is made
get:baconnections are
get:bamildly involved
get:baIf at site A th
get:baTransmission Cont
get:baFunctional Specif
get:bauser at site B 
get:bareceiving a res
get:basite B TCP that
get:baAssume that two
get:baanother when a 
get:baDepending on th
get:bathat some error
get:baA is likely to 
get:bapoint.  As a re
get:baor try to SEND 
get:bacase, it receiv
get:balocal (A's) TCP
get:bawill send a seg
get:baexample shown i
get:bare-open the con
get:baTCP A      
get:ba1.  (CRASH)    
get:ba2.  CLOSED     
get:ba3.  SYN-SENT --
get:ba4.  (!!)     <-
get:ba5.  SYN-SENT --
get:ba6.  SYN-SENT   
get:ba7.  SYN-SENT --
get:baWhen the SYN ar
get:baand the incomin
get:baacknowledgment 
get:ba100).  TCP A se
get:basent and, being
get:badetected a half
get:ba[Page 34]        
get:baSeptember 1981   
get:bacontinue to try
get:bareduced to the 
get:baAn interesting 
get:batries to send d
get:baThis is illustr
get:baTCP A from TCP 
get:baexists, so TCP 
get:baprocesses it an
get:baTCP A    
get:ba1.  (CRASH)    
get:ba2.  (??)    <--
get:ba3.          -->
get:baActive
get:baIn figure 12, w
get:bawaiting for SYN
get:bainto action.  A
get:bagenerate a RST 
get:bathe reset and r
get:baTCP A      
get:ba1.  LISTEN     
get:ba2.       ... <S
get:ba3.  (??) <-- <S
get:ba4.       --> <S
get:ba5.  LISTEN     
get:baOld Duplic
get:baTransmission Cont
get:baFunctional Specif
get:baA variety of ot
get:baby the followin
get:baReset Generatio
get:baAs a general ru
get:bawhich apparentl
get:bamust not be sen
get:baThere are three: groups of states
get:ba1.  If the co
get:bain response t
get:baparticular, S
get:baby this means
get:baIf the incomi
get:basequence numb
get:bareset has seq
get:baof the sequen
get:baThe connectio
get:ba2.  If the co
get:baSYN-SENT, SYN
get:basomething not
get:baif an incomin
get:badoes not exac
get:baconnection, a
get:baIf our SYN ha
get:baincoming segm
get:baeither raise 
get:bathe system) o
get:baincoming segm
get:bacontinue as i
get:bacannot raise 
get:badetected in t
get:baterminated th
get:baincoming segm
get:bamatch the loc
get:bamust be sent.
get:baIf the incomi
get:basequence numb
get:bareset has seq
get:baof the sequen
get:baThe connectio
get:ba[Page 36]        
get:baSeptember 1981   
get:ba3.  If the co
get:baFIN-WAIT-1, F
get:baany unaccepta
get:baunacceptible 
get:baacknowledgmen
get:baand an acknow
get:bato be receive
get:baIf an incomin
get:baprecedence wh
get:baand precedenc
get:baconnection go
get:banumber from t
get:baReset Processin
get:baIn all states e
get:baby checking the
get:bais in the windo
get:bato an initial S
get:baacknowledges th
get:baThe receiver of
get:bareceiver was in
get:bain SYN-RECEIVED
get:bathen the receiv
get:baaborts the conn
get:bawas in any othe
get:baand goes to the
get:ba3.5.  Closing a C
get:baCLOSE is an ope
get:banotion of closi
get:bainterpretation,
get:bathe receiving s
get:bain a simplex fa
get:bauntil he is tol
get:bacould initiate 
get:baRECEIVE until s
get:bahas CLOSED.  We
get:baRECEIVEs are ou
get:bacan terminate h
get:babuffers SENT be
get:badata in return 
get:basuccessfully to
get:baTCP.  Users mus
get:bathe TCP says no
get:baTransmission Cont
get:baFunctional Specif
get:baThere are essen:tially three cases
get:ba1) The user i
get:ba2) The remote
get:ba3) Both users
get:baCase 1:  Local 
get:baIn this case,
get:baoutgoing segm
get:baaccepted by t
get:baare allowed i
get:bawill be retra
get:baboth acknowle
get:bacan ACK this 
get:basend its own 
get:baCase 2:  TCP re
get:baIf an unsolic
get:bacan ACK it an
get:bauser will res
get:bathe other TCP
get:bauntil its own
get:baconnection.  
get:bathe connectio
get:baCase 3:  both u
get:baA simultaneou
get:baFIN segments 
get:bahave been pro
get:bahas received.
get:ba[Page 38]        
get:baSeptember 1981   
get:baTCP A      
get:ba1.  ESTABLISHED
get:baFIN-WAIT-1 
get:ba3.  FIN-WAIT-2 
get:ba4.             
get:baTIME-WAIT  
get:ba5.  TIME-WAIT  
get:baCLOSED     
get:baTCP A      
get:ba1.  ESTABLISHED
get:ba2.  (Close)    
get:baFIN-WAIT-1 
get:ba3.  CLOSING    
get:ba4.  TIME-WAIT  
get:ba(2 MSL)    
get:baCLOSED     
get:baTransmission Cont
get:baFunctional Specif
get:ba3.6.  Precedence 
get:baThe intent is t
get:bawith exactly th
get:bahigher of the p
get:baThe precedence 
get:badefined in the 
get:baspecification t
get:bathe security pa
get:bauser group, and
get:baA connection at
get:balower precedenc
get:baa connection du
get:baacknowledgment 
get:baNote that TCP m
get:baprecedence will
get:basegments and po
get:baThe security pa
get:ba(the values wou
get:banon-secure envi
get:baparameters, tho
get:ba3.7.  Data Commun
get:baOnce the connec
get:baexchange of seg
get:ba(checksum test 
get:baretransmission 
get:baDuplicate segme
get:baAs discussed in
get:bacertain tests o
get:basegments to ver
get:baThe sender of d
get:bathe variable SN
get:basequence number
get:bakeeps track of 
get:bavariable SND.UN
get:basent has been a
get:baWhen the sender
get:baSND.NXT.  When 
get:basends an acknow
get:ba[Page 40]        
get:baSeptember 1981   
get:baacknowledgment 
get:bathese variables
get:baThe amount by w
get:badata in the seg
get:basegments must c
get:baThe CLOSE user 
get:baflag in an inco
get:baRetransmission 
get:baBecause of the 
get:bainternetwork sy
get:baretransmission 
get:bafor determining
get:baAn Example Re
get:baMeasure the
get:baparticular 
get:bacovers that
get:basegments re
get:baTime (RTT).:  Next compute a Smoothed Round Trip Time (SRTT) as
get:baSRTT = ( 
get:baand based o:n this, compute the retransmission timeout (RTO) as
get:baRTO = min
get:bawhere UBOUN
get:baLBOUND is a
get:baa smoothing
get:bafactor (e.g
get:baThe Communicati
get:baThe objective o
get:bato stimulate th
get:bapermit the rece
get:bathe currently k
get:baThis mechanism 
get:bathe end of urge
get:bathe receive seq
get:bamust tell the u
get:banumber catches 
get:baTransmission Cont
get:baFunctional Specif
get:bainto "normal mo
get:bais in "urgent m
get:baThe method empl
get:batransmitted.  T
get:bameaningful and 
get:bathe urgent poin
get:bano urgent data 
get:baTo send an urge
get:baoctet.  If the 
get:bathe urgent info
get:baManaging the Wi
get:baThe window sent
get:banumbers the sen
get:baprepared to acc
get:bathe currently a
get:baIndicating a la
get:baarrives than ca
get:bain excessive re
get:banetwork and the
get:batransmission of
get:babetween each ne
get:baThe mechanisms 
get:basubsequently ad
get:bathat much data.
get:badiscouraged.  T
get:bashrink the wind
get:baon the part of 
get:baThe sending TCP
get:baleast one octet
get:basending TCP mus
get:bathe window is z
get:bainterval when t
get:baguarantee that 
get:bawindow will be 
get:baWhen the receiv
get:bastill send an a
get:baand current win
get:baThe sending TCP
get:ba[Page 42]        
get:baSeptember 1981   
get:bawhich fit the c
get:baretransmission 
get:baIn a connection
get:babe carried in a
get:banumber so there
get:baorder.  This is
get:bainformation to 
get:bathe data receiv
get:bathe window info
get:baacknowledgment 
get:baequal or greate
get:baThe window mana
get:bacommunication p
get:baWindow Manage
get:baAllocating 
get:bamany small 
get:bafewer large
get:baOne suggest
get:badefer updat
get:baleast X per
get:baconnection 
get:baAnother sug
get:basegments by
get:basending dat
get:badata must b
get:baNote that t
get:baretransmiss
get:baacknowledgm
get:bawindow info
get:banew window 
get:baThe segment
get:baof transmit
get:basegment con
get:bais accepted
get:baIf the send
get:bawindow is n
get:baalternating
get:bapauses in t
get:baTransmission Cont
get:baFunctional Specif
get:baresult in b
get:babig pair. A
get:bamostly smal
get:baThe suggest
get:baactively at
get:bawindows, si
get:bato many sma
get:baThere are of co:urse two interfaces of concern
get:baand the TCP/low
get:baof the user/TCP
get:baprotocol module
get:bain detail by th
get:bacase that the l
get:bathat TCPs might
get:baUser/TCP Interf
get:baThe following
get:baat best, fict
get:bafacilities.  
get:baimplementatio
get:baTCPs must pro
get:bathat all TCP 
get:bahierarchy.  T
get:barequired of a
get:baTCP User Comm
get:baThe followi
get:bainterface. 
get:bafunction ca
get:bameant to ru
get:baThe user co
get:baTCP must pe
get:baIndividual 
get:bamay provide
get:basingle call
get:baautomatical
get:baissued by t
get:ba[Page 44]        
get:baSeptember 1981   
get:baIn providin
get:banot only ac
get:baprocesses i:t serves.  The latter consists of
get:ba(a) gener
get:baremote cl
get:ba(b) repli
get:bavarious t
get:baFormat:  
get:ba[, timeou
get:ba-> local 
get:baWe assume
get:baprocesses
get:bato use th
get:baimplement
get:bafor the s
get:balower lev
get:baresult of
get:baable to m
get:baprocess c
get:baIf the ac
get:bacall to L
get:bahave eith
get:baparticula
get:bafor any c
get:baby the su
get:baA transmi
get:bafilled in
get:baOn an act
get:basynchroni
get:baThe timeo
get:bafor all d
get:badelivered
get:bawill abor
get:baThe TCP o
get:bathe users
get:baTransmission Cont
get:baFunctional Specif
get:baprecedenc
get:baor securi
get:bathe defau
get:baTCP will 
get:basecurity/
get:bathe prece
get:barequested
get:baThe prece
get:barequested
get:barequest, 
get:baconnectio
get:bathis prec
get:baallowed t
get:baor that a
get:baA local c
get:baThe local
get:bafor the c
get:baFormat:  
get:bacount, PU
get:baThis call
get:bato be sen
get:banot been 
get:baimplement
get:baautomatic
get:baauthorize
get:baIf the PU
get:bato the re
get:basegment c
get:bathe data 
get:batransmiss
get:baIf the UR
get:bawill have
get:bathe urgen
get:bapointer i
get:babeen cons
get:bais to sti
get:baindicate 
get:ba[Page 46]        
get:baSeptember 1981   
get:badata has 
get:baTCP signa
get:baof times 
get:baurgent da
get:baIf no for
get:baconnectio
get:bahas becom
get:balocal soc
get:baforeign s
get:baforeign s
get:baknowing t
get:baHowever, 
get:babecomes s
get:baSTATUS ca
get:baimplement
get:basocket is
get:baIf a time
get:baconnectio
get:baIn the si
get:bathe sendi
get:baor the ti
get:bais both s
get:baconnectio
get:baoffers po
get:basophistic
get:bathe proce
get:bafurthermo
get:baMultiple 
get:bathe TCP w
get:baWe have i
get:bawhich a S
get:bapseudo-in
get:bareturn a 
get:baimmediate
get:babeen ackn
get:baassume ev
get:baclose any
get:bakind (syn
get:basignals, 
get:bawith spec
get:baIn order 
get:baindicatio
get:baTransmission Cont
get:baFunctional Specif
get:babuffer ad
get:bathe SEND 
get:baindicatin
get:bacalling p
get:baFormat:  
get:bacount) ->
get:baThis comm
get:baspecified
get:bacalling p
get:baerror is 
get:baIn the si
get:bacalling p
get:baerror occ
get:baA more so
get:baRECEIVEs 
get:basegments 
get:bathe cost 
get:banotify th
get:baIf enough
get:bathe PUSH 
get:baThe buffe
get:baa PUSH is
get:bareturned 
get:baIf there 
get:baas it arr
get:bashould th
get:baadditiona
get:bacall to R
get:bamay now l
get:baurgent po
get:bain the sa
get:baboundary 
get:baTo distin
get:bacare of t
get:bareturn co
get:bacount ind
get:baAlternati
get:ba[Page 48]        
get:baSeptember 1981   
get:baallocate 
get:bawith the 
get:baFormat:  
get:baThis comm
get:bathe conne
get:baauthorize
get:baClosing c
get:bathe sense
get:baretransmi
get:baserviced.
get:bacalls, fo
get:bato the de
get:bacontinue 
get:bamay be tr
get:bameans "I 
get:bareceive a
get:banot well 
get:baof all it
get:bainto ABOR
get:baThe user 
get:bainitiativ
get:ba(e.g., re
get:badestinati
get:baBecause c
get:baforeign T
get:bashort tim
get:bareplies t
get:baClose als
get:baFormat:  
get:baThis is a
get:baexcluded 
get:batypically
get:baThis comm
get:bainformati:on
get:balocal s
get:baTransmission Cont
get:baFunctional Specif
get:baforeign
get:balocal c
get:bareceive
get:basend wi
get:baconnect
get:banumber 
get:banumber 
get:baurgent 
get:baprecede
get:basecurit
get:baand tra
get:baDepending
get:baimplement
get:baavailable
get:baauthorize
get:baprevents 
get:baconnectio
get:baFormat:  
get:baThis comm
get:baaborted, 
get:babe sent t
get:baDepending
get:baindicatio
get:bareceive a
get:baTCP-to-User M
get:baIt is assum
get:bameans for t
get:bathe TCP doe
get:bato the user
get:baan error me
get:barelating to
get:baother user 
get:baThe followi:ng information is provided
get:baLocal Con
get:baResponse 
get:baBuffer Ad
get:baByte coun
get:baPush flag
get:baUrgent fl
get:ba[Page 50]        
get:baSeptember 1981   
get:baTCP/Lower-Level
get:baThe TCP calls
get:bareceive infor
get:bainternetwork 
get:baProtocol (IP)
get:baIf the lower 
get:baof service an
get:bafor these par:ameters
get:baType of Ser:vice = Precedence: routine, Delay: normal, Throughput
get:banormal, Rel:iability
get:baTime to Liv
get:baNote that
get:baHere we e
get:babe delive
get:baIf the lower 
get:bafeature) and 
get:baroute informa
get:baso that the s
get:bachecksum be t
get:baalso importan
get:baAny lower lev
get:badestination a
get:bathe "TCP leng
get:baof IP and to 
get:baTransmission Cont
get:baFunctional Specif
get:ba3.9.  Event Proce
get:baThe processing 
get:baimplementation.
get:baprocessing sequ
get:basection only in
get:baThe activity of
get:baThe events that: occur can be cast into three categories
get:baarriving segmen
get:baprocessing the 
get:bacases the proce
get:baEvents that o:ccur
get:baArriving Se
get:baSEGMENT A
get:baUSER TIME
get:baRETRANSMI
get:baTIME-WAIT
get:baThe model of th
get:baimmediate retur
get:bapseudo interrup
get:bameans cause a d
get:baError responses
get:bacommands refere:ncing connections that do not exist receive "error
get:baconnection not 
get:baPlease note in 
get:baacknowledgment 
get:baof the sequence
get:baequal to (modul
get:ba[Page 52]        
get:baSeptember 1981   
get:baA natural way t
get:baimagine that th
get:bathat their cont
get:bain the sequence
get:baand processed i
get:baWhen a segment 
get:bathe segment to 
get:bato be consisten
get:baNote that if no
get:baTransmission Cont
get:baFunctional Specif
get:baCLOSED STATE 
get:baCreate a ne
get:bastate infor
get:basocket, pre
get:bainformation
get:baunspecified
get:baparameters 
get:baprecedence 
get:ba"error:  pr:ecedence not allowed" or "error
get:banot allowed
get:baactive and :the foreign socket is unspecified, return "error
get:baforeign soc
get:baspecified, 
get:ba(ISS) is se
get:bais sent.  S
get:bastate, and 
get:baIf the call
get:bareturn "err:or
get:bano room to :create a new connection, return "error
get:baresources".
get:baIf active a
get:baconnection 
get:basegment, se
get:bastate.  Dat
get:baqueued for 
get:baurgent bit 
get:basegments se
get:baqueue the r:equest, respond with "error
get:baIf Foreign :socket was not specified, then return "error
get:basocket unsp
get:ba[Page 54]        
get:baSeptember 1981   
get:baSYN-SENT STAT
get:baSYN-RECEIVED 
get:baESTABLISHED S
get:baFIN-WAIT-1 ST
get:baFIN-WAIT-2 ST
get:baCLOSE-WAIT ST
get:baCLOSING STATE
get:baLAST-ACK STAT
get:baTIME-WAIT STA
get:baReturn "err:or
get:baTransmission Cont
get:baFunctional Specif
get:baCLOSED STATE 
get:baIf the user
get:ba"error:  co
get:baOtherwise, :return "error
get:baIf the fore
get:bafrom passiv
get:baSND.UNA to 
get:baassociated 
get:batransmissio
get:barequested i
get:baas a result
get:barequest, re:spond with "error
get:baForeign soc:ket was not specified, then return "error
get:basocket unsp
get:baSYN-SENT STAT
get:baSYN-RECEIVED 
get:baQueue the d
get:baIf no space: to queue, respond with "error
get:baresources".
get:baESTABLISHED S
get:baCLOSE-WAIT ST
get:baSegmentize 
get:baacknowledgm
get:bainsufficien:t space to remember this buffer, simply return "error
get:bainsufficien
get:baIf the urge
get:baurgent poin
get:ba[Page 56]        
get:baSeptember 1981   
get:baFIN-WAIT-1 ST
get:baFIN-WAIT-2 ST
get:baCLOSING STATE
get:baLAST-ACK STAT
get:baTIME-WAIT STA
get:baReturn "err:or
get:baTransmission Cont
get:baFunctional Specif
get:baCLOSED STATE 
get:baIf the user
get:ba"error:  co
get:baOtherwise r:eturn "error
get:baSYN-SENT STAT
get:baSYN-RECEIVED 
get:baQueue for p
get:bais no room :to queue this request, respond with "error
get:bainsufficien
get:baESTABLISHED S
get:baFIN-WAIT-1 ST
get:baFIN-WAIT-2 ST
get:baIf insuffic
get:barequest, qu
get:baremember th:e RECEIVE, respond with "error
get:baresources".
get:baReassemble 
get:bato user.  M
get:baIf RCV.UP i
get:bauser notify
get:baWhen the TC
get:bathat fact m
get:baacknowledgm
get:badescribed b
get:ba[Page 58]        
get:baSeptember 1981   
get:baCLOSE-WAIT ST
get:baSince the r
get:basatisfied b
get:bauser.  If n
get:ba"error:  co
get:batext can be
get:baCLOSING STATE
get:baLAST-ACK STAT
get:baTIME-WAIT STA
get:baReturn "err:or
get:baTransmission Cont
get:baFunctional Specif
get:baCLOSED STATE 
get:baIf the user
get:ba"error:  co
get:baOtherwise, :return "error
get:baAny outstan:ding RECEIVEs are returned with "error
get:baresponses. 
get:baSYN-SENT STAT
get:baDelete the :TCB and return "error
get:baqueued SEND
get:baSYN-RECEIVED 
get:baIf no SENDs
get:bathen form a
get:baotherwise q
get:baESTABLISHED S
get:baQueue this 
get:baform a FIN 
get:baFIN-WAIT-1 ST
get:baFIN-WAIT-2 ST
get:baStrictly sp:eaking, this is an error and should receive a "error
get:baconnection 
get:baacceptable,
get:baFIN may be 
get:ba[Page 60]        
get:baSeptember 1981   
get:baCLOSE-WAIT ST
get:baQueue this 
get:basegmentized
get:baCLOSING STATE
get:baLAST-ACK STAT
get:baTIME-WAIT STA
get:baRespond wit:h "error
get:baTransmission Cont
get:baFunctional Specif
get:baCLOSED STATE 
get:baIf the user
get:ba"error:  co
get:baOtherwise r:eturn "error
get:baAny outstan:ding RECEIVEs should be returned with "error
get:baconnection 
get:baSYN-SENT STAT
get:baAll queued 
get:banotificatio
get:baSYN-RECEIVED 
get:baESTABLISHED S
get:baFIN-WAIT-1 ST
get:baFIN-WAIT-2 ST
get:baCLOSE-WAIT ST
get:baSend a rese:t segment
get:ba<SEQ=SND.
get:baAll queued 
get:banotificatio
get:baRST formed 
get:baTCB, enter 
get:baCLOSING STATE
get:baLAST-ACK STAT
get:baTIME-WAIT STA
get:baRespond wit
get:ba[Page 62]        
get:baSeptember 1981   
get:baCLOSED STATE 
get:baIf the user
get:ba"error:  co
get:baOtherwise r:eturn "error
get:baReturn "sta
get:baSYN-SENT STAT
get:baReturn "sta
get:baSYN-RECEIVED 
get:baReturn "sta
get:baESTABLISHED S
get:baReturn "sta
get:baFIN-WAIT-1 ST
get:baReturn "sta
get:baFIN-WAIT-2 ST
get:baReturn "sta
get:baCLOSE-WAIT ST
get:baReturn "sta
get:baCLOSING STATE
get:baReturn "sta
get:baLAST-ACK STAT
get:baReturn "sta
get:baTransmission Cont
get:baFunctional Specif
get:baTIME-WAIT STA
get:baReturn "sta
get:ba[Page 64]        
get:baSeptember 1981   
get:baSEGMENT ARRIVES
get:baIf the state 
get:baall data in
get:basegment con
get:bacontaining 
get:baacknowledgm
get:bareset seque
get:baIf the ACK 
get:ba<SEQ=0><A
get:baIf the ACK 
get:ba<SEQ=SEG.
get:baIf the state 
get:bafirst check
get:baAn incomi
get:basecond chec
get:baAny ackno
get:bathe LISTE
get:bafor any a
get:baformatted: as follows
get:ba<SEQ=SE
get:bathird check
get:baIf the SY
get:basecurity/
get:bamatch the
get:ba<SEQ=SE
get:baTransmission Cont
get:baFunctional Specif
get:baIf the SE
get:bathe user 
get:basend a re
get:ba<SEQ=SE
get:baIf the SE
get:baSet RCV.N
get:bacontrol o
get:bashould be: selected and a SYN segment sent of the form
get:ba<SEQ=IS
get:baSND.NXT i
get:bastate sho
get:baincoming 
get:bain the SY
get:banot be re
get:bathe forei
get:baunspecifi
get:bafourth othe
get:baAny other
get:bamust have
get:baprocessin
get:bait could 
get:baincarnati
get:babut if yo
get:baIf the state 
get:bafirst check
get:baIf the AC
get:baIf SEG.
get:bathe RST
get:ba<SEQ=
get:baand dis
get:baIf SND.
get:basecond chec
get:ba[Page 66]        
get:baSeptember 1981   
get:baIf the RS
get:baIf the :ACK was acceptable then signal the user "error
get:baconnect
get:badelete 
get:baand ret
get:bathird check
get:baIf the se
get:bamatch the
get:baIf ther
get:ba<SEQ=
get:baOtherwi
get:ba<SEQ=
get:baIf there 
get:baThe pre
get:baTCB, if
get:ba<SEQ=
get:baIf there 
get:baIf the 
get:bain the 
get:bathe pre
get:baallowed
get:ba<SEQ=
get:baIf the 
get:bain the 
get:baIf a rese
get:bafourth chec
get:baThis step
get:bano ACK, a
get:baIf the SY
get:baTransmission Cont
get:baFunctional Specif
get:baare accep
get:baSEG.SEQ. 
get:bais an ACK
get:baare there
get:baIf SND.UN
get:bastate to 
get:ba<SEQ=SN
get:baand send 
get:batransmiss
get:batext in t
get:babelow whe
get:baOtherwise
get:ba<SEQ=IS
get:baand send 
get:basegment, 
get:bahas been 
get:bafifth, if n
get:basegment and
get:ba[Page 68]        
get:baSeptember 1981   
get:bafirst check s
get:baSYN-RECEIVE
get:baESTABLISHED
get:baFIN-WAIT-1 
get:baFIN-WAIT-2 
get:baCLOSE-WAIT 
get:baCLOSING STA
get:baLAST-ACK ST
get:baTIME-WAIT S
get:baSegments 
get:baare used 
get:badone in S
get:baboundary 
get:baprocessed
get:baThere are
get:basegment
get:baSegment R
get:baLength  W
get:ba------- -
get:ba0     
get:ba0     
get:ba>0     
get:ba>0     
get:baIf the RC
get:baspecial a
get:baIf an inc
get:bashould be
get:bathe segme:nt and return)
get:ba<SEQ=SN
get:baAfter sen
get:baand retur
get:baTransmission Cont
get:baFunctional Specif
get:baIn the fo
get:basegment t
get:baOne could
get:batrimming 
get:baSYN and F
get:babegins at
get:banumbers m
get:basecond check 
get:baSYN-RECEIVE
get:baIf the RS
get:baIf this
get:bacame fr
get:baLISTEN 
get:bathis co
get:bafrom SY
get:bathe use
get:baon the 
get:baactive 
get:baand ret
get:baESTABLISHED
get:baIf the RS
get:bashould re
get:baflushed. 
get:ba"connecti
get:baTCB, and 
get:baCLOSING STA
get:baLAST-ACK ST
get:baIf the RS
get:baTCB, and 
get:ba[Page 70]        
get:baSeptember 1981   
get:bathird check s
get:baSYN-RECEIVE
get:baIf the se
get:baexactly m
get:bathen send
get:baESTABLISHED
get:baIf the se
get:baexactly m
get:bathen send
get:bareceive "
get:baflushed. 
get:ba"connecti
get:baTCB, and 
get:baNote this c
get:baa segment f
get:badifferent s
get:bacurrent con
get:bafourth, check
get:baSYN-RECEIVE
get:baESTABLISHED
get:baFIN-WAIT ST
get:baFIN-WAIT ST
get:baCLOSE-WAIT 
get:baCLOSING STA
get:baLAST-ACK ST
get:baTIME-WAIT S
get:baIf the SY
get:baoutstandi
get:baall segme
get:bareceive a
get:bathe CLOSE
get:baIf the SY
get:baand an ac
get:banumber ch
get:baTransmission Cont
get:baFunctional Specif
get:bafifth check t
get:baif the ACK 
get:baif the ACK 
get:baSYN-RECEI
get:baIf SND.
get:baand con
get:baIf th
get:bareset
get:ba<SE
get:baand s
get:baESTABLISH
get:baIf SND.
get:baAny seg
get:baentirel
get:bapositiv
get:bafully a
get:ba"ok" re
get:ba(SEG.AC
get:basomethi
get:badrop th
get:baIf SND.
get:baupdated
get:baSND.WL2
get:baSND.WL1
get:baNote th
get:barecords
get:baSND.WND
get:bathe las
get:baprevent
get:ba[Page 72]        
get:baSeptember 1981   
get:baFIN-WAIT-
get:baIn addi
get:baour FIN
get:baprocess
get:baFIN-WAIT-
get:baIn addi
get:bathe ret
get:baacknowl
get:baCLOSE-WAI
get:baDo the 
get:baCLOSING S
get:baIn addi
get:bathe ACK
get:baotherwi
get:baLAST-ACK 
get:baThe onl
get:baacknowl
get:badelete 
get:baTIME-WAIT
get:baThe onl
get:baretrans
get:bathe 2 M
get:basixth, check 
get:baESTABLISHED
get:baFIN-WAIT-1 
get:baFIN-WAIT-2 
get:baIf the UR
get:bathe user 
get:bapointer (
get:bauser has 
get:bamode") fo
get:basignal th
get:baTransmission Cont
get:baFunctional Specif
get:baCLOSE-WAIT 
get:baCLOSING STA
get:baLAST-ACK ST
get:baThis shou
get:baremote si
get:baseventh, proc
get:baESTABLISHED
get:baFIN-WAIT-1 
get:baFIN-WAIT-2 
get:baOnce in t
get:batext to u
get:bainto buff
get:baempty.  I
get:bathe user 
get:bahas been 
get:baWhen the 
get:bauser it m
get:baOnce the 
get:baRCV.NXT o
get:baapporopri
get:baRCV.NXT a
get:baPlease no
get:baSend an a:cknowledgment of the form
get:ba<SEQ=SN
get:baThis ackn
get:batransmitt
get:ba[Page 74]        
get:baSeptember 1981   
get:baCLOSE-WAIT 
get:baCLOSING STA
get:baLAST-ACK ST
get:baTIME-WAIT S
get:baThis shou
get:baremote si
get:baeighth, check
get:baDo not proc
get:basince the S
get:baIf the FIN 
get:bareturn any 
get:baover the FI
get:baFIN implies
get:baSYN-RECEI
get:baESTABLISH
get:baEnter t
get:baFIN-WAIT-
get:baIf our 
get:baenter T
get:batimers;
get:baFIN-WAIT-
get:baEnter t
get:baoff the
get:baCLOSE-WAI
get:baRemain 
get:baCLOSING S
get:baRemain 
get:baLAST-ACK 
get:baRemain 
get:baTransmission Cont
get:baFunctional Specif
get:baTIME-WAIT
get:baRemain 
get:batimeout
get:ba[Page 76]        
get:baSeptember 1981   
get:baFor any state
get:bathe user "err:or
get:baand for any o
get:bastate and ret
get:baRETRANSMISSION 
get:baFor any state
get:bathe retransmi
get:baretransmissio
get:baTIME-WAIT TIMEO
get:baIf the time-w
get:baenter the CLO
get:baTransmission Cont
get:ba[Page 78]        
get:baSeptember 1981   
get:baBBN Rep
get:baa Host 
get:bahost an
get:baA contr
get:baindicat
get:baspecifi
get:bais expe
get:bapreviou
get:baThe uni
get:baARPANET
get:baA unit 
get:baIMPs.  
get:baA logic
get:baA messa
get:banetwork
get:baDestination Addre
get:baThe des
get:baidentif
get:baA contr
get:baindicat
get:baoccupyi
get:baA porti
get:bafragmen
get:baA file 
get:baTransmission Cont
get:baControl
get:bafragmen
get:baA compu
get:bafrom th
get:baAn Inte
get:baby the 
get:baThe Int
get:baARPANET
get:baA sourc
get:bainternet datagram
get:baThe uni
get:bahigher 
get:bainternet fragment
get:baA porti
get:baheader.
get:baInterne
get:baThe Ini
get:banumber 
get:baThe Ini
get:baon a co
get:babased p
get:baThe Ini
get:baused by
get:baControl
get:badata.  
get:baon an A
get:ba[Page 80]        
get:baSeptember 1981   
get:baThis is
get:badata re
get:basequenc
get:baof the 
get:baThe uni
get:baAn impl
get:baprocedu
get:baMaximum
get:bathe int
get:baAn eigh
get:baAn Opti
get:bamay be 
get:baprimari
get:batimesta
get:baoptions
get:baA packa
get:balogical
get:balogical
get:baThe por
get:baoutput 
get:baA progr
get:bathe poi
get:baA contr
get:bathis se
get:bareceivi
get:bareceive
get:baTransmission Cont
get:bareceive
get:RFC
get:De
get:I
get:September 1981   
get:PREFACE .....
get:1.  INTRODUCTION 
get:1.1  Motivation
get:1.2  Scope ....
get:1.3  About This
get:1.4  Interfaces
get:1.5  Operation 
get:2.  PHILOSOPHY ..
get:2.1  Elements o
get:2.2  Model of O
get:2.3  The Host E
get:2.4  Interfaces
get:2.5  Relation t
get:2.6  Reliable C
get:2.7  Connection
get:2.8  Data Commu
get:2.9  Precedence
get:2.10 Robustness
get:3.  FUNCTIONAL SP
get:3.1  Header For
get:3.2  Terminolog
get:3.3  Sequence N
get:3.4  Establishi
get:3.5  Closing a 
get:3.6  Precedence
get:3.7  Data Commu
get:3.8  Interfaces
get:3.9  Event Proc
get:GLOSSARY ........
get:REFERENCES ......
get:Transmission Cont
get:[Page ii]        
get:September 1981   
get:This document des
get:(TCP).  There hav
get:specification on 
get:draws heavily fro
get:both in terms of 
get:several details a
get:and redescribes t
get:RFC
get:Replaces: RFC 761
get:IENs:  129, 124, 
get:55, 44, 40, 27, 2
get:The Transmission 
get:reliable host-to-
get:communication net
get:This document des
get:Transmission Cont
get:interface to prog
get:Computer commun
get:role in militar
get:document focuse
get:communication r
get:communication u
get:congestion, but
get:government sect
get:As strategic an
get:developed and d
get:interconnecting
get:communication p
get:applications.  
get:Deputy Undersec
get:declared the Tr
get:be a basis for 
get:standardization
get:TCP is a connec
get:fit into a laye
get:applications.  
get:communication b
get:distinct but in
get:assumptions are
get:protocols below
get:potentially unr
get:protocols.  In 
get:wide spectrum o
get:connections to 
get:Transmission Cont
get:TCP is based on
get:TCP fits into a
get:Internet Protoc
get:receive variabl
get:datagram "envel
get:addressing sour
get:internet protoc
get:the TCP segment
get:multiple networ
get:also carries in
get:and compartment
get:communicated en
get:Much of this do
get:which are co-re
get:computer.  Some
get:front-end compu
get:as well as netw
get:an interface to
get:implementable e
get:host-to-front e
get:The TCP is inte
get:communication s
get:intended to be 
get:1.3.  About this 
get:This document r
get:any TCP impleme
get:protocols and i
get:[Page 2]         
get:September 1981   
get:section offers 
get:operation.  Sec
get:design.  Sectio
get:required of TCP
get:user calls, err
get:The TCP interfa
get:the other side 
get:The interface b
get:illustrated in 
get:calls much like
get:application pro
get:calls to open a
get:established con
get:asynchronously 
get:considerable fr
get:interfaces whic
get:environment, a 
get:interface for a
get:The interface b
get:unspecified exc
get:two levels can 
get:Typically, one 
get:interface.  TCP
get:interconnected 
get:throughout this
get:As noted above,
get:securable logic
get:processes.  To 
get:communication s:ystem requires facilities in the following areas
get:Basic Data Tr
get:Precedence an
get:The basic opera
get:the following p
get:Transmission Cont
get:Basic Data Tran:sfer
get:The TCP is ab
get:direction bet
get:segments for 
get:the TCPs deci
get:Sometimes use
get:submitted to 
get:function is d
get:actually tran
get:pushed throug
get:promptly forw
get:The exact pus
get:the push func
get:Reliability
get:The TCP must 
get:delivered out
get:is achieved b
get:transmitted, 
get:receiving TCP
get:interval, the
get:numbers are u
get:out of order 
get:adding a chec
get:receiver, and
get:As long as th
get:system does n
get:errors will a
get:internet comm
get:Flow Control
get:TCP provides 
get:sent by the s
get:every ACK ind
get:the last segm
get:allowed numbe
get:receiving fur
get:[Page 4]         
get:September 1981   
get:Multiplexing
get:To allow for 
get:communication
get:addresses or 
get:and host addr
get:a socket.  A 
get:That is, a so
get:The binding o
get:Host.  Howeve
get:(e.g., a "log
get:made known to
get:through the k
get:addresses of 
get:Connections
get:The reliabili
get:that TCPs ini
get:each data str
get:sockets, sequ
get:Each connecti
get:identifying i
get:When two proc
get:establish a c
get:side).  When 
get:terminated or
get:Since connect
get:over the unre
get:mechanism wit
get:erroneous ini
get:Precedence and :Security
get:The users of 
get:communication
get:these feature
get:Transmission Cont
get:[Page 6]         
get:September 1981   
get:2.1.  Elements of
get:The internetwor
get:which are in tu
get:that the networ
get:large networks 
get:packet switchin
get:consume message
get:networks, the g
get:communication s
get:connections bet
get:The term packet
get:transaction bet
get:exchanged withi
get:Hosts are compu
get:network's point
get:Processes are v
get:accordance with
get:in execution). 
get:viewed as commu
get:Thus, all commu
get:Since a process
get:streams between
get:that each proce
get:communicates wi
get:2.2.  Model of Op
get:Processes trans
get:data as argumen
get:segments and ca
get:the destination
get:into the receiv
get:TCPs include co
get:ensure reliable
get:The model of in
get:protocol module
get:to the local ne
get:inside internet
get:internet module
get:through the loc
get:The packet swit
get:Transmission Cont
get:other operation
get:destination int
get:At a gateway be
get:from its local 
get:the internet da
get:then "wrapped" 
get:routed to the n
get:A gateway is pe
get:internet datagr
get:through the nex
get:internet datagr
get:further broken 
get:internet datagr
get:internet module
get:A destination i
get:(after reassemb
get:destination TCP
get:This simple mod
get:important featu
get:to the gateway 
get:service paramet
get:Included in the
get:datagram.  Data
get:host and gatewa
get:properly segreg
get:2.3.  The Host En
get:The TCP is assu
get:access the TCP 
get:may call on oth
get:data structures
get:controlled by a
get:network device 
get:datagram protoc
get:The mechanisms 
get:front-end proce
get:host-to-front-e
get:the type of TCP
get:[Page 8]         
get:September 1981   
get:The TCP/user in
get:to OPEN or CLOS
get:STATUS about a 
get:programs on the
get:from, and close
get:The TCP/interne
get:datagrams addre
get:system.  These 
get:service, preced
get:2.5.  Relation to
get:The following d
get:hierarchy
get:+------+ +
get:|Telnet| |
get:+------+ +
get:|   
get:+----
get:| TCP
get:+----
get:| 
get:+----
get:|    
get:+----
get:+--
get:|  
get:+--
get:It is expected 
get:protocols effic
get:protocols like 
get:2.6.  Reliable Co
get:A stream of dat
get:order at the de
get:Transmission Cont
get:Transmission is
get:acknowledgments
get:sequence number
get:segment is tran
get:sequence number
get:is the sequence
get:transmissions i
get:segment contain
get:starts a timer;
get:segment is dele
get:received before
get:An acknowledgme
get:delivered to th
get:the responsibil
get:To govern the f
get:employed.  The 
get:This window spe
get:acknowledgment 
get:2.7.  Connection 
get:To identify the
get:provides a port
get:independently b
get:unique addresse
get:identifying the
get:will be unique 
get:A connection is
get:local socket ma
get:sockets.  A con
get:that is, it is 
get:TCPs are free t
get:However, severa
get:There must be w
get:the "appropriat
get:may "own" ports
get:the ports they 
get:issue, but we e
get:uniquely alloca
get:associating the
get:A connection is
get:foreign socket 
get:[Page 10]        
get:September 1981   
get:connection name
get:subsequent call
get:about a connect
get:is a data struc
get:implementation 
get:pointer to the 
get:whether the con
get:be passively wa
get:A passive OPEN 
get:connection requ
get:Often the proce
get:request from an
get:is used to deno
get:are allowed onl
get:A service proce
get:processes would
get:foreign socket.
get:requested a con
get:local socket we
get:Well-known sock
get:a socket addres
get:"Telnet-Server"
get:socket, and oth
get:Entry, Text Gen
get:being for test 
get:access to a "Lo
get:at which a newl
get:well-known sock
get:of sockets to s
get:Processes can i
get:from other proc
get:been establishe
get:other at the sa
get:is critical for
get:components act 
get:There are two p
get:passive OPENs a
get:local passive O
get:case, the match
get:OPENs has left 
get:foreign socket 
get:Other possibili
get:Transmission Cont
get:If there are se
get:same local sock
get:with the specif
get:TCB exists, bef
get:The procedures 
get:control flag an
get:exchange has be
get:A connection is
get:containing a SY
get:command.  The m
get:connection has 
get:when sequence n
get:The clearing of
get:in this case ca
get:2.8.  Data Commun
get:The data that f
get:octets.  The se
get:in that call (a
get:through to the 
get:A sending TCP i
get:send that data 
get:function is sig
get:receiving TCP s
get:the sending TCP
get:There is no nec
get:boundaries.  Th
get:single SEND cal
get:The purpose of 
get:from the sendin
get:record service.
get:There is a coup
get:of data that cr
get:associated with
get:buffer is retur
get:not filled.  If
get:PUSH is seen, t
get:TCP also provid
get:at some point f
get:[Page 12]        
get:September 1981   
get:currently readi
get:define what the
get:urgent data, bu
get:take action to 
get:2.9.  Precedence 
get:The TCP makes u
get:security option
get:basis to TCP us
get:a multilevel se
get:use only, and o
get:compartment.  C
get:users may be li
get:TCP modules whi
get:properly mark o
get:precedence.  Su
get:higher level pr
get:them to specify
get:precedence of c
get:2.10.  Robustness
get:TCP implementat:ions will follow a general principle of robustness
get:conservative in
get:Transmission Cont
get:[Page 14]        
get:September 1981   
get:3.1.  Header Form
get:TCP segments ar
get:header carries 
get:destination hos
get:header, supplyi
get:division allows
get:TCP Header Form
get:0            
get:0 1 2 3 4 5 6
get:+-+-+-+-+-+-+-
get:|          Sou
get:+-+-+-+-+-+-+-
get:|             
get:+-+-+-+-+-+-+-
get:|             
get:+-+-+-+-+-+-+-
get:|  Data |     
get:| Offset| Rese
get:|       |     
get:+-+-+-+-+-+-+-
get:|           Ch
get:+-+-+-+-+-+-+-
get:|             
get:+-+-+-+-+-+-+-
get:|             
get:+-+-+-+-+-+-+-
get:Note th
get:Source Port:  1
get:The source po
get:Destination Por:t
get:The destinati
get:Transmission Cont
get:Functional Specif
get:Sequence Number:
get:The sequence 
get:when SYN is p
get:initial seque
get:Acknowledgment :Number
get:If the ACK co
get:next sequence
get:receive.  Onc
get:Data Offset:  4
get:The number of
get:the data begi
get:integral numb
get:Reserved:  6 bi
get:Reserved for 
get:Control Bits:  :6 bits (from left to right)
get:URG:  Urgent 
get:ACK:  Acknowl
get:PSH:  Push Fu
get:RST:  Reset t
get:SYN:  Synchro
get:FIN:  No more
get:Window:  16 bit
get:The number of
get:acknowledgmen
get:Checksum:  16 b
get:The checksum 
get:complement su
get:segment conta
get:checksummed, 
get:form a 16 bit
get:transmitted a
get:the checksum 
get:The checksum 
get:[Page 16]        
get:September 1981   
get:prefixed to t
get:Address, the 
get:This gives th
get:information i
get:across the TC
get:calls by the 
get:The TCP Len
get:octets (thi
get:computed), 
get:Urgent Pointer:
get:This field co
get:positive offs
get:urgent pointe
get:the urgent da
get:the URG contr
get:Options:  varia
get:Options may o
get:multiple of 8
get:checksum.  An
get:cases for the: format of an option
get:Case 1:  A 
get:Case 2:  An
get:th
get:The option-le
get:option-length
get:Note that the
get:field might i
get:End-of-Option
get:A TCP must im
get:Transmission Cont
get:Functional Specif
get:Currently def:ined options include (kind indicated in octal)
get:Kind     Le
get:----     --
get:0         
get:1         
get:2         
get:Specific Opti
get:End of Opti
get:+--------
get:|00000000
get:+--------
get:This opti
get:might not
get:the Data 
get:not the e
get:the optio
get:No-Operatio
get:+--------
get:|00000001
get:+--------
get:This opti
get:align the
get:There is 
get:receivers
get:not begin
get:Maximum Seg
get:+--------
get:|00000010
get:+--------
get:Kind=2  
get:[Page 18]        
get:September 1981   
get:Maximum S:egment Size Option Data
get:If this
get:receive
get:This fi
get:(i.e., 
get:option 
get:Padding:  varia
get:The TCP heade
get:and data begi
get:3.2.  Terminology
get:Before we can d
get:to introduce so
get:connection requ
get:of these variab
get:Transmission Co
get:TCB are the loc
get:precedence of t
get:buffers, pointe
get:In addition sev
get:sequence number
get:Send Sequence
get:SND.UNA - s
get:SND.NXT - s
get:SND.WND - s
get:SND.UP  - s
get:SND.WL1 - s
get:SND.WL2 - s
get:u
get:ISS     - i
get:Receive Seque
get:RCV.NXT - r
get:RCV.WND - r
get:RCV.UP  - r
get:IRS     - i
get:Transmission Cont
get:Functional Specif
get:The following d
get:the sequence sp
get:Send Sequence S
get:---
get:1 - old s
get:2 - seque
get:3 - seque
get:4 - futur
get:The send window
get:Receive Sequenc
get:1 - old s
get:2 - seque
get:3 - futur
get:The receive win
get:There are also 
get:take their valu
get:[Page 20]        
get:September 1981   
get:Current Segme
get:SEG.SEQ - s
get:SEG.ACK - s
get:SEG.LEN - s
get:SEG.WND - s
get:SEG.UP  - s
get:SEG.PRC - s
get:A connection pr
get:lifetime.  The :states are
get:ESTABLISHED, FI
get:TIME-WAIT, and 
get:because it repr
get:no connection. : Briefly the meanings of the states are
get:LISTEN - repr
get:TCP and port.
get:SYN-SENT - re
get:after having 
get:SYN-RECEIVED 
get:request ackno
get:connection re
get:ESTABLISHED -
get:delivered to 
get:of the connec
get:FIN-WAIT-1 - 
get:from the remo
get:termination r
get:FIN-WAIT-2 - 
get:from the remo
get:CLOSE-WAIT - 
get:from the loca
get:CLOSING - rep
get:acknowledgmen
get:LAST-ACK - re
get:connection te
get:(which includ
get:Transmission Cont
get:Functional Specif
get:TIME-WAIT - r
get:the remote TC
get:termination r
get:CLOSED - repr
get:A TCP connectio
get:events.  The ev
get:ABORT, and STAT
get:containing the 
get:The state diagr
get:with the causin
get:error condition
get:changes.  In a 
get:the reaction of
get:NOTE BENE:  thi
get:the total speci
get:[Page 22]        
get:September 1981   
get:+---------+     
get:|         |<----
get:|   SYN   |     
get:|   RCVD  |<----
get:|         |     
get:|         |-----
get:+---------+   rc
get:|           --
get:|             
get:|             
get:|  CLOSE      
get:| -------     
get:| snd FIN     
get:|             
get:V             
get:+---------+     
get:|  FIN    |<----
get:| WAIT-1  |-----
get:+---------+     
get:| rcv ACK of F
get:| ------------
get:V        x    
get:+---------+     
get:|FINWAIT-2|     
get:+---------+     
get:|             
get:|  rcv FIN    
get:|  -------    
get:\ snd ACK    
get:------------
get:Transmission Cont
get:Functional Specif
get:3.3.  Sequence Nu
get:A fundamental n
get:over a TCP conn
get:sequenced, each
get:mechanism emplo
get:number X indica
get:received.  This
get:detection in th
get:within a segmen
get:the header is t
get:numbered consec
get:It is essential
get:finite, though 
get:Since the space
get:numbers must be
get:preserves the r
get:2**32 - 1 to 0 
get:arithmetic, so 
get:comparison of s
get:(modulo 2**32).
get:The typical kin
get:perform include:
get:(a)  Determin
get:number s
get:(b)  Determin
get:have bee
get:retransm
get:(c)  Determin
get:which ar
get:receive 
get:[Page 24]        
get:September 1981   
get:In response to 
get:following compa
get:SND.UNA = old
get:SND.NXT = nex
get:SEG.ACK = ack
get:num
get:SEG.SEQ = fir
get:SEG.LEN = the
get:(co
get:SEG.SEQ+SEG.L
get:A new acknowled
get:the inequality :below holds
get:SND.UNA < SEG
get:A segment on th
get:of its sequence
get:acknowledgment 
get:When data is re:ceived the following comparisons are needed
get:RCV.NXT = nex
get:is the le
get:RCV.NXT+RCV.W
get:segment, 
get:SEG.SEQ = fir
get:SEG.SEQ+SEG.L
get:A segment is ju
get:RCV.NXT =< SE
get:RCV.NXT =< SE
get:Transmission Cont
get:Functional Specif
get:The first part 
get:segment falls i
get:if the end of t
get:either part of 
get:Actually, it is
get:windows and zer
get:acceptability o:f an incoming segment
get:Segment Recei
get:Length  Windo
get:------- -----
get:0       0 
get:0      >0 
get:>0       0 
get:>0      >0 
get:Note that when 
get:acceptable exce
get:maintain a zero
get:ACKs.  However,
get:process the RST
get:We have taken a
get:control informa
get:some control fl
get:and acknowledge
get:control will be
get:carried in the 
get:for implicitly 
get:are the only co
get:are used only a
get:purposes, the S
get:octet of the se
get:to occur after 
get:occurs.  The se
get:space occupying
get:sequence number
get:[Page 26]        
get:September 1981   
get:Initial Sequenc
get:The protocol pl
get:used over and o
get:sockets.  New i
get:incarnations of
get:-- "how does th
get:incarnations of
get:connection is b
get:connection brea
get:To avoid confus
get:connection from
get:be present in t
get:assure this, ev
get:sequence number
get:an initial sequ
get:new 32 bit ISN.
get:bit clock whose
get:microseconds.  
get:Since we assume
get:the Maximum Seg
get:hours we can re
get:For each connec
get:sequence number
get:the data sendin
get:learned during 
get:For a connectio
get:synchronize on 
get:an exchange of 
get:called "SYN" (f
get:shorthand, segm
get:Hence, the solu
get:initial sequenc
get:The synchroniza
get:sequence number
get:from the other 
get:initial sequenc
get:1) A --> B  S
get:2) A <-- B  A
get:3) A <-- B  S
get:4) A --> B  A
get:Transmission Cont
get:Functional Specif
get:Because steps 2
get:called the thre
get:A three way han
get:tied to a globa
get:mechanisms for 
get:no way of knowi
get:unless it remem
get:(which is not a
get:verify this SYN
get:clock-driven sc
get:Knowing When to
get:To be sure that
get:sequence number
get:the network, th
get:(MSL) before as
get:recovering from
get:lost.  For this
get:is an engineeri
get:it is desirable
get:sense, yet reta
get:not wait at all
get:than those rece
get:The TCP Quiet T
get:This specific
get:retaining any
get:each active (
get:TCP segments 
get:in the intern
get:paragraphs be
get:TCP implement
get:at the risk o
get:data rejected
get:TCPs consume 
get:entered into 
get:duplicate det
get:relies on the
get:the extent th
get:values before
get:been delivere
get:copies of the
get:such an assum
get:[Page 28]        
get:September 1981   
get:assigned the 
get:at the receiv
get:that each seg
get:as there are 
get:Under normal 
get:to emit and t
get:mistakenly us
get:been acknowle
get:data is drain
get:very large to
get:cause trouble
get:to use up 2**
get:lifetime in t
get:this is deeme
get:rates escalat
get:cycle time is
get:within reason
get:The basic dup
get:defeated, how
get:sequence numb
get:the TCP were 
get:upon crashing
get:connection (p
get:packets with 
get:packets still
get:incarnation o
get:about the seq
get:specification
get:before emitti
get:segments from
get:Even hosts wh
get:initial seque
get:(i.e., even i
get:number for ea
get:Suppose, for 
get:sequence numb
get:and that even
get:takes on a va
get:segment sent 
get:at this insta
get:incarnation o
get:S1 = ISN(t) -
get:connection!  
get:Transmission Cont
get:Functional Specif
get:duplicates in
get:of S1 may arr
get:the new incar
get:The problem i
get:crashed nor d
get:the system fr
get:One way to de
get:segments for 
get:time" specifi
get:willing to ri
get:destination m
get:Implementors 
get:connection by
get:informally im
get:Obviously, ev
get:necessary aft
get:To summarize:
get:numbers in th
get:"busy" or "in
get:block of spac
get:segment, if a
get:sequence numb
get:the previous 
get:number overla
get:3.4.  Establishin
get:The "three-way 
get:connection.  Th
get:responded to by
get:simultaneously 
get:occurs, each TC
get:acknowledgment 
get:an old duplicat
get:recipient, that
get:Proper use of "
get:Several example
get:examples do not
get:segments, this 
get:doesn't deliver
get:valid (i.e., th
get:connection reac
get:reduces the pos
get:[Page 30]        
get:September 1981   
get:implementation 
get:information for
get:The simplest th
get:figures should 
get:numbered for re
get:departure of a 
get:segment at B fr
get:Ellipsis (...) 
get:(delayed).  An 
get:Comments appear
get:the departure o
get:the center of e
get:form, with sequ
get:fields such as 
get:in the interest
get:TCP A      
get:1.  CLOSED     
get:2.  SYN-SENT   
get:3.  ESTABLISHED
get:4.  ESTABLISHED
get:5.  ESTABLISHED
get:Basic 3
get:In line 2 of fi
get:indicating that
get:number 100.  In
get:received from T
get:B is now expect
get:occupied sequen
get:At line 4, TCP 
get:TCP B's SYN; an
get:sequence number
get:because the ACK
get:would wind up A
get:Transmission Cont
get:Functional Specif
get:Simultaneous in
get:figure 8.  Each
get:TCP A      
get:1.  CLOSED     
get:2.  SYN-SENT   
get:3.  SYN-RECEIVE
get:4.             
get:5.  SYN-RECEIVE
get:6.  ESTABLISHED
get:7.             
get:S
get:The principle r
get:duplicate conne
get:this, a special
get:receiving TCP i
get:SYN-RECEIVED), 
get:If the TCP is i
get:FIN-WAIT-1, FIN
get:aborts the conn
get:case under "hal
get:[Page 32]        
get:September 1981   
get:TCP A      
get:1.  CLOSED     
get:2.  SYN-SENT   
get:3.  (duplicate)
get:4.  SYN-SENT   
get:5.  SYN-SENT   
get:6.             
get:7.  SYN-SENT   
get:8.  ESTABLISHED
get:As a simple exa
get:figure 9.  At l
get:cannot tell tha
get:(line 4).  TCP 
get:RST (reset) wit
get:believable.  TC
get:When the origin
get:synchronization
get:before the RST,
get:sent in both di
get:Half-Open Conne
get:An established 
get:TCPs has closed
get:knowledge of th
get:become desynchr
get:memory.  Such c
get:attempt is made
get:connections are
get:mildly involved
get:If at site A th
get:Transmission Cont
get:Functional Specif
get:user at site B 
get:receiving a res
get:site B TCP that
get:Assume that two
get:another when a 
get:Depending on th
get:that some error
get:A is likely to 
get:point.  As a re
get:or try to SEND 
get:case, it receiv
get:local (A's) TCP
get:will send a seg
get:example shown i
get:re-open the con
get:TCP A      
get:1.  (CRASH)    
get:2.  CLOSED     
get:3.  SYN-SENT --
get:4.  (!!)     <-
get:5.  SYN-SENT --
get:6.  SYN-SENT   
get:7.  SYN-SENT --
get:When the SYN ar
get:and the incomin
get:acknowledgment 
get:100).  TCP A se
get:sent and, being
get:detected a half
get:[Page 34]        
get:September 1981   
get:continue to try
get:reduced to the 
get:An interesting 
get:tries to send d
get:This is illustr
get:TCP A from TCP 
get:exists, so TCP 
get:processes it an
get:TCP A    
get:1.  (CRASH)    
get:2.  (??)    <--
get:3.          -->
get:Active
get:In figure 12, w
get:waiting for SYN
get:into action.  A
get:generate a RST 
get:the reset and r
get:TCP A      
get:1.  LISTEN     
get:2.       ... <S
get:3.  (??) <-- <S
get:4.       --> <S
get:5.  LISTEN     
get:Old Duplic
get:Transmission Cont
get:Functional Specif
get:A variety of ot
get:by the followin
get:Reset Generatio
get:As a general ru
get:which apparentl
get:must not be sen
get:There are three: groups of states
get:1.  If the co
get:in response t
get:particular, S
get:by this means
get:If the incomi
get:sequence numb
get:reset has seq
get:of the sequen
get:The connectio
get:2.  If the co
get:SYN-SENT, SYN
get:something not
get:if an incomin
get:does not exac
get:connection, a
get:If our SYN ha
get:incoming segm
get:either raise 
get:the system) o
get:incoming segm
get:continue as i
get:cannot raise 
get:detected in t
get:terminated th
get:incoming segm
get:match the loc
get:must be sent.
get:If the incomi
get:sequence numb
get:reset has seq
get:of the sequen
get:The connectio
get:[Page 36]        
get:September 1981   
get:3.  If the co
get:FIN-WAIT-1, F
get:any unaccepta
get:unacceptible 
get:acknowledgmen
get:and an acknow
get:to be receive
get:If an incomin
get:precedence wh
get:and precedenc
get:connection go
get:number from t
get:Reset Processin
get:In all states e
get:by checking the
get:is in the windo
get:to an initial S
get:acknowledges th
get:The receiver of
get:receiver was in
get:in SYN-RECEIVED
get:then the receiv
get:aborts the conn
get:was in any othe
get:and goes to the
get:3.5.  Closing a C
get:CLOSE is an ope
get:notion of closi
get:interpretation,
get:the receiving s
get:in a simplex fa
get:until he is tol
get:could initiate 
get:RECEIVE until s
get:has CLOSED.  We
get:RECEIVEs are ou
get:can terminate h
get:buffers SENT be
get:data in return 
get:successfully to
get:TCP.  Users mus
get:the TCP says no
get:Transmission Cont
get:Functional Specif
get:There are essen:tially three cases
get:1) The user i
get:2) The remote
get:3) Both users
get:Case 1:  Local 
get:In this case,
get:outgoing segm
get:accepted by t
get:are allowed i
get:will be retra
get:both acknowle
get:can ACK this 
get:send its own 
get:Case 2:  TCP re
get:If an unsolic
get:can ACK it an
get:user will res
get:the other TCP
get:until its own
get:connection.  
get:the connectio
get:Case 3:  both u
get:A simultaneou
get:FIN segments 
get:have been pro
get:has received.
get:[Page 38]        
get:September 1981   
get:TCP A      
get:1.  ESTABLISHED
get:FIN-WAIT-1 
get:3.  FIN-WAIT-2 
get:4.             
get:TIME-WAIT  
get:5.  TIME-WAIT  
get:CLOSED     
get:TCP A      
get:1.  ESTABLISHED
get:2.  (Close)    
get:FIN-WAIT-1 
get:3.  CLOSING    
get:4.  TIME-WAIT  
get:(2 MSL)    
get:CLOSED     
get:Transmission Cont
get:Functional Specif
get:3.6.  Precedence 
get:The intent is t
get:with exactly th
get:higher of the p
get:The precedence 
get:defined in the 
get:specification t
get:the security pa
get:user group, and
get:A connection at
get:lower precedenc
get:a connection du
get:acknowledgment 
get:Note that TCP m
get:precedence will
get:segments and po
get:The security pa
get:(the values wou
get:non-secure envi
get:parameters, tho
get:3.7.  Data Commun
get:Once the connec
get:exchange of seg
get:(checksum test 
get:retransmission 
get:Duplicate segme
get:As discussed in
get:certain tests o
get:segments to ver
get:The sender of d
get:the variable SN
get:sequence number
get:keeps track of 
get:variable SND.UN
get:sent has been a
get:When the sender
get:SND.NXT.  When 
get:sends an acknow
get:[Page 40]        
get:September 1981   
get:acknowledgment 
get:these variables
get:The amount by w
get:data in the seg
get:segments must c
get:The CLOSE user 
get:flag in an inco
get:Retransmission 
get:Because of the 
get:internetwork sy
get:retransmission 
get:for determining
get:An Example Re
get:Measure the
get:particular 
get:covers that
get:segments re
get:Time (RTT).:  Next compute a Smoothed Round Trip Time (SRTT) as
get:SRTT = ( 
get:and based o:n this, compute the retransmission timeout (RTO) as
get:RTO = min
get:where UBOUN
get:LBOUND is a
get:a smoothing
get:factor (e.g
get:The Communicati
get:The objective o
get:to stimulate th
get:permit the rece
get:the currently k
get:This mechanism 
get:the end of urge
get:the receive seq
get:must tell the u
get:number catches 
get:Transmission Cont
get:Functional Specif
get:into "normal mo
get:is in "urgent m
get:The method empl
get:transmitted.  T
get:meaningful and 
get:the urgent poin
get:no urgent data 
get:To send an urge
get:octet.  If the 
get:the urgent info
get:Managing the Wi
get:The window sent
get:numbers the sen
get:prepared to acc
get:the currently a
get:Indicating a la
get:arrives than ca
get:in excessive re
get:network and the
get:transmission of
get:between each ne
get:The mechanisms 
get:subsequently ad
get:that much data.
get:discouraged.  T
get:shrink the wind
get:on the part of 
get:The sending TCP
get:least one octet
get:sending TCP mus
get:the window is z
get:interval when t
get:guarantee that 
get:window will be 
get:When the receiv
get:still send an a
get:and current win
get:The sending TCP
get:[Page 42]        
get:September 1981   
get:which fit the c
get:retransmission 
get:In a connection
get:be carried in a
get:number so there
get:order.  This is
get:information to 
get:the data receiv
get:the window info
get:acknowledgment 
get:equal or greate
get:The window mana
get:communication p
get:Window Manage
get:Allocating 
get:many small 
get:fewer large
get:One suggest
get:defer updat
get:least X per
get:connection 
get:Another sug
get:segments by
get:sending dat
get:data must b
get:Note that t
get:retransmiss
get:acknowledgm
get:window info
get:new window 
get:The segment
get:of transmit
get:segment con
get:is accepted
get:If the send
get:window is n
get:alternating
get:pauses in t
get:Transmission Cont
get:Functional Specif
get:result in b
get:big pair. A
get:mostly smal
get:The suggest
get:actively at
get:windows, si
get:to many sma
get:There are of co:urse two interfaces of concern
get:and the TCP/low
get:of the user/TCP
get:protocol module
get:in detail by th
get:case that the l
get:that TCPs might
get:User/TCP Interf
get:The following
get:at best, fict
get:facilities.  
get:implementatio
get:TCPs must pro
get:that all TCP 
get:hierarchy.  T
get:required of a
get:TCP User Comm
get:The followi
get:interface. 
get:function ca
get:meant to ru
get:The user co
get:TCP must pe
get:Individual 
get:may provide
get:single call
get:automatical
get:issued by t
get:[Page 44]        
get:September 1981   
get:In providin
get:not only ac
get:processes i:t serves.  The latter consists of
get:(a) gener
get:remote cl
get:(b) repli
get:various t
get:Format:  
get:[, timeou
get:-> local 
get:We assume
get:processes
get:to use th
get:implement
get:for the s
get:lower lev
get:result of
get:able to m
get:process c
get:If the ac
get:call to L
get:have eith
get:particula
get:for any c
get:by the su
get:A transmi
get:filled in
get:On an act
get:synchroni
get:The timeo
get:for all d
get:delivered
get:will abor
get:The TCP o
get:the users
get:Transmission Cont
get:Functional Specif
get:precedenc
get:or securi
get:the defau
get:TCP will 
get:security/
get:the prece
get:requested
get:The prece
get:requested
get:request, 
get:connectio
get:this prec
get:allowed t
get:or that a
get:A local c
get:The local
get:for the c
get:Format:  
get:count, PU
get:This call
get:to be sen
get:not been 
get:implement
get:automatic
get:authorize
get:If the PU
get:to the re
get:segment c
get:the data 
get:transmiss
get:If the UR
get:will have
get:the urgen
get:pointer i
get:been cons
get:is to sti
get:indicate 
get:[Page 46]        
get:September 1981   
get:data has 
get:TCP signa
get:of times 
get:urgent da
get:If no for
get:connectio
get:has becom
get:local soc
get:foreign s
get:foreign s
get:knowing t
get:However, 
get:becomes s
get:STATUS ca
get:implement
get:socket is
get:If a time
get:connectio
get:In the si
get:the sendi
get:or the ti
get:is both s
get:connectio
get:offers po
get:sophistic
get:the proce
get:furthermo
get:Multiple 
get:the TCP w
get:We have i
get:which a S
get:pseudo-in
get:return a 
get:immediate
get:been ackn
get:assume ev
get:close any
get:kind (syn
get:signals, 
get:with spec
get:In order 
get:indicatio
get:Transmission Cont
get:Functional Specif
get:buffer ad
get:the SEND 
get:indicatin
get:calling p
get:Format:  
get:count) ->
get:This comm
get:specified
get:calling p
get:error is 
get:In the si
get:calling p
get:error occ
get:A more so
get:RECEIVEs 
get:segments 
get:the cost 
get:notify th
get:If enough
get:the PUSH 
get:The buffe
get:a PUSH is
get:returned 
get:If there 
get:as it arr
get:should th
get:additiona
get:call to R
get:may now l
get:urgent po
get:in the sa
get:boundary 
get:To distin
get:care of t
get:return co
get:count ind
get:Alternati
get:[Page 48]        
get:September 1981   
get:allocate 
get:with the 
get:Format:  
get:This comm
get:the conne
get:authorize
get:Closing c
get:the sense
get:retransmi
get:serviced.
get:calls, fo
get:to the de
get:continue 
get:may be tr
get:means "I 
get:receive a
get:not well 
get:of all it
get:into ABOR
get:The user 
get:initiativ
get:(e.g., re
get:destinati
get:Because c
get:foreign T
get:short tim
get:replies t
get:Close als
get:Format:  
get:This is a
get:excluded 
get:typically
get:This comm
get:informati:on
get:local s
get:Transmission Cont
get:Functional Specif
get:foreign
get:local c
get:receive
get:send wi
get:connect
get:number 
get:number 
get:urgent 
get:precede
get:securit
get:and tra
get:Depending
get:implement
get:available
get:authorize
get:prevents 
get:connectio
get:Format:  
get:This comm
get:aborted, 
get:be sent t
get:Depending
get:indicatio
get:receive a
get:TCP-to-User M
get:It is assum
get:means for t
get:the TCP doe
get:to the user
get:an error me
get:relating to
get:other user 
get:The followi:ng information is provided
get:Local Con
get:Response 
get:Buffer Ad
get:Byte coun
get:Push flag
get:Urgent fl
get:[Page 50]        
get:September 1981   
get:TCP/Lower-Level
get:The TCP calls
get:receive infor
get:internetwork 
get:Protocol (IP)
get:If the lower 
get:of service an
get:for these par:ameters
get:Type of Ser:vice = Precedence: routine, Delay: normal, Throughput
get:normal, Rel:iability
get:Time to Liv
get:Note that
get:Here we e
get:be delive
get:If the lower 
get:feature) and 
get:route informa
get:so that the s
get:checksum be t
get:also importan
get:Any lower lev
get:destination a
get:the "TCP leng
get:of IP and to 
get:Transmission Cont
get:Functional Specif
get:3.9.  Event Proce
get:The processing 
get:implementation.
get:processing sequ
get:section only in
get:The activity of
get:The events that: occur can be cast into three categories
get:arriving segmen
get:processing the 
get:cases the proce
get:Events that o:ccur
get:Arriving Se
get:SEGMENT A
get:USER TIME
get:RETRANSMI
get:TIME-WAIT
get:The model of th
get:immediate retur
get:pseudo interrup
get:means cause a d
get:Error responses
get:commands refere:ncing connections that do not exist receive "error
get:connection not 
get:Please note in 
get:acknowledgment 
get:of the sequence
get:equal to (modul
get:[Page 52]        
get:September 1981   
get:A natural way t
get:imagine that th
get:that their cont
get:in the sequence
get:and processed i
get:When a segment 
get:the segment to 
get:to be consisten
get:Note that if no
get:Transmission Cont
get:Functional Specif
get:CLOSED STATE 
get:Create a ne
get:state infor
get:socket, pre
get:information
get:unspecified
get:parameters 
get:precedence 
get:"error:  pr:ecedence not allowed" or "error
get:not allowed
get:active and :the foreign socket is unspecified, return "error
get:foreign soc
get:specified, 
get:(ISS) is se
get:is sent.  S
get:state, and 
get:If the call
get:return "err:or
get:no room to :create a new connection, return "error
get:resources".
get:If active a
get:connection 
get:segment, se
get:state.  Dat
get:queued for 
get:urgent bit 
get:segments se
get:queue the r:equest, respond with "error
get:If Foreign :socket was not specified, then return "error
get:socket unsp
get:[Page 54]        
get:September 1981   
get:SYN-SENT STAT
get:SYN-RECEIVED 
get:ESTABLISHED S
get:FIN-WAIT-1 ST
get:FIN-WAIT-2 ST
get:CLOSE-WAIT ST
get:CLOSING STATE
get:LAST-ACK STAT
get:TIME-WAIT STA
get:Return "err:or
get:Transmission Cont
get:Functional Specif
get:CLOSED STATE 
get:If the user
get:"error:  co
get:Otherwise, :return "error
get:If the fore
get:from passiv
get:SND.UNA to 
get:associated 
get:transmissio
get:requested i
get:as a result
get:request, re:spond with "error
get:Foreign soc:ket was not specified, then return "error
get:socket unsp
get:SYN-SENT STAT
get:SYN-RECEIVED 
get:Queue the d
get:If no space: to queue, respond with "error
get:resources".
get:ESTABLISHED S
get:CLOSE-WAIT ST
get:Segmentize 
get:acknowledgm
get:insufficien:t space to remember this buffer, simply return "error
get:insufficien
get:If the urge
get:urgent poin
get:[Page 56]        
get:September 1981   
get:FIN-WAIT-1 ST
get:FIN-WAIT-2 ST
get:CLOSING STATE
get:LAST-ACK STAT
get:TIME-WAIT STA
get:Return "err:or
get:Transmission Cont
get:Functional Specif
get:CLOSED STATE 
get:If the user
get:"error:  co
get:Otherwise r:eturn "error
get:SYN-SENT STAT
get:SYN-RECEIVED 
get:Queue for p
get:is no room :to queue this request, respond with "error
get:insufficien
get:ESTABLISHED S
get:FIN-WAIT-1 ST
get:FIN-WAIT-2 ST
get:If insuffic
get:request, qu
get:remember th:e RECEIVE, respond with "error
get:resources".
get:Reassemble 
get:to user.  M
get:If RCV.UP i
get:user notify
get:When the TC
get:that fact m
get:acknowledgm
get:described b
get:[Page 58]        
get:September 1981   
get:CLOSE-WAIT ST
get:Since the r
get:satisfied b
get:user.  If n
get:"error:  co
get:text can be
get:CLOSING STATE
get:LAST-ACK STAT
get:TIME-WAIT STA
get:Return "err:or
get:Transmission Cont
get:Functional Specif
get:CLOSED STATE 
get:If the user
get:"error:  co
get:Otherwise, :return "error
get:Any outstan:ding RECEIVEs are returned with "error
get:responses. 
get:SYN-SENT STAT
get:Delete the :TCB and return "error
get:queued SEND
get:SYN-RECEIVED 
get:If no SENDs
get:then form a
get:otherwise q
get:ESTABLISHED S
get:Queue this 
get:form a FIN 
get:FIN-WAIT-1 ST
get:FIN-WAIT-2 ST
get:Strictly sp:eaking, this is an error and should receive a "error
get:connection 
get:acceptable,
get:FIN may be 
get:[Page 60]        
get:September 1981   
get:CLOSE-WAIT ST
get:Queue this 
get:segmentized
get:CLOSING STATE
get:LAST-ACK STAT
get:TIME-WAIT STA
get:Respond wit:h "error
get:Transmission Cont
get:Functional Specif
get:CLOSED STATE 
get:If the user
get:"error:  co
get:Otherwise r:eturn "error
get:Any outstan:ding RECEIVEs should be returned with "error
get:connection 
get:SYN-SENT STAT
get:All queued 
get:notificatio
get:SYN-RECEIVED 
get:ESTABLISHED S
get:FIN-WAIT-1 ST
get:FIN-WAIT-2 ST
get:CLOSE-WAIT ST
get:Send a rese:t segment
get:<SEQ=SND.
get:All queued 
get:notificatio
get:RST formed 
get:TCB, enter 
get:CLOSING STATE
get:LAST-ACK STAT
get:TIME-WAIT STA
get:Respond wit
get:[Page 62]        
get:September 1981   
get:CLOSED STATE 
get:If the user
get:"error:  co
get:Otherwise r:eturn "error
get:Return "sta
get:SYN-SENT STAT
get:Return "sta
get:SYN-RECEIVED 
get:Return "sta
get:ESTABLISHED S
get:Return "sta
get:FIN-WAIT-1 ST
get:Return "sta
get:FIN-WAIT-2 ST
get:Return "sta
get:CLOSE-WAIT ST
get:Return "sta
get:CLOSING STATE
get:Return "sta
get:LAST-ACK STAT
get:Return "sta
get:Transmission Cont
get:Functional Specif
get:TIME-WAIT STA
get:Return "sta
get:[Page 64]        
get:September 1981   
get:SEGMENT ARRIVES
get:If the state 
get:all data in
get:segment con
get:containing 
get:acknowledgm
get:reset seque
get:If the ACK 
get:<SEQ=0><A
get:If the ACK 
get:<SEQ=SEG.
get:If the state 
get:first check
get:An incomi
get:second chec
get:Any ackno
get:the LISTE
get:for any a
get:formatted: as follows
get:<SEQ=SE
get:third check
get:If the SY
get:security/
get:match the
get:<SEQ=SE
get:Transmission Cont
get:Functional Specif
get:If the SE
get:the user 
get:send a re
get:<SEQ=SE
get:If the SE
get:Set RCV.N
get:control o
get:should be: selected and a SYN segment sent of the form
get:<SEQ=IS
get:SND.NXT i
get:state sho
get:incoming 
get:in the SY
get:not be re
get:the forei
get:unspecifi
get:fourth othe
get:Any other
get:must have
get:processin
get:it could 
get:incarnati
get:but if yo
get:If the state 
get:first check
get:If the AC
get:If SEG.
get:the RST
get:<SEQ=
get:and dis
get:If SND.
get:second chec
get:[Page 66]        
get:September 1981   
get:If the RS
get:If the :ACK was acceptable then signal the user "error
get:connect
get:delete 
get:and ret
get:third check
get:If the se
get:match the
get:If ther
get:<SEQ=
get:Otherwi
get:<SEQ=
get:If there 
get:The pre
get:TCB, if
get:<SEQ=
get:If there 
get:If the 
get:in the 
get:the pre
get:allowed
get:<SEQ=
get:If the 
get:in the 
get:If a rese
get:fourth chec
get:This step
get:no ACK, a
get:If the SY
get:Transmission Cont
get:Functional Specif
get:are accep
get:SEG.SEQ. 
get:is an ACK
get:are there
get:If SND.UN
get:state to 
get:<SEQ=SN
get:and send 
get:transmiss
get:text in t
get:below whe
get:Otherwise
get:<SEQ=IS
get:and send 
get:segment, 
get:has been 
get:fifth, if n
get:segment and
get:[Page 68]        
get:September 1981   
get:first check s
get:SYN-RECEIVE
get:ESTABLISHED
get:FIN-WAIT-1 
get:FIN-WAIT-2 
get:CLOSE-WAIT 
get:CLOSING STA
get:LAST-ACK ST
get:TIME-WAIT S
get:Segments 
get:are used 
get:done in S
get:boundary 
get:processed
get:There are
get:segment
get:Segment R
get:Length  W
get:------- -
get:0     
get:0     
get:>0     
get:>0     
get:If the RC
get:special a
get:If an inc
get:should be
get:the segme:nt and return)
get:<SEQ=SN
get:After sen
get:and retur
get:Transmission Cont
get:Functional Specif
get:In the fo
get:segment t
get:One could
get:trimming 
get:SYN and F
get:begins at
get:numbers m
get:second check 
get:SYN-RECEIVE
get:If the RS
get:If this
get:came fr
get:LISTEN 
get:this co
get:from SY
get:the use
get:on the 
get:active 
get:and ret
get:ESTABLISHED
get:If the RS
get:should re
get:flushed. 
get:"connecti
get:TCB, and 
get:CLOSING STA
get:LAST-ACK ST
get:If the RS
get:TCB, and 
get:[Page 70]        
get:September 1981   
get:third check s
get:SYN-RECEIVE
get:If the se
get:exactly m
get:then send
get:ESTABLISHED
get:If the se
get:exactly m
get:then send
get:receive "
get:flushed. 
get:"connecti
get:TCB, and 
get:Note this c
get:a segment f
get:different s
get:current con
get:fourth, check
get:SYN-RECEIVE
get:ESTABLISHED
get:FIN-WAIT ST
get:FIN-WAIT ST
get:CLOSE-WAIT 
get:CLOSING STA
get:LAST-ACK ST
get:TIME-WAIT S
get:If the SY
get:outstandi
get:all segme
get:receive a
get:the CLOSE
get:If the SY
get:and an ac
get:number ch
get:Transmission Cont
get:Functional Specif
get:fifth check t
get:if the ACK 
get:if the ACK 
get:SYN-RECEI
get:If SND.
get:and con
get:If th
get:reset
get:<SE
get:and s
get:ESTABLISH
get:If SND.
get:Any seg
get:entirel
get:positiv
get:fully a
get:"ok" re
get:(SEG.AC
get:somethi
get:drop th
get:If SND.
get:updated
get:SND.WL2
get:SND.WL1
get:Note th
get:records
get:SND.WND
get:the las
get:prevent
get:[Page 72]        
get:September 1981   
get:FIN-WAIT-
get:In addi
get:our FIN
get:process
get:FIN-WAIT-
get:In addi
get:the ret
get:acknowl
get:CLOSE-WAI
get:Do the 
get:CLOSING S
get:In addi
get:the ACK
get:otherwi
get:LAST-ACK 
get:The onl
get:acknowl
get:delete 
get:TIME-WAIT
get:The onl
get:retrans
get:the 2 M
get:sixth, check 
get:ESTABLISHED
get:FIN-WAIT-1 
get:FIN-WAIT-2 
get:If the UR
get:the user 
get:pointer (
get:user has 
get:mode") fo
get:signal th
get:Transmission Cont
get:Functional Specif
get:CLOSE-WAIT 
get:CLOSING STA
get:LAST-ACK ST
get:This shou
get:remote si
get:seventh, proc
get:ESTABLISHED
get:FIN-WAIT-1 
get:FIN-WAIT-2 
get:Once in t
get:text to u
get:into buff
get:empty.  I
get:the user 
get:has been 
get:When the 
get:user it m
get:Once the 
get:RCV.NXT o
get:apporopri
get:RCV.NXT a
get:Please no
get:Send an a:cknowledgment of the form
get:<SEQ=SN
get:This ackn
get:transmitt
get:[Page 74]        
get:September 1981   
get:CLOSE-WAIT 
get:CLOSING STA
get:LAST-ACK ST
get:TIME-WAIT S
get:This shou
get:remote si
get:eighth, check
get:Do not proc
get:since the S
get:If the FIN 
get:return any 
get:over the FI
get:FIN implies
get:SYN-RECEI
get:ESTABLISH
get:Enter t
get:FIN-WAIT-
get:If our 
get:enter T
get:timers;
get:FIN-WAIT-
get:Enter t
get:off the
get:CLOSE-WAI
get:Remain 
get:CLOSING S
get:Remain 
get:LAST-ACK 
get:Remain 
get:Transmission Cont
get:Functional Specif
get:TIME-WAIT
get:Remain 
get:timeout
get:[Page 76]        
get:September 1981   
get:For any state
get:the user "err:or
get:and for any o
get:state and ret
get:RETRANSMISSION 
get:For any state
get:the retransmi
get:retransmissio
get:TIME-WAIT TIMEO
get:If the time-w
get:enter the CLO
get:Transmission Cont
get:[Page 78]        
get:September 1981   
get:BBN Rep
get:a Host 
get:host an
get:A contr
get:indicat
get:specifi
get:is expe
get:previou
get:The uni
get:ARPANET
get:A unit 
get:IMPs.  
get:A logic
get:A messa
get:network
get:Destination Addre
get:The des
get:identif
get:A contr
get:indicat
get:occupyi
get:A porti
get:fragmen
get:A file 
get:Transmission Cont
get:Control
get:fragmen
get:A compu
get:from th
get:An Inte
get:by the 
get:The Int
get:ARPANET
get:A sourc
get:internet datagram
get:The uni
get:higher 
get:internet fragment
get:A porti
get:header.
get:Interne
get:The Ini
get:number 
get:The Ini
get:on a co
get:based p
get:The Ini
get:used by
get:Control
get:data.  
get:on an A
get:[Page 80]        
get:September 1981   
get:This is
get:data re
get:sequenc
get:of the 
get:The uni
get:An impl
get:procedu
get:Maximum
get:the int
get:An eigh
get:An Opti
get:may be 
get:primari
get:timesta
get:options
get:A packa
get:logical
get:logical
get:The por
get:output 
get:A progr
get:the poi
get:A contr
get:this se
get:receivi
get:receive
get:Transmission Cont
get:receive
get:receive
get:receive next sequ
get:This is
get:receive
get:This re
get:is will
get:segment
get:RCV.NXT
get:Segment
get:range a
get:A contr
get:that th
get:interac
get:sequenc
get:segment
get:it.  In
get:rise to
get:Real Ti:me Protocol
get:of time
get:segment
get:segment
get:segment
get:segment
get:segment
get:[Page 82]        
get:September 1981   
get:segment
get:A logic
get:unit of
get:segment acknowled
get:The seq
get:arrivin
get:The amo
get:includi
get:The num
get:This is
get:use on 
get:initial
get:each oc
get:This re
get:(receiv
get:window 
get:receivi
get:be emit
get:SND.UNA
get:between
get:send se
get:left se
get:send ur
get:segment
get:segment
get:Transmission Cont
get:send wi
get:An addr
get:is, the
get:The sou
get:A contr
get:number,
get:where t
get:Transmi
get:the sta
get:The pre
get:Transmi:ssion Control Protocol
get:reliabl
get:Type of
get:An Inte
get:for thi
get:A contr
get:indicat
get:urgent 
get:sequenc
get:pointer
get:A contr
get:field c
get:indicat
get:urgent 
get:[Page 84]        
get:September 1981   
get:[1]  Cerf, V., an
get:Intercommuni
get:Vol. COM-22,
get:[2]  Postel, J. (
get:Protocol Spe
get:Institute, S
get:[3]  Dalal, Y. an
get:Protocols", 
get:December 197
get:[4]  Postel, J., 
get:Institute, S
get:aRFC
get:aDe
get:aI
get:aSeptember 1981   
get:aPREFACE .....
get:a1.  INTRODUCTION 
get:a1.1  Motivation
get:a1.2  Scope ....
get:a1.3  About This
get:a1.4  Interfaces
get:a1.5  Operation 
get:a2.  PHILOSOPHY ..
get:a2.1  Elements o
get:a2.2  Model of O
get:a2.3  The Host E
get:a2.4  Interfaces
get:a2.5  Relation t
get:a2.6  Reliable C
get:a2.7  Connection
get:a2.8  Data Commu
get:a2.9  Precedence
get:a2.10 Robustness
get:a3.  FUNCTIONAL SP
get:a3.1  Header For
get:a3.2  Terminolog
get:a3.3  Sequence N
get:a3.4  Establishi
get:a3.5  Closing a 
get:a3.6  Precedence
get:a3.7  Data Commu
get:a3.8  Interfaces
get:a3.9  Event Proc
get:aGLOSSARY ........
get:aREFERENCES ......
get:aTransmission Cont
get:a[Page ii]        
get:aSeptember 1981   
get:aThis document des
get:a(TCP).  There hav
get:aspecification on 
get:adraws heavily fro
get:aboth in terms of 
get:aseveral details a
get:aand redescribes t
get:aRFC
get:aReplaces: RFC 761
get:aIENs:  129, 124, 
get:a55, 44, 40, 27, 2
get:aThe Transmission 
get:areliable host-to-
get:acommunication net
get:aThis document des
get:aTransmission Cont
get:ainterface to prog
get:aComputer commun
get:arole in militar
get:adocument focuse
get:acommunication r
get:acommunication u
get:acongestion, but
get:agovernment sect
get:aAs strategic an
get:adeveloped and d
get:ainterconnecting
get:acommunication p
get:aapplications.  
get:aDeputy Undersec
get:adeclared the Tr
get:abe a basis for 
get:astandardization
get:aTCP is a connec
get:afit into a laye
get:aapplications.  
get:acommunication b
get:adistinct but in
get:aassumptions are
get:aprotocols below
get:apotentially unr
get:aprotocols.  In 
get:awide spectrum o
get:aconnections to 
get:aTransmission Cont
get:aTCP is based on
get:aTCP fits into a
get:aInternet Protoc
get:areceive variabl
get:adatagram "envel
get:aaddressing sour
get:ainternet protoc
get:athe TCP segment
get:amultiple networ
get:aalso carries in
get:aand compartment
get:acommunicated en
get:aMuch of this do
get:awhich are co-re
get:acomputer.  Some
get:afront-end compu
get:aas well as netw
get:aan interface to
get:aimplementable e
get:ahost-to-front e
get:aThe TCP is inte
get:acommunication s
get:aintended to be 
get:a1.3.  About this 
get:aThis document r
get:aany TCP impleme
get:aprotocols and i
get:a[Page 2]         
get:aSeptember 1981   
get:asection offers 
get:aoperation.  Sec
get:adesign.  Sectio
get:arequired of TCP
get:auser calls, err
get:aThe TCP interfa
get:athe other side 
get:aThe interface b
get:aillustrated in 
get:acalls much like
get:aapplication pro
get:acalls to open a
get:aestablished con
get:aasynchronously 
get:aconsiderable fr
get:ainterfaces whic
get:aenvironment, a 
get:ainterface for a
get:aThe interface b
get:aunspecified exc
get:atwo levels can 
get:aTypically, one 
get:ainterface.  TCP
get:ainterconnected 
get:athroughout this
get:aAs noted above,
get:asecurable logic
get:aprocesses.  To 
get:acommunication s:ystem requires facilities in the following areas
get:aBasic Data Tr
get:aPrecedence an
get:aThe basic opera
get:athe following p
get:aTransmission Cont
get:aBasic Data Tran:sfer
get:aThe TCP is ab
get:adirection bet
get:asegments for 
get:athe TCPs deci
get:aSometimes use
get:asubmitted to 
get:afunction is d
get:aactually tran
get:apushed throug
get:apromptly forw
get:aThe exact pus
get:athe push func
get:aReliability
get:aThe TCP must 
get:adelivered out
get:ais achieved b
get:atransmitted, 
get:areceiving TCP
get:ainterval, the
get:anumbers are u
get:aout of order 
get:aadding a chec
get:areceiver, and
get:aAs long as th
get:asystem does n
get:aerrors will a
get:ainternet comm
get:aFlow Control
get:aTCP provides 
get:asent by the s
get:aevery ACK ind
get:athe last segm
get:aallowed numbe
get:areceiving fur
get:a[Page 4]         
get:aSeptember 1981   
get:aMultiplexing
get:aTo allow for 
get:acommunication
get:aaddresses or 
get:aand host addr
get:aa socket.  A 
get:aThat is, a so
get:aThe binding o
get:aHost.  Howeve
get:a(e.g., a "log
get:amade known to
get:athrough the k
get:aaddresses of 
get:aConnections
get:aThe reliabili
get:athat TCPs ini
get:aeach data str
get:asockets, sequ
get:aEach connecti
get:aidentifying i
get:aWhen two proc
get:aestablish a c
get:aside).  When 
get:aterminated or
get:aSince connect
get:aover the unre
get:amechanism wit
get:aerroneous ini
get:aPrecedence and :Security
get:aThe users of 
get:acommunication
get:athese feature
get:aTransmission Cont
get:a[Page 6]         
get:aSeptember 1981   
get:a2.1.  Elements of
get:aThe internetwor
get:awhich are in tu
get:athat the networ
get:alarge networks 
get:apacket switchin
get:aconsume message
get:anetworks, the g
get:acommunication s
get:aconnections bet
get:aThe term packet
get:atransaction bet
get:aexchanged withi
get:aHosts are compu
get:anetwork's point
get:aProcesses are v
get:aaccordance with
get:ain execution). 
get:aviewed as commu
get:aThus, all commu
get:aSince a process
get:astreams between
get:athat each proce
get:acommunicates wi
get:a2.2.  Model of Op
get:aProcesses trans
get:adata as argumen
get:asegments and ca
get:athe destination
get:ainto the receiv
get:aTCPs include co
get:aensure reliable
get:aThe model of in
get:aprotocol module
get:ato the local ne
get:ainside internet
get:ainternet module
get:athrough the loc
get:aThe packet swit
get:aTransmission Cont
get:aother operation
get:adestination int
get:aAt a gateway be
get:afrom its local 
get:athe internet da
get:athen "wrapped" 
get:arouted to the n
get:aA gateway is pe
get:ainternet datagr
get:athrough the nex
get:ainternet datagr
get:afurther broken 
get:ainternet datagr
get:ainternet module
get:aA destination i
get:a(after reassemb
get:adestination TCP
get:aThis simple mod
get:aimportant featu
get:ato the gateway 
get:aservice paramet
get:aIncluded in the
get:adatagram.  Data
get:ahost and gatewa
get:aproperly segreg
get:a2.3.  The Host En
get:aThe TCP is assu
get:aaccess the TCP 
get:amay call on oth
get:adata structures
get:acontrolled by a
get:anetwork device 
get:adatagram protoc
get:aThe mechanisms 
get:afront-end proce
get:ahost-to-front-e
get:athe type of TCP
get:a[Page 8]         
get:aSeptember 1981   
get:aThe TCP/user in
get:ato OPEN or CLOS
get:aSTATUS about a 
get:aprograms on the
get:afrom, and close
get:aThe TCP/interne
get:adatagrams addre
get:asystem.  These 
get:aservice, preced
get:a2.5.  Relation to
get:aThe following d
get:ahierarchy
get:a+------+ +
get:a|Telnet| |
get:a+------+ +
get:a|   
get:a+----
get:a| TCP
get:a+----
get:a| 
get:a+----
get:a|    
get:a+----
get:a+--
get:a|  
get:a+--
get:aIt is expected 
get:aprotocols effic
get:aprotocols like 
get:a2.6.  Reliable Co
get:aA stream of dat
get:aorder at the de
get:aTransmission Cont
get:aTransmission is
get:aacknowledgments
get:asequence number
get:asegment is tran
get:asequence number
get:ais the sequence
get:atransmissions i
get:asegment contain
get:astarts a timer;
get:asegment is dele
get:areceived before
get:aAn acknowledgme
get:adelivered to th
get:athe responsibil
get:aTo govern the f
get:aemployed.  The 
get:aThis window spe
get:aacknowledgment 
get:a2.7.  Connection 
get:aTo identify the
get:aprovides a port
get:aindependently b
get:aunique addresse
get:aidentifying the
get:awill be unique 
get:aA connection is
get:alocal socket ma
get:asockets.  A con
get:athat is, it is 
get:aTCPs are free t
get:aHowever, severa
get:aThere must be w
get:athe "appropriat
get:amay "own" ports
get:athe ports they 
get:aissue, but we e
get:auniquely alloca
get:aassociating the
get:aA connection is
get:aforeign socket 
get:a[Page 10]        
get:aSeptember 1981   
get:aconnection name
get:asubsequent call
get:aabout a connect
get:ais a data struc
get:aimplementation 
get:apointer to the 
get:awhether the con
get:abe passively wa
get:aA passive OPEN 
get:aconnection requ
get:aOften the proce
get:arequest from an
get:ais used to deno
get:aare allowed onl
get:aA service proce
get:aprocesses would
get:aforeign socket.
get:arequested a con
get:alocal socket we
get:aWell-known sock
get:aa socket addres
get:a"Telnet-Server"
get:asocket, and oth
get:aEntry, Text Gen
get:abeing for test 
get:aaccess to a "Lo
get:aat which a newl
get:awell-known sock
get:aof sockets to s
get:aProcesses can i
get:afrom other proc
get:abeen establishe
get:aother at the sa
get:ais critical for
get:acomponents act 
get:aThere are two p
get:apassive OPENs a
get:alocal passive O
get:acase, the match
get:aOPENs has left 
get:aforeign socket 
get:aOther possibili
get:aTransmission Cont
get:aIf there are se
get:asame local sock
get:awith the specif
get:aTCB exists, bef
get:aThe procedures 
get:acontrol flag an
get:aexchange has be
get:aA connection is
get:acontaining a SY
get:acommand.  The m
get:aconnection has 
get:awhen sequence n
get:aThe clearing of
get:ain this case ca
get:a2.8.  Data Commun
get:aThe data that f
get:aoctets.  The se
get:ain that call (a
get:athrough to the 
get:aA sending TCP i
get:asend that data 
get:afunction is sig
get:areceiving TCP s
get:athe sending TCP
get:aThere is no nec
get:aboundaries.  Th
get:asingle SEND cal
get:aThe purpose of 
get:afrom the sendin
get:arecord service.
get:aThere is a coup
get:aof data that cr
get:aassociated with
get:abuffer is retur
get:anot filled.  If
get:aPUSH is seen, t
get:aTCP also provid
get:aat some point f
get:a[Page 12]        
get:aSeptember 1981   
get:acurrently readi
get:adefine what the
get:aurgent data, bu
get:atake action to 
get:a2.9.  Precedence 
get:aThe TCP makes u
get:asecurity option
get:abasis to TCP us
get:aa multilevel se
get:ause only, and o
get:acompartment.  C
get:ausers may be li
get:aTCP modules whi
get:aproperly mark o
get:aprecedence.  Su
get:ahigher level pr
get:athem to specify
get:aprecedence of c
get:a2.10.  Robustness
get:aTCP implementat:ions will follow a general principle of robustness
get:aconservative in
get:aTransmission Cont
get:a[Page 14]        
get:aSeptember 1981   
get:a3.1.  Header Form
get:aTCP segments ar
get:aheader carries 
get:adestination hos
get:aheader, supplyi
get:adivision allows
get:aTCP Header Form
get:a0            
get:a0 1 2 3 4 5 6
get:a+-+-+-+-+-+-+-
get:a|          Sou
get:a+-+-+-+-+-+-+-
get:a|             
get:a+-+-+-+-+-+-+-
get:a|             
get:a+-+-+-+-+-+-+-
get:a|  Data |     
get:a| Offset| Rese
get:a|       |     
get:a+-+-+-+-+-+-+-
get:a|           Ch
get:a+-+-+-+-+-+-+-
get:a|             
get:a+-+-+-+-+-+-+-
get:a|             
get:a+-+-+-+-+-+-+-
get:aNote th
get:aSource Port:  1
get:aThe source po
get:aDestination Por:t
get:aThe destinati
get:aTransmission Cont
get:aFunctional Specif
get:aSequence Number:
get:aThe sequence 
get:awhen SYN is p
get:ainitial seque
get:aAcknowledgment :Number
get:aIf the ACK co
get:anext sequence
get:areceive.  Onc
get:aData Offset:  4
get:aThe number of
get:athe data begi
get:aintegral numb
get:aReserved:  6 bi
get:aReserved for 
get:aControl Bits:  :6 bits (from left to right)
get:aURG:  Urgent 
get:aACK:  Acknowl
get:aPSH:  Push Fu
get:aRST:  Reset t
get:aSYN:  Synchro
get:aFIN:  No more
get:aWindow:  16 bit
get:aThe number of
get:aacknowledgmen
get:aChecksum:  16 b
get:aThe checksum 
get:acomplement su
get:asegment conta
get:achecksummed, 
get:aform a 16 bit
get:atransmitted a
get:athe checksum 
get:aThe checksum 
get:a[Page 16]        
get:aSeptember 1981   
get:aprefixed to t
get:aAddress, the 
get:aThis gives th
get:ainformation i
get:aacross the TC
get:acalls by the 
get:aThe TCP Len
get:aoctets (thi
get:acomputed), 
get:aUrgent Pointer:
get:aThis field co
get:apositive offs
get:aurgent pointe
get:athe urgent da
get:athe URG contr
get:aOptions:  varia
get:aOptions may o
get:amultiple of 8
get:achecksum.  An
get:acases for the: format of an option
get:aCase 1:  A 
get:aCase 2:  An
get:ath
get:aThe option-le
get:aoption-length
get:aNote that the
get:afield might i
get:aEnd-of-Option
get:aA TCP must im
get:aTransmission Cont
get:aFunctional Specif
get:aCurrently def:ined options include (kind indicated in octal)
get:aKind     Le
get:a----     --
get:a0         
get:a1         
get:a2         
get:aSpecific Opti
get:aEnd of Opti
get:a+--------
get:a|00000000
get:a+--------
get:aThis opti
get:amight not
get:athe Data 
get:anot the e
get:athe optio
get:aNo-Operatio
get:a+--------
get:a|00000001
get:a+--------
get:aThis opti
get:aalign the
get:aThere is 
get:areceivers
get:anot begin
get:aMaximum Seg
get:a+--------
get:a|00000010
get:a+--------
get:aKind=2  
get:a[Page 18]        
get:aSeptember 1981   
get:aMaximum S:egment Size Option Data
get:aIf this
get:areceive
get:aThis fi
get:a(i.e., 
get:aoption 
get:aPadding:  varia
get:aThe TCP heade
get:aand data begi
get:a3.2.  Terminology
get:aBefore we can d
get:ato introduce so
get:aconnection requ
get:aof these variab
get:aTransmission Co
get:aTCB are the loc
get:aprecedence of t
get:abuffers, pointe
get:aIn addition sev
get:asequence number
get:aSend Sequence
get:aSND.UNA - s
get:aSND.NXT - s
get:aSND.WND - s
get:aSND.UP  - s
get:aSND.WL1 - s
get:aSND.WL2 - s
get:au
get:aISS     - i
get:aReceive Seque
get:aRCV.NXT - r
get:aRCV.WND - r
get:aRCV.UP  - r
get:aIRS     - i
get:aTransmission Cont
get:aFunctional Specif
get:aThe following d
get:athe sequence sp
get:aSend Sequence S
get:a---
get:a1 - old s
get:a2 - seque
get:a3 - seque
get:a4 - futur
get:aThe send window
get:aReceive Sequenc
get:a1 - old s
get:a2 - seque
get:a3 - futur
get:aThe receive win
get:aThere are also 
get:atake their valu
get:a[Page 20]        
get:aSeptember 1981   
get:aCurrent Segme
get:aSEG.SEQ - s
get:aSEG.ACK - s
get:aSEG.LEN - s
get:aSEG.WND - s
get:aSEG.UP  - s
get:aSEG.PRC - s
get:aA connection pr
get:alifetime.  The :states are
get:aESTABLISHED, FI
get:aTIME-WAIT, and 
get:abecause it repr
get:ano connection. : Briefly the meanings of the states are
get:aLISTEN - repr
get:aTCP and port.
get:aSYN-SENT - re
get:aafter having 
get:aSYN-RECEIVED 
get:arequest ackno
get:aconnection re
get:aESTABLISHED -
get:adelivered to 
get:aof the connec
get:aFIN-WAIT-1 - 
get:afrom the remo
get:atermination r
get:aFIN-WAIT-2 - 
get:afrom the remo
get:aCLOSE-WAIT - 
get:afrom the loca
get:aCLOSING - rep
get:aacknowledgmen
get:aLAST-ACK - re
get:aconnection te
get:a(which includ
get:aTransmission Cont
get:aFunctional Specif
get:aTIME-WAIT - r
get:athe remote TC
get:atermination r
get:aCLOSED - repr
get:aA TCP connectio
get:aevents.  The ev
get:aABORT, and STAT
get:acontaining the 
get:aThe state diagr
get:awith the causin
get:aerror condition
get:achanges.  In a 
get:athe reaction of
get:aNOTE BENE:  thi
get:athe total speci
get:a[Page 22]        
get:aSeptember 1981   
get:a+---------+     
get:a|         |<----
get:a|   SYN   |     
get:a|   RCVD  |<----
get:a|         |     
get:a|         |-----
get:a+---------+   rc
get:a|           --
get:a|             
get:a|             
get:a|  CLOSE      
get:a| -------     
get:a| snd FIN     
get:a|             
get:aV             
get:a+---------+     
get:a|  FIN    |<----
get:a| WAIT-1  |-----
get:a+---------+     
get:a| rcv ACK of F
get:a| ------------
get:aV        x    
get:a+---------+     
get:a|FINWAIT-2|     
get:a+---------+     
get:a|             
get:a|  rcv FIN    
get:a|  -------    
get:a\ snd ACK    
get:a------------
get:aTransmission Cont
get:aFunctional Specif
get:a3.3.  Sequence Nu
get:aA fundamental n
get:aover a TCP conn
get:asequenced, each
get:amechanism emplo
get:anumber X indica
get:areceived.  This
get:adetection in th
get:awithin a segmen
get:athe header is t
get:anumbered consec
get:aIt is essential
get:afinite, though 
get:aSince the space
get:anumbers must be
get:apreserves the r
get:a2**32 - 1 to 0 
get:aarithmetic, so 
get:acomparison of s
get:a(modulo 2**32).
get:aThe typical kin
get:aperform include:
get:a(a)  Determin
get:anumber s
get:a(b)  Determin
get:ahave bee
get:aretransm
get:a(c)  Determin
get:awhich ar
get:areceive 
get:a[Page 24]        
get:aSeptember 1981   
get:aIn response to 
get:afollowing compa
get:aSND.UNA = old
get:aSND.NXT = nex
get:aSEG.ACK = ack
get:anum
get:aSEG.SEQ = fir
get:aSEG.LEN = the
get:a(co
get:aSEG.SEQ+SEG.L
get:aA new acknowled
get:athe inequality :below holds
get:aSND.UNA < SEG
get:aA segment on th
get:aof its sequence
get:aacknowledgment 
get:aWhen data is re:ceived the following comparisons are needed
get:aRCV.NXT = nex
get:ais the le
get:aRCV.NXT+RCV.W
get:asegment, 
get:aSEG.SEQ = fir
get:aSEG.SEQ+SEG.L
get:aA segment is ju
get:aRCV.NXT =< SE
get:aRCV.NXT =< SE
get:aTransmission Cont
get:aFunctional Specif
get:aThe first part 
get:asegment falls i
get:aif the end of t
get:aeither part of 
get:aActually, it is
get:awindows and zer
get:aacceptability o:f an incoming segment
get:aSegment Recei
get:aLength  Windo
get:a------- -----
get:a0       0 
get:a0      >0 
get:a>0       0 
get:a>0      >0 
get:aNote that when 
get:aacceptable exce
get:amaintain a zero
get:aACKs.  However,
get:aprocess the RST
get:aWe have taken a
get:acontrol informa
get:asome control fl
get:aand acknowledge
get:acontrol will be
get:acarried in the 
get:afor implicitly 
get:aare the only co
get:aare used only a
get:apurposes, the S
get:aoctet of the se
get:ato occur after 
get:aoccurs.  The se
get:aspace occupying
get:asequence number
get:a[Page 26]        
get:aSeptember 1981   
get:aInitial Sequenc
get:aThe protocol pl
get:aused over and o
get:asockets.  New i
get:aincarnations of
get:a-- "how does th
get:aincarnations of
get:aconnection is b
get:aconnection brea
get:aTo avoid confus
get:aconnection from
get:abe present in t
get:aassure this, ev
get:asequence number
get:aan initial sequ
get:anew 32 bit ISN.
get:abit clock whose
get:amicroseconds.  
get:aSince we assume
get:athe Maximum Seg
get:ahours we can re
get:aFor each connec
get:asequence number
get:athe data sendin
get:alearned during 
get:aFor a connectio
get:asynchronize on 
get:aan exchange of 
get:acalled "SYN" (f
get:ashorthand, segm
get:aHence, the solu
get:ainitial sequenc
get:aThe synchroniza
get:asequence number
get:afrom the other 
get:ainitial sequenc
get:a1) A --> B  S
get:a2) A <-- B  A
get:a3) A <-- B  S
get:a4) A --> B  A
get:aTransmission Cont
get:aFunctional Specif
get:aBecause steps 2
get:acalled the thre
get:aA three way han
get:atied to a globa
get:amechanisms for 
get:ano way of knowi
get:aunless it remem
get:a(which is not a
get:averify this SYN
get:aclock-driven sc
get:aKnowing When to
get:aTo be sure that
get:asequence number
get:athe network, th
get:a(MSL) before as
get:arecovering from
get:alost.  For this
get:ais an engineeri
get:ait is desirable
get:asense, yet reta
get:anot wait at all
get:athan those rece
get:aThe TCP Quiet T
get:aThis specific
get:aretaining any
get:aeach active (
get:aTCP segments 
get:ain the intern
get:aparagraphs be
get:aTCP implement
get:aat the risk o
get:adata rejected
get:aTCPs consume 
get:aentered into 
get:aduplicate det
get:arelies on the
get:athe extent th
get:avalues before
get:abeen delivere
get:acopies of the
get:asuch an assum
get:a[Page 28]        
get:aSeptember 1981   
get:aassigned the 
get:aat the receiv
get:athat each seg
get:aas there are 
get:aUnder normal 
get:ato emit and t
get:amistakenly us
get:abeen acknowle
get:adata is drain
get:avery large to
get:acause trouble
get:ato use up 2**
get:alifetime in t
get:athis is deeme
get:arates escalat
get:acycle time is
get:awithin reason
get:aThe basic dup
get:adefeated, how
get:asequence numb
get:athe TCP were 
get:aupon crashing
get:aconnection (p
get:apackets with 
get:apackets still
get:aincarnation o
get:aabout the seq
get:aspecification
get:abefore emitti
get:asegments from
get:aEven hosts wh
get:ainitial seque
get:a(i.e., even i
get:anumber for ea
get:aSuppose, for 
get:asequence numb
get:aand that even
get:atakes on a va
get:asegment sent 
get:aat this insta
get:aincarnation o
get:aS1 = ISN(t) -
get:aconnection!  
get:aTransmission Cont
get:aFunctional Specif
get:aduplicates in
get:aof S1 may arr
get:athe new incar
get:aThe problem i
get:acrashed nor d
get:athe system fr
get:aOne way to de
get:asegments for 
get:atime" specifi
get:awilling to ri
get:adestination m
get:aImplementors 
get:aconnection by
get:ainformally im
get:aObviously, ev
get:anecessary aft
get:aTo summarize:
get:anumbers in th
get:a"busy" or "in
get:ablock of spac
get:asegment, if a
get:asequence numb
get:athe previous 
get:anumber overla
get:a3.4.  Establishin
get:aThe "three-way 
get:aconnection.  Th
get:aresponded to by
get:asimultaneously 
get:aoccurs, each TC
get:aacknowledgment 
get:aan old duplicat
get:arecipient, that
get:aProper use of "
get:aSeveral example
get:aexamples do not
get:asegments, this 
get:adoesn't deliver
get:avalid (i.e., th
get:aconnection reac
get:areduces the pos
get:a[Page 30]        
get:aSeptember 1981   
get:aimplementation 
get:ainformation for
get:aThe simplest th
get:afigures should 
get:anumbered for re
get:adeparture of a 
get:asegment at B fr
get:aEllipsis (...) 
get:a(delayed).  An 
get:aComments appear
get:athe departure o
get:athe center of e
get:aform, with sequ
get:afields such as 
get:ain the interest
get:aTCP A      
get:a1.  CLOSED     
get:a2.  SYN-SENT   
get:a3.  ESTABLISHED
get:a4.  ESTABLISHED
get:a5.  ESTABLISHED
get:aBasic 3
get:aIn line 2 of fi
get:aindicating that
get:anumber 100.  In
get:areceived from T
get:aB is now expect
get:aoccupied sequen
get:aAt line 4, TCP 
get:aTCP B's SYN; an
get:asequence number
get:abecause the ACK
get:awould wind up A
get:aTransmission Cont
get:aFunctional Specif
get:aSimultaneous in
get:afigure 8.  Each
get:aTCP A      
get:a1.  CLOSED     
get:a2.  SYN-SENT   
get:a3.  SYN-RECEIVE
get:a4.             
get:a5.  SYN-RECEIVE
get:a6.  ESTABLISHED
get:a7.             
get:aS
get:aThe principle r
get:aduplicate conne
get:athis, a special
get:areceiving TCP i
get:aSYN-RECEIVED), 
get:aIf the TCP is i
get:aFIN-WAIT-1, FIN
get:aaborts the conn
get:acase under "hal
get:a[Page 32]        
get:aSeptember 1981   
get:aTCP A      
get:a1.  CLOSED     
get:a2.  SYN-SENT   
get:a3.  (duplicate)
get:a4.  SYN-SENT   
get:a5.  SYN-SENT   
get:a6.             
get:a7.  SYN-SENT   
get:a8.  ESTABLISHED
get:aAs a simple exa
get:afigure 9.  At l
get:acannot tell tha
get:a(line 4).  TCP 
get:aRST (reset) wit
get:abelievable.  TC
get:aWhen the origin
get:asynchronization
get:abefore the RST,
get:asent in both di
get:aHalf-Open Conne
get:aAn established 
get:aTCPs has closed
get:aknowledge of th
get:abecome desynchr
get:amemory.  Such c
get:aattempt is made
get:aconnections are
get:amildly involved
get:aIf at site A th
get:aTransmission Cont
get:aFunctional Specif
get:auser at site B 
get:areceiving a res
get:asite B TCP that
get:aAssume that two
get:aanother when a 
get:aDepending on th
get:athat some error
get:aA is likely to 
get:apoint.  As a re
get:aor try to SEND 
get:acase, it receiv
get:alocal (A's) TCP
get:awill send a seg
get:aexample shown i
get:are-open the con
get:aTCP A      
get:a1.  (CRASH)    
get:a2.  CLOSED     
get:a3.  SYN-SENT --
get:a4.  (!!)     <-
get:a5.  SYN-SENT --
get:a6.  SYN-SENT   
get:a7.  SYN-SENT --
get:aWhen the SYN ar
get:aand the incomin
get:aacknowledgment 
get:a100).  TCP A se
get:asent and, being
get:adetected a half
get:a[Page 34]        
get:aSeptember 1981   
get:acontinue to try
get:areduced to the 
get:aAn interesting 
get:atries to send d
get:aThis is illustr
get:aTCP A from TCP 
get:aexists, so TCP 
get:aprocesses it an
get:aTCP A    
get:a1.  (CRASH)    
get:a2.  (??)    <--
get:a3.          -->
get:aActive
get:aIn figure 12, w
get:awaiting for SYN
get:ainto action.  A
get:agenerate a RST 
get:athe reset and r
get:aTCP A      
get:a1.  LISTEN     
get:a2.       ... <S
get:a3.  (??) <-- <S
get:a4.       --> <S
get:a5.  LISTEN     
get:aOld Duplic
get:aTransmission Cont
get:aFunctional Specif
get:aA variety of ot
get:aby the followin
get:aReset Generatio
get:aAs a general ru
get:awhich apparentl
get:amust not be sen
get:aThere are three: groups of states
get:a1.  If the co
get:ain response t
get:aparticular, S
get:aby this means
get:aIf the incomi
get:asequence numb
get:areset has seq
get:aof the sequen
get:aThe connectio
get:a2.  If the co
get:aSYN-SENT, SYN
get:asomething not
get:aif an incomin
get:adoes not exac
get:aconnection, a
get:aIf our SYN ha
get:aincoming segm
get:aeither raise 
get:athe system) o
get:aincoming segm
get:acontinue as i
get:acannot raise 
get:adetected in t
get:aterminated th
get:aincoming segm
get:amatch the loc
get:amust be sent.
get:aIf the incomi
get:asequence numb
get:areset has seq
get:aof the sequen
get:aThe connectio
get:a[Page 36]        
get:aSeptember 1981   
get:a3.  If the co
get:aFIN-WAIT-1, F
get:aany unaccepta
get:aunacceptible 
get:aacknowledgmen
get:aand an acknow
get:ato be receive
get:aIf an incomin
get:aprecedence wh
get:aand precedenc
get:aconnection go
get:anumber from t
get:aReset Processin
get:aIn all states e
get:aby checking the
get:ais in the windo
get:ato an initial S
get:aacknowledges th
get:aThe receiver of
get:areceiver was in
get:ain SYN-RECEIVED
get:athen the receiv
get:aaborts the conn
get:awas in any othe
get:aand goes to the
get:a3.5.  Closing a C
get:aCLOSE is an ope
get:anotion of closi
get:ainterpretation,
get:athe receiving s
get:ain a simplex fa
get:auntil he is tol
get:acould initiate 
get:aRECEIVE until s
get:ahas CLOSED.  We
get:aRECEIVEs are ou
get:acan terminate h
get:abuffers SENT be
get:adata in return 
get:asuccessfully to
get:aTCP.  Users mus
get:athe TCP says no
get:aTransmission Cont
get:aFunctional Specif
get:aThere are essen:tially three cases
get:a1) The user i
get:a2) The remote
get:a3) Both users
get:aCase 1:  Local 
get:aIn this case,
get:aoutgoing segm
get:aaccepted by t
get:aare allowed i
get:awill be retra
get:aboth acknowle
get:acan ACK this 
get:asend its own 
get:aCase 2:  TCP re
get:aIf an unsolic
get:acan ACK it an
get:auser will res
get:athe other TCP
get:auntil its own
get:aconnection.  
get:athe connectio
get:aCase 3:  both u
get:aA simultaneou
get:aFIN segments 
get:ahave been pro
get:ahas received.
get:a[Page 38]        
get:aSeptember 1981   
get:aTCP A      
get:a1.  ESTABLISHED
get:aFIN-WAIT-1 
get:a3.  FIN-WAIT-2 
get:a4.             
get:aTIME-WAIT  
get:a5.  TIME-WAIT  
get:aCLOSED     
get:aTCP A      
get:a1.  ESTABLISHED
get:a2.  (Close)    
get:aFIN-WAIT-1 
get:a3.  CLOSING    
get:a4.  TIME-WAIT  
get:a(2 MSL)    
get:aCLOSED     
get:aTransmission Cont
get:aFunctional Specif
get:a3.6.  Precedence 
get:aThe intent is t
get:awith exactly th
get:ahigher of the p
get:aThe precedence 
get:adefined in the 
get:aspecification t
get:athe security pa
get:auser group, and
get:aA connection at
get:alower precedenc
get:aa connection du
get:aacknowledgment 
get:aNote that TCP m
get:aprecedence will
get:asegments and po
get:aThe security pa
get:a(the values wou
get:anon-secure envi
get:aparameters, tho
get:a3.7.  Data Commun
get:aOnce the connec
get:aexchange of seg
get:a(checksum test 
get:aretransmission 
get:aDuplicate segme
get:aAs discussed in
get:acertain tests o
get:asegments to ver
get:aThe sender of d
get:athe variable SN
get:asequence number
get:akeeps track of 
get:avariable SND.UN
get:asent has been a
get:aWhen the sender
get:aSND.NXT.  When 
get:asends an acknow
get:a[Page 40]        
get:aSeptember 1981   
get:aacknowledgment 
get:athese variables
get:aThe amount by w
get:adata in the seg
get:asegments must c
get:aThe CLOSE user 
get:aflag in an inco
get:aRetransmission 
get:aBecause of the 
get:ainternetwork sy
get:aretransmission 
get:afor determining
get:aAn Example Re
get:aMeasure the
get:aparticular 
get:acovers that
get:asegments re
get:aTime (RTT).:  Next compute a Smoothed Round Trip Time (SRTT) as
get:aSRTT = ( 
get:aand based o:n this, compute the retransmission timeout (RTO) as
get:aRTO = min
get:awhere UBOUN
get:aLBOUND is a
get:aa smoothing
get:afactor (e.g
get:aThe Communicati
get:aThe objective o
get:ato stimulate th
get:apermit the rece
get:athe currently k
get:aThis mechanism 
get:athe end of urge
get:athe receive seq
get:amust tell the u
get:anumber catches 
get:aTransmission Cont
get:aFunctional Specif
get:ainto "normal mo
get:ais in "urgent m
get:aThe method empl
get:atransmitted.  T
get:ameaningful and 
get:athe urgent poin
get:ano urgent data 
get:aTo send an urge
get:aoctet.  If the 
get:athe urgent info
get:aManaging the Wi
get:aThe window sent
get:anumbers the sen
get:aprepared to acc
get:athe currently a
get:aIndicating a la
get:aarrives than ca
get:ain excessive re
get:anetwork and the
get:atransmission of
get:abetween each ne
get:aThe mechanisms 
get:asubsequently ad
get:athat much data.
get:adiscouraged.  T
get:ashrink the wind
get:aon the part of 
get:aThe sending TCP
get:aleast one octet
get:asending TCP mus
get:athe window is z
get:ainterval when t
get:aguarantee that 
get:awindow will be 
get:aWhen the receiv
get:astill send an a
get:aand current win
get:aThe sending TCP
get:a[Page 42]        
get:aSeptember 1981   
get:awhich fit the c
get:aretransmission 
get:aIn a connection
get:abe carried in a
get:anumber so there
get:aorder.  This is
get:ainformation to 
get:athe data receiv
get:athe window info
get:aacknowledgment 
get:aequal or greate
get:aThe window mana
get:acommunication p
get:aWindow Manage
get:aAllocating 
get:amany small 
get:afewer large
get:aOne suggest
get:adefer updat
get:aleast X per
get:aconnection 
get:aAnother sug
get:asegments by
get:asending dat
get:adata must b
get:aNote that t
get:aretransmiss
get:aacknowledgm
get:awindow info
get:anew window 
get:aThe segment
get:aof transmit
get:asegment con
get:ais accepted
get:aIf the send
get:awindow is n
get:aalternating
get:apauses in t
get:aTransmission Cont
get:aFunctional Specif
get:aresult in b
get:abig pair. A
get:amostly smal
get:aThe suggest
get:aactively at
get:awindows, si
get:ato many sma
get:aThere are of co:urse two interfaces of concern
get:aand the TCP/low
get:aof the user/TCP
get:aprotocol module
get:ain detail by th
get:acase that the l
get:athat TCPs might
get:aUser/TCP Interf
get:aThe following
get:aat best, fict
get:afacilities.  
get:aimplementatio
get:aTCPs must pro
get:athat all TCP 
get:ahierarchy.  T
get:arequired of a
get:aTCP User Comm
get:aThe followi
get:ainterface. 
get:afunction ca
get:ameant to ru
get:aThe user co
get:aTCP must pe
get:aIndividual 
get:amay provide
get:asingle call
get:aautomatical
get:aissued by t
get:a[Page 44]        
get:aSeptember 1981   
get:aIn providin
get:anot only ac
get:aprocesses i:t serves.  The latter consists of
get:a(a) gener
get:aremote cl
get:a(b) repli
get:avarious t
get:aFormat:  
get:a[, timeou
get:a-> local 
get:aWe assume
get:aprocesses
get:ato use th
get:aimplement
get:afor the s
get:alower lev
get:aresult of
get:aable to m
get:aprocess c
get:aIf the ac
get:acall to L
get:ahave eith
get:aparticula
get:afor any c
get:aby the su
get:aA transmi
get:afilled in
get:aOn an act
get:asynchroni
get:aThe timeo
get:afor all d
get:adelivered
get:awill abor
get:aThe TCP o
get:athe users
get:aTransmission Cont
get:aFunctional Specif
get:aprecedenc
get:aor securi
get:athe defau
get:aTCP will 
get:asecurity/
get:athe prece
get:arequested
get:aThe prece
get:arequested
get:arequest, 
get:aconnectio
get:athis prec
get:aallowed t
get:aor that a
get:aA local c
get:aThe local
get:afor the c
get:aFormat:  
get:acount, PU
get:aThis call
get:ato be sen
get:anot been 
get:aimplement
get:aautomatic
get:aauthorize
get:aIf the PU
get:ato the re
get:asegment c
get:athe data 
get:atransmiss
get:aIf the UR
get:awill have
get:athe urgen
get:apointer i
get:abeen cons
get:ais to sti
get:aindicate 
get:a[Page 46]        
get:aSeptember 1981   
get:adata has 
get:aTCP signa
get:aof times 
get:aurgent da
get:aIf no for
get:aconnectio
get:ahas becom
get:alocal soc
get:aforeign s
get:aforeign s
get:aknowing t
get:aHowever, 
get:abecomes s
get:aSTATUS ca
get:aimplement
get:asocket is
get:aIf a time
get:aconnectio
get:aIn the si
get:athe sendi
get:aor the ti
get:ais both s
get:aconnectio
get:aoffers po
get:asophistic
get:athe proce
get:afurthermo
get:aMultiple 
get:athe TCP w
get:aWe have i
get:awhich a S
get:apseudo-in
get:areturn a 
get:aimmediate
get:abeen ackn
get:aassume ev
get:aclose any
get:akind (syn
get:asignals, 
get:awith spec
get:aIn order 
get:aindicatio
get:aTransmission Cont
get:aFunctional Specif
get:abuffer ad
get:athe SEND 
get:aindicatin
get:acalling p
get:aFormat:  
get:acount) ->
get:aThis comm
get:aspecified
get:acalling p
get:aerror is 
get:aIn the si
get:acalling p
get:aerror occ
get:aA more so
get:aRECEIVEs 
get:asegments 
get:athe cost 
get:anotify th
get:aIf enough
get:athe PUSH 
get:aThe buffe
get:aa PUSH is
get:areturned 
get:aIf there 
get:aas it arr
get:ashould th
get:aadditiona
get:acall to R
get:amay now l
get:aurgent po
get:ain the sa
get:aboundary 
get:aTo distin
get:acare of t
get:areturn co
get:acount ind
get:aAlternati
get:a[Page 48]        
get:aSeptember 1981   
get:aallocate 
get:awith the 
get:aFormat:  
get:aThis comm
get:athe conne
get:aauthorize
get:aClosing c
get:athe sense
get:aretransmi
get:aserviced.
get:acalls, fo
get:ato the de
get:acontinue 
get:amay be tr
get:ameans "I 
get:areceive a
get:anot well 
get:aof all it
get:ainto ABOR
get:aThe user 
get:ainitiativ
get:a(e.g., re
get:adestinati
get:aBecause c
get:aforeign T
get:ashort tim
get:areplies t
get:aClose als
get:aFormat:  
get:aThis is a
get:aexcluded 
get:atypically
get:aThis comm
get:ainformati:on
get:alocal s
get:aTransmission Cont
get:aFunctional Specif
get:aforeign
get:alocal c
get:areceive
get:asend wi
get:aconnect
get:anumber 
get:anumber 
get:aurgent 
get:aprecede
get:asecurit
get:aand tra
get:aDepending
get:aimplement
get:aavailable
get:aauthorize
get:aprevents 
get:aconnectio
get:aFormat:  
get:aThis comm
get:aaborted, 
get:abe sent t
get:aDepending
get:aindicatio
get:areceive a
get:aTCP-to-User M
get:aIt is assum
get:ameans for t
get:athe TCP doe
get:ato the user
get:aan error me
get:arelating to
get:aother user 
get:aThe followi:ng information is provided
get:aLocal Con
get:aResponse 
get:aBuffer Ad
get:aByte coun
get:aPush flag
get:aUrgent fl
get:a[Page 50]        
get:aSeptember 1981   
get:aTCP/Lower-Level
get:aThe TCP calls
get:areceive infor
get:ainternetwork 
get:aProtocol (IP)
get:aIf the lower 
get:aof service an
get:afor these par:ameters
get:aType of Ser:vice = Precedence: routine, Delay: normal, Throughput
get:anormal, Rel:iability
get:aTime to Liv
get:aNote that
get:aHere we e
get:abe delive
get:aIf the lower 
get:afeature) and 
get:aroute informa
get:aso that the s
get:achecksum be t
get:aalso importan
get:aAny lower lev
get:adestination a
get:athe "TCP leng
get:aof IP and to 
get:aTransmission Cont
get:aFunctional Specif
get:a3.9.  Event Proce
get:aThe processing 
get:aimplementation.
get:aprocessing sequ
get:asection only in
get:aThe activity of
get:aThe events that: occur can be cast into three categories
get:aarriving segmen
get:aprocessing the 
get:acases the proce
get:aEvents that o:ccur
get:aArriving Se
get:aSEGMENT A
get:aUSER TIME
get:aRETRANSMI
get:aTIME-WAIT
get:aThe model of th
get:aimmediate retur
get:apseudo interrup
get:ameans cause a d
get:aError responses
get:acommands refere:ncing connections that do not exist receive "error
get:aconnection not 
get:aPlease note in 
get:aacknowledgment 
get:aof the sequence
get:aequal to (modul
get:a[Page 52]        
get:aSeptember 1981   
get:aA natural way t
get:aimagine that th
get:athat their cont
get:ain the sequence
get:aand processed i
get:aWhen a segment 
get:athe segment to 
get:ato be consisten
get:aNote that if no
get:aTransmission Cont
get:aFunctional Specif
get:aCLOSED STATE 
get:aCreate a ne
get:astate infor
get:asocket, pre
get:ainformation
get:aunspecified
get:aparameters 
get:aprecedence 
get:a"error:  pr:ecedence not allowed" or "error
get:anot allowed
get:aactive and :the foreign socket is unspecified, return "error
get:aforeign soc
get:aspecified, 
get:a(ISS) is se
get:ais sent.  S
get:astate, and 
get:aIf the call
get:areturn "err:or
get:ano room to :create a new connection, return "error
get:aresources".
get:aIf active a
get:aconnection 
get:asegment, se
get:astate.  Dat
get:aqueued for 
get:aurgent bit 
get:asegments se
get:aqueue the r:equest, respond with "error
get:aIf Foreign :socket was not specified, then return "error
get:asocket unsp
get:a[Page 54]        
get:aSeptember 1981   
get:aSYN-SENT STAT
get:aSYN-RECEIVED 
get:aESTABLISHED S
get:aFIN-WAIT-1 ST
get:aFIN-WAIT-2 ST
get:aCLOSE-WAIT ST
get:aCLOSING STATE
get:aLAST-ACK STAT
get:aTIME-WAIT STA
get:aReturn "err:or
get:aTransmission Cont
get:aFunctional Specif
get:aCLOSED STATE 
get:aIf the user
get:a"error:  co
get:aOtherwise, :return "error
get:aIf the fore
get:afrom passiv
get:aSND.UNA to 
get:aassociated 
get:atransmissio
get:arequested i
get:aas a result
get:arequest, re:spond with "error
get:aForeign soc:ket was not specified, then return "error
get:asocket unsp
get:aSYN-SENT STAT
get:aSYN-RECEIVED 
get:aQueue the d
get:aIf no space: to queue, respond with "error
get:aresources".
get:aESTABLISHED S
get:aCLOSE-WAIT ST
get:aSegmentize 
get:aacknowledgm
get:ainsufficien:t space to remember this buffer, simply return "error
get:ainsufficien
get:aIf the urge
get:aurgent poin
get:a[Page 56]        
get:aSeptember 1981   
get:aFIN-WAIT-1 ST
get:aFIN-WAIT-2 ST
get:aCLOSING STATE
get:aLAST-ACK STAT
get:aTIME-WAIT STA
get:aReturn "err:or
get:aTransmission Cont
get:aFunctional Specif
get:aCLOSED STATE 
get:aIf the user
get:a"error:  co
get:aOtherwise r:eturn "error
get:aSYN-SENT STAT
get:aSYN-RECEIVED 
get:aQueue for p
get:ais no room :to queue this request, respond with "error
get:ainsufficien
get:aESTABLISHED S
get:aFIN-WAIT-1 ST
get:aFIN-WAIT-2 ST
get:aIf insuffic
get:arequest, qu
get:aremember th:e RECEIVE, respond with "error
get:aresources".
get:aReassemble 
get:ato user.  M
get:aIf RCV.UP i
get:auser notify
get:aWhen the TC
get:athat fact m
get:aacknowledgm
get:adescribed b
get:a[Page 58]        
get:aSeptember 1981   
get:aCLOSE-WAIT ST
get:aSince the r
get:asatisfied b
get:auser.  If n
get:a"error:  co
get:atext can be
get:aCLOSING STATE
get:aLAST-ACK STAT
get:aTIME-WAIT STA
get:aReturn "err:or
get:aTransmission Cont
get:aFunctional Specif
get:aCLOSED STATE 
get:aIf the user
get:a"error:  co
get:aOtherwise, :return "error
get:aAny outstan:ding RECEIVEs are returned with "error
get:aresponses. 
get:aSYN-SENT STAT
get:aDelete the :TCB and return "error
get:aqueued SEND
get:aSYN-RECEIVED 
get:aIf no SENDs
get:athen form a
get:aotherwise q
get:aESTABLISHED S
get:aQueue this 
get:aform a FIN 
get:aFIN-WAIT-1 ST
get:aFIN-WAIT-2 ST
get:aStrictly sp:eaking, this is an error and should receive a "error
get:aconnection 
get:aacceptable,
get:aFIN may be 
get:a[Page 60]        
get:aSeptember 1981   
get:aCLOSE-WAIT ST
get:aQueue this 
get:asegmentized
get:aCLOSING STATE
get:aLAST-ACK STAT
get:aTIME-WAIT STA
get:aRespond wit:h "error
get:aTransmission Cont
get:aFunctional Specif
get:aCLOSED STATE 
get:aIf the user
get:a"error:  co
get:aOtherwise r:eturn "error
get:aAny outstan:ding RECEIVEs should be returned with "error
get:aconnection 
get:aSYN-SENT STAT
get:aAll queued 
get:anotificatio
get:aSYN-RECEIVED 
get:aESTABLISHED S
get:aFIN-WAIT-1 ST
get:aFIN-WAIT-2 ST
get:aCLOSE-WAIT ST
get:aSend a rese:t segment
get:a<SEQ=SND.
get:aAll queued 
get:anotificatio
get:aRST formed 
get:aTCB, enter 
get:aCLOSING STATE
get:aLAST-ACK STAT
get:aTIME-WAIT STA
get:aRespond wit
get:a[Page 62]        
get:aSeptember 1981   
get:aCLOSED STATE 
get:aIf the user
get:a"error:  co
get:aOtherwise r:eturn "error
get:aReturn "sta
get:aSYN-SENT STAT
get:aReturn "sta
get:aSYN-RECEIVED 
get:aReturn "sta
get:aESTABLISHED S
get:aReturn "sta
get:aFIN-WAIT-1 ST
get:aReturn "sta
get:aFIN-WAIT-2 ST
get:aReturn "sta
get:aCLOSE-WAIT ST
get:aReturn "sta
get:aCLOSING STATE
get:aReturn "sta
get:aLAST-ACK STAT
get:aReturn "sta
get:aTransmission Cont
get:aFunctional Specif
get:aTIME-WAIT STA
get:aReturn "sta
get:a[Page 64]        
get:aSeptember 1981   
get:aSEGMENT ARRIVES
get:aIf the state 
get:aall data in
get:asegment con
get:acontaining 
get:aacknowledgm
get:areset seque
get:aIf the ACK 
get:a<SEQ=0><A
get:aIf the ACK 
get:a<SEQ=SEG.
get:aIf the state 
get:afirst check
get:aAn incomi
get:asecond chec
get:aAny ackno
get:athe LISTE
get:afor any a
get:aformatted: as follows
get:a<SEQ=SE
get:athird check
get:aIf the SY
get:asecurity/
get:amatch the
get:a<SEQ=SE
get:aTransmission Cont
get:aFunctional Specif
get:aIf the SE
get:athe user 
get:asend a re
get:a<SEQ=SE
get:aIf the SE
get:aSet RCV.N
get:acontrol o
get:ashould be: selected and a SYN segment sent of the form
get:a<SEQ=IS
get:aSND.NXT i
get:astate sho
get:aincoming 
get:ain the SY
get:anot be re
get:athe forei
get:aunspecifi
get:afourth othe
get:aAny other
get:amust have
get:aprocessin
get:ait could 
get:aincarnati
get:abut if yo
get:aIf the state 
get:afirst check
get:aIf the AC
get:aIf SEG.
get:athe RST
get:a<SEQ=
get:aand dis
get:aIf SND.
get:asecond chec
get:a[Page 66]        
get:aSeptember 1981   
get:aIf the RS
get:aIf the :ACK was acceptable then signal the user "error
get:aconnect
get:adelete 
get:aand ret
get:athird check
get:aIf the se
get:amatch the
get:aIf ther
get:a<SEQ=
get:aOtherwi
get:a<SEQ=
get:aIf there 
get:aThe pre
get:aTCB, if
get:a<SEQ=
get:aIf there 
get:aIf the 
get:ain the 
get:athe pre
get:aallowed
get:a<SEQ=
get:aIf the 
get:ain the 
get:aIf a rese
get:afourth chec
get:aThis step
get:ano ACK, a
get:aIf the SY
get:aTransmission Cont
get:aFunctional Specif
get:aare accep
get:aSEG.SEQ. 
get:ais an ACK
get:aare there
get:aIf SND.UN
get:astate to 
get:a<SEQ=SN
get:aand send 
get:atransmiss
get:atext in t
get:abelow whe
get:aOtherwise
get:a<SEQ=IS
get:aand send 
get:asegment, 
get:ahas been 
get:afifth, if n
get:asegment and
get:a[Page 68]        
get:aSeptember 1981   
get:afirst check s
get:aSYN-RECEIVE
get:aESTABLISHED
get:aFIN-WAIT-1 
get:aFIN-WAIT-2 
get:aCLOSE-WAIT 
get:aCLOSING STA
get:aLAST-ACK ST
get:aTIME-WAIT S
get:aSegments 
get:aare used 
get:adone in S
get:aboundary 
get:aprocessed
get:aThere are
get:asegment
get:aSegment R
get:aLength  W
get:a------- -
get:a0     
get:a0     
get:a>0     
get:a>0     
get:aIf the RC
get:aspecial a
get:aIf an inc
get:ashould be
get:athe segme:nt and return)
get:a<SEQ=SN
get:aAfter sen
get:aand retur
get:aTransmission Cont
get:aFunctional Specif
get:aIn the fo
get:asegment t
get:aOne could
get:atrimming 
get:aSYN and F
get:abegins at
get:anumbers m
get:asecond check 
get:aSYN-RECEIVE
get:aIf the RS
get:aIf this
get:acame fr
get:aLISTEN 
get:athis co
get:afrom SY
get:athe use
get:aon the 
get:aactive 
get:aand ret
get:aESTABLISHED
get:aIf the RS
get:ashould re
get:aflushed. 
get:a"connecti
get:aTCB, and 
get:aCLOSING STA
get:aLAST-ACK ST
get:aIf the RS
get:aTCB, and 
get:a[Page 70]        
get:aSeptember 1981   
get:athird check s
get:aSYN-RECEIVE
get:aIf the se
get:aexactly m
get:athen send
get:aESTABLISHED
get:aIf the se
get:aexactly m
get:athen send
get:areceive "
get:aflushed. 
get:a"connecti
get:aTCB, and 
get:aNote this c
get:aa segment f
get:adifferent s
get:acurrent con
get:afourth, check
get:aSYN-RECEIVE
get:aESTABLISHED
get:aFIN-WAIT ST
get:aFIN-WAIT ST
get:aCLOSE-WAIT 
get:aCLOSING STA
get:aLAST-ACK ST
get:aTIME-WAIT S
get:aIf the SY
get:aoutstandi
get:aall segme
get:areceive a
get:athe CLOSE
get:aIf the SY
get:aand an ac
get:anumber ch
get:aTransmission Cont
get:aFunctional Specif
get:afifth check t
get:aif the ACK 
get:aif the ACK 
get:aSYN-RECEI
get:aIf SND.
get:aand con
get:aIf th
get:areset
get:a<SE
get:aand s
get:aESTABLISH
get:aIf SND.
get:aAny seg
get:aentirel
get:apositiv
get:afully a
get:a"ok" re
get:a(SEG.AC
get:asomethi
get:adrop th
get:aIf SND.
get:aupdated
get:aSND.WL2
get:aSND.WL1
get:aNote th
get:arecords
get:aSND.WND
get:athe las
get:aprevent
get:a[Page 72]        
get:aSeptember 1981   
get:aFIN-WAIT-
get:aIn addi
get:aour FIN
get:aprocess
get:aFIN-WAIT-
get:aIn addi
get:athe ret
get:aacknowl
get:aCLOSE-WAI
get:aDo the 
get:aCLOSING S
get:aIn addi
get:athe ACK
get:aotherwi
get:aLAST-ACK 
get:aThe onl
get:aacknowl
get:adelete 
get:aTIME-WAIT
get:aThe onl
get:aretrans
get:athe 2 M
get:asixth, check 
get:aESTABLISHED
get:aFIN-WAIT-1 
get:aFIN-WAIT-2 
get:aIf the UR
get:athe user 
get:apointer (
get:auser has 
get:amode") fo
get:asignal th
get:aTransmission Cont
get:aFunctional Specif
get:aCLOSE-WAIT 
get:aCLOSING STA
get:aLAST-ACK ST
get:aThis shou
get:aremote si
get:aseventh, proc
get:aESTABLISHED
get:aFIN-WAIT-1 
get:aFIN-WAIT-2 
get:aOnce in t
get:atext to u
get:ainto buff
get:aempty.  I
get:athe user 
get:ahas been 
get:aWhen the 
get:auser it m
get:aOnce the 
get:aRCV.NXT o
get:aapporopri
get:aRCV.NXT a
get:aPlease no
get:aSend an a:cknowledgment of the form
get:a<SEQ=SN
get:aThis ackn
get:atransmitt
get:a[Page 74]        
get:aSeptember 1981   
get:aCLOSE-WAIT 
get:aCLOSING STA
get:aLAST-ACK ST
get:aTIME-WAIT S
get:aThis shou
get:aremote si
get:aeighth, check
get:aDo not proc
get:asince the S
get:aIf the FIN 
get:areturn any 
get:aover the FI
get:aFIN implies
get:aSYN-RECEI
get:aESTABLISH
get:aEnter t
get:aFIN-WAIT-
get:aIf our 
get:aenter T
get:atimers;
get:aFIN-WAIT-
get:aEnter t
get:aoff the
get:aCLOSE-WAI
get:aRemain 
get:aCLOSING S
get:aRemain 
get:aLAST-ACK 
get:aRemain 
get:aTransmission Cont
get:aFunctional Specif
get:aTIME-WAIT
get:aRemain 
get:atimeout
get:a[Page 76]        
get:aSeptember 1981   
get:aFor any state
get:athe user "err:or
get:aand for any o
get:astate and ret
get:aRETRANSMISSION 
get:aFor any state
get:athe retransmi
get:aretransmissio
get:aTIME-WAIT TIMEO
get:aIf the time-w
get:aenter the CLO
get:aTransmission Cont
get:a[Page 78]        
get:aSeptember 1981   
get:aBBN Rep
get:aa Host 
get:ahost an
get:aA contr
get:aindicat
get:aspecifi
get:ais expe
get:apreviou
get:aThe uni
get:aARPANET
get:aA unit 
get:aIMPs.  
get:aA logic
get:aA messa
get:anetwork
get:aDestination Addre
get:aThe des
get:aidentif
get:aA contr
get:aindicat
get:aoccupyi
get:aA porti
get:afragmen
get:aA file 
get:aTransmission Cont
get:aControl
get:afragmen
get:aA compu
get:afrom th
get:aAn Inte
get:aby the 
get:aThe Int
get:aARPANET
get:aA sourc
get:ainternet datagram
get:aThe uni
get:ahigher 
get:ainternet fragment
get:aA porti
get:aheader.
get:aInterne
get:aThe Ini
get:anumber 
get:aThe Ini
get:aon a co
get:abased p
get:aThe Ini
get:aused by
get:aControl
get:adata.  
get:aon an A
get:a[Page 80]        
get:aSeptember 1981   
get:aThis is
get:adata re
get:asequenc
get:aof the 
get:aThe uni
get:aAn impl
get:aprocedu
get:aMaximum
get:athe int
get:aAn eigh
get:aAn Opti
get:amay be 
get:aprimari
get:atimesta
get:aoptions
get:aA packa
get:alogical
get:alogical
get:aThe por
get:aoutput 
get:aA progr
get:athe poi
get:aA contr
get:athis se
get:areceivi
get:areceive
get:aTransmission Cont
get:areceive
get:areceive
get:areceive next sequ
get:aThis is
get:areceive
get:aThis re
get:ais will
get:asegment
get:aRCV.NXT
get:aSegment
get:arange a
get:aA contr
get:athat th
get:ainterac
get:asequenc
get:asegment
get:ait.  In
get:arise to
get:aReal Ti:me Protocol
get:aof time
get:asegment
get:asegment
get:asegment
get:asegment
get:asegment
get:a[Page 82]        
get:aSeptember 1981   
get:asegment
get:aA logic
get:aunit of
get:asegment acknowled
get:aThe seq
get:aarrivin
get:aThe amo
get:aincludi
get:aThe num
get:aThis is
get:ause on 
get:ainitial
get:aeach oc
get:aThis re
get:a(receiv
get:awindow 
get:areceivi
get:abe emit
get:aSND.UNA
get:abetween
get:asend se
get:aleft se
get:asend ur
get:asegment
get:asegment
get:aTransmission Cont
get:asend wi
get:aAn addr
get:ais, the
get:aThe sou
get:aA contr
get:anumber,
get:awhere t
get:aTransmi
get:athe sta
get:aThe pre
get:aTransmi:ssion Control Protocol
get:areliabl
get:aType of
get:aAn Inte
get:afor thi
get:aA contr
get:aindicat
get:aurgent 
get:asequenc
get:apointer
get:aA contr
get:afield c
get:aindicat
get:aurgent 
get:a[Page 84]        
get:aSeptember 1981   
get:a[1]  Cerf, V., an
get:aIntercommuni
get:aVol. COM-22,
get:a[2]  Postel, J. (
get:aProtocol Spe
get:aInstitute, S
get:a[3]  Dalal, Y. an
get:aProtocols", 
get:aDecember 197
get:a[4]  Postel, J., 
get:aInstitute, S
get:bRFC
get:bDe
get:bI
get:bSeptember 1981   
get:bPREFACE .....
get:b1.  INTRODUCTION 
get:b1.1  Motivation
get:b1.2  Scope ....
get:b1.3  About This
get:b1.4  Interfaces
get:b1.5  Operation 
get:b2.  PHILOSOPHY ..
get:b2.1  Elements o
get:b2.2  Model of O
get:b2.3  The Host E
get:b2.4  Interfaces
get:b2.5  Relation t
get:b2.6  Reliable C
get:b2.7  Connection
get:b2.8  Data Commu
get:b2.9  Precedence
get:b2.10 Robustness
get:b3.  FUNCTIONAL SP
get:b3.1  Header For
get:b3.2  Terminolog
get:b3.3  Sequence N
get:b3.4  Establishi
get:b3.5  Closing a 
get:b3.6  Precedence
get:b3.7  Data Commu
get:b3.8  Interfaces
get:b3.9  Event Proc
get:bGLOSSARY ........
get:bREFERENCES ......
get:bTransmission Cont
get:b[Page ii]        
get:bSeptember 1981   
get:bThis document des
get:b(TCP).  There hav
get:bspecification on 
get:bdraws heavily fro
get:bboth in terms of 
get:bseveral details a
get:band redescribes t
get:bRFC
get:bReplaces: RFC 761
get:bIENs:  129, 124, 
get:b55, 44, 40, 27, 2
get:bThe Transmission 
get:breliable host-to-
get:bcommunication net
get:bThis document des
get:bTransmission Cont
get:binterface to prog
get:bComputer commun
get:brole in militar
get:bdocument focuse
get:bcommunication r
get:bcommunication u
get:bcongestion, but
get:bgovernment sect
get:bAs strategic an
get:bdeveloped and d
get:binterconnecting
get:bcommunication p
get:bapplications.  
get:bDeputy Undersec
get:bdeclared the Tr
get:bbe a basis for 
get:bstandardization
get:bTCP is a connec
get:bfit into a laye
get:bapplications.  
get:bcommunication b
get:bdistinct but in
get:bassumptions are
get:bprotocols below
get:bpotentially unr
get:bprotocols.  In 
get:bwide spectrum o
get:bconnections to 
get:bTransmission Cont
get:bTCP is based on
get:bTCP fits into a
get:bInternet Protoc
get:breceive variabl
get:bdatagram "envel
get:baddressing sour
get:binternet protoc
get:bthe TCP segment
get:bmultiple networ
get:balso carries in
get:band compartment
get:bcommunicated en
get:bMuch of this do
get:bwhich are co-re
get:bcomputer.  Some
get:bfront-end compu
get:bas well as netw
get:ban interface to
get:bimplementable e
get:bhost-to-front e
get:bThe TCP is inte
get:bcommunication s
get:bintended to be 
get:b1.3.  About this 
get:bThis document r
get:bany TCP impleme
get:bprotocols and i
get:b[Page 2]         
get:bSeptember 1981   
get:bsection offers 
get:boperation.  Sec
get:bdesign.  Sectio
get:brequired of TCP
get:buser calls, err
get:bThe TCP interfa
get:bthe other side 
get:bThe interface b
get:billustrated in 
get:bcalls much like
get:bapplication pro
get:bcalls to open a
get:bestablished con
get:basynchronously 
get:bconsiderable fr
get:binterfaces whic
get:benvironment, a 
get:binterface for a
get:bThe interface b
get:bunspecified exc
get:btwo levels can 
get:bTypically, one 
get:binterface.  TCP
get:binterconnected 
get:bthroughout this
get:bAs noted above,
get:bsecurable logic
get:bprocesses.  To 
get:bcommunication s:ystem requires facilities in the following areas
get:bBasic Data Tr
get:bPrecedence an
get:bThe basic opera
get:bthe following p
get:bTransmission Cont
get:bBasic Data Tran:sfer
get:bThe TCP is ab
get:bdirection bet
get:bsegments for 
get:bthe TCPs deci
get:bSometimes use
get:bsubmitted to 
get:bfunction is d
get:bactually tran
get:bpushed throug
get:bpromptly forw
get:bThe exact pus
get:bthe push func
get:bReliability
get:bThe TCP must 
get:bdelivered out
get:bis achieved b
get:btransmitted, 
get:breceiving TCP
get:binterval, the
get:bnumbers are u
get:bout of order 
get:badding a chec
get:breceiver, and
get:bAs long as th
get:bsystem does n
get:berrors will a
get:binternet comm
get:bFlow Control
get:bTCP provides 
get:bsent by the s
get:bevery ACK ind
get:bthe last segm
get:ballowed numbe
get:breceiving fur
get:b[Page 4]         
get:bSeptember 1981   
get:bMultiplexing
get:bTo allow for 
get:bcommunication
get:baddresses or 
get:band host addr
get:ba socket.  A 
get:bThat is, a so
get:bThe binding o
get:bHost.  Howeve
get:b(e.g., a "log
get:bmade known to
get:bthrough the k
get:baddresses of 
get:bConnections
get:bThe reliabili
get:bthat TCPs ini
get:beach data str
get:bsockets, sequ
get:bEach connecti
get:bidentifying i
get:bWhen two proc
get:bestablish a c
get:bside).  When 
get:bterminated or
get:bSince connect
get:bover the unre
get:bmechanism wit
get:berroneous ini
get:bPrecedence and :Security
get:bThe users of 
get:bcommunication
get:bthese feature
get:bTransmission Cont
get:b[Page 6]         
get:bSeptember 1981   
get:b2.1.  Elements of
get:bThe internetwor
get:bwhich are in tu
get:bthat the networ
get:blarge networks 
get:bpacket switchin
get:bconsume message
get:bnetworks, the g
get:bcommunication s
get:bconnections bet
get:bThe term packet
get:btransaction bet
get:bexchanged withi
get:bHosts are compu
get:bnetwork's point
get:bProcesses are v
get:baccordance with
get:bin execution). 
get:bviewed as commu
get:bThus, all commu
get:bSince a process
get:bstreams between
get:bthat each proce
get:bcommunicates wi
get:b2.2.  Model of Op
get:bProcesses trans
get:bdata as argumen
get:bsegments and ca
get:bthe destination
get:binto the receiv
get:bTCPs include co
get:bensure reliable
get:bThe model of in
get:bprotocol module
get:bto the local ne
get:binside internet
get:binternet module
get:bthrough the loc
get:bThe packet swit
get:bTransmission Cont
get:bother operation
get:bdestination int
get:bAt a gateway be
get:bfrom its local 
get:bthe internet da
get:bthen "wrapped" 
get:brouted to the n
get:bA gateway is pe
get:binternet datagr
get:bthrough the nex
get:binternet datagr
get:bfurther broken 
get:binternet datagr
get:binternet module
get:bA destination i
get:b(after reassemb
get:bdestination TCP
get:bThis simple mod
get:bimportant featu
get:bto the gateway 
get:bservice paramet
get:bIncluded in the
get:bdatagram.  Data
get:bhost and gatewa
get:bproperly segreg
get:b2.3.  The Host En
get:bThe TCP is assu
get:baccess the TCP 
get:bmay call on oth
get:bdata structures
get:bcontrolled by a
get:bnetwork device 
get:bdatagram protoc
get:bThe mechanisms 
get:bfront-end proce
get:bhost-to-front-e
get:bthe type of TCP
get:b[Page 8]         
get:bSeptember 1981   
get:bThe TCP/user in
get:bto OPEN or CLOS
get:bSTATUS about a 
get:bprograms on the
get:bfrom, and close
get:bThe TCP/interne
get:bdatagrams addre
get:bsystem.  These 
get:bservice, preced
get:b2.5.  Relation to
get:bThe following d
get:bhierarchy
get:b+------+ +
get:b|Telnet| |
get:b+------+ +
get:b|   
get:b+----
get:b| TCP
get:b+----
get:b| 
get:b+----
get:b|    
get:b+----
get:b+--
get:b|  
get:b+--
get:bIt is expected 
get:bprotocols effic
get:bprotocols like 
get:b2.6.  Reliable Co
get:bA stream of dat
get:border at the de
get:bTransmission Cont
get:bTransmission is
get:backnowledgments
get:bsequence number
get:bsegment is tran
get:bsequence number
get:bis the sequence
get:btransmissions i
get:bsegment contain
get:bstarts a timer;
get:bsegment is dele
get:breceived before
get:bAn acknowledgme
get:bdelivered to th
get:bthe responsibil
get:bTo govern the f
get:bemployed.  The 
get:bThis window spe
get:backnowledgment 
get:b2.7.  Connection 
get:bTo identify the
get:bprovides a port
get:bindependently b
get:bunique addresse
get:bidentifying the
get:bwill be unique 
get:bA connection is
get:blocal socket ma
get:bsockets.  A con
get:bthat is, it is 
get:bTCPs are free t
get:bHowever, severa
get:bThere must be w
get:bthe "appropriat
get:bmay "own" ports
get:bthe ports they 
get:bissue, but we e
get:buniquely alloca
get:bassociating the
get:bA connection is
get:bforeign socket 
get:b[Page 10]        
get:bSeptember 1981   
get:bconnection name
get:bsubsequent call
get:babout a connect
get:bis a data struc
get:bimplementation 
get:bpointer to the 
get:bwhether the con
get:bbe passively wa
get:bA passive OPEN 
get:bconnection requ
get:bOften the proce
get:brequest from an
get:bis used to deno
get:bare allowed onl
get:bA service proce
get:bprocesses would
get:bforeign socket.
get:brequested a con
get:blocal socket we
get:bWell-known sock
get:ba socket addres
get:b"Telnet-Server"
get:bsocket, and oth
get:bEntry, Text Gen
get:bbeing for test 
get:baccess to a "Lo
get:bat which a newl
get:bwell-known sock
get:bof sockets to s
get:bProcesses can i
get:bfrom other proc
get:bbeen establishe
get:bother at the sa
get:bis critical for
get:bcomponents act 
get:bThere are two p
get:bpassive OPENs a
get:blocal passive O
get:bcase, the match
get:bOPENs has left 
get:bforeign socket 
get:bOther possibili
get:bTransmission Cont
get:bIf there are se
get:bsame local sock
get:bwith the specif
get:bTCB exists, bef
get:bThe procedures 
get:bcontrol flag an
get:bexchange has be
get:bA connection is
get:bcontaining a SY
get:bcommand.  The m
get:bconnection has 
get:bwhen sequence n
get:bThe clearing of
get:bin this case ca
get:b2.8.  Data Commun
get:bThe data that f
get:boctets.  The se
get:bin that call (a
get:bthrough to the 
get:bA sending TCP i
get:bsend that data 
get:bfunction is sig
get:breceiving TCP s
get:bthe sending TCP
get:bThere is no nec
get:bboundaries.  Th
get:bsingle SEND cal
get:bThe purpose of 
get:bfrom the sendin
get:brecord service.
get:bThere is a coup
get:bof data that cr
get:bassociated with
get:bbuffer is retur
get:bnot filled.  If
get:bPUSH is seen, t
get:bTCP also provid
get:bat some point f
get:b[Page 12]        
get:bSeptember 1981   
get:bcurrently readi
get:bdefine what the
get:burgent data, bu
get:btake action to 
get:b2.9.  Precedence 
get:bThe TCP makes u
get:bsecurity option
get:bbasis to TCP us
get:ba multilevel se
get:buse only, and o
get:bcompartment.  C
get:busers may be li
get:bTCP modules whi
get:bproperly mark o
get:bprecedence.  Su
get:bhigher level pr
get:bthem to specify
get:bprecedence of c
get:b2.10.  Robustness
get:bTCP implementat:ions will follow a general principle of robustness
get:bconservative in
get:bTransmission Cont
get:b[Page 14]        
get:bSeptember 1981   
get:b3.1.  Header Form
get:bTCP segments ar
get:bheader carries 
get:bdestination hos
get:bheader, supplyi
get:bdivision allows
get:bTCP Header Form
get:b0            
get:b0 1 2 3 4 5 6
get:b+-+-+-+-+-+-+-
get:b|          Sou
get:b+-+-+-+-+-+-+-
get:b|             
get:b+-+-+-+-+-+-+-
get:b|             
get:b+-+-+-+-+-+-+-
get:b|  Data |     
get:b| Offset| Rese
get:b|       |     
get:b+-+-+-+-+-+-+-
get:b|           Ch
get:b+-+-+-+-+-+-+-
get:b|             
get:b+-+-+-+-+-+-+-
get:b|             
get:b+-+-+-+-+-+-+-
get:bNote th
get:bSource Port:  1
get:bThe source po
get:bDestination Por:t
get:bThe destinati
get:bTransmission Cont
get:bFunctional Specif
get:bSequence Number:
get:bThe sequence 
get:bwhen SYN is p
get:binitial seque
get:bAcknowledgment :Number
get:bIf the ACK co
get:bnext sequence
get:breceive.  Onc
get:bData Offset:  4
get:bThe number of
get:bthe data begi
get:bintegral numb
get:bReserved:  6 bi
get:bReserved for 
get:bControl Bits:  :6 bits (from left to right)
get:bURG:  Urgent 
get:bACK:  Acknowl
get:bPSH:  Push Fu
get:bRST:  Reset t
get:bSYN:  Synchro
get:bFIN:  No more
get:bWindow:  16 bit
get:bThe number of
get:backnowledgmen
get:bChecksum:  16 b
get:bThe checksum 
get:bcomplement su
get:bsegment conta
get:bchecksummed, 
get:bform a 16 bit
get:btransmitted a
get:bthe checksum 
get:bThe checksum 
get:b[Page 16]        
get:bSeptember 1981   
get:bprefixed to t
get:bAddress, the 
get:bThis gives th
get:binformation i
get:bacross the TC
get:bcalls by the 
get:bThe TCP Len
get:boctets (thi
get:bcomputed), 
get:bUrgent Pointer:
get:bThis field co
get:bpositive offs
get:burgent pointe
get:bthe urgent da
get:bthe URG contr
get:bOptions:  varia
get:bOptions may o
get:bmultiple of 8
get:bchecksum.  An
get:bcases for the: format of an option
get:bCase 1:  A 
get:bCase 2:  An
get:bth
get:bThe option-le
get:boption-length
get:bNote that the
get:bfield might i
get:bEnd-of-Option
get:bA TCP must im
get:bTransmission Cont
get:bFunctional Specif
get:bCurrently def:ined options include (kind indicated in octal)
get:bKind     Le
get:b----     --
get:b0         
get:b1         
get:b2         
get:bSpecific Opti
get:bEnd of Opti
get:b+--------
get:b|00000000
get:b+--------
get:bThis opti
get:bmight not
get:bthe Data 
get:bnot the e
get:bthe optio
get:bNo-Operatio
get:b+--------
get:b|00000001
get:b+--------
get:bThis opti
get:balign the
get:bThere is 
get:breceivers
get:bnot begin
get:bMaximum Seg
get:b+--------
get:b|00000010
get:b+--------
get:bKind=2  
get:b[Page 18]        
get:bSeptember 1981   
get:bMaximum S:egment Size Option Data
get:bIf this
get:breceive
get:bThis fi
get:b(i.e., 
get:boption 
get:bPadding:  varia
get:bThe TCP heade
get:band data begi
get:b3.2.  Terminology
get:bBefore we can d
get:bto introduce so
get:bconnection requ
get:bof these variab
get:bTransmission Co
get:bTCB are the loc
get:bprecedence of t
get:bbuffers, pointe
get:bIn addition sev
get:bsequence number
get:bSend Sequence
get:bSND.UNA - s
get:bSND.NXT - s
get:bSND.WND - s
get:bSND.UP  - s
get:bSND.WL1 - s
get:bSND.WL2 - s
get:bu
get:bISS     - i
get:bReceive Seque
get:bRCV.NXT - r
get:bRCV.WND - r
get:bRCV.UP  - r
get:bIRS     - i
get:bTransmission Cont
get:bFunctional Specif
get:bThe following d
get:bthe sequence sp
get:bSend Sequence S
get:b---
get:b1 - old s
get:b2 - seque
get:b3 - seque
get:b4 - futur
get:bThe send window
get:bReceive Sequenc
get:b1 - old s
get:b2 - seque
get:b3 - futur
get:bThe receive win
get:bThere are also 
get:btake their valu
get:b[Page 20]        
get:bSeptember 1981   
get:bCurrent Segme
get:bSEG.SEQ - s
get:bSEG.ACK - s
get:bSEG.LEN - s
get:bSEG.WND - s
get:bSEG.UP  - s
get:bSEG.PRC - s
get:bA connection pr
get:blifetime.  The :states are
get:bESTABLISHED, FI
get:bTIME-WAIT, and 
get:bbecause it repr
get:bno connection. : Briefly the meanings of the states are
get:bLISTEN - repr
get:bTCP and port.
get:bSYN-SENT - re
get:bafter having 
get:bSYN-RECEIVED 
get:brequest ackno
get:bconnection re
get:bESTABLISHED -
get:bdelivered to 
get:bof the connec
get:bFIN-WAIT-1 - 
get:bfrom the remo
get:btermination r
get:bFIN-WAIT-2 - 
get:bfrom the remo
get:bCLOSE-WAIT - 
get:bfrom the loca
get:bCLOSING - rep
get:backnowledgmen
get:bLAST-ACK - re
get:bconnection te
get:b(which includ
get:bTransmission Cont
get:bFunctional Specif
get:bTIME-WAIT - r
get:bthe remote TC
get:btermination r
get:bCLOSED - repr
get:bA TCP connectio
get:bevents.  The ev
get:bABORT, and STAT
get:bcontaining the 
get:bThe state diagr
get:bwith the causin
get:berror condition
get:bchanges.  In a 
get:bthe reaction of
get:bNOTE BENE:  thi
get:bthe total speci
get:b[Page 22]        
get:bSeptember 1981   
get:b+---------+     
get:b|         |<----
get:b|   SYN   |     
get:b|   RCVD  |<----
get:b|         |     
get:b|         |-----
get:b+---------+   rc
get:b|           --
get:b|             
get:b|             
get:b|  CLOSE      
get:b| -------     
get:b| snd FIN     
get:b|             
get:bV             
get:b+---------+     
get:b|  FIN    |<----
get:b| WAIT-1  |-----
get:b+---------+     
get:b| rcv ACK of F
get:b| ------------
get:bV        x    
get:b+---------+     
get:b|FINWAIT-2|     
get:b+---------+     
get:b|             
get:b|  rcv FIN    
get:b|  -------    
get:b\ snd ACK    
get:b------------
get:bTransmission Cont
get:bFunctional Specif
get:b3.3.  Sequence Nu
get:bA fundamental n
get:bover a TCP conn
get:bsequenced, each
get:bmechanism emplo
get:bnumber X indica
get:breceived.  This
get:bdetection in th
get:bwithin a segmen
get:bthe header is t
get:bnumbered consec
get:bIt is essential
get:bfinite, though 
get:bSince the space
get:bnumbers must be
get:bpreserves the r
get:b2**32 - 1 to 0 
get:barithmetic, so 
get:bcomparison of s
get:b(modulo 2**32).
get:bThe typical kin
get:bperform include:
get:b(a)  Determin
get:bnumber s
get:b(b)  Determin
get:bhave bee
get:bretransm
get:b(c)  Determin
get:bwhich ar
get:breceive 
get:b[Page 24]        
get:bSeptember 1981   
get:bIn response to 
get:bfollowing compa
get:bSND.UNA = old
get:bSND.NXT = nex
get:bSEG.ACK = ack
get:bnum
get:bSEG.SEQ = fir
get:bSEG.LEN = the
get:b(co
get:bSEG.SEQ+SEG.L
get:bA new acknowled
get:bthe inequality :below holds
get:bSND.UNA < SEG
get:bA segment on th
get:bof its sequence
get:backnowledgment 
get:bWhen data is re:ceived the following comparisons are needed
get:bRCV.NXT = nex
get:bis the le
get:bRCV.NXT+RCV.W
get:bsegment, 
get:bSEG.SEQ = fir
get:bSEG.SEQ+SEG.L
get:bA segment is ju
get:bRCV.NXT =< SE
get:bRCV.NXT =< SE
get:bTransmission Cont
get:bFunctional Specif
get:bThe first part 
get:bsegment falls i
get:bif the end of t
get:beither part of 
get:bActually, it is
get:bwindows and zer
get:bacceptability o:f an incoming segment
get:bSegment Recei
get:bLength  Windo
get:b------- -----
get:b0       0 
get:b0      >0 
get:b>0       0 
get:b>0      >0 
get:bNote that when 
get:bacceptable exce
get:bmaintain a zero
get:bACKs.  However,
get:bprocess the RST
get:bWe have taken a
get:bcontrol informa
get:bsome control fl
get:band acknowledge
get:bcontrol will be
get:bcarried in the 
get:bfor implicitly 
get:bare the only co
get:bare used only a
get:bpurposes, the S
get:boctet of the se
get:bto occur after 
get:boccurs.  The se
get:bspace occupying
get:bsequence number
get:b[Page 26]        
get:bSeptember 1981   
get:bInitial Sequenc
get:bThe protocol pl
get:bused over and o
get:bsockets.  New i
get:bincarnations of
get:b-- "how does th
get:bincarnations of
get:bconnection is b
get:bconnection brea
get:bTo avoid confus
get:bconnection from
get:bbe present in t
get:bassure this, ev
get:bsequence number
get:ban initial sequ
get:bnew 32 bit ISN.
get:bbit clock whose
get:bmicroseconds.  
get:bSince we assume
get:bthe Maximum Seg
get:bhours we can re
get:bFor each connec
get:bsequence number
get:bthe data sendin
get:blearned during 
get:bFor a connectio
get:bsynchronize on 
get:ban exchange of 
get:bcalled "SYN" (f
get:bshorthand, segm
get:bHence, the solu
get:binitial sequenc
get:bThe synchroniza
get:bsequence number
get:bfrom the other 
get:binitial sequenc
get:b1) A --> B  S
get:b2) A <-- B  A
get:b3) A <-- B  S
get:b4) A --> B  A
get:bTransmission Cont
get:bFunctional Specif
get:bBecause steps 2
get:bcalled the thre
get:bA three way han
get:btied to a globa
get:bmechanisms for 
get:bno way of knowi
get:bunless it remem
get:b(which is not a
get:bverify this SYN
get:bclock-driven sc
get:bKnowing When to
get:bTo be sure that
get:bsequence number
get:bthe network, th
get:b(MSL) before as
get:brecovering from
get:blost.  For this
get:bis an engineeri
get:bit is desirable
get:bsense, yet reta
get:bnot wait at all
get:bthan those rece
get:bThe TCP Quiet T
get:bThis specific
get:bretaining any
get:beach active (
get:bTCP segments 
get:bin the intern
get:bparagraphs be
get:bTCP implement
get:bat the risk o
get:bdata rejected
get:bTCPs consume 
get:bentered into 
get:bduplicate det
get:brelies on the
get:bthe extent th
get:bvalues before
get:bbeen delivere
get:bcopies of the
get:bsuch an assum
get:b[Page 28]        
get:bSeptember 1981   
get:bassigned the 
get:bat the receiv
get:bthat each seg
get:bas there are 
get:bUnder normal 
get:bto emit and t
get:bmistakenly us
get:bbeen acknowle
get:bdata is drain
get:bvery large to
get:bcause trouble
get:bto use up 2**
get:blifetime in t
get:bthis is deeme
get:brates escalat
get:bcycle time is
get:bwithin reason
get:bThe basic dup
get:bdefeated, how
get:bsequence numb
get:bthe TCP were 
get:bupon crashing
get:bconnection (p
get:bpackets with 
get:bpackets still
get:bincarnation o
get:babout the seq
get:bspecification
get:bbefore emitti
get:bsegments from
get:bEven hosts wh
get:binitial seque
get:b(i.e., even i
get:bnumber for ea
get:bSuppose, for 
get:bsequence numb
get:band that even
get:btakes on a va
get:bsegment sent 
get:bat this insta
get:bincarnation o
get:bS1 = ISN(t) -
get:bconnection!  
get:bTransmission Cont
get:bFunctional Specif
get:bduplicates in
get:bof S1 may arr
get:bthe new incar
get:bThe problem i
get:bcrashed nor d
get:bthe system fr
get:bOne way to de
get:bsegments for 
get:btime" specifi
get:bwilling to ri
get:bdestination m
get:bImplementors 
get:bconnection by
get:binformally im
get:bObviously, ev
get:bnecessary aft
get:bTo summarize:
get:bnumbers in th
get:b"busy" or "in
get:bblock of spac
get:bsegment, if a
get:bsequence numb
get:bthe previous 
get:bnumber overla
get:b3.4.  Establishin
get:bThe "three-way 
get:bconnection.  Th
get:bresponded to by
get:bsimultaneously 
get:boccurs, each TC
get:backnowledgment 
get:ban old duplicat
get:brecipient, that
get:bProper use of "
get:bSeveral example
get:bexamples do not
get:bsegments, this 
get:bdoesn't deliver
get:bvalid (i.e., th
get:bconnection reac
get:breduces the pos
get:b[Page 30]        
get:bSeptember 1981   
get:bimplementation 
get:binformation for
get:bThe simplest th
get:bfigures should 
get:bnumbered for re
get:bdeparture of a 
get:bsegment at B fr
get:bEllipsis (...) 
get:b(delayed).  An 
get:bComments appear
get:bthe departure o
get:bthe center of e
get:bform, with sequ
get:bfields such as 
get:bin the interest
get:bTCP A      
get:b1.  CLOSED     
get:b2.  SYN-SENT   
get:b3.  ESTABLISHED
get:b4.  ESTABLISHED
get:b5.  ESTABLISHED
get:bBasic 3
get:bIn line 2 of fi
get:bindicating that
get:bnumber 100.  In
get:breceived from T
get:bB is now expect
get:boccupied sequen
get:bAt line 4, TCP 
get:bTCP B's SYN; an
get:bsequence number
get:bbecause the ACK
get:bwould wind up A
get:bTransmission Cont
get:bFunctional Specif
get:bSimultaneous in
get:bfigure 8.  Each
get:bTCP A      
get:b1.  CLOSED     
get:b2.  SYN-SENT   
get:b3.  SYN-RECEIVE
get:b4.             
get:b5.  SYN-RECEIVE
get:b6.  ESTABLISHED
get:b7.             
get:bS
get:bThe principle r
get:bduplicate conne
get:bthis, a special
get:breceiving TCP i
get:bSYN-RECEIVED), 
get:bIf the TCP is i
get:bFIN-WAIT-1, FIN
get:baborts the conn
get:bcase under "hal
get:b[Page 32]        
get:bSeptember 1981   
get:bTCP A      
get:b1.  CLOSED     
get:b2.  SYN-SENT   
get:b3.  (duplicate)
get:b4.  SYN-SENT   
get:b5.  SYN-SENT   
get:b6.             
get:b7.  SYN-SENT   
get:b8.  ESTABLISHED
get:bAs a simple exa
get:bfigure 9.  At l
get:bcannot tell tha
get:b(line 4).  TCP 
get:bRST (reset) wit
get:bbelievable.  TC
get:bWhen the origin
get:bsynchronization
get:bbefore the RST,
get:bsent in both di
get:bHalf-Open Conne
get:bAn established 
get:bTCPs has closed
get:bknowledge of th
get:bbecome desynchr
get:bmemory.  Such c
get:battempt is made
get:bconnections are
get:bmildly involved
get:bIf at site A th
get:bTransmission Cont
get:bFunctional Specif
get:buser at site B 
get:breceiving a res
get:bsite B TCP that
get:bAssume that two
get:banother when a 
get:bDepending on th
get:bthat some error
get:bA is likely to 
get:bpoint.  As a re
get:bor try to SEND 
get:bcase, it receiv
get:blocal (A's) TCP
get:bwill send a seg
get:bexample shown i
get:bre-open the con
get:bTCP A      
get:b1.  (CRASH)    
get:b2.  CLOSED     
get:b3.  SYN-SENT --
get:b4.  (!!)     <-
get:b5.  SYN-SENT --
get:b6.  SYN-SENT   
get:b7.  SYN-SENT --
get:bWhen the SYN ar
get:band the incomin
get:backnowledgment 
get:b100).  TCP A se
get:bsent and, being
get:bdetected a half
get:b[Page 34]        
get:bSeptember 1981   
get:bcontinue to try
get:breduced to the 
get:bAn interesting 
get:btries to send d
get:bThis is illustr
get:bTCP A from TCP 
get:bexists, so TCP 
get:bprocesses it an
get:bTCP A    
get:b1.  (CRASH)    
get:b2.  (??)    <--
get:b3.          -->
get:bActive
get:bIn figure 12, w
get:bwaiting for SYN
get:binto action.  A
get:bgenerate a RST 
get:bthe reset and r
get:bTCP A      
get:b1.  LISTEN     
get:b2.       ... <S
get:b3.  (??) <-- <S
get:b4.       --> <S
get:b5.  LISTEN     
get:bOld Duplic
get:bTransmission Cont
get:bFunctional Specif
get:bA variety of ot
get:bby the followin
get:bReset Generatio
get:bAs a general ru
get:bwhich apparentl
get:bmust not be sen
get:bThere are three: groups of states
get:b1.  If the co
get:bin response t
get:bparticular, S
get:bby this means
get:bIf the incomi
get:bsequence numb
get:breset has seq
get:bof the sequen
get:bThe connectio
get:b2.  If the co
get:bSYN-SENT, SYN
get:bsomething not
get:bif an incomin
get:bdoes not exac
get:bconnection, a
get:bIf our SYN ha
get:bincoming segm
get:beither raise 
get:bthe system) o
get:bincoming segm
get:bcontinue as i
get:bcannot raise 
get:bdetected in t
get:bterminated th
get:bincoming segm
get:bmatch the loc
get:bmust be sent.
get:bIf the incomi
get:bsequence numb
get:breset has seq
get:bof the sequen
get:bThe connectio
get:b[Page 36]        
get:bSeptember 1981   
get:b3.  If the co
get:bFIN-WAIT-1, F
get:bany unaccepta
get:bunacceptible 
get:backnowledgmen
get:band an acknow
get:bto be receive
get:bIf an incomin
get:bprecedence wh
get:band precedenc
get:bconnection go
get:bnumber from t
get:bReset Processin
get:bIn all states e
get:bby checking the
get:bis in the windo
get:bto an initial S
get:backnowledges th
get:bThe receiver of
get:breceiver was in
get:bin SYN-RECEIVED
get:bthen the receiv
get:baborts the conn
get:bwas in any othe
get:band goes to the
get:b3.5.  Closing a C
get:bCLOSE is an ope
get:bnotion of closi
get:binterpretation,
get:bthe receiving s
get:bin a simplex fa
get:buntil he is tol
get:bcould initiate 
get:bRECEIVE until s
get:bhas CLOSED.  We
get:bRECEIVEs are ou
get:bcan terminate h
get:bbuffers SENT be
get:bdata in return 
get:bsuccessfully to
get:bTCP.  Users mus
get:bthe TCP says no
get:bTransmission Cont
get:bFunctional Specif
get:bThere are essen:tially three cases
get:b1) The user i
get:b2) The remote
get:b3) Both users
get:bCase 1:  Local 
get:bIn this case,
get:boutgoing segm
get:baccepted by t
get:bare allowed i
get:bwill be retra
get:bboth acknowle
get:bcan ACK this 
get:bsend its own 
get:bCase 2:  TCP re
get:bIf an unsolic
get:bcan ACK it an
get:buser will res
get:bthe other TCP
get:buntil its own
get:bconnection.  
get:bthe connectio
get:bCase 3:  both u
get:bA simultaneou
get:bFIN segments 
get:bhave been pro
get:bhas received.
get:b[Page 38]        
get:bSeptember 1981   
get:bTCP A      
get:b1.  ESTABLISHED
get:bFIN-WAIT-1 
get:b3.  FIN-WAIT-2 
get:b4.             
get:bTIME-WAIT  
get:b5.  TIME-WAIT  
get:bCLOSED     
get:bTCP A      
get:b1.  ESTABLISHED
get:b2.  (Close)    
get:bFIN-WAIT-1 
get:b3.  CLOSING    
get:b4.  TIME-WAIT  
get:b(2 MSL)    
get:bCLOSED     
get:bTransmission Cont
get:bFunctional Specif
get:b3.6.  Precedence 
get:bThe intent is t
get:bwith exactly th
get:bhigher of the p
get:bThe precedence 
get:bdefined in the 
get:bspecification t
get:bthe security pa
get:buser group, and
get:bA connection at
get:blower precedenc
get:ba connection du
get:backnowledgment 
get:bNote that TCP m
get:bprecedence will
get:bsegments and po
get:bThe security pa
get:b(the values wou
get:bnon-secure envi
get:bparameters, tho
get:b3.7.  Data Commun
get:bOnce the connec
get:bexchange of seg
get:b(checksum test 
get:bretransmission 
get:bDuplicate segme
get:bAs discussed in
get:bcertain tests o
get:bsegments to ver
get:bThe sender of d
get:bthe variable SN
get:bsequence number
get:bkeeps track of 
get:bvariable SND.UN
get:bsent has been a
get:bWhen the sender
get:bSND.NXT.  When 
get:bsends an acknow
get:b[Page 40]        
get:bSeptember 1981   
get:backnowledgment 
get:bthese variables
get:bThe amount by w
get:bdata in the seg
get:bsegments must c
get:bThe CLOSE user 
get:bflag in an inco
get:bRetransmission 
get:bBecause of the 
get:binternetwork sy
get:bretransmission 
get:bfor determining
get:bAn Example Re
get:bMeasure the
get:bparticular 
get:bcovers that
get:bsegments re
get:bTime (RTT).:  Next compute a Smoothed Round Trip Time (SRTT) as
get:bSRTT = ( 
get:band based o:n this, compute the retransmission timeout (RTO) as
get:bRTO = min
get:bwhere UBOUN
get:bLBOUND is a
get:ba smoothing
get:bfactor (e.g
get:bThe Communicati
get:bThe objective o
get:bto stimulate th
get:bpermit the rece
get:bthe currently k
get:bThis mechanism 
get:bthe end of urge
get:bthe receive seq
get:bmust tell the u
get:bnumber catches 
get:bTransmission Cont
get:bFunctional Specif
get:binto "normal mo
get:bis in "urgent m
get:bThe method empl
get:btransmitted.  T
get:bmeaningful and 
get:bthe urgent poin
get:bno urgent data 
get:bTo send an urge
get:boctet.  If the 
get:bthe urgent info
get:bManaging the Wi
get:bThe window sent
get:bnumbers the sen
get:bprepared to acc
get:bthe currently a
get:bIndicating a la
get:barrives than ca
get:bin excessive re
get:bnetwork and the
get:btransmission of
get:bbetween each ne
get:bThe mechanisms 
get:bsubsequently ad
get:bthat much data.
get:bdiscouraged.  T
get:bshrink the wind
get:bon the part of 
get:bThe sending TCP
get:bleast one octet
get:bsending TCP mus
get:bthe window is z
get:binterval when t
get:bguarantee that 
get:bwindow will be 
get:bWhen the receiv
get:bstill send an a
get:band current win
get:bThe sending TCP
get:b[Page 42]        
get:bSeptember 1981   
get:bwhich fit the c
get:bretransmission 
get:bIn a connection
get:bbe carried in a
get:bnumber so there
get:border.  This is
get:binformation to 
get:bthe data receiv
get:bthe window info
get:backnowledgment 
get:bequal or greate
get:bThe window mana
get:bcommunication p
get:bWindow Manage
get:bAllocating 
get:bmany small 
get:bfewer large
get:bOne suggest
get:bdefer updat
get:bleast X per
get:bconnection 
get:bAnother sug
get:bsegments by
get:bsending dat
get:bdata must b
get:bNote that t
get:bretransmiss
get:backnowledgm
get:bwindow info
get:bnew window 
get:bThe segment
get:bof transmit
get:bsegment con
get:bis accepted
get:bIf the send
get:bwindow is n
get:balternating
get:bpauses in t
get:bTransmission Cont
get:bFunctional Specif
get:bresult in b
get:bbig pair. A
get:bmostly smal
get:bThe suggest
get:bactively at
get:bwindows, si
get:bto many sma
get:bThere are of co:urse two interfaces of concern
get:band the TCP/low
get:bof the user/TCP
get:bprotocol module
get:bin detail by th
get:bcase that the l
get:bthat TCPs might
get:bUser/TCP Interf
get:bThe following
get:bat best, fict
get:bfacilities.  
get:bimplementatio
get:bTCPs must pro
get:bthat all TCP 
get:bhierarchy.  T
get:brequired of a
get:bTCP User Comm
get:bThe followi
get:binterface. 
get:bfunction ca
get:bmeant to ru
get:bThe user co
get:bTCP must pe
get:bIndividual 
get:bmay provide
get:bsingle call
get:bautomatical
get:bissued by t
get:b[Page 44]        
get:bSeptember 1981   
get:bIn providin
get:bnot only ac
get:bprocesses i:t serves.  The latter consists of
get:b(a) gener
get:bremote cl
get:b(b) repli
get:bvarious t
get:bFormat:  
get:b[, timeou
get:b-> local 
get:bWe assume
get:bprocesses
get:bto use th
get:bimplement
get:bfor the s
get:blower lev
get:bresult of
get:bable to m
get:bprocess c
get:bIf the ac
get:bcall to L
get:bhave eith
get:bparticula
get:bfor any c
get:bby the su
get:bA transmi
get:bfilled in
get:bOn an act
get:bsynchroni
get:bThe timeo
get:bfor all d
get:bdelivered
get:bwill abor
get:bThe TCP o
get:bthe users
get:bTransmission Cont
get:bFunctional Specif
get:bprecedenc
get:bor securi
get:bthe defau
get:bTCP will 
get:bsecurity/
get:bthe prece
get:brequested
get:bThe prece
get:brequested
get:brequest, 
get:bconnectio
get:bthis prec
get:ballowed t
get:bor that a
get:bA local c
get:bThe local
get:bfor the c
get:bFormat:  
get:bcount, PU
get:bThis call
get:bto be sen
get:bnot been 
get:bimplement
get:bautomatic
get:bauthorize
get:bIf the PU
get:bto the re
get:bsegment c
get:bthe data 
get:btransmiss
get:bIf the UR
get:bwill have
get:bthe urgen
get:bpointer i
get:bbeen cons
get:bis to sti
get:bindicate 
get:b[Page 46]        
get:bSeptember 1981   
get:bdata has 
get:bTCP signa
get:bof times 
get:burgent da
get:bIf no for
get:bconnectio
get:bhas becom
get:blocal soc
get:bforeign s
get:bforeign s
get:bknowing t
get:bHowever, 
get:bbecomes s
get:bSTATUS ca
get:bimplement
get:bsocket is
get:bIf a time
get:bconnectio
get:bIn the si
get:bthe sendi
get:bor the ti
get:bis both s
get:bconnectio
get:boffers po
get:bsophistic
get:bthe proce
get:bfurthermo
get:bMultiple 
get:bthe TCP w
get:bWe have i
get:bwhich a S
get:bpseudo-in
get:breturn a 
get:bimmediate
get:bbeen ackn
get:bassume ev
get:bclose any
get:bkind (syn
get:bsignals, 
get:bwith spec
get:bIn order 
get:bindicatio
get:bTransmission Cont
get:bFunctional Specif
get:bbuffer ad
get:bthe SEND 
get:bindicatin
get:bcalling p
get:bFormat:  
get:bcount) ->
get:bThis comm
get:bspecified
get:bcalling p
get:berror is 
get:bIn the si
get:bcalling p
get:berror occ
get:bA more so
get:bRECEIVEs 
get:bsegments 
get:bthe cost 
get:bnotify th
get:bIf enough
get:bthe PUSH 
get:bThe buffe
get:ba PUSH is
get:breturned 
get:bIf there 
get:bas it arr
get:bshould th
get:badditiona
get:bcall to R
get:bmay now l
get:burgent po
get:bin the sa
get:bboundary 
get:bTo distin
get:bcare of t
get:breturn co
get:bcount ind
get:bAlternati
get:b[Page 48]        
get:bSeptember 1981   
get:ballocate 
get:bwith the 
get:bFormat:  
get:bThis comm
get:bthe conne
get:bauthorize
get:bClosing c
get:bthe sense
get:bretransmi
get:bserviced.
get:bcalls, fo
get:bto the de
get:bcontinue 
get:bmay be tr
get:bmeans "I 
get:breceive a
get:bnot well 
get:bof all it
get:binto ABOR
get:bThe user 
get:binitiativ
get:b(e.g., re
get:bdestinati
get:bBecause c
get:bforeign T
get:bshort tim
get:breplies t
get:bClose als
get:bFormat:  
get:bThis is a
get:bexcluded 
get:btypically
get:bThis comm
get:binformati:on
get:blocal s
get:bTransmission Cont
get:bFunctional Specif
get:bforeign
get:blocal c
get:breceive
get:bsend wi
get:bconnect
get:bnumber 
get:bnumber 
get:burgent 
get:bprecede
get:bsecurit
get:band tra
get:bDepending
get:bimplement
get:bavailable
get:bauthorize
get:bprevents 
get:bconnectio
get:bFormat:  
get:bThis comm
get:baborted, 
get:bbe sent t
get:bDepending
get:bindicatio
get:breceive a
get:bTCP-to-User M
get:bIt is assum
get:bmeans for t
get:bthe TCP doe
get:bto the user
get:ban error me
get:brelating to
get:bother user 
get:bThe followi:ng information is provided
get:bLocal Con
get:bResponse 
get:bBuffer Ad
get:bByte coun
get:bPush flag
get:bUrgent fl
get:b[Page 50]        
get:bSeptember 1981   
get:bTCP/Lower-Level
get:bThe TCP calls
get:breceive infor
get:binternetwork 
get:bProtocol (IP)
get:bIf the lower 
get:bof service an
get:bfor these par:ameters
get:bType of Ser:vice = Precedence: routine, Delay: normal, Throughput
get:bnormal, Rel:iability
get:bTime to Liv
get:bNote that
get:bHere we e
get:bbe delive
get:bIf the lower 
get:bfeature) and 
get:broute informa
get:bso that the s
get:bchecksum be t
get:balso importan
get:bAny lower lev
get:bdestination a
get:bthe "TCP leng
get:bof IP and to 
get:bTransmission Cont
get:bFunctional Specif
get:b3.9.  Event Proce
get:bThe processing 
get:bimplementation.
get:bprocessing sequ
get:bsection only in
get:bThe activity of
get:bThe events that: occur can be cast into three categories
get:barriving segmen
get:bprocessing the 
get:bcases the proce
get:bEvents that o:ccur
get:bArriving Se
get:bSEGMENT A
get:bUSER TIME
get:bRETRANSMI
get:bTIME-WAIT
get:bThe model of th
get:bimmediate retur
get:bpseudo interrup
get:bmeans cause a d
get:bError responses
get:bcommands refere:ncing connections that do not exist receive "error
get:bconnection not 
get:bPlease note in 
get:backnowledgment 
get:bof the sequence
get:bequal to (modul
get:b[Page 52]        
get:bSeptember 1981   
get:bA natural way t
get:bimagine that th
get:bthat their cont
get:bin the sequence
get:band processed i
get:bWhen a segment 
get:bthe segment to 
get:bto be consisten
get:bNote that if no
get:bTransmission Cont
get:bFunctional Specif
get:bCLOSED STATE 
get:bCreate a ne
get:bstate infor
get:bsocket, pre
get:binformation
get:bunspecified
get:bparameters 
get:bprecedence 
get:b"error:  pr:ecedence not allowed" or "error
get:bnot allowed
get:bactive and :the foreign socket is unspecified, return "error
get:bforeign soc
get:bspecified, 
get:b(ISS) is se
get:bis sent.  S
get:bstate, and 
get:bIf the call
get:breturn "err:or
get:bno room to :create a new connection, return "error
get:bresources".
get:bIf active a
get:bconnection 
get:bsegment, se
get:bstate.  Dat
get:bqueued for 
get:burgent bit 
get:bsegments se
get:bqueue the r:equest, respond with "error
get:bIf Foreign :socket was not specified, then return "error
get:bsocket unsp
get:b[Page 54]        
get:bSeptember 1981   
get:bSYN-SENT STAT
get:bSYN-RECEIVED 
get:bESTABLISHED S
get:bFIN-WAIT-1 ST
get:bFIN-WAIT-2 ST
get:bCLOSE-WAIT ST
get:bCLOSING STATE
get:bLAST-ACK STAT
get:bTIME-WAIT STA
get:bReturn "err:or
get:bTransmission Cont
get:bFunctional Specif
get:bCLOSED STATE 
get:bIf the user
get:b"error:  co
get:bOtherwise, :return "error
get:bIf the fore
get:bfrom passiv
get:bSND.UNA to 
get:bassociated 
get:btransmissio
get:brequested i
get:bas a result
get:brequest, re:spond with "error
get:bForeign soc:ket was not specified, then return "error
get:bsocket unsp
get:bSYN-SENT STAT
get:bSYN-RECEIVED 
get:bQueue the d
get:bIf no space: to queue, respond with "error
get:bresources".
get:bESTABLISHED S
get:bCLOSE-WAIT ST
get:bSegmentize 
get:backnowledgm
get:binsufficien:t space to remember this buffer, simply return "error
get:binsufficien
get:bIf the urge
get:burgent poin
get:b[Page 56]        
get:bSeptember 1981   
get:bFIN-WAIT-1 ST
get:bFIN-WAIT-2 ST
get:bCLOSING STATE
get:bLAST-ACK STAT
get:bTIME-WAIT STA
get:bReturn "err:or
get:bTransmission Cont
get:bFunctional Specif
get:bCLOSED STATE 
get:bIf the user
get:b"error:  co
get:bOtherwise r:eturn "error
get:bSYN-SENT STAT
get:bSYN-RECEIVED 
get:bQueue for p
get:bis no room :to queue this request, respond with "error
get:binsufficien
get:bESTABLISHED S
get:bFIN-WAIT-1 ST
get:bFIN-WAIT-2 ST
get:bIf insuffic
get:brequest, qu
get:bremember th:e RECEIVE, respond with "error
get:bresources".
get:bReassemble 
get:bto user.  M
get:bIf RCV.UP i
get:buser notify
get:bWhen the TC
get:bthat fact m
get:backnowledgm
get:bdescribed b
get:b[Page 58]        
get:bSeptember 1981   
get:bCLOSE-WAIT ST
get:bSince the r
get:bsatisfied b
get:buser.  If n
get:b"error:  co
get:btext can be
get:bCLOSING STATE
get:bLAST-ACK STAT
get:bTIME-WAIT STA
get:bReturn "err:or
get:bTransmission Cont
get:bFunctional Specif
get:bCLOSED STATE 
get:bIf the user
get:b"error:  co
get:bOtherwise, :return "error
get:bAny outstan:ding RECEIVEs are returned with "error
get:bresponses. 
get:bSYN-SENT STAT
get:bDelete the :TCB and return "error
get:bqueued SEND
get:bSYN-RECEIVED 
get:bIf no SENDs
get:bthen form a
get:botherwise q
get:bESTABLISHED S
get:bQueue this 
get:bform a FIN 
get:bFIN-WAIT-1 ST
get:bFIN-WAIT-2 ST
get:bStrictly sp:eaking, this is an error and should receive a "error
get:bconnection 
get:bacceptable,
get:bFIN may be 
get:b[Page 60]        
get:bSeptember 1981   
get:bCLOSE-WAIT ST
get:bQueue this 
get:bsegmentized
get:bCLOSING STATE
get:bLAST-ACK STAT
get:bTIME-WAIT STA
get:bRespond wit:h "error
get:bTransmission Cont
get:bFunctional Specif
get:bCLOSED STATE 
get:bIf the user
get:b"error:  co
get:bOtherwise r:eturn "error
get:bAny outstan:ding RECEIVEs should be returned with "error
get:bconnection 
get:bSYN-SENT STAT
get:bAll queued 
get:bnotificatio
get:bSYN-RECEIVED 
get:bESTABLISHED S
get:bFIN-WAIT-1 ST
get:bFIN-WAIT-2 ST
get:bCLOSE-WAIT ST
get:bSend a rese:t segment
get:b<SEQ=SND.
get:bAll queued 
get:bnotificatio
get:bRST formed 
get:bTCB, enter 
get:bCLOSING STATE
get:bLAST-ACK STAT
get:bTIME-WAIT STA
get:bRespond wit
get:b[Page 62]        
get:bSeptember 1981   
get:bCLOSED STATE 
get:bIf the user
get:b"error:  co
get:bOtherwise r:eturn "error
get:bReturn "sta
get:bSYN-SENT STAT
get:bReturn "sta
get:bSYN-RECEIVED 
get:bReturn "sta
get:bESTABLISHED S
get:bReturn "sta
get:bFIN-WAIT-1 ST
get:bReturn "sta
get:bFIN-WAIT-2 ST
get:bReturn "sta
get:bCLOSE-WAIT ST
get:bReturn "sta
get:bCLOSING STATE
get:bReturn "sta
get:bLAST-ACK STAT
get:bReturn "sta
get:bTransmission Cont
get:bFunctional Specif
get:bTIME-WAIT STA
get:bReturn "sta
get:b[Page 64]        
get:bSeptember 1981   
get:bSEGMENT ARRIVES
get:bIf the state 
get:ball data in
get:bsegment con
get:bcontaining 
get:backnowledgm
get:breset seque
get:bIf the ACK 
get:b<SEQ=0><A
get:bIf the ACK 
get:b<SEQ=SEG.
get:bIf the state 
get:bfirst check
get:bAn incomi
get:bsecond chec
get:bAny ackno
get:bthe LISTE
get:bfor any a
get:bformatted: as follows
get:b<SEQ=SE
get:bthird check
get:bIf the SY
get:bsecurity/
get:bmatch the
get:b<SEQ=SE
get:bTransmission Cont
get:bFunctional Specif
get:bIf the SE
get:bthe user 
get:bsend a re
get:b<SEQ=SE
get:bIf the SE
get:bSet RCV.N
get:bcontrol o
get:bshould be: selected and a SYN segment sent of the form
get:b<SEQ=IS
get:bSND.NXT i
get:bstate sho
get:bincoming 
get:bin the SY
get:bnot be re
get:bthe forei
get:bunspecifi
get:bfourth othe
get:bAny other
get:bmust have
get:bprocessin
get:bit could 
get:bincarnati
get:bbut if yo
get:bIf the state 
get:bfirst check
get:bIf the AC
get:bIf SEG.
get:bthe RST
get:b<SEQ=
get:band dis
get:bIf SND.
get:bsecond chec
get:b[Page 66]        
get:bSeptember 1981   
get:bIf the RS
get:bIf the :ACK was acceptable then signal the user "error
get:bconnect
get:bdelete 
get:band ret
get:bthird check
get:bIf the se
get:bmatch the
get:bIf ther
get:b<SEQ=
get:bOtherwi
get:b<SEQ=
get:bIf there 
get:bThe pre
get:bTCB, if
get:b<SEQ=
get:bIf there 
get:bIf the 
get:bin the 
get:bthe pre
get:ballowed
get:b<SEQ=
get:bIf the 
get:bin the 
get:bIf a rese
get:bfourth chec
get:bThis step
get:bno ACK, a
get:bIf the SY
get:bTransmission Cont
get:bFunctional Specif
get:bare accep
get:bSEG.SEQ. 
get:bis an ACK
get:bare there
get:bIf SND.UN
get:bstate to 
get:b<SEQ=SN
get:band send 
get:btransmiss
get:btext in t
get:bbelow whe
get:bOtherwise
get:b<SEQ=IS
get:band send 
get:bsegment, 
get:bhas been 
get:bfifth, if n
get:bsegment and
get:b[Page 68]        
get:bSeptember 1981   
get:bfirst check s
get:bSYN-RECEIVE
get:bESTABLISHED
get:bFIN-WAIT-1 
get:bFIN-WAIT-2 
get:bCLOSE-WAIT 
get:bCLOSING STA
get:bLAST-ACK ST
get:bTIME-WAIT S
get:bSegments 
get:bare used 
get:bdone in S
get:bboundary 
get:bprocessed
get:bThere are
get:bsegment
get:bSegment R
get:bLength  W
get:b------- -
get:b0     
get:b0     
get:b>0     
get:b>0     
get:bIf the RC
get:bspecial a
get:bIf an inc
get:bshould be
get:bthe segme:nt and return)
get:b<SEQ=SN
get:bAfter sen
get:band retur
get:bTransmission Cont
get:bFunctional Specif
get:bIn the fo
get:bsegment t
get:bOne could
get:btrimming 
get:bSYN and F
get:bbegins at
get:bnumbers m
get:bsecond check 
get:bSYN-RECEIVE
get:bIf the RS
get:bIf this
get:bcame fr
get:bLISTEN 
get:bthis co
get:bfrom SY
get:bthe use
get:bon the 
get:bactive 
get:band ret
get:bESTABLISHED
get:bIf the RS
get:bshould re
get:bflushed. 
get:b"connecti
get:bTCB, and 
get:bCLOSING STA
get:bLAST-ACK ST
get:bIf the RS
get:bTCB, and 
get:b[Page 70]        
get:bSeptember 1981   
get:bthird check s
get:bSYN-RECEIVE
get:bIf the se
get:bexactly m
get:bthen send
get:bESTABLISHED
get:bIf the se
get:bexactly m
get:bthen send
get:breceive "
get:bflushed. 
get:b"connecti
get:bTCB, and 
get:bNote this c
get:ba segment f
get:bdifferent s
get:bcurrent con
get:bfourth, check
get:bSYN-RECEIVE
get:bESTABLISHED
get:bFIN-WAIT ST
get:bFIN-WAIT ST
get:bCLOSE-WAIT 
get:bCLOSING STA
get:bLAST-ACK ST
get:bTIME-WAIT S
get:bIf the SY
get:boutstandi
get:ball segme
get:breceive a
get:bthe CLOSE
get:bIf the SY
get:band an ac
get:bnumber ch
get:bTransmission Cont
get:bFunctional Specif
get:bfifth check t
get:bif the ACK 
get:bif the ACK 
get:bSYN-RECEI
get:bIf SND.
get:band con
get:bIf th
get:breset
get:b<SE
get:band s
get:bESTABLISH
get:bIf SND.
get:bAny seg
get:bentirel
get:bpositiv
get:bfully a
get:b"ok" re
get:b(SEG.AC
get:bsomethi
get:bdrop th
get:bIf SND.
get:bupdated
get:bSND.WL2
get:bSND.WL1
get:bNote th
get:brecords
get:bSND.WND
get:bthe las
get:bprevent
get:b[Page 72]        
get:bSeptember 1981   
get:bFIN-WAIT-
get:bIn addi
get:bour FIN
get:bprocess
get:bFIN-WAIT-
get:bIn addi
get:bthe ret
get:backnowl
get:bCLOSE-WAI
get:bDo the 
get:bCLOSING S
get:bIn addi
get:bthe ACK
get:botherwi
get:bLAST-ACK 
get:bThe onl
get:backnowl
get:bdelete 
get:bTIME-WAIT
get:bThe onl
get:bretrans
get:bthe 2 M
get:bsixth, check 
get:bESTABLISHED
get:bFIN-WAIT-1 
get:bFIN-WAIT-2 
get:bIf the UR
get:bthe user 
get:bpointer (
get:buser has 
get:bmode") fo
get:bsignal th
get:bTransmission Cont
get:bFunctional Specif
get:bCLOSE-WAIT 
get:bCLOSING STA
get:bLAST-ACK ST
get:bThis shou
get:bremote si
get:bseventh, proc
get:bESTABLISHED
get:bFIN-WAIT-1 
get:bFIN-WAIT-2 
get:bOnce in t
get:btext to u
get:binto buff
get:bempty.  I
get:bthe user 
get:bhas been 
get:bWhen the 
get:buser it m
get:bOnce the 
get:bRCV.NXT o
get:bapporopri
get:bRCV.NXT a
get:bPlease no
get:bSend an a:cknowledgment of the form
get:b<SEQ=SN
get:bThis ackn
get:btransmitt
get:b[Page 74]        
get:bSeptember 1981   
get:bCLOSE-WAIT 
get:bCLOSING STA
get:bLAST-ACK ST
get:bTIME-WAIT S
get:bThis shou
get:bremote si
get:beighth, check
get:bDo not proc
get:bsince the S
get:bIf the FIN 
get:breturn any 
get:bover the FI
get:bFIN implies
get:bSYN-RECEI
get:bESTABLISH
get:bEnter t
get:bFIN-WAIT-
get:bIf our 
get:benter T
get:btimers;
get:bFIN-WAIT-
get:bEnter t
get:boff the
get:bCLOSE-WAI
get:bRemain 
get:bCLOSING S
get:bRemain 
get:bLAST-ACK 
get:bRemain 
get:bTransmission Cont
get:bFunctional Specif
get:bTIME-WAIT
get:bRemain 
get:btimeout
get:b[Page 76]        
get:bSeptember 1981   
get:bFor any state
get:bthe user "err:or
get:band for any o
get:bstate and ret
get:bRETRANSMISSION 
get:bFor any state
get:bthe retransmi
get:bretransmissio
get:bTIME-WAIT TIMEO
get:bIf the time-w
get:benter the CLO
get:bTransmission Cont
get:b[Page 78]        
get:bSeptember 1981   
get:bBBN Rep
get:ba Host 
get:bhost an
get:bA contr
get:bindicat
get:bspecifi
get:bis expe
get:bpreviou
get:bThe uni
get:bARPANET
get:bA unit 
get:bIMPs.  
get:bA logic
get:bA messa
get:bnetwork
get:bDestination Addre
get:bThe des
get:bidentif
get:bA contr
get:bindicat
get:boccupyi
get:bA porti
get:bfragmen
get:bA file 
get:bTransmission Cont
get:bControl
get:bfragmen
get:bA compu
get:bfrom th
get:bAn Inte
get:bby the 
get:bThe Int
get:bARPANET
get:bA sourc
get:binternet datagram
get:bThe uni
get:bhigher 
get:binternet fragment
get:bA porti
get:bheader.
get:bInterne
get:bThe Ini
get:bnumber 
get:bThe Ini
get:bon a co
get:bbased p
get:bThe Ini
get:bused by
get:bControl
get:bdata.  
get:bon an A
get:b[Page 80]        
get:bSeptember 1981   
get:bThis is
get:bdata re
get:bsequenc
get:bof the 
get:bThe uni
get:bAn impl
get:bprocedu
get:bMaximum
get:bthe int
get:bAn eigh
get:bAn Opti
get:bmay be 
get:bprimari
get:btimesta
get:boptions
get:bA packa
get:blogical
get:blogical
get:bThe por
get:boutput 
get:bA progr
get:bthe poi
get:bA contr
get:bthis se
get:breceivi
get:breceive
get:bTransmission Cont
get:breceive
get:breceive
get:breceive next sequ
get:bThis is
get:breceive
get:bThis re
get:bis will
get:bsegment
get:bRCV.NXT
get:bSegment
get:brange a
get:bA contr
get:bthat th
get:binterac
get:bsequenc
get:bsegment
get:bit.  In
get:brise to
get:bReal Ti:me Protocol
get:bof time
get:bsegment
get:bsegment
get:bsegment
get:bsegment
get:bsegment
get:b[Page 82]        
get:bSeptember 1981   
get:bsegment
get:bA logic
get:bunit of
get:bsegment acknowled
get:bThe seq
get:barrivin
get:bThe amo
get:bincludi
get:bThe num
get:bThis is
get:buse on 
get:binitial
get:beach oc
get:bThis re
get:b(receiv
get:bwindow 
get:breceivi
get:bbe emit
get:bSND.UNA
get:bbetween
get:bsend se
get:bleft se
get:bsend ur
get:bsegment
get:bsegment
get:bTransmission Cont
get:bsend wi
get:bAn addr
get:bis, the
get:bThe sou
get:bA contr
get:bnumber,
get:bwhere t
get:bTransmi
get:bthe sta
get:bThe pre
get:bTransmi:ssion Control Protocol
get:breliabl
get:bType of
get:bAn Inte
get:bfor thi
get:bA contr
get:bindicat
get:burgent 
get:bsequenc
get:bpointer
get:bA contr
get:bfield c
get:bindicat
get:burgent 
get:b[Page 84]        
get:bSeptember 1981   
get:b[1]  Cerf, V., an
get:bIntercommuni
get:bVol. COM-22,
get:b[2]  Postel, J. (
get:bProtocol Spe
get:bInstitute, S
get:b[3]  Dalal, Y. an
get:bProtocols", 
get:bDecember 197
get:b[4]  Postel, J., 
get:bInstitute, S
get:baRFC
get:baDe
get:baI
get:baSeptember 1981   
get:baPREFACE .....
get:ba1.  INTRODUCTION 
get:ba1.1  Motivation
get:ba1.2  Scope ....
get:ba1.3  About This
get:ba1.4  Interfaces
get:ba1.5  Operation 
get:ba2.  PHILOSOPHY ..
get:ba2.1  Elements o
get:ba2.2  Model of O
get:ba2.3  The Host E
get:ba2.4  Interfaces
get:ba2.5  Relation t
get:ba2.6  Reliable C
get:ba2.7  Connection
get:ba2.8  Data Commu
get:ba2.9  Precedence
get:ba2.10 Robustness
get:ba3.  FUNCTIONAL SP
get:ba3.1  Header For
get:ba3.2  Terminolog
get:ba3.3  Sequence N
get:ba3.4  Establishi
get:ba3.5  Closing a 
get:ba3.6  Precedence
get:ba3.7  Data Commu
get:ba3.8  Interfaces
get:ba3.9  Event Proc
get:baGLOSSARY ........
get:baREFERENCES ......
get:baTransmission Cont
get:ba[Page ii]        
get:baSeptember 1981   
get:baThis document des
get:ba(TCP).  There hav
get:baspecification on 
get:badraws heavily fro
get:baboth in terms of 
get:baseveral details a
get:baand redescribes t
get:baRFC
get:baReplaces: RFC 761
get:baIENs:  129, 124, 
get:ba55, 44, 40, 27, 2
get:baThe Transmission 
get:bareliable host-to-
get:bacommunication net
get:baThis document des
get:baTransmission Cont
get:bainterface to prog
get:baComputer commun
get:barole in militar
get:badocument focuse
get:bacommunication r
get:bacommunication u
get:bacongestion, but
get:bagovernment sect
get:baAs strategic an
get:badeveloped and d
get:bainterconnecting
get:bacommunication p
get:baapplications.  
get:baDeputy Undersec
get:badeclared the Tr
get:babe a basis for 
get:bastandardization
get:baTCP is a connec
get:bafit into a laye
get:baapplications.  
get:bacommunication b
get:badistinct but in
get:baassumptions are
get:baprotocols below
get:bapotentially unr
get:baprotocols.  In 
get:bawide spectrum o
get:baconnections to 
get:baTransmission Cont
get:baTCP is based on
get:baTCP fits into a
get:baInternet Protoc
get:bareceive variabl
get:badatagram "envel
get:baaddressing sour
get:bainternet protoc
get:bathe TCP segment
get:bamultiple networ
get:baalso carries in
get:baand compartment
get:bacommunicated en
get:baMuch of this do
get:bawhich are co-re
get:bacomputer.  Some
get:bafront-end compu
get:baas well as netw
get:baan interface to
get:baimplementable e
get:bahost-to-front e
get:baThe TCP is inte
get:bacommunication s
get:baintended to be 
get:ba1.3.  About this 
get:baThis document r
get:baany TCP impleme
get:baprotocols and i
get:ba[Page 2]         
get:baSeptember 1981   
get:basection offers 
get:baoperation.  Sec
get:badesign.  Sectio
get:barequired of TCP
get:bauser calls, err
get:baThe TCP interfa
get:bathe other side 
get:baThe interface b
get:baillustrated in 
get:bacalls much like
get:baapplication pro
get:bacalls to open a
get:baestablished con
get:baasynchronously 
get:baconsiderable fr
get:bainterfaces whic
get:baenvironment, a 
get:bainterface for a
get:baThe interface b
get:baunspecified exc
get:batwo levels can 
get:baTypically, one 
get:bainterface.  TCP
get:bainterconnected 
get:bathroughout this
get:baAs noted above,
get:basecurable logic
get:baprocesses.  To 
get:bacommunication s:ystem requires facilities in the following areas
get:baBasic Data Tr
get:baPrecedence an
get:baThe basic opera
get:bathe following p
get:baTransmission Cont
get:baBasic Data Tran:sfer
get:baThe TCP is ab
get:badirection bet
get:basegments for 
get:bathe TCPs deci
get:baSometimes use
get:basubmitted to 
get:bafunction is d
get:baactually tran
get:bapushed throug
get:bapromptly forw
get:baThe exact pus
get:bathe push func
get:baReliability
get:baThe TCP must 
get:badelivered out
get:bais achieved b
get:batransmitted, 
get:bareceiving TCP
get:bainterval, the
get:banumbers are u
get:baout of order 
get:baadding a chec
get:bareceiver, and
get:baAs long as th
get:basystem does n
get:baerrors will a
get:bainternet comm
get:baFlow Control
get:baTCP provides 
get:basent by the s
get:baevery ACK ind
get:bathe last segm
get:baallowed numbe
get:bareceiving fur
get:ba[Page 4]         
get:baSeptember 1981   
get:baMultiplexing
get:baTo allow for 
get:bacommunication
get:baaddresses or 
get:baand host addr
get:baa socket.  A 
get:baThat is, a so
get:baThe binding o
get:baHost.  Howeve
get:ba(e.g., a "log
get:bamade known to
get:bathrough the k
get:baaddresses of 
get:baConnections
get:baThe reliabili
get:bathat TCPs ini
get:baeach data str
get:basockets, sequ
get:baEach connecti
get:baidentifying i
get:baWhen two proc
get:baestablish a c
get:baside).  When 
get:baterminated or
get:baSince connect
get:baover the unre
get:bamechanism wit
get:baerroneous ini
get:baPrecedence and :Security
get:baThe users of 
get:bacommunication
get:bathese feature
get:baTransmission Cont
get:ba[Page 6]         
get:baSeptember 1981   
get:ba2.1.  Elements of
get:baThe internetwor
get:bawhich are in tu
get:bathat the networ
get:balarge networks 
get:bapacket switchin
get:baconsume message
get:banetworks, the g
get:bacommunication s
get:baconnections bet
get:baThe term packet
get:batransaction bet
get:baexchanged withi
get:baHosts are compu
get:banetwork's point
get:baProcesses are v
get:baaccordance with
get:bain execution). 
get:baviewed as commu
get:baThus, all commu
get:baSince a process
get:bastreams between
get:bathat each proce
get:bacommunicates wi
get:ba2.2.  Model of Op
get:baProcesses trans
get:badata as argumen
get:basegments and ca
get:bathe destination
get:bainto the receiv
get:baTCPs include co
get:baensure reliable
get:baThe model of in
get:baprotocol module
get:bato the local ne
get:bainside internet
get:bainternet module
get:bathrough the loc
get:baThe packet swit
get:baTransmission Cont
get:baother operation
get:badestination int
get:baAt a gateway be
get:bafrom its local 
get:bathe internet da
get:bathen "wrapped" 
get:barouted to the n
get:baA gateway is pe
get:bainternet datagr
get:bathrough the nex
get:bainternet datagr
get:bafurther broken 
get:bainternet datagr
get:bainternet module
get:baA destination i
get:ba(after reassemb
get:badestination TCP
get:baThis simple mod
get:baimportant featu
get:bato the gateway 
get:baservice paramet
get:baIncluded in the
get:badatagram.  Data
get:bahost and gatewa
get:baproperly segreg
get:ba2.3.  The Host En
get:baThe TCP is assu
get:baaccess the TCP 
get:bamay call on oth
get:badata structures
get:bacontrolled by a
get:banetwork device 
get:badatagram protoc
get:baThe mechanisms 
get:bafront-end proce
get:bahost-to-front-e
get:bathe type of TCP
get:ba[Page 8]         
get:baSeptember 1981   
get:baThe TCP/user in
get:bato OPEN or CLOS
get:baSTATUS about a 
get:baprograms on the
get:bafrom, and close
get:baThe TCP/interne
get:badatagrams addre
get:basystem.  These 
get:baservice, preced
get:ba2.5.  Relation to
get:baThe following d
get:bahierarchy
get:ba+------+ +
get:ba|Telnet| |
get:ba+------+ +
get:ba|   
get:ba+----
get:ba| TCP
get:ba+----
get:ba| 
get:ba+----
get:ba|    
get:ba+----
get:ba+--
get:ba|  
get:ba+--
get:baIt is expected 
get:baprotocols effic
get:baprotocols like 
get:ba2.6.  Reliable Co
get:baA stream of dat
get:baorder at the de
get:baTransmission Cont
get:baTransmission is
get:baacknowledgments
get:basequence number
get:basegment is tran
get:basequence number
get:bais the sequence
get:batransmissions i
get:basegment contain
get:bastarts a timer;
get:basegment is dele
get:bareceived before
get:baAn acknowledgme
get:badelivered to th
get:bathe responsibil
get:baTo govern the f
get:baemployed.  The 
get:baThis window spe
get:baacknowledgment 
get:ba2.7.  Connection 
get:baTo identify the
get:baprovides a port
get:baindependently b
get:baunique addresse
get:baidentifying the
get:bawill be unique 
get:baA connection is
get:balocal socket ma
get:basockets.  A con
get:bathat is, it is 
get:baTCPs are free t
get:baHowever, severa
get:baThere must be w
get:bathe "appropriat
get:bamay "own" ports
get:bathe ports they 
get:baissue, but we e
get:bauniquely alloca
get:baassociating the
get:baA connection is
get:baforeign socket 
get:ba[Page 10]        
get:baSeptember 1981   
get:baconnection name
get:basubsequent call
get:baabout a connect
get:bais a data struc
get:baimplementation 
get:bapointer to the 
get:bawhether the con
get:babe passively wa
get:baA passive OPEN 
get:baconnection requ
get:baOften the proce
get:barequest from an
get:bais used to deno
get:baare allowed onl
get:baA service proce
get:baprocesses would
get:baforeign socket.
get:barequested a con
get:balocal socket we
get:baWell-known sock
get:baa socket addres
get:ba"Telnet-Server"
get:basocket, and oth
get:baEntry, Text Gen
get:babeing for test 
get:baaccess to a "Lo
get:baat which a newl
get:bawell-known sock
get:baof sockets to s
get:baProcesses can i
get:bafrom other proc
get:babeen establishe
get:baother at the sa
get:bais critical for
get:bacomponents act 
get:baThere are two p
get:bapassive OPENs a
get:balocal passive O
get:bacase, the match
get:baOPENs has left 
get:baforeign socket 
get:baOther possibili
get:baTransmission Cont
get:baIf there are se
get:basame local sock
get:bawith the specif
get:baTCB exists, bef
get:baThe procedures 
get:bacontrol flag an
get:baexchange has be
get:baA connection is
get:bacontaining a SY
get:bacommand.  The m
get:baconnection has 
get:bawhen sequence n
get:baThe clearing of
get:bain this case ca
get:ba2.8.  Data Commun
get:baThe data that f
get:baoctets.  The se
get:bain that call (a
get:bathrough to the 
get:baA sending TCP i
get:basend that data 
get:bafunction is sig
get:bareceiving TCP s
get:bathe sending TCP
get:baThere is no nec
get:baboundaries.  Th
get:basingle SEND cal
get:baThe purpose of 
get:bafrom the sendin
get:barecord service.
get:baThere is a coup
get:baof data that cr
get:baassociated with
get:babuffer is retur
get:banot filled.  If
get:baPUSH is seen, t
get:baTCP also provid
get:baat some point f
get:ba[Page 12]        
get:baSeptember 1981   
get:bacurrently readi
get:badefine what the
get:baurgent data, bu
get:batake action to 
get:ba2.9.  Precedence 
get:baThe TCP makes u
get:basecurity option
get:babasis to TCP us
get:baa multilevel se
get:bause only, and o
get:bacompartment.  C
get:bausers may be li
get:baTCP modules whi
get:baproperly mark o
get:baprecedence.  Su
get:bahigher level pr
get:bathem to specify
get:baprecedence of c
get:ba2.10.  Robustness
get:baTCP implementat:ions will follow a general principle of robustness
get:baconservative in
get:baTransmission Cont
get:ba[Page 14]        
get:baSeptember 1981   
get:ba3.1.  Header Form
get:baTCP segments ar
get:baheader carries 
get:badestination hos
get:baheader, supplyi
get:badivision allows
get:baTCP Header Form
get:ba0            
get:ba0 1 2 3 4 5 6
get:ba+-+-+-+-+-+-+-
get:ba|          Sou
get:ba+-+-+-+-+-+-+-
get:ba|             
get:ba+-+-+-+-+-+-+-
get:ba|             
get:ba+-+-+-+-+-+-+-
get:ba|  Data |     
get:ba| Offset| Rese
get:ba|       |     
get:ba+-+-+-+-+-+-+-
get:ba|           Ch
get:ba+-+-+-+-+-+-+-
get:ba|             
get:ba+-+-+-+-+-+-+-
get:ba|             
get:ba+-+-+-+-+-+-+-
get:baNote th
get:baSource Port:  1
get:baThe source po
get:baDestination Por:t
get:baThe destinati
get:baTransmission Cont
get:baFunctional Specif
get:baSequence Number:
get:baThe sequence 
get:bawhen SYN is p
get:bainitial seque
get:baAcknowledgment :Number
get:baIf the ACK co
get:banext sequence
get:bareceive.  Onc
get:baData Offset:  4
get:baThe number of
get:bathe data begi
get:baintegral numb
get:baReserved:  6 bi
get:baReserved for 
get:baControl Bits:  :6 bits (from left to right)
get:baURG:  Urgent 
get:baACK:  Acknowl
get:baPSH:  Push Fu
get:baRST:  Reset t
get:baSYN:  Synchro
get:baFIN:  No more
get:baWindow:  16 bit
get:baThe number of
get:baacknowledgmen
get:baChecksum:  16 b
get:baThe checksum 
get:bacomplement su
get:basegment conta
get:bachecksummed, 
get:baform a 16 bit
get:batransmitted a
get:bathe checksum 
get:baThe checksum 
get:ba[Page 16]        
get:baSeptember 1981   
get:baprefixed to t
get:baAddress, the 
get:baThis gives th
get:bainformation i
get:baacross the TC
get:bacalls by the 
get:baThe TCP Len
get:baoctets (thi
get:bacomputed), 
get:baUrgent Pointer:
get:baThis field co
get:bapositive offs
get:baurgent pointe
get:bathe urgent da
get:bathe URG contr
get:baOptions:  varia
get:baOptions may o
get:bamultiple of 8
get:bachecksum.  An
get:bacases for the: format of an option
get:baCase 1:  A 
get:baCase 2:  An
get:bath
get:baThe option-le
get:baoption-length
get:baNote that the
get:bafield might i
get:baEnd-of-Option
get:baA TCP must im
get:baTransmission Cont
get:baFunctional Specif
get:baCurrently def:ined options include (kind indicated in octal)
get:baKind     Le
get:ba----     --
get:ba0         
get:ba1         
get:ba2         
get:baSpecific Opti
get:baEnd of Opti
get:ba+--------
get:ba|00000000
get:ba+--------
get:baThis opti
get:bamight not
get:bathe Data 
get:banot the e
get:bathe optio
get:baNo-Operatio
get:ba+--------
get:ba|00000001
get:ba+--------
get:baThis opti
get:baalign the
get:baThere is 
get:bareceivers
get:banot begin
get:baMaximum Seg
get:ba+--------
get:ba|00000010
get:ba+--------
get:baKind=2  
get:ba[Page 18]        
get:baSeptember 1981   
get:baMaximum S:egment Size Option Data
get:baIf this
get:bareceive
get:baThis fi
get:ba(i.e., 
get:baoption 
get:baPadding:  varia
get:baThe TCP heade
get:baand data begi
get:ba3.2.  Terminology
get:baBefore we can d
get:bato introduce so
get:baconnection requ
get:baof these variab
get:baTransmission Co
get:baTCB are the loc
get:baprecedence of t
get:babuffers, pointe
get:baIn addition sev
get:basequence number
get:baSend Sequence
get:baSND.UNA - s
get:baSND.NXT - s
get:baSND.WND - s
get:baSND.UP  - s
get:baSND.WL1 - s
get:baSND.WL2 - s
get:bau
get:baISS     - i
get:baReceive Seque
get:baRCV.NXT - r
get:baRCV.WND - r
get:baRCV.UP  - r
get:baIRS     - i
get:baTransmission Cont
get:baFunctional Specif
get:baThe following d
get:bathe sequence sp
get:baSend Sequence S
get:ba---
get:ba1 - old s
get:ba2 - seque
get:ba3 - seque
get:ba4 - futur
get:baThe send window
get:baReceive Sequenc
get:ba1 - old s
get:ba2 - seque
get:ba3 - futur
get:baThe receive win
get:baThere are also 
get:batake their valu
get:ba[Page 20]        
get:baSeptember 1981   
get:baCurrent Segme
get:baSEG.SEQ - s
get:baSEG.ACK - s
get:baSEG.LEN - s
get:baSEG.WND - s
get:baSEG.UP  - s
get:baSEG.PRC - s
get:baA connection pr
get:balifetime.  The :states are
get:baESTABLISHED, FI
get:baTIME-WAIT, and 
get:babecause it repr
get:bano connection. : Briefly the meanings of the states are
get:baLISTEN - repr
get:baTCP and port.
get:baSYN-SENT - re
get:baafter having 
get:baSYN-RECEIVED 
get:barequest ackno
get:baconnection re
get:baESTABLISHED -
get:badelivered to 
get:baof the connec
get:baFIN-WAIT-1 - 
get:bafrom the remo
get:batermination r
get:baFIN-WAIT-2 - 
get:bafrom the remo
get:baCLOSE-WAIT - 
get:bafrom the loca
get:baCLOSING - rep
get:baacknowledgmen
get:baLAST-ACK - re
get:baconnection te
get:ba(which includ
get:baTransmission Cont
get:baFunctional Specif
get:baTIME-WAIT - r
get:bathe remote TC
get:batermination r
get:baCLOSED - repr
get:baA TCP connectio
get:baevents.  The ev
get:baABORT, and STAT
get:bacontaining the 
get:baThe state diagr
get:bawith the causin
get:baerror condition
get:bachanges.  In a 
get:bathe reaction of
get:baNOTE BENE:  thi
get:bathe total speci
get:ba[Page 22]        
get:baSeptember 1981   
get:ba+---------+     
get:ba|         |<----
get:ba|   SYN   |     
get:ba|   RCVD  |<----
get:ba|         |     
get:ba|         |-----
get:ba+---------+   rc
get:ba|           --
get:ba|             
get:ba|             
get:ba|  CLOSE      
get:ba| -------     
get:ba| snd FIN     
get:ba|             
get:baV             
get:ba+---------+     
get:ba|  FIN    |<----
get:ba| WAIT-1  |-----
get:ba+---------+     
get:ba| rcv ACK of F
get:ba| ------------
get:baV        x    
get:ba+---------+     
get:ba|FINWAIT-2|     
get:ba+---------+     
get:ba|             
get:ba|  rcv FIN    
get:ba|  -------    
get:ba\ snd ACK    
get:ba------------
get:baTransmission Cont
get:baFunctional Specif
get:ba3.3.  Sequence Nu
get:baA fundamental n
get:baover a TCP conn
get:basequenced, each
get:bamechanism emplo
get:banumber X indica
get:bareceived.  This
get:badetection in th
get:bawithin a segmen
get:bathe header is t
get:banumbered consec
get:baIt is essential
get:bafinite, though 
get:baSince the space
get:banumbers must be
get:bapreserves the r
get:ba2**32 - 1 to 0 
get:baarithmetic, so 
get:bacomparison of s
get:ba(modulo 2**32).
get:baThe typical kin
get:baperform include:
get:ba(a)  Determin
get:banumber s
get:ba(b)  Determin
get:bahave bee
get:baretransm
get:ba(c)  Determin
get:bawhich ar
get:bareceive 
get:ba[Page 24]        
get:baSeptember 1981   
get:baIn response to 
get:bafollowing compa
get:baSND.UNA = old
get:baSND.NXT = nex
get:baSEG.ACK = ack
get:banum
get:baSEG.SEQ = fir
get:baSEG.LEN = the
get:ba(co
get:baSEG.SEQ+SEG.L
get:baA new acknowled
get:bathe inequality :below holds
get:baSND.UNA < SEG
get:baA segment on th
get:baof its sequence
get:baacknowledgment 
get:baWhen data is re:ceived the following comparisons are needed
get:baRCV.NXT = nex
get:bais the le
get:baRCV.NXT+RCV.W
get:basegment, 
get:baSEG.SEQ = fir
get:baSEG.SEQ+SEG.L
get:baA segment is ju
get:baRCV.NXT =< SE
get:baRCV.NXT =< SE
get:baTransmission Cont
get:baFunctional Specif
get:baThe first part 
get:basegment falls i
get:baif the end of t
get:baeither part of 
get:baActually, it is
get:bawindows and zer
get:baacceptability o:f an incoming segment
get:baSegment Recei
get:baLength  Windo
get:ba------- -----
get:ba0       0 
get:ba0      >0 
get:ba>0       0 
get:ba>0      >0 
get:baNote that when 
get:baacceptable exce
get:bamaintain a zero
get:baACKs.  However,
get:baprocess the RST
get:baWe have taken a
get:bacontrol informa
get:basome control fl
get:baand acknowledge
get:bacontrol will be
get:bacarried in the 
get:bafor implicitly 
get:baare the only co
get:baare used only a
get:bapurposes, the S
get:baoctet of the se
get:bato occur after 
get:baoccurs.  The se
get:baspace occupying
get:basequence number
get:ba[Page 26]        
get:baSeptember 1981   
get:baInitial Sequenc
get:baThe protocol pl
get:baused over and o
get:basockets.  New i
get:baincarnations of
get:ba-- "how does th
get:baincarnations of
get:baconnection is b
get:baconnection brea
get:baTo avoid confus
get:baconnection from
get:babe present in t
get:baassure this, ev
get:basequence number
get:baan initial sequ
get:banew 32 bit ISN.
get:babit clock whose
get:bamicroseconds.  
get:baSince we assume
get:bathe Maximum Seg
get:bahours we can re
get:baFor each connec
get:basequence number
get:bathe data sendin
get:balearned during 
get:baFor a connectio
get:basynchronize on 
get:baan exchange of 
get:bacalled "SYN" (f
get:bashorthand, segm
get:baHence, the solu
get:bainitial sequenc
get:baThe synchroniza
get:basequence number
get:bafrom the other 
get:bainitial sequenc
get:ba1) A --> B  S
get:ba2) A <-- B  A
get:ba3) A <-- B  S
get:ba4) A --> B  A
get:baTransmission Cont
get:baFunctional Specif
get:baBecause steps 2
get:bacalled the thre
get:baA three way han
get:batied to a globa
get:bamechanisms for 
get:bano way of knowi
get:baunless it remem
get:ba(which is not a
get:baverify this SYN
get:baclock-driven sc
get:baKnowing When to
get:baTo be sure that
get:basequence number
get:bathe network, th
get:ba(MSL) before as
get:barecovering from
get:balost.  For this
get:bais an engineeri
get:bait is desirable
get:basense, yet reta
get:banot wait at all
get:bathan those rece
get:baThe TCP Quiet T
get:baThis specific
get:baretaining any
get:baeach active (
get:baTCP segments 
get:bain the intern
get:baparagraphs be
get:baTCP implement
get:baat the risk o
get:badata rejected
get:baTCPs consume 
get:baentered into 
get:baduplicate det
get:barelies on the
get:bathe extent th
get:bavalues before
get:babeen delivere
get:bacopies of the
get:basuch an assum
get:ba[Page 28]        
get:baSeptember 1981   
get:baassigned the 
get:baat the receiv
get:bathat each seg
get:baas there are 
get:baUnder normal 
get:bato emit and t
get:bamistakenly us
get:babeen acknowle
get:badata is drain
get:bavery large to
get:bacause trouble
get:bato use up 2**
get:balifetime in t
get:bathis is deeme
get:barates escalat
get:bacycle time is
get:bawithin reason
get:baThe basic dup
get:badefeated, how
get:basequence numb
get:bathe TCP were 
get:baupon crashing
get:baconnection (p
get:bapackets with 
get:bapackets still
get:baincarnation o
get:baabout the seq
get:baspecification
get:babefore emitti
get:basegments from
get:baEven hosts wh
get:bainitial seque
get:ba(i.e., even i
get:banumber for ea
get:baSuppose, for 
get:basequence numb
get:baand that even
get:batakes on a va
get:basegment sent 
get:baat this insta
get:baincarnation o
get:baS1 = ISN(t) -
get:baconnection!  
get:baTransmission Cont
get:baFunctional Specif
get:baduplicates in
get:baof S1 may arr
get:bathe new incar
get:baThe problem i
get:bacrashed nor d
get:bathe system fr
get:baOne way to de
get:basegments for 
get:batime" specifi
get:bawilling to ri
get:badestination m
get:baImplementors 
get:baconnection by
get:bainformally im
get:baObviously, ev
get:banecessary aft
get:baTo summarize:
get:banumbers in th
get:ba"busy" or "in
get:bablock of spac
get:basegment, if a
get:basequence numb
get:bathe previous 
get:banumber overla
get:ba3.4.  Establishin
get:baThe "three-way 
get:baconnection.  Th
get:baresponded to by
get:basimultaneously 
get:baoccurs, each TC
get:baacknowledgment 
get:baan old duplicat
get:barecipient, that
get:baProper use of "
get:baSeveral example
get:baexamples do not
get:basegments, this 
get:badoesn't deliver
get:bavalid (i.e., th
get:baconnection reac
get:bareduces the pos
get:ba[Page 30]        
get:baSeptember 1981   
get:baimplementation 
get:bainformation for
get:baThe simplest th
get:bafigures should 
get:banumbered for re
get:badeparture of a 
get:basegment at B fr
get:baEllipsis (...) 
get:ba(delayed).  An 
get:baComments appear
get:bathe departure o
get:bathe center of e
get:baform, with sequ
get:bafields such as 
get:bain the interest
get:baTCP A      
get:ba1.  CLOSED     
get:ba2.  SYN-SENT   
get:ba3.  ESTABLISHED
get:ba4.  ESTABLISHED
get:ba5.  ESTABLISHED
get:baBasic 3
get:baIn line 2 of fi
get:baindicating that
get:banumber 100.  In
get:bareceived from T
get:baB is now expect
get:baoccupied sequen
get:baAt line 4, TCP 
get:baTCP B's SYN; an
get:basequence number
get:babecause the ACK
get:bawould wind up A
get:baTransmission Cont
get:baFunctional Specif
get:baSimultaneous in
get:bafigure 8.  Each
get:baTCP A      
get:ba1.  CLOSED     
get:ba2.  SYN-SENT   
get:ba3.  SYN-RECEIVE
get:ba4.             
get:ba5.  SYN-RECEIVE
get:ba6.  ESTABLISHED
get:ba7.             
get:baS
get:baThe principle r
get:baduplicate conne
get:bathis, a special
get:bareceiving TCP i
get:baSYN-RECEIVED), 
get:baIf the TCP is i
get:baFIN-WAIT-1, FIN
get:baaborts the conn
get:bacase under "hal
get:ba[Page 32]        
get:baSeptember 1981   
get:baTCP A      
get:ba1.  CLOSED     
get:ba2.  SYN-SENT   
get:ba3.  (duplicate)
get:ba4.  SYN-SENT   
get:ba5.  SYN-SENT   
get:ba6.             
get:ba7.  SYN-SENT   
get:ba8.  ESTABLISHED
get:baAs a simple exa
get:bafigure 9.  At l
get:bacannot tell tha
get:ba(line 4).  TCP 
get:baRST (reset) wit
get:babelievable.  TC
get:baWhen the origin
get:basynchronization
get:babefore the RST,
get:basent in both di
get:baHalf-Open Conne
get:baAn established 
get:baTCPs has closed
get:baknowledge of th
get:babecome desynchr
get:bamemory.  Such c
get:baattempt is made
get:baconnections are
get:bamildly involved
get:baIf at site A th
get:baTransmission Cont
get:baFunctional Specif
get:bauser at site B 
get:bareceiving a res
get:basite B TCP that
get:baAssume that two
get:baanother when a 
get:baDepending on th
get:bathat some error
get:baA is likely to 
get:bapoint.  As a re
get:baor try to SEND 
get:bacase, it receiv
get:balocal (A's) TCP
get:bawill send a seg
get:baexample shown i
get:bare-open the con
get:baTCP A      
get:ba1.  (CRASH)    
get:ba2.  CLOSED     
get:ba3.  SYN-SENT --
get:ba4.  (!!)     <-
get:ba5.  SYN-SENT --
get:ba6.  SYN-SENT   
get:ba7.  SYN-SENT --
get:baWhen the SYN ar
get:baand the incomin
get:baacknowledgment 
get:ba100).  TCP A se
get:basent and, being
get:badetected a half
get:ba[Page 34]        
get:baSeptember 1981   
get:bacontinue to try
get:bareduced to the 
get:baAn interesting 
get:batries to send d
get:baThis is illustr
get:baTCP A from TCP 
get:baexists, so TCP 
get:baprocesses it an
get:baTCP A    
get:ba1.  (CRASH)    
get:ba2.  (??)    <--
get:ba3.          -->
get:baActive
get:baIn figure 12, w
get:bawaiting for SYN
get:bainto action.  A
get:bagenerate a RST 
get:bathe reset and r
get:baTCP A      
get:ba1.  LISTEN     
get:ba2.       ... <S
get:ba3.  (??) <-- <S
get:ba4.       --> <S
get:ba5.  LISTEN     
get:baOld Duplic
get:baTransmission Cont
get:baFunctional Specif
get:baA variety of ot
get:baby the followin
get:baReset Generatio
get:baAs a general ru
get:bawhich apparentl
get:bamust not be sen
get:baThere are three: groups of states
get:ba1.  If the co
get:bain response t
get:baparticular, S
get:baby this means
get:baIf the incomi
get:basequence numb
get:bareset has seq
get:baof the sequen
get:baThe connectio
get:ba2.  If the co
get:baSYN-SENT, SYN
get:basomething not
get:baif an incomin
get:badoes not exac
get:baconnection, a
get:baIf our SYN ha
get:baincoming segm
get:baeither raise 
get:bathe system) o
get:baincoming segm
get:bacontinue as i
get:bacannot raise 
get:badetected in t
get:baterminated th
get:baincoming segm
get:bamatch the loc
get:bamust be sent.
get:baIf the incomi
get:basequence numb
get:bareset has seq
get:baof the sequen
get:baThe connectio
get:ba[Page 36]        
get:baSeptember 1981   
get:ba3.  If the co
get:baFIN-WAIT-1, F
get:baany unaccepta
get:baunacceptible 
get:baacknowledgmen
get:baand an acknow
get:bato be receive
get:baIf an incomin
get:baprecedence wh
get:baand precedenc
get:baconnection go
get:banumber from t
get:baReset Processin
get:baIn all states e
get:baby checking the
get:bais in the windo
get:bato an initial S
get:baacknowledges th
get:baThe receiver of
get:bareceiver was in
get:bain SYN-RECEIVED
get:bathen the receiv
get:baaborts the conn
get:bawas in any othe
get:baand goes to the
get:ba3.5.  Closing a C
get:baCLOSE is an ope
get:banotion of closi
get:bainterpretation,
get:bathe receiving s
get:bain a simplex fa
get:bauntil he is tol
get:bacould initiate 
get:baRECEIVE until s
get:bahas CLOSED.  We
get:baRECEIVEs are ou
get:bacan terminate h
get:babuffers SENT be
get:badata in return 
get:basuccessfully to
get:baTCP.  Users mus
get:bathe TCP says no
get:baTransmission Cont
get:baFunctional Specif
get:baThere are essen:tially three cases
get:ba1) The user i
get:ba2) The remote
get:ba3) Both users
get:baCase 1:  Local 
get:baIn this case,
get:baoutgoing segm
get:baaccepted by t
get:baare allowed i
get:bawill be retra
get:baboth acknowle
get:bacan ACK this 
get:basend its own 
get:baCase 2:  TCP re
get:baIf an unsolic
get:bacan ACK it an
get:bauser will res
get:bathe other TCP
get:bauntil its own
get:baconnection.  
get:bathe connectio
get:baCase 3:  both u
get:baA simultaneou
get:baFIN segments 
get:bahave been pro
get:bahas received.
get:ba[Page 38]        
get:baSeptember 1981   
get:baTCP A      
get:ba1.  ESTABLISHED
get:baFIN-WAIT-1 
get:ba3.  FIN-WAIT-2 
get:ba4.             
get:baTIME-WAIT  
get:ba5.  TIME-WAIT  
get:baCLOSED     
get:baTCP A      
get:ba1.  ESTABLISHED
get:ba2.  (Close)    
get:baFIN-WAIT-1 
get:ba3.  CLOSING    
get:ba4.  TIME-WAIT  
get:ba(2 MSL)    
get:baCLOSED     
get:baTransmission Cont
get:baFunctional Specif
get:ba3.6.  Precedence 
get:baThe intent is t
get:bawith exactly th
get:bahigher of the p
get:baThe precedence 
get:badefined in the 
get:baspecification t
get:bathe security pa
get:bauser group, and
get:baA connection at
get:balower precedenc
get:baa connection du
get:baacknowledgment 
get:baNote that TCP m
get:baprecedence will
get:basegments and po
get:baThe security pa
get:ba(the values wou
get:banon-secure envi
get:baparameters, tho
get:ba3.7.  Data Commun
get:baOnce the connec
get:baexchange of seg
get:ba(checksum test 
get:baretransmission 
get:baDuplicate segme
get:baAs discussed in
get:bacertain tests o
get:basegments to ver
get:baThe sender of d
get:bathe variable SN
get:basequence number
get:bakeeps track of 
get:bavariable SND.UN
get:basent has been a
get:baWhen the sender
get:baSND.NXT.  When 
get:basends an acknow
get:ba[Page 40]        
get:baSeptember 1981   
get:baacknowledgment 
get:bathese variables
get:baThe amount by w
get:badata in the seg
get:basegments must c
get:baThe CLOSE user 
get:baflag in an inco
get:baRetransmission 
get:baBecause of the 
get:bainternetwork sy
get:baretransmission 
get:bafor determining
get:baAn Example Re
get:baMeasure the
get:baparticular 
get:bacovers that
get:basegments re
get:baTime (RTT).:  Next compute a Smoothed Round Trip Time (SRTT) as
get:baSRTT = ( 
get:baand based o:n this, compute the retransmission timeout (RTO) as
get:baRTO = min
get:bawhere UBOUN
get:baLBOUND is a
get:baa smoothing
get:bafactor (e.g
get:baThe Communicati
get:baThe objective o
get:bato stimulate th
get:bapermit the rece
get:bathe currently k
get:baThis mechanism 
get:bathe end of urge
get:bathe receive seq
get:bamust tell the u
get:banumber catches 
get:baTransmission Cont
get:baFunctional Specif
get:bainto "normal mo
get:bais in "urgent m
get:baThe method empl
get:batransmitted.  T
get:bameaningful and 
get:bathe urgent poin
get:bano urgent data 
get:baTo send an urge
get:baoctet.  If the 
get:bathe urgent info
get:baManaging the Wi
get:baThe window sent
get:banumbers the sen
get:baprepared to acc
get:bathe currently a
get:baIndicating a la
get:baarrives than ca
get:bain excessive re
get:banetwork and the
get:batransmission of
get:babetween each ne
get:baThe mechanisms 
get:basubsequently ad
get:bathat much data.
get:badiscouraged.  T
get:bashrink the wind
get:baon the part of 
get:baThe sending TCP
get:baleast one octet
get:basending TCP mus
get:bathe window is z
get:bainterval when t
get:baguarantee that 
get:bawindow will be 
get:baWhen the receiv
get:bastill send an a
get:baand current win
get:baThe sending TCP
get:ba[Page 42]        
get:baSeptember 1981   
get:bawhich fit the c
get:baretransmission 
get:baIn a connection
get:babe carried in a
get:banumber so there
get:baorder.  This is
get:bainformation to 
get:bathe data receiv
get:bathe window info
get:baacknowledgment 
get:baequal or greate
get:baThe window mana
get:bacommunication p
get:baWindow Manage
get:baAllocating 
get:bamany small 
get:bafewer large
get:baOne suggest
get:badefer updat
get:baleast X per
get:baconnection 
get:baAnother sug
get:basegments by
get:basending dat
get:badata must b
get:baNote that t
get:baretransmiss
get:baacknowledgm
get:bawindow info
get:banew window 
get:baThe segment
get:baof transmit
get:basegment con
get:bais accepted
get:baIf the send
get:bawindow is n
get:baalternating
get:bapauses in t
get:baTransmission Cont
get:baFunctional Specif
get:baresult in b
get:babig pair. A
get:bamostly smal
get:baThe suggest
get:baactively at
get:bawindows, si
get:bato many sma
get:baThere are of co:urse two interfaces of concern
get:baand the TCP/low
get:baof the user/TCP
get:baprotocol module
get:bain detail by th
get:bacase that the l
get:bathat TCPs might
get:baUser/TCP Interf
get:baThe following
get:baat best, fict
get:bafacilities.  
get:baimplementatio
get:baTCPs must pro
get:bathat all TCP 
get:bahierarchy.  T
get:barequired of a
get:baTCP User Comm
get:baThe followi
get:bainterface. 
get:bafunction ca
get:bameant to ru
get:baThe user co
get:baTCP must pe
get:baIndividual 
get:bamay provide
get:basingle call
get:baautomatical
get:baissued by t
get:ba[Page 44]        
get:baSeptember 1981   
get:baIn providin
get:banot only ac
get:baprocesses i:t serves.  The latter consists of
get:ba(a) gener
get:baremote cl
get:ba(b) repli
get:bavarious t
get:baFormat:  
get:ba[, timeou
get:ba-> local 
get:baWe assume
get:baprocesses
get:bato use th
get:baimplement
get:bafor the s
get:balower lev
get:baresult of
get:baable to m
get:baprocess c
get:baIf the ac
get:bacall to L
get:bahave eith
get:baparticula
get:bafor any c
get:baby the su
get:baA transmi
get:bafilled in
get:baOn an act
get:basynchroni
get:baThe timeo
get:bafor all d
get:badelivered
get:bawill abor
get:baThe TCP o
get:bathe users
get:baTransmission Cont
get:baFunctional Specif
get:baprecedenc
get:baor securi
get:bathe defau
get:baTCP will 
get:basecurity/
get:bathe prece
get:barequested
get:baThe prece
get:barequested
get:barequest, 
get:baconnectio
get:bathis prec
get:baallowed t
get:baor that a
get:baA local c
get:baThe local
get:bafor the c
get:baFormat:  
get:bacount, PU
get:baThis call
get:bato be sen
get:banot been 
get:baimplement
get:baautomatic
get:baauthorize
get:baIf the PU
get:bato the re
get:basegment c
get:bathe data 
get:batransmiss
get:baIf the UR
get:bawill have
get:bathe urgen
get:bapointer i
get:babeen cons
get:bais to sti
get:baindicate 
get:ba[Page 46]        
get:baSeptember 1981   
get:badata has 
get:baTCP signa
get:baof times 
get:baurgent da
get:baIf no for
get:baconnectio
get:bahas becom
get:balocal soc
get:baforeign s
get:baforeign s
get:baknowing t
get:baHowever, 
get:babecomes s
get:baSTATUS ca
get:baimplement
get:basocket is
get:baIf a time
get:baconnectio
get:baIn the si
get:bathe sendi
get:baor the ti
get:bais both s
get:baconnectio
get:baoffers po
get:basophistic
get:bathe proce
get:bafurthermo
get:baMultiple 
get:bathe TCP w
get:baWe have i
get:bawhich a S
get:bapseudo-in
get:bareturn a 
get:baimmediate
get:babeen ackn
get:baassume ev
get:baclose any
get:bakind (syn
get:basignals, 
get:bawith spec
get:baIn order 
get:baindicatio
get:baTransmission Cont
get:baFunctional Specif
get:babuffer ad
get:bathe SEND 
get:baindicatin
get:bacalling p
get:baFormat:  
get:bacount) ->
get:baThis comm
get:baspecified
get:bacalling p
get:baerror is 
get:baIn the si
get:bacalling p
get:baerror occ
get:baA more so
get:baRECEIVEs 
get:basegments 
get:bathe cost 
get:banotify th
get:baIf enough
get:bathe PUSH 
get:baThe buffe
get:baa PUSH is
get:bareturned 
get:baIf there 
get:baas it arr
get:bashould th
get:baadditiona
get:bacall to R
get:bamay now l
get:baurgent po
get:bain the sa
get:baboundary 
get:baTo distin
get:bacare of t
get:bareturn co
get:bacount ind
get:baAlternati
get:ba[Page 48]        
get:baSeptember 1981   
get:baallocate 
get:bawith the 
get:baFormat:  
get:baThis comm
get:bathe conne
get:baauthorize
get:baClosing c
get:bathe sense
get:baretransmi
get:baserviced.
get:bacalls, fo
get:bato the de
get:bacontinue 
get:bamay be tr
get:bameans "I 
get:bareceive a
get:banot well 
get:baof all it
get:bainto ABOR
get:baThe user 
get:bainitiativ
get:ba(e.g., re
get:badestinati
get:baBecause c
get:baforeign T
get:bashort tim
get:bareplies t
get:baClose als
get:baFormat:  
get:baThis is a
get:baexcluded 
get:batypically
get:baThis comm
get:bainformati:on
get:balocal s
get:baTransmission Cont
get:baFunctional Specif
get:baforeign
get:balocal c
get:bareceive
get:basend wi
get:baconnect
get:banumber 
get:banumber 
get:baurgent 
get:baprecede
get:basecurit
get:baand tra
get:baDepending
get:baimplement
get:baavailable
get:baauthorize
get:baprevents 
get:baconnectio
get:baFormat:  
get:baThis comm
get:baaborted, 
get:babe sent t
get:baDepending
get:baindicatio
get:bareceive a
get:baTCP-to-User M
get:baIt is assum
get:bameans for t
get:bathe TCP doe
get:bato the user
get:baan error me
get:barelating to
get:baother user 
get:baThe followi:ng information is provided
get:baLocal Con
get:baResponse 
get:baBuffer Ad
get:baByte coun
get:baPush flag
get:baUrgent fl
get:ba[Page 50]        
get:baSeptember 1981   
get:baTCP/Lower-Level
get:baThe TCP calls
get:bareceive infor
get:bainternetwork 
get:baProtocol (IP)
get:baIf the lower 
get:baof service an
get:bafor these par:ameters
get:baType of Ser:vice = Precedence: routine, Delay: normal, Throughput
get:banormal, Rel:iability
get:baTime to Liv
get:baNote that
get:baHere we e
get:babe delive
get:baIf the lower 
get:bafeature) and 
get:baroute informa
get:baso that the s
get:bachecksum be t
get:baalso importan
get:baAny lower lev
get:badestination a
get:bathe "TCP leng
get:baof IP and to 
get:baTransmission Cont
get:baFunctional Specif
get:ba3.9.  Event Proce
get:baThe processing 
get:baimplementation.
get:baprocessing sequ
get:basection only in
get:baThe activity of
get:baThe events that: occur can be cast into three categories
get:baarriving segmen
get:baprocessing the 
get:bacases the proce
get:baEvents that o:ccur
get:baArriving Se
get:baSEGMENT A
get:baUSER TIME
get:baRETRANSMI
get:baTIME-WAIT
get:baThe model of th
get:baimmediate retur
get:bapseudo interrup
get:bameans cause a d
get:baError responses
get:bacommands refere:ncing connections that do not exist receive "error
get:baconnection not 
get:baPlease note in 
get:baacknowledgment 
get:baof the sequence
get:baequal to (modul
get:ba[Page 52]        
get:baSeptember 1981   
get:baA natural way t
get:baimagine that th
get:bathat their cont
get:bain the sequence
get:baand processed i
get:baWhen a segment 
get:bathe segment to 
get:bato be consisten
get:baNote that if no
get:baTransmission Cont
get:baFunctional Specif
get:baCLOSED STATE 
get:baCreate a ne
get:bastate infor
get:basocket, pre
get:bainformation
get:baunspecified
get:baparameters 
get:baprecedence 
get:ba"error:  pr:ecedence not allowed" or "error
get:banot allowed
get:baactive and :the foreign socket is unspecified, return "error
get:baforeign soc
get:baspecified, 
get:ba(ISS) is se
get:bais sent.  S
get:bastate, and 
get:baIf the call
get:bareturn "err:or
get:bano room to :create a new connection, return "error
get:baresources".
get:baIf active a
get:baconnection 
get:basegment, se
get:bastate.  Dat
get:baqueued for 
get:baurgent bit 
get:basegments se
get:baqueue the r:equest, respond with "error
get:baIf Foreign :socket was not specified, then return "error
get:basocket unsp
get:ba[Page 54]        
get:baSeptember 1981   
get:baSYN-SENT STAT
get:baSYN-RECEIVED 
get:baESTABLISHED S
get:baFIN-WAIT-1 ST
get:baFIN-WAIT-2 ST
get:baCLOSE-WAIT ST
get:baCLOSING STATE
get:baLAST-ACK STAT
get:baTIME-WAIT STA
get:baReturn "err:or
get:baTransmission Cont
get:baFunctional Specif
get:baCLOSED STATE 
get:baIf the user
get:ba"error:  co
get:baOtherwise, :return "error
get:baIf the fore
get:bafrom passiv
get:baSND.UNA to 
get:baassociated 
get:batransmissio
get:barequested i
get:baas a result
get:barequest, re:spond with "error
get:baForeign soc:ket was not specified, then return "error
get:basocket unsp
get:baSYN-SENT STAT
get:baSYN-RECEIVED 
get:baQueue the d
get:baIf no space: to queue, respond with "error
get:baresources".
get:baESTABLISHED S
get:baCLOSE-WAIT ST
get:baSegmentize 
get:baacknowledgm
get:bainsufficien:t space to remember this buffer, simply return "error
get:bainsufficien
get:baIf the urge
get:baurgent poin
get:ba[Page 56]        
get:baSeptember 1981   
get:baFIN-WAIT-1 ST
get:baFIN-WAIT-2 ST
get:baCLOSING STATE
get:baLAST-ACK STAT
get:baTIME-WAIT STA
get:baReturn "err:or
get:baTransmission Cont
get:baFunctional Specif
get:baCLOSED STATE 
get:baIf the user
get:ba"error:  co
get:baOtherwise r:eturn "error
get:baSYN-SENT STAT
get:baSYN-RECEIVED 
get:baQueue for p
get:bais no room :to queue this request, respond with "error
get:bainsufficien
get:baESTABLISHED S
get:baFIN-WAIT-1 ST
get:baFIN-WAIT-2 ST
get:baIf insuffic
get:barequest, qu
get:baremember th:e RECEIVE, respond with "error
get:baresources".
get:baReassemble 
get:bato user.  M
get:baIf RCV.UP i
get:bauser notify
get:baWhen the TC
get:bathat fact m
get:baacknowledgm
get:badescribed b
get:ba[Page 58]        
get:baSeptember 1981   
get:baCLOSE-WAIT ST
get:baSince the r
get:basatisfied b
get:bauser.  If n
get:ba"error:  co
get:batext can be
get:baCLOSING STATE
get:baLAST-ACK STAT
get:baTIME-WAIT STA
get:baReturn "err:or
get:baTransmission Cont
get:baFunctional Specif
get:baCLOSED STATE 
get:baIf the user
get:ba"error:  co
get:baOtherwise, :return "error
get:baAny outstan:ding RECEIVEs are returned with "error
get:baresponses. 
get:baSYN-SENT STAT
get:baDelete the :TCB and return "error
get:baqueued SEND
get:baSYN-RECEIVED 
get:baIf no SENDs
get:bathen form a
get:baotherwise q
get:baESTABLISHED S
get:baQueue this 
get:baform a FIN 
get:baFIN-WAIT-1 ST
get:baFIN-WAIT-2 ST
get:baStrictly sp:eaking, this is an error and should receive a "error
get:baconnection 
get:baacceptable,
get:baFIN may be 
get:ba[Page 60]        
get:baSeptember 1981   
get:baCLOSE-WAIT ST
get:baQueue this 
get:basegmentized
get:baCLOSING STATE
get:baLAST-ACK STAT
get:baTIME-WAIT STA
get:baRespond wit:h "error
get:baTransmission Cont
get:baFunctional Specif
get:baCLOSED STATE 
get:baIf the user
get:ba"error:  co
get:baOtherwise r:eturn "error
get:baAny outstan:ding RECEIVEs should be returned with "error
get:baconnection 
get:baSYN-SENT STAT
get:baAll queued 
get:banotificatio
get:baSYN-RECEIVED 
get:baESTABLISHED S
get:baFIN-WAIT-1 ST
get:baFIN-WAIT-2 ST
get:baCLOSE-WAIT ST
get:baSend a rese:t segment
get:ba<SEQ=SND.
get:baAll queued 
get:banotificatio
get:baRST formed 
get:baTCB, enter 
get:baCLOSING STATE
get:baLAST-ACK STAT
get:baTIME-WAIT STA
get:baRespond wit
get:ba[Page 62]        
get:baSeptember 1981   
get:baCLOSED STATE 
get:baIf the user
get:ba"error:  co
get:baOtherwise r:eturn "error
get:baReturn "sta
get:baSYN-SENT STAT
get:baReturn "sta
get:baSYN-RECEIVED 
get:baReturn "sta
get:baESTABLISHED S
get:baReturn "sta
get:baFIN-WAIT-1 ST
get:baReturn "sta
get:baFIN-WAIT-2 ST
get:baReturn "sta
get:baCLOSE-WAIT ST
get:baReturn "sta
get:baCLOSING STATE
get:baReturn "sta
get:baLAST-ACK STAT
get:baReturn "sta
get:baTransmission Cont
get:baFunctional Specif
get:baTIME-WAIT STA
get:baReturn "sta
get:ba[Page 64]        
get:baSeptember 1981   
get:baSEGMENT ARRIVES
get:baIf the state 
get:baall data in
get:basegment con
get:bacontaining 
get:baacknowledgm
get:bareset seque
get:baIf the ACK 
get:ba<SEQ=0><A
get:baIf the ACK 
get:ba<SEQ=SEG.
get:baIf the state 
get:bafirst check
get:baAn incomi
get:basecond chec
get:baAny ackno
get:bathe LISTE
get:bafor any a
get:baformatted: as follows
get:ba<SEQ=SE
get:bathird check
get:baIf the SY
get:basecurity/
get:bamatch the
get:ba<SEQ=SE
get:baTransmission Cont
get:baFunctional Specif
get:baIf the SE
get:bathe user 
get:basend a re
get:ba<SEQ=SE
get:baIf the SE
get:baSet RCV.N
get:bacontrol o
get:bashould be: selected and a SYN segment sent of the form
get:ba<SEQ=IS
get:baSND.NXT i
get:bastate sho
get:baincoming 
get:bain the SY
get:banot be re
get:bathe forei
get:baunspecifi
get:bafourth othe
get:baAny other
get:bamust have
get:baprocessin
get:bait could 
get:baincarnati
get:babut if yo
get:baIf the state 
get:bafirst check
get:baIf the AC
get:baIf SEG.
get:bathe RST
get:ba<SEQ=
get:baand dis
get:baIf SND.
get:basecond chec
get:ba[Page 66]        
get:baSeptember 1981   
get:baIf the RS
get:baIf the :ACK was acceptable then signal the user "error
get:baconnect
get:badelete 
get:baand ret
get:bathird check
get:baIf the se
get:bamatch the
get:baIf ther
get:ba<SEQ=
get:baOtherwi
get:ba<SEQ=
get:baIf there 
get:baThe pre
get:baTCB, if
get:ba<SEQ=
get:baIf there 
get:baIf the 
get:bain the 
get:bathe pre
get:baallowed
get:ba<SEQ=
get:baIf the 
get:bain the 
get:baIf a rese
get:bafourth chec
get:baThis step
get:bano ACK, a
get:baIf the SY
get:baTransmission Cont
get:baFunctional Specif
get:baare accep
get:baSEG.SEQ. 
get:bais an ACK
get:baare there
get:baIf SND.UN
get:bastate to 
get:ba<SEQ=SN
get:baand send 
get:batransmiss
get:batext in t
get:babelow whe
get:baOtherwise
get:ba<SEQ=IS
get:baand send 
get:basegment, 
get:bahas been 
get:bafifth, if n
get:basegment and
get:ba[Page 68]        
get:baSeptember 1981   
get:bafirst check s
get:baSYN-RECEIVE
get:baESTABLISHED
get:baFIN-WAIT-1 
get:baFIN-WAIT-2 
get:baCLOSE-WAIT 
get:baCLOSING STA
get:baLAST-ACK ST
get:baTIME-WAIT S
get:baSegments 
get:baare used 
get:badone in S
get:baboundary 
get:baprocessed
get:baThere are
get:basegment
get:baSegment R
get:baLength  W
get:ba------- -
get:ba0     
get:ba0     
get:ba>0     
get:ba>0     
get:baIf the RC
get:baspecial a
get:baIf an inc
get:bashould be
get:bathe segme:nt and return)
get:ba<SEQ=SN
get:baAfter sen
get:baand retur
get:baTransmission Cont
get:baFunctional Specif
get:baIn the fo
get:basegment t
get:baOne could
get:batrimming 
get:baSYN and F
get:babegins at
get:banumbers m
get:basecond check 
get:baSYN-RECEIVE
get:baIf the RS
get:baIf this
get:bacame fr
get:baLISTEN 
get:bathis co
get:bafrom SY
get:bathe use
get:baon the 
get:baactive 
get:baand ret
get:baESTABLISHED
get:baIf the RS
get:bashould re
get:baflushed. 
get:ba"connecti
get:baTCB, and 
get:baCLOSING STA
get:baLAST-ACK ST
get:baIf the RS
get:baTCB, and 
get:ba[Page 70]        
get:baSeptember 1981   
get:bathird check s
get:baSYN-RECEIVE
get:baIf the se
get:baexactly m
get:bathen send
get:baESTABLISHED
get:baIf the se
get:baexactly m
get:bathen send
get:bareceive "
get:baflushed. 
get:ba"connecti
get:baTCB, and 
get:baNote this c
get:baa segment f
get:badifferent s
get:bacurrent con
get:bafourth, check
get:baSYN-RECEIVE
get:baESTABLISHED
get:baFIN-WAIT ST
get:baFIN-WAIT ST
get:baCLOSE-WAIT 
get:baCLOSING STA
get:baLAST-ACK ST
get:baTIME-WAIT S
get:baIf the SY
get:baoutstandi
get:baall segme
get:bareceive a
get:bathe CLOSE
get:baIf the SY
get:baand an ac
get:banumber ch
get:baTransmission Cont
get:baFunctional Specif
get:bafifth check t
get:baif the ACK 
get:baif the ACK 
get:baSYN-RECEI
get:baIf SND.
get:baand con
get:baIf th
get:bareset
get:ba<SE
get:baand s
get:baESTABLISH
get:baIf SND.
get:baAny seg
get:baentirel
get:bapositiv
get:bafully a
get:ba"ok" re
get:ba(SEG.AC
get:basomethi
get:badrop th
get:baIf SND.
get:baupdated
get:baSND.WL2
get:baSND.WL1
get:baNote th
get:barecords
get:baSND.WND
get:bathe las
get:baprevent
get:ba[Page 72]        
get:baSeptember 1981   
get:baFIN-WAIT-
get:baIn addi
get:baour FIN
get:baprocess
get:baFIN-WAIT-
get:baIn addi
get:bathe ret
get:baacknowl
get:baCLOSE-WAI
get:baDo the 
get:baCLOSING S
get:baIn addi
get:bathe ACK
get:baotherwi
get:baLAST-ACK 
get:baThe onl
get:baacknowl
get:badelete 
get:baTIME-WAIT
get:baThe onl
get:baretrans
get:bathe 2 M
get:basixth, check 
get:baESTABLISHED
get:baFIN-WAIT-1 
get:baFIN-WAIT-2 
get:baIf the UR
get:bathe user 
get:bapointer (
get:bauser has 
get:bamode") fo
get:basignal th
get:baTransmission Cont
get:baFunctional Specif
get:baCLOSE-WAIT 
get:baCLOSING STA
get:baLAST-ACK ST
get:baThis shou
get:baremote si
get:baseventh, proc
get:baESTABLISHED
get:baFIN-WAIT-1 
get:baFIN-WAIT-2 
get:baOnce in t
get:batext to u
get:bainto buff
get:baempty.  I
get:bathe user 
get:bahas been 
get:baWhen the 
get:bauser it m
get:baOnce the 
get:baRCV.NXT o
get:baapporopri
get:baRCV.NXT a
get:baPlease no
get:baSend an a:cknowledgment of the form
get:ba<SEQ=SN
get:baThis ackn
get:batransmitt
get:ba[Page 74]        
get:baSeptember 1981   
get:baCLOSE-WAIT 
get:baCLOSING STA
get:baLAST-ACK ST
get:baTIME-WAIT S
get:baThis shou
get:baremote si
get:baeighth, check
get:baDo not proc
get:basince the S
get:baIf the FIN 
get:bareturn any 
get:baover the FI
get:baFIN implies
get:baSYN-RECEI
get:baESTABLISH
get:baEnter t
get:baFIN-WAIT-
get:baIf our 
get:baenter T
get:batimers;
get:baFIN-WAIT-
get:baEnter t
get:baoff the
get:baCLOSE-WAI
get:baRemain 
get:baCLOSING S
get:baRemain 
get:baLAST-ACK 
get:baRemain 
get:baTransmission Cont
get:baFunctional Specif
get:baTIME-WAIT
get:baRemain 
get:batimeout
get:ba[Page 76]        
get:baSeptember 1981   
get:baFor any state
get:bathe user "err:or
get:baand for any o
get:bastate and ret
get:baRETRANSMISSION 
get:baFor any state
get:bathe retransmi
get:baretransmissio
get:baTIME-WAIT TIMEO
get:baIf the time-w
get:baenter the CLO
get:baTransmission Cont
get:ba[Page 78]        
get:baSeptember 1981   
get:baBBN Rep
get:baa Host 
get:bahost an
get:baA contr
get:baindicat
get:baspecifi
get:bais expe
get:bapreviou
get:baThe uni
get:baARPANET
get:baA unit 
get:baIMPs.  
get:baA logic
get:baA messa
get:banetwork
get:baDestination Addre
get:baThe des
get:baidentif
get:baA contr
get:baindicat
get:baoccupyi
get:baA porti
get:bafragmen
get:baA file 
get:baTransmission Cont
get:baControl
get:bafragmen
get:baA compu
get:bafrom th
get:baAn Inte
get:baby the 
get:baThe Int
get:baARPANET
get:baA sourc
get:bainternet datagram
get:baThe uni
get:bahigher 
get:bainternet fragment
get:baA porti
get:baheader.
get:baInterne
get:baThe Ini
get:banumber 
get:baThe Ini
get:baon a co
get:babased p
get:baThe Ini
get:baused by
get:baControl
get:badata.  
get:baon an A
get:ba[Page 80]        
get:baSeptember 1981   
get:baThis is
get:badata re
get:basequenc
get:baof the 
get:baThe uni
get:baAn impl
get:baprocedu
get:baMaximum
get:bathe int
get:baAn eigh
get:baAn Opti
get:bamay be 
get:baprimari
get:batimesta
get:baoptions
get:baA packa
get:balogical
get:balogical
get:baThe por
get:baoutput 
get:baA progr
get:bathe poi
get:baA contr
get:bathis se
get:bareceivi
get:bareceive
get:baTransmission Cont
get:bareceive
get:RFC
get:De
get:I
get:September 1981   
get:PREFACE .....
get:1.  INTRODUCTION 
get:1.1  Motivation
get:1.2  Scope ....
get:1.3  About This
get:1.4  Interfaces
get:1.5  Operation 
get:2.  PHILOSOPHY ..
get:2.1  Elements o
get:2.2  Model of O
get:2.3  The Host E
get:2.4  Interfaces
get:2.5  Relation t
get:2.6  Reliable C
get:2.7  Connection
get:2.8  Data Commu
get:2.9  Precedence
get:2.10 Robustness
get:3.  FUNCTIONAL SP
get:3.1  Header For
get:3.2  Terminolog
get:3.3  Sequence N
get:3.4  Establishi
get:3.5  Closing a 
get:3.6  Precedence
get:3.7  Data Commu
get:3.8  Interfaces
get:3.9  Event Proc
get:GLOSSARY ........
get:REFERENCES ......
get:Transmission Cont
get:[Page ii]        
get:September 1981   
get:This document des
get:(TCP).  There hav
get:specification on 
get:draws heavily fro
get:both in terms of 
get:several details a
get:and redescribes t
get:RFC
get:Replaces: RFC 761
get:IENs:  129, 124, 
get:55, 44, 40, 27, 2
get:The Transmission 
get:reliable host-to-
get:communication net
get:This document des
get:Transmission Cont
get:interface to prog
get:Computer commun
get:role in militar
get:document focuse
get:communication r
get:communication u
get:congestion, but
get:government sect
get:As strategic an
get:developed and d
get:interconnecting
get:communication p
get:applications.  
get:Deputy Undersec
get:declared the Tr
get:be a basis for 
get:standardization
get:TCP is a connec
get:fit into a laye
get:applications.  
get:communication b
get:distinct but in
get:assumptions are
get:protocols below
get:potentially unr
get:protocols.  In 
get:wide spectrum o
get:connections to 
get:Transmission Cont
get:TCP is based on
get:TCP fits into a
get:Internet Protoc
get:receive variabl
get:datagram "envel
get:addressing sour
get:internet protoc
get:the TCP segment
get:multiple networ
get:also carries in
get:and compartment
get:communicated en
get:Much of this do
get:which are co-re
get:computer.  Some
get:front-end compu
get:as well as netw
get:an interface to
get:implementable e
get:host-to-front e
get:The TCP is inte
get:communication s
get:intended to be 
get:1.3.  About this 
get:This document r
get:any TCP impleme
get:protocols and i
get:[Page 2]         
get:September 1981   
get:section offers 
get:operation.  Sec
get:design.  Sectio
get:required of TCP
get:user calls, err
get:The TCP interfa
get:the other side 
get:The interface b
get:illustrated in 
get:calls much like
get:application pro
get:calls to open a
get:established con
get:asynchronously 
get:considerable fr
get:interfaces whic
get:environment, a 
get:interface for a
get:The interface b
get:unspecified exc
get:two levels can 
get:Typically, one 
get:interface.  TCP
get:interconnected 
get:throughout this
get:As noted above,
get:securable logic
get:processes.  To 
get:communication s:ystem requires facilities in the following areas
get:Basic Data Tr
get:Precedence an
get:The basic opera
get:the following p
get:Transmission Cont
get:Basic Data Tran:sfer
get:The TCP is ab
get:direction bet
get:segments for 
get:the TCPs deci
get:Sometimes use
get:submitted to 
get:function is d
get:actually tran
get:pushed throug
get:promptly forw
get:The exact pus
get:the push func
get:Reliability
get:The TCP must 
get:delivered out
get:is achieved b
get:transmitted, 
get:receiving TCP
get:interval, the
get:numbers are u
get:out of order 
get:adding a chec
get:receiver, and
get:As long as th
get:system does n
get:errors will a
get:internet comm
get:Flow Control
get:TCP provides 
get:sent by the s
get:every ACK ind
get:the last segm
get:allowed numbe
get:receiving fur
get:[Page 4]         
get:September 1981   
get:Multiplexing
get:To allow for 
get:communication
get:addresses or 
get:and host addr
get:a socket.  A 
get:That is, a so
get:The binding o
get:Host.  Howeve
get:(e.g., a "log
get:made known to
get:through the k
get:addresses of 
get:Connections
get:The reliabili
get:that TCPs ini
get:each data str
get:sockets, sequ
get:Each connecti
get:identifying i
get:When two proc
get:establish a c
get:side).  When 
get:terminated or
get:Since connect
get:over the unre
get:mechanism wit
get:erroneous ini
get:Precedence and :Security
get:The users of 
get:communication
get:these feature
get:Transmission Cont
get:[Page 6]         
get:September 1981   
get:2.1.  Elements of
get:The internetwor
get:which are in tu
get:that the networ
get:large networks 
get:packet switchin
get:consume message
get:networks, the g
get:communication s
get:connections bet
get:The term packet
get:transaction bet
get:exchanged withi
get:Hosts are compu
get:network's point
get:Processes are v
get:accordance with
get:in execution). 
get:viewed as commu
get:Thus, all commu
get:Since a process
get:streams between
get:that each proce
get:communicates wi
get:2.2.  Model of Op
get:Processes trans
get:data as argumen
get:segments and ca
get:the destination
get:into the receiv
get:TCPs include co
get:ensure reliable
get:The model of in
get:protocol module
get:to the local ne
get:inside internet
get:internet module
get:through the loc
get:The packet swit
get:Transmission Cont
get:other operation
get:destination int
get:At a gateway be
get:from its local 
get:the internet da
get:then "wrapped" 
get:routed to the n
get:A gateway is pe
get:internet datagr
get:through the nex
get:internet datagr
get:further broken 
get:internet datagr
get:internet module
get:A destination i
get:(after reassemb
get:destination TCP
get:This simple mod
get:important featu
get:to the gateway 
get:service paramet
get:Included in the
get:datagram.  Data
get:host and gatewa
get:properly segreg
get:2.3.  The Host En
get:The TCP is assu
get:access the TCP 
get:may call on oth
get:data structures
get:controlled by a
get:network device 
get:datagram protoc
get:The mechanisms 
get:front-end proce
get:host-to-front-e
get:the type of TCP
get:[Page 8]         
get:September 1981   
get:The TCP/user in
get:to OPEN or CLOS
get:STATUS about a 
get:programs on the
get:from, and close
get:The TCP/interne
get:datagrams addre
get:system.  These 
get:service, preced
get:2.5.  Relation to
get:The following d
get:hierarchy
get:+------+ +
get:|Telnet| |
get:+------+ +
get:|   
get:+----
get:| TCP
get:+----
get:| 
get:+----
get:|    
get:+----
get:+--
get:|  
get:+--
get:It is expected 
get:protocols effic
get:protocols like 
get:2.6.  Reliable Co
get:A stream of dat
get:order at the de
get:Transmission Cont
get:Transmission is
get:acknowledgments
get:sequence number
get:segment is tran
get:sequence number
get:is the sequence
get:transmissions i
get:segment contain
get:starts a timer;
get:segment is dele
get:received before
get:An acknowledgme
get:delivered to th
get:the responsibil
get:To govern the f
get:employed.  The 
get:This window spe
get:acknowledgment 
get:2.7.  Connection 
get:To identify the
get:provides a port
get:independently b
get:unique addresse
get:identifying the
get:will be unique 
get:A connection is
get:local socket ma
get:sockets.  A con
get:that is, it is 
get:TCPs are free t
get:However, severa
get:There must be w
get:the "appropriat
get:may "own" ports
get:the ports they 
get:issue, but we e
get:uniquely alloca
get:associating the
get:A connection is
get:foreign socket 
get:[Page 10]        
get:September 1981   
get:connection name
get:subsequent call
get:about a connect
get:is a data struc
get:implementation 
get:pointer to the 
get:whether the con
get:be passively wa
get:A passive OPEN 
get:connection requ
get:Often the proce
get:request from an
get:is used to deno
get:are allowed onl
get:A service proce
get:processes would
get:foreign socket.
get:requested a con
get:local socket we
get:Well-known sock
get:a socket addres
get:"Telnet-Server"
get:socket, and oth
get:Entry, Text Gen
get:being for test 
get:access to a "Lo
get:at which a newl
get:well-known sock
get:of sockets to s
get:Processes can i
get:from other proc
get:been establishe
get:other at the sa
get:is critical for
get:components act 
get:There are two p
get:passive OPENs a
get:local passive O
get:case, the match
get:OPENs has left 
get:foreign socket 
get:Other possibili
get:Transmission Cont
get:If there are se
get:same local sock
get:with the specif
get:TCB exists, bef
get:The procedures 
get:control flag an
get:exchange has be
get:A connection is
get:containing a SY
get:command.  The m
get:connection has 
get:when sequence n
get:The clearing of
get:in this case ca
get:2.8.  Data Commun
get:The data that f
get:octets.  The se
get:in that call (a
get:through to the 
get:A sending TCP i
get:send that data 
get:function is sig
get:receiving TCP s
get:the sending TCP
get:There is no nec
get:boundaries.  Th
get:single SEND cal
get:The purpose of 
get:from the sendin
get:record service.
get:There is a coup
get:of data that cr
get:associated with
get:buffer is retur
get:not filled.  If
get:PUSH is seen, t
get:TCP also provid
get:at some point f
get:[Page 12]        
get:September 1981   
get:currently readi
get:define what the
get:urgent data, bu
get:take action to 
get:2.9.  Precedence 
get:The TCP makes u
get:security option
get:basis to TCP us
get:a multilevel se
get:use only, and o
get:compartment.  C
get:users may be li
get:TCP modules whi
get:properly mark o
get:precedence.  Su
get:higher level pr
get:them to specify
get:precedence of c
get:2.10.  Robustness
get:TCP implementat:ions will follow a general principle of robustness
get:conservative in
get:Transmission Cont
get:[Page 14]        
get:September 1981   
get:3.1.  Header Form
get:TCP segments ar
get:header carries 
get:destination hos
get:header, supplyi
get:division allows
get:TCP Header Form
get:0            
get:0 1 2 3 4 5 6
get:+-+-+-+-+-+-+-
get:|          Sou
get:+-+-+-+-+-+-+-
get:|             
get:+-+-+-+-+-+-+-
get:|             
get:+-+-+-+-+-+-+-
get:|  Data |     
get:| Offset| Rese
get:|       |     
get:+-+-+-+-+-+-+-
get:|           Ch
get:+-+-+-+-+-+-+-
get:|             
get:+-+-+-+-+-+-+-
get:|             
get:+-+-+-+-+-+-+-
get:Note th
get:Source Port:  1
get:The source po
get:Destination Por:t
get:The destinati
get:Transmission Cont
get:Functional Specif
get:Sequence Number:
get:The sequence 
get:when SYN is p
get:initial seque
get:Acknowledgment :Number
get:If the ACK co
get:next sequence
get:receive.  Onc
get:Data Offset:  4
get:The number of
get:the data begi
get:integral numb
get:Reserved:  6 bi
get:Reserved for 
get:Control Bits:  :6 bits (from left to right)
get:URG:  Urgent 
get:ACK:  Acknowl
get:PSH:  Push Fu
get:RST:  Reset t
get:SYN:  Synchro
get:FIN:  No more
get:Window:  16 bit
get:The number of
get:acknowledgmen
get:Checksum:  16 b
get:The checksum 
get:complement su
get:segment conta
get:checksummed, 
get:form a 16 bit
get:transmitted a
get:the checksum 
get:The checksum 
get:[Page 16]        
get:September 1981   
get:prefixed to t
get:Address, the 
get:This gives th
get:information i
get:across the TC
get:calls by the 
get:The TCP Len
get:octets (thi
get:computed), 
get:Urgent Pointer:
get:This field co
get:positive offs
get:urgent pointe
get:the urgent da
get:the URG contr
get:Options:  varia
get:Options may o
get:multiple of 8
get:checksum.  An
get:cases for the: format of an option
get:Case 1:  A 
get:Case 2:  An
get:th
get:The option-le
get:option-length
get:Note that the
get:field might i
get:End-of-Option
get:A TCP must im
get:Transmission Cont
get:Functional Specif
get:Currently def:ined options include (kind indicated in octal)
get:Kind     Le
get:----     --
get:0         
get:1         
get:2         
get:Specific Opti
get:End of Opti
get:+--------
get:|00000000
get:+--------
get:This opti
get:might not
get:the Data 
get:not the e
get:the optio
get:No-Operatio
get:+--------
get:|00000001
get:+--------
get:This opti
get:align the
get:There is 
get:receivers
get:not begin
get:Maximum Seg
get:+--------
get:|00000010
get:+--------
get:Kind=2  
get:[Page 18]        
get:September 1981   
get:Maximum S:egment Size Option Data
get:If this
get:receive
get:This fi
get:(i.e., 
get:option 
get:Padding:  varia
get:The TCP heade
get:and data begi
get:3.2.  Terminology
get:Before we can d
get:to introduce so
get:connection requ
get:of these variab
get:Transmission Co
get:TCB are the loc
get:precedence of t
get:buffers, pointe
get:In addition sev
get:sequence number
get:Send Sequence
get:SND.UNA - s
get:SND.NXT - s
get:SND.WND - s
get:SND.UP  - s
get:SND.WL1 - s
get:SND.WL2 - s
get:u
get:ISS     - i
get:Receive Seque
get:RCV.NXT - r
get:RCV.WND - r
get:RCV.UP  - r
get:IRS     - i
get:Transmission Cont
get:Functional Specif
get:The following d
get:the sequence sp
get:Send Sequence S
get:---
get:1 - old s
get:2 - seque
get:3 - seque
get:4 - futur
get:The send window
get:Receive Sequenc
get:1 - old s
get:2 - seque
get:3 - futur
get:The receive win
get:There are also 
get:take their valu
get:[Page 20]        
get:September 1981   
get:Current Segme
get:SEG.SEQ - s
get:SEG.ACK - s
get:SEG.LEN - s
get:SEG.WND - s
get:SEG.UP  - s
get:SEG.PRC - s
get:A connection pr
get:lifetime.  The :states are
get:ESTABLISHED, FI
get:TIME-WAIT, and 
get:because it repr
get:no connection. : Briefly the meanings of the states are
get:LISTEN - repr
get:TCP and port.
get:SYN-SENT - re
get:after having 
get:SYN-RECEIVED 
get:request ackno
get:connection re
get:ESTABLISHED -
get:delivered to 
get:of the connec
get:FIN-WAIT-1 - 
get:from the remo
get:termination r
get:FIN-WAIT-2 - 
get:from the remo
get:CLOSE-WAIT - 
get:from the loca
get:CLOSING - rep
get:acknowledgmen
get:LAST-ACK - re
get:connection te
get:(which includ
get:Transmission Cont
get:Functional Specif
get:TIME-WAIT - r
get:the remote TC
get:termination r
get:CLOSED - repr
get:A TCP connectio
get:events.  The ev
get:ABORT, and STAT
get:containing the 
get:The state diagr
get:with the causin
get:error condition
get:changes.  In a 
get:the reaction of
get:NOTE BENE:  thi
get:the total speci
get:[Page 22]        
get:September 1981   
get:+---------+     
get:|         |<----
get:|   SYN   |     
get:|   RCVD  |<----
get:|         |     
get:|         |-----
get:+---------+   rc
get:|           --
get:|             
get:|             
get:|  CLOSE      
get:| -------     
get:| snd FIN     
get:|             
get:V             
get:+---------+     
get:|  FIN    |<----
get:| WAIT-1  |-----
get:+---------+     
get:| rcv ACK of F
get:| ------------
get:V        x    
get:+---------+     
get:|FINWAIT-2|     
get:+---------+     
get:|             
get:|  rcv FIN    
get:|  -------    
get:\ snd ACK    
get:------------
get:Transmission Cont
get:Functional Specif
get:3.3.  Sequence Nu
get:A fundamental n
get:over a TCP conn
get:sequenced, each
get:mechanism emplo
get:number X indica
get:received.  This
get:detection in th
get:within a segmen
get:the header is t
get:numbered consec
get:It is essential
get:finite, though 
get:Since the space
get:numbers must be
get:preserves the r
get:2**32 - 1 to 0 
get:arithmetic, so 
get:comparison of s
get:(modulo 2**32).
get:The typical kin
get:perform include:
get:(a)  Determin
get:number s
get:(b)  Determin
get:have bee
get:retransm
get:(c)  Determin
get:which ar
get:receive 
get:[Page 24]        
get:September 1981   
get:In response to 
get:following compa
get:SND.UNA = old
get:SND.NXT = nex
get:SEG.ACK = ack
get:num
get:SEG.SEQ = fir
get:SEG.LEN = the
get:(co
get:SEG.SEQ+SEG.L
get:A new acknowled
get:the inequality :below holds
get:SND.UNA < SEG
get:A segment on th
get:of its sequence
get:acknowledgment 
get:When data is re:ceived the following comparisons are needed
get:RCV.NXT = nex
get:is the le
get:RCV.NXT+RCV.W
get:segment, 
get:SEG.SEQ = fir
get:SEG.SEQ+SEG.L
get:A segment is ju
get:RCV.NXT =< SE
get:RCV.NXT =< SE
get:Transmission Cont
get:Functional Specif
get:The first part 
get:segment falls i
get:if the end of t
get:either part of 
get:Actually, it is
get:windows and zer
get:acceptability o:f an incoming segment
get:Segment Recei
get:Length  Windo
get:------- -----
get:0       0 
get:0      >0 
get:>0       0 
get:>0      >0 
get:Note that when 
get:acceptable exce
get:maintain a zero
get:ACKs.  However,
get:process the RST
get:We have taken a
get:control informa
get:some control fl
get:and acknowledge
get:control will be
get:carried in the 
get:for implicitly 
get:are the only co
get:are used only a
get:purposes, the S
get:octet of the se
get:to occur after 
get:occurs.  The se
get:space occupying
get:sequence number
get:[Page 26]        
get:September 1981   
get:Initial Sequenc
get:The protocol pl
get:used over and o
get:sockets.  New i
get:incarnations of
get:-- "how does th
get:incarnations of
get:connection is b
get:connection brea
get:To avoid confus
get:connection from
get:be present in t
get:assure this, ev
get:sequence number
get:an initial sequ
get:new 32 bit ISN.
get:bit clock whose
get:microseconds.  
get:Since we assume
get:the Maximum Seg
get:hours we can re
get:For each connec
get:sequence number
get:the data sendin
get:learned during 
get:For a connectio
get:synchronize on 
get:an exchange of 
get:called "SYN" (f
get:shorthand, segm
get:Hence, the solu
get:initial sequenc
get:The synchroniza
get:sequence number
get:from the other 
get:initial sequenc
get:1) A --> B  S
get:2) A <-- B  A
get:3) A <-- B  S
get:4) A --> B  A
get:Transmission Cont
get:Functional Specif
get:Because steps 2
get:called the thre
get:A three way han
get:tied to a globa
get:mechanisms for 
get:no way of knowi
get:unless it remem
get:(which is not a
get:verify this SYN
get:clock-driven sc
get:Knowing When to
get:To be sure that
get:sequence number
get:the network, th
get:(MSL) before as
get:recovering from
get:lost.  For this
get:is an engineeri
get:it is desirable
get:sense, yet reta
get:not wait at all
get:than those rece
get:The TCP Quiet T
get:This specific
get:retaining any
get:each active (
get:TCP segments 
get:in the intern
get:paragraphs be
get:TCP implement
get:at the risk o
get:data rejected
get:TCPs consume 
get:entered into 
get:duplicate det
get:relies on the
get:the extent th
get:values before
get:been delivere
get:copies of the
get:such an assum
get:[Page 28]        
get:September 1981   
get:assigned the 
get:at the receiv
get:that each seg
get:as there are 
get:Under normal 
get:to emit and t
get:mistakenly us
get:been acknowle
get:data is drain
get:very large to
get:cause trouble
get:to use up 2**
get:lifetime in t
get:this is deeme
get:rates escalat
get:cycle time is
get:within reason
get:The basic dup
get:defeated, how
get:sequence numb
get:the TCP were 
get:upon crashing
get:connection (p
get:packets with 
get:packets still
get:incarnation o
get:about the seq
get:specification
get:before emitti
get:segments from
get:Even hosts wh
get:initial seque
get:(i.e., even i
get:number for ea
get:Suppose, for 
get:sequence numb
get:and that even
get:takes on a va
get:segment sent 
get:at this insta
get:incarnation o
get:S1 = ISN(t) -
get:connection!  
get:Transmission Cont
get:Functional Specif
get:duplicates in
get:of S1 may arr
get:the new incar
get:The problem i
get:crashed nor d
get:the system fr
get:One way to de
get:segments for 
get:time" specifi
get:willing to ri
get:destination m
get:Implementors 
get:connection by
get:informally im
get:Obviously, ev
get:necessary aft
get:To summarize:
get:numbers in th
get:"busy" or "in
get:block of spac
get:segment, if a
get:sequence numb
get:the previous 
get:number overla
get:3.4.  Establishin
get:The "three-way 
get:connection.  Th
get:responded to by
get:simultaneously 
get:occurs, each TC
get:acknowledgment 
get:an old duplicat
get:recipient, that
get:Proper use of "
get:Several example
get:examples do not
get:segments, this 
get:doesn't deliver
get:valid (i.e., th
get:connection reac
get:reduces the pos
get:[Page 30]        
get:September 1981   
get:implementation 
get:information for
get:The simplest th
get:figures should 
get:numbered for re
get:departure of a 
get:segment at B fr
get:Ellipsis (...) 
get:(delayed).  An 
get:Comments appear
get:the departure o
get:the center of e
get:form, with sequ
get:fields such as 
get:in the interest
get:TCP A      
get:1.  CLOSED     
get:2.  SYN-SENT   
get:3.  ESTABLISHED
get:4.  ESTABLISHED
get:5.  ESTABLISHED
get:Basic 3
get:In line 2 of fi
get:indicating that
get:number 100.  In
get:received from T
get:B is now expect
get:occupied sequen
get:At line 4, TCP 
get:TCP B's SYN; an
get:sequence number
get:because the ACK
get:would wind up A
get:Transmission Cont
get:Functional Specif
get:Simultaneous in
get:figure 8.  Each
get:TCP A      
get:1.  CLOSED     
get:2.  SYN-SENT   
get:3.  SYN-RECEIVE
get:4.             
get:5.  SYN-RECEIVE
get:6.  ESTABLISHED
get:7.             
get:S
get:The principle r
get:duplicate conne
get:this, a special
get:receiving TCP i
get:SYN-RECEIVED), 
get:If the TCP is i
get:FIN-WAIT-1, FIN
get:aborts the conn
get:case under "hal
get:[Page 32]        
get:September 1981   
get:TCP A      
get:1.  CLOSED     
get:2.  SYN-SENT   
get:3.  (duplicate)
get:4.  SYN-SENT   
get:5.  SYN-SENT   
get:6.             
get:7.  SYN-SENT   
get:8.  ESTABLISHED
get:As a simple exa
get:figure 9.  At l
get:cannot tell tha
get:(line 4).  TCP 
get:RST (reset) wit
get:believable.  TC
get:When the origin
get:synchronization
get:before the RST,
get:sent in both di
get:Half-Open Conne
get:An established 
get:TCPs has closed
get:knowledge of th
get:become desynchr
get:memory.  Such c
get:attempt is made
get:connections are
get:mildly involved
get:If at site A th
get:Transmission Cont
get:Functional Specif
get:user at site B 
get:receiving a res
get:site B TCP that
get:Assume that two
get:another when a 
get:Depending on th
get:that some error
get:A is likely to 
get:point.  As a re
get:or try to SEND 
get:case, it receiv
get:local (A's) TCP
get:will send a seg
get:example shown i
get:re-open the con
get:TCP A      
get:1.  (CRASH)    
get:2.  CLOSED     
get:3.  SYN-SENT --
get:4.  (!!)     <-
get:5.  SYN-SENT --
get:6.  SYN-SENT   
get:7.  SYN-SENT --
get:When the SYN ar
get:and the incomin
get:acknowledgment 
get:100).  TCP A se
get:sent and, being
get:detected a half
get:[Page 34]        
get:September 1981   
get:continue to try
get:reduced to the 
get:An interesting 
get:tries to send d
get:This is illustr
get:TCP A from TCP 
get:exists, so TCP 
get:processes it an
get:TCP A    
get:1.  (CRASH)    
get:2.  (??)    <--
get:3.          -->
get:Active
get:In figure 12, w
get:waiting for SYN
get:into action.  A
get:generate a RST 
get:the reset and r
get:TCP A      
get:1.  LISTEN     
get:2.       ... <S
get:3.  (??) <-- <S
get:4.       --> <S
get:5.  LISTEN     
get:Old Duplic
get:Transmission Cont
get:Functional Specif
get:A variety of ot
get:by the followin
get:Reset Generatio
get:As a general ru
get:which apparentl
get:must not be sen
get:There are three: groups of states
get:1.  If the co
get:in response t
get:particular, S
get:by this means
get:If the incomi
get:sequence numb
get:reset has seq
get:of the sequen
get:The connectio
get:2.  If the co
get:SYN-SENT, SYN
get:something not
get:if an incomin
get:does not exac
get:connection, a
get:If our SYN ha
get:incoming segm
get:either raise 
get:the system) o
get:incoming segm
get:continue as i
get:cannot raise 
get:detected in t
get:terminated th
get:incoming segm
get:match the loc
get:must be sent.
get:If the incomi
get:sequence numb
get:reset has seq
get:of the sequen
get:The connectio
get:[Page 36]        
get:September 1981   
get:3.  If the co
get:FIN-WAIT-1, F
get:any unaccepta
get:unacceptible 
get:acknowledgmen
get:and an acknow
get:to be receive
get:If an incomin
get:precedence wh
get:and precedenc
get:connection go
get:number from t
get:Reset Processin
get:In all states e
get:by checking the
get:is in the windo
get:to an initial S
get:acknowledges th
get:The receiver of
get:receiver was in
get:in SYN-RECEIVED
get:then the receiv
get:aborts the conn
get:was in any othe
get:and goes to the
get:3.5.  Closing a C
get:CLOSE is an ope
get:notion of closi
get:interpretation,
get:the receiving s
get:in a simplex fa
get:until he is tol
get:could initiate 
get:RECEIVE until s
get:has CLOSED.  We
get:RECEIVEs are ou
get:can terminate h
get:buffers SENT be
get:data in return 
get:successfully to
get:TCP.  Users mus
get:the TCP says no
get:Transmission Cont
get:Functional Specif
get:There are essen:tially three cases
get:1) The user i
get:2) The remote
get:3) Both users
get:Case 1:  Local 
get:In this case,
get:outgoing segm
get:accepted by t
get:are allowed i
get:will be retra
get:both acknowle
get:can ACK this 
get:send its own 
get:Case 2:  TCP re
get:If an unsolic
get:can ACK it an
get:user will res
get:the other TCP
get:until its own
get:connection.  
get:the connectio
get:Case 3:  both u
get:A simultaneou
get:FIN segments 
get:have been pro
get:has received.
get:[Page 38]        
get:September 1981   
get:TCP A      
get:1.  ESTABLISHED
get:FIN-WAIT-1 
get:3.  FIN-WAIT-2 
get:4.             
get:TIME-WAIT  
get:5.  TIME-WAIT  
get:CLOSED     
get:TCP A      
get:1.  ESTABLISHED
get:2.  (Close)    
get:FIN-WAIT-1 
get:3.  CLOSING    
get:4.  TIME-WAIT  
get:(2 MSL)    
get:CLOSED     
get:Transmission Cont
get:Functional Specif
get:3.6.  Precedence 
get:The intent is t
get:with exactly th
get:higher of the p
get:The precedence 
get:defined in the 
get:specification t
get:the security pa
get:user group, and
get:A connection at
get:lower precedenc
get:a connection du
get:acknowledgment 
get:Note that TCP m
get:precedence will
get:segments and po
get:The security pa
get:(the values wou
get:non-secure envi
get:parameters, tho
get:3.7.  Data Commun
get:Once the connec
get:exchange of seg
get:(checksum test 
get:retransmission 
get:Duplicate segme
get:As discussed in
get:certain tests o
get:segments to ver
get:The sender of d
get:the variable SN
get:sequence number
get:keeps track of 
get:variable SND.UN
get:sent has been a
get:When the sender
get:SND.NXT.  When 
get:sends an acknow
get:[Page 40]        
get:September 1981   
get:acknowledgment 
get:these variables
get:The amount by w
get:data in the seg
get:segments must c
get:The CLOSE user 
get:flag in an inco
get:Retransmission 
get:Because of the 
get:internetwork sy
get:retransmission 
get:for determining
get:An Example Re
get:Measure the
get:particular 
get:covers that
get:segments re
get:Time (RTT).:  Next compute a Smoothed Round Trip Time (SRTT) as
get:SRTT = ( 
get:and based o:n this, compute the retransmission timeout (RTO) as
get:RTO = min
get:where UBOUN
get:LBOUND is a
get:a smoothing
get:factor (e.g
get:The Communicati
get:The objective o
get:to stimulate th
get:permit the rece
get:the currently k
get:This mechanism 
get:the end of urge
get:the receive seq
get:must tell the u
get:number catches 
get:Transmission Cont
get:Functional Specif
get:into "normal mo
get:is in "urgent m
get:The method empl
get:transmitted.  T
get:meaningful and 
get:the urgent poin
get:no urgent data 
get:To send an urge
get:octet.  If the 
get:the urgent info
get:Managing the Wi
get:The window sent
get:numbers the sen
get:prepared to acc
get:the currently a
get:Indicating a la
get:arrives than ca
get:in excessive re
get:network and the
get:transmission of
get:between each ne
get:The mechanisms 
get:subsequently ad
get:that much data.
get:discouraged.  T
get:shrink the wind
get:on the part of 
get:The sending TCP
get:least one octet
get:sending TCP mus
get:the window is z
get:interval when t
get:guarantee that 
get:window will be 
get:When the receiv
get:still send an a
get:and current win
get:The sending TCP
get:[Page 42]        
get:September 1981   
get:which fit the c
get:retransmission 
get:In a connection
get:be carried in a
get:number so there
get:order.  This is
get:information to 
get:the data receiv
get:the window info
get:acknowledgment 
get:equal or greate
get:The window mana
get:communication p
get:Window Manage
get:Allocating 
get:many small 
get:fewer large
get:One suggest
get:defer updat
get:least X per
get:connection 
get:Another sug
get:segments by
get:sending dat
get:data must b
get:Note that t
get:retransmiss
get:acknowledgm
get:window info
get:new window 
get:The segment
get:of transmit
get:segment con
get:is accepted
get:If the send
get:window is n
get:alternating
get:pauses in t
get:Transmission Cont
get:Functional Specif
get:result in b
get:big pair. A
get:mostly smal
get:The suggest
get:actively at
get:windows, si
get:to many sma
get:There are of co:urse two interfaces of concern
get:and the TCP/low
get:of the user/TCP
get:protocol module
get:in detail by th
get:case that the l
get:that TCPs might
get:User/TCP Interf
get:The following
get:at best, fict
get:facilities.  
get:implementatio
get:TCPs must pro
get:that all TCP 
get:hierarchy.  T
get:required of a
get:TCP User Comm
get:The followi
get:interface. 
get:function ca
get:meant to ru
get:The user co
get:TCP must pe
get:Individual 
get:may provide
get:single call
get:automatical
get:issued by t
get:[Page 44]        
get:September 1981   
get:In providin
get:not only ac
get:processes i:t serves.  The latter consists of
get:(a) gener
get:remote cl
get:(b) repli
get:various t
get:Format:  
get:[, timeou
get:-> local 
get:We assume
get:processes
get:to use th
get:implement
get:for the s
get:lower lev
get:result of
get:able to m
get:process c
get:If the ac
get:call to L
get:have eith
get:particula
get:for any c
get:by the su
get:A transmi
get:filled in
get:On an act
get:synchroni
get:The timeo
get:for all d
get:delivered
get:will abor
get:The TCP o
get:the users
get:Transmission Cont
get:Functional Specif
get:precedenc
get:or securi
get:the defau
get:TCP will 
get:security/
get:the prece
get:requested
get:The prece
get:requested
get:request, 
get:connectio
get:this prec
get:allowed t
get:or that a
get:A local c
get:The local
get:for the c
get:Format:  
get:count, PU
get:This call
get:to be sen
get:not been 
get:implement
get:automatic
get:authorize
get:If the PU
get:to the re
get:segment c
get:the data 
get:transmiss
get:If the UR
get:will have
get:the urgen
get:pointer i
get:been cons
get:is to sti
get:indicate 
get:[Page 46]        
get:September 1981   
get:data has 
get:TCP signa
get:of times 
get:urgent da
get:If no for
get:connectio
get:has becom
get:local soc
get:foreign s
get:foreign s
get:knowing t
get:However, 
get:becomes s
get:STATUS ca
get:implement
get:socket is
get:If a time
get:connectio
get:In the si
get:the sendi
get:or the ti
get:is both s
get:connectio
get:offers po
get:sophistic
get:the proce
get:furthermo
get:Multiple 
get:the TCP w
get:We have i
get:which a S
get:pseudo-in
get:return a 
get:immediate
get:been ackn
get:assume ev
get:close any
get:kind (syn
get:signals, 
get:with spec
get:In order 
get:indicatio
get:Transmission Cont
get:Functional Specif
get:buffer ad
get:the SEND 
get:indicatin
get:calling p
get:Format:  
get:count) ->
get:This comm
get:specified
get:calling p
get:error is 
get:In the si
get:calling p
get:error occ
get:A more so
get:RECEIVEs 
get:segments 
get:the cost 
get:notify th
get:If enough
get:the PUSH 
get:The buffe
get:a PUSH is
get:returned 
get:If there 
get:as it arr
get:should th
get:additiona
get:call to R
get:may now l
get:urgent po
get:in the sa
get:boundary 
get:To distin
get:care of t
get:return co
get:count ind
get:Alternati
get:[Page 48]        
get:September 1981   
get:allocate 
get:with the 
get:Format:  
get:This comm
get:the conne
get:authorize
get:Closing c
get:the sense
get:retransmi
get:serviced.
get:calls, fo
get:to the de
get:continue 
get:may be tr
get:means "I 
get:receive a
get:not well 
get:of all it
get:into ABOR
get:The user 
get:initiativ
get:(e.g., re
get:destinati
get:Because c
get:foreign T
get:short tim
get:replies t
get:Close als
get:Format:  
get:This is a
get:excluded 
get:typically
get:This comm
get:informati:on
get:local s
get:Transmission Cont
get:Functional Specif
get:foreign
get:local c
get:receive
get:send wi
get:connect
get:number 
get:number 
get:urgent 
get:precede
get:securit
get:and tra
get:Depending
get:implement
get:available
get:authorize
get:prevents 
get:connectio
get:Format:  
get:This comm
get:aborted, 
get:be sent t
get:Depending
get:indicatio
get:receive a
get:TCP-to-User M
get:It is assum
get:means for t
get:the TCP doe
get:to the user
get:an error me
get:relating to
get:other user 
get:The followi:ng information is provided
get:Local Con
get:Response 
get:Buffer Ad
get:Byte coun
get:Push flag
get:Urgent fl
get:[Page 50]        
get:September 1981   
get:TCP/Lower-Level
get:The TCP calls
get:receive infor
get:internetwork 
get:Protocol (IP)
get:If the lower 
get:of service an
get:for these par:ameters
get:Type of Ser:vice = Precedence: routine, Delay: normal, Throughput
get:normal, Rel:iability
get:Time to Liv
get:Note that
get:Here we e
get:be delive
get:If the lower 
get:feature) and 
get:route informa
get:so that the s
get:checksum be t
get:also importan
get:Any lower lev
get:destination a
get:the "TCP leng
get:of IP and to 
get:Transmission Cont
get:Functional Specif
get:3.9.  Event Proce
get:The processing 
get:implementation.
get:processing sequ
get:section only in
get:The activity of
get:The events that: occur can be cast into three categories
get:arriving segmen
get:processing the 
get:cases the proce
get:Events that o:ccur
get:Arriving Se
get:SEGMENT A
get:USER TIME
get:RETRANSMI
get:TIME-WAIT
get:The model of th
get:immediate retur
get:pseudo interrup
get:means cause a d
get:Error responses
get:commands refere:ncing connections that do not exist receive "error
get:connection not 
get:Please note in 
get:acknowledgment 
get:of the sequence
get:equal to (modul
get:[Page 52]        
get:September 1981   
get:A natural way t
get:imagine that th
get:that their cont
get:in the sequence
get:and processed i
get:When a segment 
get:the segment to 
get:to be consisten
get:Note that if no
get:Transmission Cont
get:Functional Specif
get:CLOSED STATE 
get:Create a ne
get:state infor
get:socket, pre
get:information
get:unspecified
get:parameters 
get:precedence 
get:"error:  pr:ecedence not allowed" or "error
get:not allowed
get:active and :the foreign socket is unspecified, return "error
get:foreign soc
get:specified, 
get:(ISS) is se
get:is sent.  S
get:state, and 
get:If the call
get:return "err:or
get:no room to :create a new connection, return "error
get:resources".
get:If active a
get:connection 
get:segment, se
get:state.  Dat
get:queued for 
get:urgent bit 
get:segments se
get:queue the r:equest, respond with "error
get:If Foreign :socket was not specified, then return "error
get:socket unsp
get:[Page 54]        
get:September 1981   
get:SYN-SENT STAT
get:SYN-RECEIVED 
get:ESTABLISHED S
get:FIN-WAIT-1 ST
get:FIN-WAIT-2 ST
get:CLOSE-WAIT ST
get:CLOSING STATE
get:LAST-ACK STAT
get:TIME-WAIT STA
get:Return "err:or
get:Transmission Cont
get:Functional Specif
get:CLOSED STATE 
get:If the user
get:"error:  co
get:Otherwise, :return "error
get:If the fore
get:from passiv
get:SND.UNA to 
get:associated 
get:transmissio
get:requested i
get:as a result
get:request, re:spond with "error
get:Foreign soc:ket was not specified, then return "error
get:socket unsp
get:SYN-SENT STAT
get:SYN-RECEIVED 
get:Queue the d
get:If no space: to queue, respond with "error
get:resources".
get:ESTABLISHED S
get:CLOSE-WAIT ST
get:Segmentize 
get:acknowledgm
get:insufficien:t space to remember this buffer, simply return "error
get:insufficien
get:If the urge
get:urgent poin
get:[Page 56]        
get:September 1981   
get:FIN-WAIT-1 ST
get:FIN-WAIT-2 ST
get:CLOSING STATE
get:LAST-ACK STAT
get:TIME-WAIT STA
get:Return "err:or
get:Transmission Cont
get:Functional Specif
get:CLOSED STATE 
get:If the user
get:"error:  co
get:Otherwise r:eturn "error
get:SYN-SENT STAT
get:SYN-RECEIVED 
get:Queue for p
get:is no room :to queue this request, respond with "error
get:insufficien
get:ESTABLISHED S
get:FIN-WAIT-1 ST
get:FIN-WAIT-2 ST
get:If insuffic
get:request, qu
get:remember th:e RECEIVE, respond with "error
get:resources".
get:Reassemble 
get:to user.  M
get:If RCV.UP i
get:user notify
get:When the TC
get:that fact m
get:acknowledgm
get:described b
get:[Page 58]        
get:September 1981   
get:CLOSE-WAIT ST
get:Since the r
get:satisfied b
get:user.  If n
get:"error:  co
get:text can be
get:CLOSING STATE
get:LAST-ACK STAT
get:TIME-WAIT STA
get:Return "err:or
get:Transmission Cont
get:Functional Specif
get:CLOSED STATE 
get:If the user
get:"error:  co
get:Otherwise, :return "error
get:Any outstan:ding RECEIVEs are returned with "error
get:responses. 
get:SYN-SENT STAT
get:Delete the :TCB and return "error
get:queued SEND
get:SYN-RECEIVED 
get:If no SENDs
get:then form a
get:otherwise q
get:ESTABLISHED S
get:Queue this 
get:form a FIN 
get:FIN-WAIT-1 ST
get:FIN-WAIT-2 ST
get:Strictly sp:eaking, this is an error and should receive a "error
get:connection 
get:acceptable,
get:FIN may be 
get:[Page 60]        
get:September 1981   
get:CLOSE-WAIT ST
get:Queue this 
get:segmentized
get:CLOSING STATE
get:LAST-ACK STAT
get:TIME-WAIT STA
get:Respond wit:h "error
get:Transmission Cont
get:Functional Specif
get:CLOSED STATE 
get:If the user
get:"error:  co
get:Otherwise r:eturn "error
get:Any outstan:ding RECEIVEs should be returned with "error
get:connection 
get:SYN-SENT STAT
get:All queued 
get:notificatio
get:SYN-RECEIVED 
get:ESTABLISHED S
get:FIN-WAIT-1 ST
get:FIN-WAIT-2 ST
get:CLOSE-WAIT ST
get:Send a rese:t segment
get:<SEQ=SND.
get:All queued 
get:notificatio
get:RST formed 
get:TCB, enter 
get:CLOSING STATE
get:LAST-ACK STAT
get:TIME-WAIT STA
get:Respond wit
get:[Page 62]        
get:September 1981   
get:CLOSED STATE 
get:If the user
get:"error:  co
get:Otherwise r:eturn "error
get:Return "sta
get:SYN-SENT STAT
get:Return "sta
get:SYN-RECEIVED 
get:Return "sta
get:ESTABLISHED S
get:Return "sta
get:FIN-WAIT-1 ST
get:Return "sta
get:FIN-WAIT-2 ST
get:Return "sta
get:CLOSE-WAIT ST
get:Return "sta
get:CLOSING STATE
get:Return "sta
get:LAST-ACK STAT
get:Return "sta
get:Transmission Cont
get:Functional Specif
get:TIME-WAIT STA
get:Return "sta
get:[Page 64]        
get:September 1981   
get:SEGMENT ARRIVES
get:If the state 
get:all data in
get:segment con
get:containing 
get:acknowledgm
get:reset seque
get:If the ACK 
get:<SEQ=0><A
get:If the ACK 
get:<SEQ=SEG.
get:If the state 
get:first check
get:An incomi
get:second chec
get:Any ackno
get:the LISTE
get:for any a
get:formatted: as follows
get:<SEQ=SE
get:third check
get:If the SY
get:security/
get:match the
get:<SEQ=SE
get:Transmission Cont
get:Functional Specif
get:If the SE
get:the user 
get:send a re
get:<SEQ=SE
get:If the SE
get:Set RCV.N
get:control o
get:should be: selected and a SYN segment sent of the form
get:<SEQ=IS
get:SND.NXT i
get:state sho
get:incoming 
get:in the SY
get:not be re
get:the forei
get:unspecifi
get:fourth othe
get:Any other
get:must have
get:processin
get:it could 
get:incarnati
get:but if yo
get:If the state 
get:first check
get:If the AC
get:If SEG.
get:the RST
get:<SEQ=
get:and dis
get:If SND.
get:second chec
get:[Page 66]        
get:September 1981   
get:If the RS
get:If the :ACK was acceptable then signal the user "error
get:connect
get:delete 
get:and ret
get:third check
get:If the se
get:match the
get:If ther
get:<SEQ=
get:Otherwi
get:<SEQ=
get:If there 
get:The pre
get:TCB, if
get:<SEQ=
get:If there 
get:If the 
get:in the 
get:the pre
get:allowed
get:<SEQ=
get:If the 
get:in the 
get:If a rese
get:fourth chec
get:This step
get:no ACK, a
get:If the SY
get:Transmission Cont
get:Functional Specif
get:are accep
get:SEG.SEQ. 
get:is an ACK
get:are there
get:If SND.UN
get:state to 
get:<SEQ=SN
get:and send 
get:transmiss
get:text in t
get:below whe
get:Otherwise
get:<SEQ=IS
get:and send 
get:segment, 
get:has been 
get:fifth, if n
get:segment and
get:[Page 68]        
get:September 1981   
get:first check s
get:SYN-RECEIVE
get:ESTABLISHED
get:FIN-WAIT-1 
get:FIN-WAIT-2 
get:CLOSE-WAIT 
get:CLOSING STA
get:LAST-ACK ST
get:TIME-WAIT S
get:Segments 
get:are used 
get:done in S
get:boundary 
get:processed
get:There are
get:segment
get:Segment R
get:Length  W
get:------- -
get:0     
get:0     
get:>0     
get:>0     
get:If the RC
get:special a
get:If an inc
get:should be
get:the segme:nt and return)
get:<SEQ=SN
get:After sen
get:and retur
get:Transmission Cont
get:Functional Specif
get:In the fo
get:segment t
get:One could
get:trimming 
get:SYN and F
get:begins at
get:numbers m
get:second check 
get:SYN-RECEIVE
get:If the RS
get:If this
get:came fr
get:LISTEN 
get:this co
get:from SY
get:the use
get:on the 
get:active 
get:and ret
get:ESTABLISHED
get:If the RS
get:should re
get:flushed. 
get:"connecti
get:TCB, and 
get:CLOSING STA
get:LAST-ACK ST
get:If the RS
get:TCB, and 
get:[Page 70]        
get:September 1981   
get:third check s
get:SYN-RECEIVE
get:If the se
get:exactly m
get:then send
get:ESTABLISHED
get:If the se
get:exactly m
get:then send
get:receive "
get:flushed. 
get:"connecti
get:TCB, and 
get:Note this c
get:a segment f
get:different s
get:current con
get:fourth, check
get:SYN-RECEIVE
get:ESTABLISHED
get:FIN-WAIT ST
get:FIN-WAIT ST
get:CLOSE-WAIT 
get:CLOSING STA
get:LAST-ACK ST
get:TIME-WAIT S
get:If the SY
get:outstandi
get:all segme
get:receive a
get:the CLOSE
get:If the SY
get:and an ac
get:number ch
get:Transmission Cont
get:Functional Specif
get:fifth check t
get:if the ACK 
get:if the ACK 
get:SYN-RECEI
get:If SND.
get:and con
get:If th
get:reset
get:<SE
get:and s
get:ESTABLISH
get:If SND.
get:Any seg
get:entirel
get:positiv
get:fully a
get:"ok" re
get:(SEG.AC
get:somethi
get:drop th
get:If SND.
get:updated
get:SND.WL2
get:SND.WL1
get:Note th
get:records
get:SND.WND
get:the las
get:prevent
get:[Page 72]        
get:September 1981   
get:FIN-WAIT-
get:In addi
get:our FIN
get:process
get:FIN-WAIT-
get:In addi
get:the ret
get:acknowl
get:CLOSE-WAI
get:Do the 
get:CLOSING S
get:In addi
get:the ACK
get:otherwi
get:LAST-ACK 
get:The onl
get:acknowl
get:delete 
get:TIME-WAIT
get:The onl
get:retrans
get:the 2 M
get:sixth, check 
get:ESTABLISHED
get:FIN-WAIT-1 
get:FIN-WAIT-2 
get:If the UR
get:the user 
get:pointer (
get:user has 
get:mode") fo
get:signal th
get:Transmission Cont
get:Functional Specif
get:CLOSE-WAIT 
get:CLOSING STA
get:LAST-ACK ST
get:This shou
get:remote si
get:seventh, proc
get:ESTABLISHED
get:FIN-WAIT-1 
get:FIN-WAIT-2 
get:Once in t
get:text to u
get:into buff
get:empty.  I
get:the user 
get:has been 
get:When the 
get:user it m
get:Once the 
get:RCV.NXT o
get:apporopri
get:RCV.NXT a
get:Please no
get:Send an a:cknowledgment of the form
get:<SEQ=SN
get:This ackn
get:transmitt
get:[Page 74]        
get:September 1981   
get:CLOSE-WAIT 
get:CLOSING STA
get:LAST-ACK ST
get:TIME-WAIT S
get:This shou
get:remote si
get:eighth, check
get:Do not proc
get:since the S
get:If the FIN 
get:return any 
get:over the FI
get:FIN implies
get:SYN-RECEI
get:ESTABLISH
get:Enter t
get:FIN-WAIT-
get:If our 
get:enter T
get:timers;
get:FIN-WAIT-
get:Enter t
get:off the
get:CLOSE-WAI
get:Remain 
get:CLOSING S
get:Remain 
get:LAST-ACK 
get:Remain 
get:Transmission Cont
get:Functional Specif
get:TIME-WAIT
get:Remain 
get:timeout
get:[Page 76]        
get:September 1981   
get:For any state
get:the user "err:or
get:and for any o
get:state and ret
get:RETRANSMISSION 
get:For any state
get:the retransmi
get:retransmissio
get:TIME-WAIT TIMEO
get:If the time-w
get:enter the CLO
get:Transmission Cont
get:[Page 78]        
get:September 1981   
get:BBN Rep
get:a Host 
get:host an
get:A contr
get:indicat
get:specifi
get:is expe
get:previou
get:The uni
get:ARPANET
get:A unit 
get:IMPs.  
get:A logic
get:A messa
get:network
get:Destination Addre
get:The des
get:identif
get:A contr
get:indicat
get:occupyi
get:A porti
get:fragmen
get:A file 
get:Transmission Cont
get:Control
get:fragmen
get:A compu
get:from th
get:An Inte
get:by the 
get:The Int
get:ARPANET
get:A sourc
get:internet datagram
get:The uni
get:higher 
get:internet fragment
get:A porti
get:header.
get:Interne
get:The Ini
get:number 
get:The Ini
get:on a co
get:based p
get:The Ini
get:used by
get:Control
get:data.  
get:on an A
get:[Page 80]        
get:September 1981   
get:This is
get:data re
get:sequenc
get:of the 
get:The uni
get:An impl
get:procedu
get:Maximum
get:the int
get:An eigh
get:An Opti
get:may be 
get:primari
get:timesta
get:options
get:A packa
get:logical
get:logical
get:The por
get:output 
get:A progr
get:the poi
get:A contr
get:this se
get:receivi
get:receive
get:Transmission Cont
get:receive
get:receive
get:receive next sequ
get:This is
get:receive
get:This re
get:is will
get:segment
get:RCV.NXT
get:Segment
get:range a
get:A contr
get:that th
get:interac
get:sequenc
get:segment
get:it.  In
get:rise to
get:Real Ti:me Protocol
get:of time
get:segment
get:segment
get:segment
get:segment
get:segment
get:[Page 82]        
get:September 1981   
get:segment
get:A logic
get:unit of
get:segment acknowled
get:The seq
get:arrivin
get:The amo
get:includi
get:The num
get:This is
get:use on 
get:initial
get:each oc
get:This re
get:(receiv
get:window 
get:receivi
get:be emit
get:SND.UNA
get:between
get:send se
get:left se
get:send ur
get:segment
get:segment
get:Transmission Cont
get:send wi
get:An addr
get:is, the
get:The sou
get:A contr
get:number,
get:where t
get:Transmi
get:the sta
get:The pre
get:Transmi:ssion Control Protocol
get:reliabl
get:Type of
get:An Inte
get:for thi
get:A contr
get:indicat
get:urgent 
get:sequenc
get:pointer
get:A contr
get:field c
get:indicat
get:urgent 
get:[Page 84]        
get:September 1981   
get:[1]  Cerf, V., an
get:Intercommuni
get:Vol. COM-22,
get:[2]  Postel, J. (
get:Protocol Spe
get:Institute, S
get:[3]  Dalal, Y. an
get:Protocols", 
get:December 197
get:[4]  Postel, J., 
get:Institute, S
get:aRFC
get:aDe
get:aI
get:aSeptember 1981   
get:aPREFACE .....
get:a1.  INTRODUCTION 
get:a1.1  Motivation
get:a1.2  Scope ....
get:a1.3  About This
get:a1.4  Interfaces
get:a1.5  Operation 
get:a2.  PHILOSOPHY ..
get:a2.1  Elements o
get:a2.2  Model of O
get:a2.3  The Host E
get:a2.4  Interfaces
get:a2.5  Relation t
get:a2.6  Reliable C
get:a2.7  Connection
get:a2.8  Data Commu
get:a2.9  Precedence
get:a2.10 Robustness
get:a3.  FUNCTIONAL SP
get:a3.1  Header For
get:a3.2  Terminolog
get:a3.3  Sequence N
get:a3.4  Establishi
get:a3.5  Closing a 
get:a3.6  Precedence
get:a3.7  Data Commu
get:a3.8  Interfaces
get:a3.9  Event Proc
get:aGLOSSARY ........
get:aREFERENCES ......
get:aTransmission Cont
get:a[Page ii]        
get:aSeptember 1981   
get:aThis document des
get:a(TCP).  There hav
get:aspecification on 
get:adraws heavily fro
get:aboth in terms of 
get:aseveral details a
get:aand redescribes t
get:aRFC
get:aReplaces: RFC 761
get:aIENs:  129, 124, 
get:a55, 44, 40, 27, 2
get:aThe Transmission 
get:areliable host-to-
get:acommunication net
get:aThis document des
get:aTransmission Cont
get:ainterface to prog
get:aComputer commun
get:arole in militar
get:adocument focuse
get:acommunication r
get:acommunication u
get:acongestion, but
get:agovernment sect
get:aAs strategic an
get:adeveloped and d
get:ainterconnecting
get:acommunication p
get:aapplications.  
get:aDeputy Undersec
get:adeclared the Tr
get:abe a basis for 
get:astandardization
get:aTCP is a connec
get:afit into a laye
get:aapplications.  
get:acommunication b
get:adistinct but in
get:aassumptions are
get:aprotocols below
get:apotentially unr
get:aprotocols.  In 
get:awide spectrum o
get:aconnections to 
get:aTransmission Cont
get:aTCP is based on
get:aTCP fits into a
get:aInternet Protoc
get:areceive variabl
get:adatagram "envel
get:aaddressing sour
get:ainternet protoc
get:athe TCP segment
get:amultiple networ
get:aalso carries in
get:aand compartment
get:acommunicated en
get:aMuch of this do
get:awhich are co-re
get:acomputer.  Some
get:afront-end compu
get:aas well as netw
get:aan interface to
get:aimplementable e
get:ahost-to-front e
get:aThe TCP is inte
get:acommunication s
get:aintended to be 
get:a1.3.  About this 
get:aThis document r
get:aany TCP impleme
get:aprotocols and i
get:a[Page 2]         
get:aSeptember 1981   
get:asection offers 
get:aoperation.  Sec
get:adesign.  Sectio
get:arequired of TCP
get:auser calls, err
get:aThe TCP interfa
get:athe other side 
get:aThe interface b
get:aillustrated in 
get:acalls much like
get:aapplication pro
get:acalls to open a
get:aestablished con
get:aasynchronously 
get:aconsiderable fr
get:ainterfaces whic
get:aenvironment, a 
get:ainterface for a
get:aThe interface b
get:aunspecified exc
get:atwo levels can 
get:aTypically, one 
get:ainterface.  TCP
get:ainterconnected 
get:athroughout this
get:aAs noted above,
get:asecurable logic
get:aprocesses.  To 
get:acommunication s:ystem requires facilities in the following areas
get:aBasic Data Tr
get:aPrecedence an
get:aThe basic opera
get:athe following p
get:aTransmission Cont
get:aBasic Data Tran:sfer
get:aThe TCP is ab
get:adirection bet
get:asegments for 
get:athe TCPs deci
get:aSometimes use
get:asubmitted to 
get:afunction is d
get:aactually tran
get:apushed throug
get:apromptly forw
get:aThe exact pus
get:athe push func
get:aReliability
get:aThe TCP must 
get:adelivered out
get:ais achieved b
get:atransmitted, 
get:areceiving TCP
get:ainterval, the
get:anumbers are u
get:aout of order 
get:aadding a chec
get:areceiver, and
get:aAs long as th
get:asystem does n
get:aerrors will a
get:ainternet comm
get:aFlow Control
get:aTCP provides 
get:asent by the s
get:aevery ACK ind
get:athe last segm
get:aallowed numbe
get:areceiving fur
get:a[Page 4]         
get:aSeptember 1981   
get:aMultiplexing
get:aTo allow for 
get:acommunication
get:aaddresses or 
get:aand host addr
get:aa socket.  A 
get:aThat is, a so
get:aThe binding o
get:aHost.  Howeve
get:a(e.g., a "log
get:amade known to
get:athrough the k
get:aaddresses of 
get:aConnections
get:aThe reliabili
get:athat TCPs ini
get:aeach data str
get:asockets, sequ
get:aEach connecti
get:aidentifying i
get:aWhen two proc
get:aestablish a c
get:aside).  When 
get:aterminated or
get:aSince connect
get:aover the unre
get:amechanism wit
get:aerroneous ini
get:aPrecedence and :Security
get:aThe users of 
get:acommunication
get:athese feature
get:aTransmission Cont
get:a[Page 6]         
get:aSeptember 1981   
get:a2.1.  Elements of
get:aThe internetwor
get:awhich are in tu
get:athat the networ
get:alarge networks 
get:apacket switchin
get:aconsume message
get:anetworks, the g
get:acommunication s
get:aconnections bet
get:aThe term packet
get:atransaction bet
get:aexchanged withi
get:aHosts are compu
get:anetwork's point
get:aProcesses are v
get:aaccordance with
get:ain execution). 
get:aviewed as commu
get:aThus, all commu
get:aSince a process
get:astreams between
get:athat each proce
get:acommunicates wi
get:a2.2.  Model of Op
get:aProcesses trans
get:adata as argumen
get:asegments and ca
get:athe destination
get:ainto the receiv
get:aTCPs include co
get:aensure reliable
get:aThe model of in
get:aprotocol module
get:ato the local ne
get:ainside internet
get:ainternet module
get:athrough the loc
get:aThe packet swit
get:aTransmission Cont
get:aother operation
get:adestination int
get:aAt a gateway be
get:afrom its local 
get:athe internet da
get:athen "wrapped" 
get:arouted to the n
get:aA gateway is pe
get:ainternet datagr
get:athrough the nex
get:ainternet datagr
get:afurther broken 
get:ainternet datagr
get:ainternet module
get:aA destination i
get:a(after reassemb
get:adestination TCP
get:aThis simple mod
get:aimportant featu
get:ato the gateway 
get:aservice paramet
get:aIncluded in the
get:adatagram.  Data
get:ahost and gatewa
get:aproperly segreg
get:a2.3.  The Host En
get:aThe TCP is assu
get:aaccess the TCP 
get:amay call on oth
get:adata structures
get:acontrolled by a
get:anetwork device 
get:adatagram protoc
get:aThe mechanisms 
get:afront-end proce
get:ahost-to-front-e
get:athe type of TCP
get:a[Page 8]         
get:aSeptember 1981   
get:aThe TCP/user in
get:ato OPEN or CLOS
get:aSTATUS about a 
get:aprograms on the
get:afrom, and close
get:aThe TCP/interne
get:adatagrams addre
get:asystem.  These 
get:aservice, preced
get:a2.5.  Relation to
get:aThe following d
get:ahierarchy
get:a+------+ +
get:a|Telnet| |
get:a+------+ +
get:a|   
get:a+----
get:a| TCP
get:a+----
get:a| 
get:a+----
get:a|    
get:a+----
get:a+--
get:a|  
get:a+--
get:aIt is expected 
get:aprotocols effic
get:aprotocols like 
get:a2.6.  Reliable Co
get:aA stream of dat
get:aorder at the de
get:aTransmission Cont
get:aTransmission is
get:aacknowledgments
get:asequence number
get:asegment is tran
get:asequence number
get:ais the sequence
get:atransmissions i
get:asegment contain
get:astarts a timer;
get:asegment is dele
get:areceived before
get:aAn acknowledgme
get:adelivered to th
get:athe responsibil
get:aTo govern the f
get:aemployed.  The 
get:aThis window spe
get:aacknowledgment 
get:a2.7.  Connection 
get:aTo identify the
get:aprovides a port
get:aindependently b
get:aunique addresse
get:aidentifying the
get:awill be unique 
get:aA connection is
get:alocal socket ma
get:asockets.  A con
get:athat is, it is 
get:aTCPs are free t
get:aHowever, severa
get:aThere must be w
get:athe "appropriat
get:amay "own" ports
get:athe ports they 
get:aissue, but we e
get:auniquely alloca
get:aassociating the
get:aA connection is
get:aforeign socket 
get:a[Page 10]        
get:aSeptember 1981   
get:aconnection name
get:asubsequent call
get:aabout a connect
get:ais a data struc
get:aimplementation 
get:apointer to the 
get:awhether the con
get:abe passively wa
get:aA passive OPEN 
get:aconnection requ
get:aOften the proce
get:arequest from an
get:ais used to deno
get:aare allowed onl
get:aA service proce
get:aprocesses would
get:aforeign socket.
get:arequested a con
get:alocal socket we
get:aWell-known sock
get:aa socket addres
get:a"Telnet-Server"
get:asocket, and oth
get:aEntry, Text Gen
get:abeing for test 
get:aaccess to a "Lo
get:aat which a newl
get:awell-known sock
get:aof sockets to s
get:aProcesses can i
get:afrom other proc
get:abeen establishe
get:aother at the sa
get:ais critical for
get:acomponents act 
get:aThere are two p
get:apassive OPENs a
get:alocal passive O
get:acase, the match
get:aOPENs has left 
get:aforeign socket 
get:aOther possibili
get:aTransmission Cont
get:aIf there are se
get:asame local sock
get:awith the specif
get:aTCB exists, bef
get:aThe procedures 
get:acontrol flag an
get:aexchange has be
get:aA connection is
get:acontaining a SY
get:acommand.  The m
get:aconnection has 
get:awhen sequence n
get:aThe clearing of
get:ain this case ca
get:a2.8.  Data Commun
get:aThe data that f
get:aoctets.  The se
get:ain that call (a
get:athrough to the 
get:aA sending TCP i
get:asend that data 
get:afunction is sig
get:areceiving TCP s
get:athe sending TCP
get:aThere is no nec
get:aboundaries.  Th
get:asingle SEND cal
get:aThe purpose of 
get:afrom the sendin
get:arecord service.
get:aThere is a coup
get:aof data that cr
get:aassociated with
get:abuffer is retur
get:anot filled.  If
get:aPUSH is seen, t
get:aTCP also provid
get:aat some point f
get:a[Page 12]        
get:aSeptember 1981   
get:acurrently readi
get:adefine what the
get:aurgent data, bu
get:atake action to 
get:a2.9.  Precedence 
get:aThe TCP makes u
get:asecurity option
get:abasis to TCP us
get:aa multilevel se
get:ause only, and o
get:acompartment.  C
get:ausers may be li
get:aTCP modules whi
get:aproperly mark o
get:aprecedence.  Su
get:ahigher level pr
get:athem to specify
get:aprecedence of c
get:a2.10.  Robustness
get:aTCP implementat:ions will follow a general principle of robustness
get:aconservative in
get:aTransmission Cont
get:a[Page 14]        
get:aSeptember 1981   
get:a3.1.  Header Form
get:aTCP segments ar
get:aheader carries 
get:adestination hos
get:aheader, supplyi
get:adivision allows
get:aTCP Header Form
get:a0            
get:a0 1 2 3 4 5 6
get:a+-+-+-+-+-+-+-
get:a|          Sou
get:a+-+-+-+-+-+-+-
get:a|             
get:a+-+-+-+-+-+-+-
get:a|             
get:a+-+-+-+-+-+-+-
get:a|  Data |     
get:a| Offset| Rese
get:a|       |     
get:a+-+-+-+-+-+-+-
get:a|           Ch
get:a+-+-+-+-+-+-+-
get:a|             
get:a+-+-+-+-+-+-+-
get:a|             
get:a+-+-+-+-+-+-+-
get:aNote th
get:aSource Port:  1
get:aThe source po
get:aDestination Por:t
get:aThe destinati
get:aTransmission Cont
get:aFunctional Specif
get:aSequence Number:
get:aThe sequence 
get:awhen SYN is p
get:ainitial seque
get:aAcknowledgment :Number
get:aIf the ACK co
get:anext sequence
get:areceive.  Onc
get:aData Offset:  4
get:aThe number of
get:athe data begi
get:aintegral numb
get:aReserved:  6 bi
get:aReserved for 
get:aControl Bits:  :6 bits (from left to right)
get:aURG:  Urgent 
get:aACK:  Acknowl
get:aPSH:  Push Fu
get:aRST:  Reset t
get:aSYN:  Synchro
get:aFIN:  No more
get:aWindow:  16 bit
get:aThe number of
get:aacknowledgmen
get:aChecksum:  16 b
get:aThe checksum 
get:acomplement su
get:asegment conta
get:achecksummed, 
get:aform a 16 bit
get:atransmitted a
get:athe checksum 
get:aThe checksum 
get:a[Page 16]        
get:aSeptember 1981   
get:aprefixed to t
get:aAddress, the 
get:aThis gives th
get:ainformation i
get:aacross the TC
get:acalls by the 
get:aThe TCP Len
get:aoctets (thi
get:acomputed), 
get:aUrgent Pointer:
get:aThis field co
get:apositive offs
get:aurgent pointe
get:athe urgent da
get:athe URG contr
get:aOptions:  varia
get:aOptions may o
get:amultiple of 8
get:achecksum.  An
get:acases for the: format of an option
get:aCase 1:  A 
get:aCase 2:  An
get:ath
get:aThe option-le
get:aoption-length
get:aNote that the
get:afield might i
get:aEnd-of-Option
get:aA TCP must im
get:aTransmission Cont
get:aFunctional Specif
get:aCurrently def:ined options include (kind indicated in octal)
get:aKind     Le
get:a----     --
get:a0         
get:a1         
get:a2         
get:aSpecific Opti
get:aEnd of Opti
get:a+--------
get:a|00000000
get:a+--------
get:aThis opti
get:amight not
get:athe Data 
get:anot the e
get:athe optio
get:aNo-Operatio
get:a+--------
get:a|00000001
get:a+--------
get:aThis opti
get:aalign the
get:aThere is 
get:areceivers
get:anot begin
get:aMaximum Seg
get:a+--------
get:a|00000010
get:a+--------
get:aKind=2  
get:a[Page 18]        
get:aSeptember 1981   
get:aMaximum S:egment Size Option Data
get:aIf this
get:areceive
get:aThis fi
get:a(i.e., 
get:aoption 
get:aPadding:  varia
get:aThe TCP heade
get:aand data begi
get:a3.2.  Terminology
get:aBefore we can d
get:ato introduce so
get:aconnection requ
get:aof these variab
get:aTransmission Co
get:aTCB are the loc
get:aprecedence of t
get:abuffers, pointe
get:aIn addition sev
get:asequence number
get:aSend Sequence
get:aSND.UNA - s
get:aSND.NXT - s
get:aSND.WND - s
get:aSND.UP  - s
get:aSND.WL1 - s
get:aSND.WL2 - s
get:au
get:aISS     - i
get:aReceive Seque
get:aRCV.NXT - r
get:aRCV.WND - r
get:aRCV.UP  - r
get:aIRS     - i
get:aTransmission Cont
get:aFunctional Specif
get:aThe following d
get:athe sequence sp
get:aSend Sequence S
get:a---
get:a1 - old s
get:a2 - seque
get:a3 - seque
get:a4 - futur
get:aThe send window
get:aReceive Sequenc
get:a1 - old s
get:a2 - seque
get:a3 - futur
get:aThe receive win
get:aThere are also 
get:atake their valu
get:a[Page 20]        
get:aSeptember 1981   
get:aCurrent Segme
get:aSEG.SEQ - s
get:aSEG.ACK - s
get:aSEG.LEN - s
get:aSEG.WND - s
get:aSEG.UP  - s
get:aSEG.PRC - s
get:aA connection pr
get:alifetime.  The :states are
get:aESTABLISHED, FI
get:aTIME-WAIT, and 
get:abecause it repr
get:ano connection. : Briefly the meanings of the states are
get:aLISTEN - repr
get:aTCP and port.
get:aSYN-SENT - re
get:aafter having 
get:aSYN-RECEIVED 
get:arequest ackno
get:aconnection re
get:aESTABLISHED -
get:adelivered to 
get:aof the connec
get:aFIN-WAIT-1 - 
get:afrom the remo
get:atermination r
get:aFIN-WAIT-2 - 
get:afrom the remo
get:aCLOSE-WAIT - 
get:afrom the loca
get:aCLOSING - rep
get:aacknowledgmen
get:aLAST-ACK - re
get:aconnection te
get:a(which includ
get:aTransmission Cont
get:aFunctional Specif
get:aTIME-WAIT - r
get:athe remote TC
get:atermination r
get:aCLOSED - repr
get:aA TCP connectio
get:aevents.  The ev
get:aABORT, and STAT
get:acontaining the 
get:aThe state diagr
get:awith the causin
get:aerror condition
get:achanges.  In a 
get:athe reaction of
get:aNOTE BENE:  thi
get:athe total speci
get:a[Page 22]        
get:aSeptember 1981   
get:a+---------+     
get:a|         |<----
get:a|   SYN   |     
get:a|   RCVD  |<----
get:a|         |     
get:a|         |-----
get:a+---------+   rc
get:a|           --
get:a|             
get:a|             
get:a|  CLOSE      
get:a| -------     
get:a| snd FIN     
get:a|             
get:aV             
get:a+---------+     
get:a|  FIN    |<----
get:a| WAIT-1  |-----
get:a+---------+     
get:a| rcv ACK of F
get:a| ------------
get:aV        x    
get:a+---------+     
get:a|FINWAIT-2|     
get:a+---------+     
get:a|             
get:a|  rcv FIN    
get:a|  -------    
get:a\ snd ACK    
get:a------------
get:aTransmission Cont
get:aFunctional Specif
get:a3.3.  Sequence Nu
get:aA fundamental n
get:aover a TCP conn
get:asequenced, each
get:amechanism emplo
get:anumber X indica
get:areceived.  This
get:adetection in th
get:awithin a segmen
get:athe header is t
get:anumbered consec
get:aIt is essential
get:afinite, though 
get:aSince the space
get:anumbers must be
get:apreserves the r
get:a2**32 - 1 to 0 
get:aarithmetic, so 
get:acomparison of s
get:a(modulo 2**32).
get:aThe typical kin
get:aperform include:
get:a(a)  Determin
get:anumber s
get:a(b)  Determin
get:ahave bee
get:aretransm
get:a(c)  Determin
get:awhich ar
get:areceive 
get:a[Page 24]        
get:aSeptember 1981   
get:aIn response to 
get:afollowing compa
get:aSND.UNA = old
get:aSND.NXT = nex
get:aSEG.ACK = ack
get:anum
get:aSEG.SEQ = fir
get:aSEG.LEN = the
get:a(co
get:aSEG.SEQ+SEG.L
get:aA new acknowled
get:athe inequality :below holds
get:aSND.UNA < SEG
get:aA segment on th
get:aof its sequence
get:aacknowledgment 
get:aWhen data is re:ceived the following comparisons are needed
get:aRCV.NXT = nex
get:ais the le
get:aRCV.NXT+RCV.W
get:asegment, 
get:aSEG.SEQ = fir
get:aSEG.SEQ+SEG.L
get:aA segment is ju
get:aRCV.NXT =< SE
get:aRCV.NXT =< SE
get:aTransmission Cont
get:aFunctional Specif
get:aThe first part 
get:asegment falls i
get:aif the end of t
get:aeither part of 
get:aActually, it is
get:awindows and zer
get:aacceptability o:f an incoming segment
get:aSegment Recei
get:aLength  Windo
get:a------- -----
get:a0       0 
get:a0      >0 
get:a>0       0 
get:a>0      >0 
get:aNote that when 
get:aacceptable exce
get:amaintain a zero
get:aACKs.  However,
get:aprocess the RST
get:aWe have taken a
get:acontrol informa
get:asome control fl
get:aand acknowledge
get:acontrol will be
get:acarried in the 
get:afor implicitly 
get:aare the only co
get:aare used only a
get:apurposes, the S
get:aoctet of the se
get:ato occur after 
get:aoccurs.  The se
get:aspace occupying
get:asequence number
get:a[Page 26]        
get:aSeptember 1981   
get:aInitial Sequenc
get:aThe protocol pl
get:aused over and o
get:asockets.  New i
get:aincarnations of
get:a-- "how does th
get:aincarnations of
get:aconnection is b
get:aconnection brea
get:aTo avoid confus
get:aconnection from
get:abe present in t
get:aassure this, ev
get:asequence number
get:aan initial sequ
get:anew 32 bit ISN.
get:abit clock whose
get:amicroseconds.  
get:aSince we assume
get:athe Maximum Seg
get:ahours we can re
get:aFor each connec
get:asequence number
get:athe data sendin
get:alearned during 
get:aFor a connectio
get:asynchronize on 
get:aan exchange of 
get:acalled "SYN" (f
get:ashorthand, segm
get:aHence, the solu
get:ainitial sequenc
get:aThe synchroniza
get:asequence number
get:afrom the other 
get:ainitial sequenc
get:a1) A --> B  S
get:a2) A <-- B  A
get:a3) A <-- B  S
get:a4) A --> B  A
get:aTransmission Cont
get:aFunctional Specif
get:aBecause steps 2
get:acalled the thre
get:aA three way han
get:atied to a globa
get:amechanisms for 
get:ano way of knowi
get:aunless it remem
get:a(which is not a
get:averify this SYN
get:aclock-driven sc
get:aKnowing When to
get:aTo be sure that
get:asequence number
get:athe network, th
get:a(MSL) before as
get:arecovering from
get:alost.  For this
get:ais an engineeri
get:ait is desirable
get:asense, yet reta
get:anot wait at all
get:athan those rece
get:aThe TCP Quiet T
get:aThis specific
get:aretaining any
get:aeach active (
get:aTCP segments 
get:ain the intern
get:aparagraphs be
get:aTCP implement
get:aat the risk o
get:adata rejected
get:aTCPs consume 
get:aentered into 
get:aduplicate det
get:arelies on the
get:athe extent th
get:avalues before
get:abeen delivere
get:acopies of the
get:asuch an assum
get:a[Page 28]        
get:aSeptember 1981   
get:aassigned the 
get:aat the receiv
get:athat each seg
get:aas there are 
get:aUnder normal 
get:ato emit and t
get:amistakenly us
get:abeen acknowle
get:adata is drain
get:avery large to
get:acause trouble
get:ato use up 2**
get:alifetime in t
get:athis is deeme
get:arates escalat
get:acycle time is
get:awithin reason
get:aThe basic dup
get:adefeated, how
get:asequence numb
get:athe TCP were 
get:aupon crashing
get:aconnection (p
get:apackets with 
get:apackets still
get:aincarnation o
get:aabout the seq
get:aspecification
get:abefore emitti
get:asegments from
get:aEven hosts wh
get:ainitial seque
get:a(i.e., even i
get:anumber for ea
get:aSuppose, for 
get:asequence numb
get:aand that even
get:atakes on a va
get:asegment sent 
get:aat this insta
get:aincarnation o
get:aS1 = ISN(t) -
get:aconnection!  
get:aTransmission Cont
get:aFunctional Specif
get:aduplicates in
get:aof S1 may arr
get:athe new incar
get:aThe problem i
get:acrashed nor d
get:athe system fr
get:aOne way to de
get:asegments for 
get:atime" specifi
get:awilling to ri
get:adestination m
get:aImplementors 
get:aconnection by
get:ainformally im
get:aObviously, ev
get:anecessary aft
get:aTo summarize:
get:anumbers in th
get:a"busy" or "in
get:ablock of spac
get:asegment, if a
get:asequence numb
get:athe previous 
get:anumber overla
get:a3.4.  Establishin
get:aThe "three-way 
get:aconnection.  Th
get:aresponded to by
get:asimultaneously 
get:aoccurs, each TC
get:aacknowledgment 
get:aan old duplicat
get:arecipient, that
get:aProper use of "
get:aSeveral example
get:aexamples do not
get:asegments, this 
get:adoesn't deliver
get:avalid (i.e., th
get:aconnection reac
get:areduces the pos
get:a[Page 30]        
get:aSeptember 1981   
get:aimplementation 
get:ainformation for
get:aThe simplest th
get:afigures should 
get:anumbered for re
get:adeparture of a 
get:asegment at B fr
get:aEllipsis (...) 
get:a(delayed).  An 
get:aComments appear
get:athe departure o
get:athe center of e
get:aform, with sequ
get:afields such as 
get:ain the interest
get:aTCP A      
get:a1.  CLOSED     
get:a2.  SYN-SENT   
get:a3.  ESTABLISHED
get:a4.  ESTABLISHED
get:a5.  ESTABLISHED
get:aBasic 3
get:aIn line 2 of fi
get:aindicating that
get:anumber 100.  In
get:areceived from T
get:aB is now expect
get:aoccupied sequen
get:aAt line 4, TCP 
get:aTCP B's SYN; an
get:asequence number
get:abecause the ACK
get:awould wind up A
get:aTransmission Cont
get:aFunctional Specif
get:aSimultaneous in
get:afigure 8.  Each
get:aTCP A      
get:a1.  CLOSED     
get:a2.  SYN-SENT   
get:a3.  SYN-RECEIVE
get:a4.             
get:a5.  SYN-RECEIVE
get:a6.  ESTABLISHED
get:a7.             
get:aS
get:aThe principle r
get:aduplicate conne
get:athis, a special
get:areceiving TCP i
get:aSYN-RECEIVED), 
get:aIf the TCP is i
get:aFIN-WAIT-1, FIN
get:aaborts the conn
get:acase under "hal
get:a[Page 32]        
get:aSeptember 1981   
get:aTCP A      
get:a1.  CLOSED     
get:a2.  SYN-SENT   
get:a3.  (duplicate)
get:a4.  SYN-SENT   
get:a5.  SYN-SENT   
get:a6.             
get:a7.  SYN-SENT   
get:a8.  ESTABLISHED
get:aAs a simple exa
get:afigure 9.  At l
get:acannot tell tha
get:a(line 4).  TCP 
get:aRST (reset) wit
get:abelievable.  TC
get:aWhen the origin
get:asynchronization
get:abefore the RST,
get:asent in both di
get:aHalf-Open Conne
get:aAn established 
get:aTCPs has closed
get:aknowledge of th
get:abecome desynchr
get:amemory.  Such c
get:aattempt is made
get:aconnections are
get:amildly involved
get:aIf at site A th
get:aTransmission Cont
get:aFunctional Specif
get:auser at site B 
get:areceiving a res
get:asite B TCP that
get:aAssume that two
get:aanother when a 
get:aDepending on th
get:athat some error
get:aA is likely to 
get:apoint.  As a re
get:aor try to SEND 
get:acase, it receiv
get:alocal (A's) TCP
get:awill send a seg
get:aexample shown i
get:are-open the con
get:aTCP A      
get:a1.  (CRASH)    
get:a2.  CLOSED     
get:a3.  SYN-SENT --
get:a4.  (!!)     <-
get:a5.  SYN-SENT --
get:a6.  SYN-SENT   
get:a7.  SYN-SENT --
get:aWhen the SYN ar
get:aand the incomin
get:aacknowledgment 
get:a100).  TCP A se
get:asent and, being
get:adetected a half
get:a[Page 34]        
get:aSeptember 1981   
get:acontinue to try
get:areduced to the 
get:aAn interesting 
get:atries to send d
get:aThis is illustr
get:aTCP A from TCP 
get:aexists, so TCP 
get:aprocesses it an
get:aTCP A    
get:a1.  (CRASH)    
get:a2.  (??)    <--
get:a3.          -->
get:aActive
get:aIn figure 12, w
get:awaiting for SYN
get:ainto action.  A
get:agenerate a RST 
get:athe reset and r
get:aTCP A      
get:a1.  LISTEN     
get:a2.       ... <S
get:a3.  (??) <-- <S
get:a4.       --> <S
get:a5.  LISTEN     
get:aOld Duplic
get:aTransmission Cont
get:aFunctional Specif
get:aA variety of ot
get:aby the followin
get:aReset Generatio
get:aAs a general ru
get:awhich apparentl
get:amust not be sen
get:aThere are three: groups of states
get:a1.  If the co
get:ain response t
get:aparticular, S
get:aby this means
get:aIf the incomi
get:asequence numb
get:areset has seq
get:aof the sequen
get:aThe connectio
get:a2.  If the co
get:aSYN-SENT, SYN
get:asomething not
get:aif an incomin
get:adoes not exac
get:aconnection, a
get:aIf our SYN ha
get:aincoming segm
get:aeither raise 
get:athe system) o
get:aincoming segm
get:acontinue as i
get:acannot raise 
get:adetected in t
get:aterminated th
get:aincoming segm
get:amatch the loc
get:amust be sent.
get:aIf the incomi
get:asequence numb
get:areset has seq
get:aof the sequen
get:aThe connectio
get:a[Page 36]        
get:aSeptember 1981   
get:a3.  If the co
get:aFIN-WAIT-1, F
get:aany unaccepta
get:aunacceptible 
get:aacknowledgmen
get:aand an acknow
get:ato be receive
get:aIf an incomin
get:aprecedence wh
get:aand precedenc
get:aconnection go
get:anumber from t
get:aReset Processin
get:aIn all states e
get:aby checking the
get:ais in the windo
get:ato an initial S
get:aacknowledges th
get:aThe receiver of
get:areceiver was in
get:ain SYN-RECEIVED
get:athen the receiv
get:aaborts the conn
get:awas in any othe
get:aand goes to the
get:a3.5.  Closing a C
get:aCLOSE is an ope
get:anotion of closi
get:ainterpretation,
get:athe receiving s
get:ain a simplex fa
get:auntil he is tol
get:acould initiate 
get:aRECEIVE until s
get:ahas CLOSED.  We
get:aRECEIVEs are ou
get:acan terminate h
get:abuffers SENT be
get:adata in return 
get:asuccessfully to
get:aTCP.  Users mus
get:athe TCP says no
get:aTransmission Cont
get:aFunctional Specif
get:aThere are essen:tially three cases
get:a1) The user i
get:a2) The remote
get:a3) Both users
get:aCase 1:  Local 
get:aIn this case,
get:aoutgoing segm
get:aaccepted by t
get:aare allowed i
get:awill be retra
get:aboth acknowle
get:acan ACK this 
get:asend its own 
get:aCase 2:  TCP re
get:aIf an unsolic
get:acan ACK it an
get:auser will res
get:athe other TCP
get:auntil its own
get:aconnection.  
get:athe connectio
get:aCase 3:  both u
get:aA simultaneou
get:aFIN segments 
get:ahave been pro
get:ahas received.
get:a[Page 38]        
get:aSeptember 1981   
get:aTCP A      
get:a1.  ESTABLISHED
get:aFIN-WAIT-1 
get:a3.  FIN-WAIT-2 
get:a4.             
get:aTIME-WAIT  
get:a5.  TIME-WAIT  
get:aCLOSED     
get:aTCP A      
get:a1.  ESTABLISHED
get:a2.  (Close)    
get:aFIN-WAIT-1 
get:a3.  CLOSING    
get:a4.  TIME-WAIT  
get:a(2 MSL)    
get:aCLOSED     
get:aTransmission Cont
get:aFunctional Specif
get:a3.6.  Precedence 
get:aThe intent is t
get:awith exactly th
get:ahigher of the p
get:aThe precedence 
get:adefined in the 
get:aspecification t
get:athe security pa
get:auser group, and
get:aA connection at
get:alower precedenc
get:aa connection du
get:aacknowledgment 
get:aNote that TCP m
get:aprecedence will
get:asegments and po
get:aThe security pa
get:a(the values wou
get:anon-secure envi
get:aparameters, tho
get:a3.7.  Data Commun
get:aOnce the connec
get:aexchange of seg
get:a(checksum test 
get:aretransmission 
get:aDuplicate segme
get:aAs discussed in
get:acertain tests o
get:asegments to ver
get:aThe sender of d
get:athe variable SN
get:asequence number
get:akeeps track of 
get:avariable SND.UN
get:asent has been a
get:aWhen the sender
get:aSND.NXT.  When 
get:asends an acknow
get:a[Page 40]        
get:aSeptember 1981   
get:aacknowledgment 
get:athese variables
get:aThe amount by w
get:adata in the seg
get:asegments must c
get:aThe CLOSE user 
get:aflag in an inco
get:aRetransmission 
get:aBecause of the 
get:ainternetwork sy
get:aretransmission 
get:afor determining
get:aAn Example Re
get:aMeasure the
get:aparticular 
get:acovers that
get:asegments re
get:aTime (RTT).:  Next compute a Smoothed Round Trip Time (SRTT) as
get:aSRTT = ( 
get:aand based o:n this, compute the retransmission timeout (RTO) as
get:aRTO = min
get:awhere UBOUN
get:aLBOUND is a
get:aa smoothing
get:afactor (e.g
get:aThe Communicati
get:aThe objective o
get:ato stimulate th
get:apermit the rece
get:athe currently k
get:aThis mechanism 
get:athe end of urge
get:athe receive seq
get:amust tell the u
get:anumber catches 
get:aTransmission Cont
get:aFunctional Specif
get:ainto "normal mo
get:ais in "urgent m
get:aThe method empl
get:atransmitted.  T
get:ameaningful and 
get:athe urgent poin
get:ano urgent data 
get:aTo send an urge
get:aoctet.  If the 
get:athe urgent info
get:aManaging the Wi
get:aThe window sent
get:anumbers the sen
get:aprepared to acc
get:athe currently a
get:aIndicating a la
get:aarrives than ca
get:ain excessive re
get:anetwork and the
get:atransmission of
get:abetween each ne
get:aThe mechanisms 
get:asubsequently ad
get:athat much data.
get:adiscouraged.  T
get:ashrink the wind
get:aon the part of 
get:aThe sending TCP
get:aleast one octet
get:asending TCP mus
get:athe window is z
get:ainterval when t
get:aguarantee that 
get:awindow will be 
get:aWhen the receiv
get:astill send an a
get:aand current win
get:aThe sending TCP
get:a[Page 42]        
get:aSeptember 1981   
get:awhich fit the c
get:aretransmission 
get:aIn a connection
get:abe carried in a
get:anumber so there
get:aorder.  This is
get:ainformation to 
get:athe data receiv
get:athe window info
get:aacknowledgment 
get:aequal or greate
get:aThe window mana
get:acommunication p
get:aWindow Manage
get:aAllocating 
get:amany small 
get:afewer large
get:aOne suggest
get:adefer updat
get:aleast X per
get:aconnection 
get:aAnother sug
get:asegments by
get:asending dat
get:adata must b
get:aNote that t
get:aretransmiss
get:aacknowledgm
get:awindow info
get:anew window 
get:aThe segment
get:aof transmit
get:asegment con
get:ais accepted
get:aIf the send
get:awindow is n
get:aalternating
get:apauses in t
get:aTransmission Cont
get:aFunctional Specif
get:aresult in b
get:abig pair. A
get:amostly smal
get:aThe suggest
get:aactively at
get:awindows, si
get:ato many sma
get:aThere are of co:urse two interfaces of concern
get:aand the TCP/low
get:aof the user/TCP
get:aprotocol module
get:ain detail by th
get:acase that the l
get:athat TCPs might
get:aUser/TCP Interf
get:aThe following
get:aat best, fict
get:afacilities.  
get:aimplementatio
get:aTCPs must pro
get:athat all TCP 
get:ahierarchy.  T
get:arequired of a
get:aTCP User Comm
get:aThe followi
get:ainterface. 
get:afunction ca
get:ameant to ru
get:aThe user co
get:aTCP must pe
get:aIndividual 
get:amay provide
get:asingle call
get:aautomatical
get:aissued by t
get:a[Page 44]        
get:aSeptember 1981   
get:aIn providin
get:anot only ac
get:aprocesses i:t serves.  The latter consists of
get:a(a) gener
get:aremote cl
get:a(b) repli
get:avarious t
get:aFormat:  
get:a[, timeou
get:a-> local 
get:aWe assume
get:aprocesses
get:ato use th
get:aimplement
get:afor the s
get:alower lev
get:aresult of
get:aable to m
get:aprocess c
get:aIf the ac
get:acall to L
get:ahave eith
get:aparticula
get:afor any c
get:aby the su
get:aA transmi
get:afilled in
get:aOn an act
get:asynchroni
get:aThe timeo
get:afor all d
get:adelivered
get:awill abor
get:aThe TCP o
get:athe users
get:aTransmission Cont
get:aFunctional Specif
get:aprecedenc
get:aor securi
get:athe defau
get:aTCP will 
get:asecurity/
get:athe prece
get:arequested
get:aThe prece
get:arequested
get:arequest, 
get:aconnectio
get:athis prec
get:aallowed t
get:aor that a
get:aA local c
get:aThe local
get:afor the c
get:aFormat:  
get:acount, PU
get:aThis call
get:ato be sen
get:anot been 
get:aimplement
get:aautomatic
get:aauthorize
get:aIf the PU
get:ato the re
get:asegment c
get:athe data 
get:atransmiss
get:aIf the UR
get:awill have
get:athe urgen
get:apointer i
get:abeen cons
get:ais to sti
get:aindicate 
get:a[Page 46]        
get:aSeptember 1981   
get:adata has 
get:aTCP signa
get:aof times 
get:aurgent da
get:aIf no for
get:aconnectio
get:ahas becom
get:alocal soc
get:aforeign s
get:aforeign s
get:aknowing t
get:aHowever, 
get:abecomes s
get:aSTATUS ca
get:aimplement
get:asocket is
get:aIf a time
get:aconnectio
get:aIn the si
get:athe sendi
get:aor the ti
get:ais both s
get:aconnectio
get:aoffers po
get:asophistic
get:athe proce
get:afurthermo
get:aMultiple 
get:athe TCP w
get:aWe have i
get:awhich a S
get:apseudo-in
get:areturn a 
get:aimmediate
get:abeen ackn
get:aassume ev
get:aclose any
get:akind (syn
get:asignals, 
get:awith spec
get:aIn order 
get:aindicatio
get:aTransmission Cont
get:aFunctional Specif
get:abuffer ad
get:athe SEND 
get:aindicatin
get:acalling p
get:aFormat:  
get:acount) ->
get:aThis comm
get:aspecified
get:acalling p
get:aerror is 
get:aIn the si
get:acalling p
get:aerror occ
get:aA more so
get:aRECEIVEs 
get:asegments 
get:athe cost 
get:anotify th
get:aIf enough
get:athe PUSH 
get:aThe buffe
get:aa PUSH is
get:areturned 
get:aIf there 
get:aas it arr
get:ashould th
get:aadditiona
get:acall to R
get:amay now l
get:aurgent po
get:ain the sa
get:aboundary 
get:aTo distin
get:acare of t
get:areturn co
get:acount ind
get:aAlternati
get:a[Page 48]        
get:aSeptember 1981   
get:aallocate 
get:awith the 
get:aFormat:  
get:aThis comm
get:athe conne
get:aauthorize
get:aClosing c
get:athe sense
get:aretransmi
get:aserviced.
get:acalls, fo
get:ato the de
get:acontinue 
get:amay be tr
get:ameans "I 
get:areceive a
get:anot well 
get:aof all it
get:ainto ABOR
get:aThe user 
get:ainitiativ
get:a(e.g., re
get:adestinati
get:aBecause c
get:aforeign T
get:ashort tim
get:areplies t
get:aClose als
get:aFormat:  
get:aThis is a
get:aexcluded 
get:atypically
get:aThis comm
get:ainformati:on
get:alocal s
get:aTransmission Cont
get:aFunctional Specif
get:aforeign
get:alocal c
get:areceive
get:asend wi
get:aconnect
get:anumber 
get:anumber 
get:aurgent 
get:aprecede
get:asecurit
get:aand tra
get:aDepending
get:aimplement
get:aavailable
get:aauthorize
get:aprevents 
get:aconnectio
get:aFormat:  
get:aThis comm
get:aaborted, 
get:abe sent t
get:aDepending
get:aindicatio
get:areceive a
get:aTCP-to-User M
get:aIt is assum
get:ameans for t
get:athe TCP doe
get:ato the user
get:aan error me
get:arelating to
get:aother user 
get:aThe followi:ng information is provided
get:aLocal Con
get:aResponse 
get:aBuffer Ad
get:aByte coun
get:aPush flag
get:aUrgent fl
get:a[Page 50]        
get:aSeptember 1981   
get:aTCP/Lower-Level
get:aThe TCP calls
get:areceive infor
get:ainternetwork 
get:aProtocol (IP)
get:aIf the lower 
get:aof service an
get:afor these par:ameters
get:aType of Ser:vice = Precedence: routine, Delay: normal, Throughput
get:anormal, Rel:iability
get:aTime to Liv
get:aNote that
get:aHere we e
get:abe delive
get:aIf the lower 
get:afeature) and 
get:aroute informa
get:aso that the s
get:achecksum be t
get:aalso importan
get:aAny lower lev
get:adestination a
get:athe "TCP leng
get:aof IP and to 
get:aTransmission Cont
get:aFunctional Specif
get:a3.9.  Event Proce
get:aThe processing 
get:aimplementation.
get:aprocessing sequ
get:asection only in
get:aThe activity of
get:aThe events that: occur can be cast into three categories
get:aarriving segmen
get:aprocessing the 
get:acases the proce
get:aEvents that o:ccur
get:aArriving Se
get:aSEGMENT A
get:aUSER TIME
get:aRETRANSMI
get:aTIME-WAIT
get:aThe model of th
get:aimmediate retur
get:apseudo interrup
get:ameans cause a d
get:aError responses
get:acommands refere:ncing connections that do not exist receive "error
get:aconnection not 
get:aPlease note in 
get:aacknowledgment 
get:aof the sequence
get:aequal to (modul
get:a[Page 52]        
get:aSeptember 1981   
get:aA natural way t
get:aimagine that th
get:athat their cont
get:ain the sequence
get:aand processed i
get:aWhen a segment 
get:athe segment to 
get:ato be consisten
get:aNote that if no
get:aTransmission Cont
get:aFunctional Specif
get:aCLOSED STATE 
get:aCreate a ne
get:astate infor
get:asocket, pre
get:ainformation
get:aunspecified
get:aparameters 
get:aprecedence 
get:a"error:  pr:ecedence not allowed" or "error
get:anot allowed
get:aactive and :the foreign socket is unspecified, return "error
get:aforeign soc
get:aspecified, 
get:a(ISS) is se
get:ais sent.  S
get:astate, and 
get:aIf the call
get:areturn "err:or
get:ano room to :create a new connection, return "error
get:aresources".
get:aIf active a
get:aconnection 
get:asegment, se
get:astate.  Dat
get:aqueued for 
get:aurgent bit 
get:asegments se
get:aqueue the r:equest, respond with "error
get:aIf Foreign :socket was not specified, then return "error
get:asocket unsp
get:a[Page 54]        
get:aSeptember 1981   
get:aSYN-SENT STAT
get:aSYN-RECEIVED 
get:aESTABLISHED S
get:aFIN-WAIT-1 ST
get:aFIN-WAIT-2 ST
get:aCLOSE-WAIT ST
get:aCLOSING STATE
get:aLAST-ACK STAT
get:aTIME-WAIT STA
get:aReturn "err:or
get:aTransmission Cont
get:aFunctional Specif
get:aCLOSED STATE 
get:aIf the user
get:a"error:  co
get:aOtherwise, :return "error
get:aIf the fore
get:afrom passiv
get:aSND.UNA to 
get:aassociated 
get:atransmissio
get:arequested i
get:aas a result
get:arequest, re:spond with "error
get:aForeign soc:ket was not specified, then return "error
get:asocket unsp
get:aSYN-SENT STAT
get:aSYN-RECEIVED 
get:aQueue the d
get:aIf no space: to queue, respond with "error
get:aresources".
get:aESTABLISHED S
get:aCLOSE-WAIT ST
get:aSegmentize 
get:aacknowledgm
get:ainsufficien:t space to remember this buffer, simply return "error
get:ainsufficien
get:aIf the urge
get:aurgent poin
get:a[Page 56]        
get:aSeptember 1981   
get:aFIN-WAIT-1 ST
get:aFIN-WAIT-2 ST
get:aCLOSING STATE
get:aLAST-ACK STAT
get:aTIME-WAIT STA
get:aReturn "err:or
get:aTransmission Cont
get:aFunctional Specif
get:aCLOSED STATE 
get:aIf the user
get:a"error:  co
get:aOtherwise r:eturn "error
get:aSYN-SENT STAT
get:aSYN-RECEIVED 
get:aQueue for p
get:ais no room :to queue this request, respond with "error
get:ainsufficien
get:aESTABLISHED S
get:aFIN-WAIT-1 ST
get:aFIN-WAIT-2 ST
get:aIf insuffic
get:arequest, qu
get:aremember th:e RECEIVE, respond with "error
get:aresources".
get:aReassemble 
get:ato user.  M
get:aIf RCV.UP i
get:auser notify
get:aWhen the TC
get:athat fact m
get:aacknowledgm
get:adescribed b
get:a[Page 58]        
get:aSeptember 1981   
get:aCLOSE-WAIT ST
get:aSince the r
get:asatisfied b
get:auser.  If n
get:a"error:  co
get:atext can be
get:aCLOSING STATE
get:aLAST-ACK STAT
get:aTIME-WAIT STA
get:aReturn "err:or
get:aTransmission Cont
get:aFunctional Specif
get:aCLOSED STATE 
get:aIf the user
get:a"error:  co
get:aOtherwise, :return "error
get:aAny outstan:ding RECEIVEs are returned with "error
get:aresponses. 
get:aSYN-SENT STAT
get:aDelete the :TCB and return "error
get:aqueued SEND
get:aSYN-RECEIVED 
get:aIf no SENDs
get:athen form a
get:aotherwise q
get:aESTABLISHED S
get:aQueue this 
get:aform a FIN 
get:aFIN-WAIT-1 ST
get:aFIN-WAIT-2 ST
get:aStrictly sp:eaking, this is an error and should receive a "error
get:aconnection 
get:aacceptable,
get:aFIN may be 
get:a[Page 60]        
get:aSeptember 1981   
get:aCLOSE-WAIT ST
get:aQueue this 
get:asegmentized
get:aCLOSING STATE
get:aLAST-ACK STAT
get:aTIME-WAIT STA
get:aRespond wit:h "error
get:aTransmission Cont
get:aFunctional Specif
get:aCLOSED STATE 
get:aIf the user
get:a"error:  co
get:aOtherwise r:eturn "error
get:aAny outstan:ding RECEIVEs should be returned with "error
get:aconnection 
get:aSYN-SENT STAT
get:aAll queued 
get:anotificatio
get:aSYN-RECEIVED 
get:aESTABLISHED S
get:aFIN-WAIT-1 ST
get:aFIN-WAIT-2 ST
get:aCLOSE-WAIT ST
get:aSend a rese:t segment
get:a<SEQ=SND.
get:aAll queued 
get:anotificatio
get:aRST formed 
get:aTCB, enter 
get:aCLOSING STATE
get:aLAST-ACK STAT
get:aTIME-WAIT STA
get:aRespond wit
get:a[Page 62]        
get:aSeptember 1981   
get:aCLOSED STATE 
get:aIf the user
get:a"error:  co
get:aOtherwise r:eturn "error
get:aReturn "sta
get:aSYN-SENT STAT
get:aReturn "sta
get:aSYN-RECEIVED 
get:aReturn "sta
get:aESTABLISHED S
get:aReturn "sta
get:aFIN-WAIT-1 ST
get:aReturn "sta
get:aFIN-WAIT-2 ST
get:aReturn "sta
get:aCLOSE-WAIT ST
get:aReturn "sta
get:aCLOSING STATE
get:aReturn "sta
get:aLAST-ACK STAT
get:aReturn "sta
get:aTransmission Cont
get:aFunctional Specif
get:aTIME-WAIT STA
get:aReturn "sta
get:a[Page 64]        
get:aSeptember 1981   
get:aSEGMENT ARRIVES
get:aIf the state 
get:aall data in
get:asegment con
get:acontaining 
get:aacknowledgm
get:areset seque
get:aIf the ACK 
get:a<SEQ=0><A
get:aIf the ACK 
get:a<SEQ=SEG.
get:aIf the state 
get:afirst check
get:aAn incomi
get:asecond chec
get:aAny ackno
get:athe LISTE
get:afor any a
get:aformatted: as follows
get:a<SEQ=SE
get:athird check
get:aIf the SY
get:asecurity/
get:amatch the
get:a<SEQ=SE
get:aTransmission Cont
get:aFunctional Specif
get:aIf the SE
get:athe user 
get:asend a re
get:a<SEQ=SE
get:aIf the SE
get:aSet RCV.N
get:acontrol o
get:ashould be: selected and a SYN segment sent of the form
get:a<SEQ=IS
get:aSND.NXT i
get:astate sho
get:aincoming 
get:ain the SY
get:anot be re
get:athe forei
get:aunspecifi
get:afourth othe
get:aAny other
get:amust have
get:aprocessin
get:ait could 
get:aincarnati
get:abut if yo
get:aIf the state 
get:afirst check
get:aIf the AC
get:aIf SEG.
get:athe RST
get:a<SEQ=
get:aand dis
get:aIf SND.
get:asecond chec
get:a[Page 66]        
get:aSeptember 1981   
get:aIf the RS
get:aIf the :ACK was acceptable then signal the user "error
get:aconnect
get:adelete 
get:aand ret
get:athird check
get:aIf the se
get:amatch the
get:aIf ther
get:a<SEQ=
get:aOtherwi
get:a<SEQ=
get:aIf there 
get:aThe pre
get:aTCB, if
get:a<SEQ=
get:aIf there 
get:aIf the 
get:ain the 
get:athe pre
get:aallowed
get:a<SEQ=
get:aIf the 
get:ain the 
get:aIf a rese
get:afourth chec
get:aThis step
get:ano ACK, a
get:aIf the SY
get:aTransmission Cont
get:aFunctional Specif
get:aare accep
get:aSEG.SEQ. 
get:ais an ACK
get:aare there
get:aIf SND.UN
get:astate to 
get:a<SEQ=SN
get:aand send 
get:atransmiss
get:atext in t
get:abelow whe
get:aOtherwise
get:a<SEQ=IS
get:aand send 
get:asegment, 
get:ahas been 
get:afifth, if n
get:asegment and
get:a[Page 68]        
get:aSeptember 1981   
get:afirst check s
get:aSYN-RECEIVE
get:aESTABLISHED
get:aFIN-WAIT-1 
get:aFIN-WAIT-2 
get:aCLOSE-WAIT 
get:aCLOSING STA
get:aLAST-ACK ST
get:aTIME-WAIT S
get:aSegments 
get:aare used 
get:adone in S
get:aboundary 
get:aprocessed
get:aThere are
get:asegment
get:aSegment R
get:aLength  W
get:a------- -
get:a0     
get:a0     
get:a>0     
get:a>0     
get:aIf the RC
get:aspecial a
get:aIf an inc
get:ashould be
get:athe segme:nt and return)
get:a<SEQ=SN
get:aAfter sen
get:aand retur
get:aTransmission Cont
get:aFunctional Specif
get:aIn the fo
get:asegment t
get:aOne could
get:atrimming 
get:aSYN and F
get:abegins at
get:anumbers m
get:asecond check 
get:aSYN-RECEIVE
get:aIf the RS
get:aIf this
get:acame fr
get:aLISTEN 
get:athis co
get:afrom SY
get:athe use
get:aon the 
get:aactive 
get:aand ret
get:aESTABLISHED
get:aIf the RS
get:ashould re
get:aflushed. 
get:a"connecti
get:aTCB, and 
get:aCLOSING STA
get:aLAST-ACK ST
get:aIf the RS
get:aTCB, and 
get:a[Page 70]        
get:aSeptember 1981   
get:athird check s
get:aSYN-RECEIVE
get:aIf the se
get:aexactly m
get:athen send
get:aESTABLISHED
get:aIf the se
get:aexactly m
get:athen send
get:areceive "
get:aflushed. 
get:a"connecti
get:aTCB, and 
get:aNote this c
get:aa segment f
get:adifferent s
get:acurrent con
get:afourth, check
get:aSYN-RECEIVE
get:aESTABLISHED
get:aFIN-WAIT ST
get:aFIN-WAIT ST
get:aCLOSE-WAIT 
get:aCLOSING STA
get:aLAST-ACK ST
get:aTIME-WAIT S
get:aIf the SY
get:aoutstandi
get:aall segme
get:areceive a
get:athe CLOSE
get:aIf the SY
get:aand an ac
get:anumber ch
get:aTransmission Cont
get:aFunctional Specif
get:afifth check t
get:aif the ACK 
get:aif the ACK 
get:aSYN-RECEI
get:aIf SND.
get:aand con
get:aIf th
get:areset
get:a<SE
get:aand s
get:aESTABLISH
get:aIf SND.
get:aAny seg
get:aentirel
get:apositiv
get:afully a
get:a"ok" re
get:a(SEG.AC
get:asomethi
get:adrop th
get:aIf SND.
get:aupdated
get:aSND.WL2
get:aSND.WL1
get:aNote th
get:arecords
get:aSND.WND
get:athe las
get:aprevent
get:a[Page 72]        
get:aSeptember 1981   
get:aFIN-WAIT-
get:aIn addi
get:aour FIN
get:aprocess
get:aFIN-WAIT-
get:aIn addi
get:athe ret
get:aacknowl
get:aCLOSE-WAI
get:aDo the 
get:aCLOSING S
get:aIn addi
get:athe ACK
get:aotherwi
get:aLAST-ACK 
get:aThe onl
get:aacknowl
get:adelete 
get:aTIME-WAIT
get:aThe onl
get:aretrans
get:athe 2 M
get:asixth, check 
get:aESTABLISHED
get:aFIN-WAIT-1 
get:aFIN-WAIT-2 
get:aIf the UR
get:athe user 
get:apointer (
get:auser has 
get:amode") fo
get:asignal th
get:aTransmission Cont
get:aFunctional Specif
get:aCLOSE-WAIT 
get:aCLOSING STA
get:aLAST-ACK ST
get:aThis shou
get:aremote si
get:aseventh, proc
get:aESTABLISHED
get:aFIN-WAIT-1 
get:aFIN-WAIT-2 
get:aOnce in t
get:atext to u
get:ainto buff
get:aempty.  I
get:athe user 
get:ahas been 
get:aWhen the 
get:auser it m
get:aOnce the 
get:aRCV.NXT o
get:aapporopri
get:aRCV.NXT a
get:aPlease no
get:aSend an a:cknowledgment of the form
get:a<SEQ=SN
get:aThis ackn
get:atransmitt
get:a[Page 74]        
get:aSeptember 1981   
get:aCLOSE-WAIT 
get:aCLOSING STA
get:aLAST-ACK ST
get:aTIME-WAIT S
get:aThis shou
get:aremote si
get:aeighth, check
get:aDo not proc
get:asince the S
get:aIf the FIN 
get:areturn any 
get:aover the FI
get:aFIN implies
get:aSYN-RECEI
get:aESTABLISH
get:aEnter t
get:aFIN-WAIT-
get:aIf our 
get:aenter T
get:atimers;
get:aFIN-WAIT-
get:aEnter t
get:aoff the
get:aCLOSE-WAI
get:aRemain 
get:aCLOSING S
get:aRemain 
get:aLAST-ACK 
get:aRemain 
get:aTransmission Cont
get:aFunctional Specif
get:aTIME-WAIT
get:aRemain 
get:atimeout
get:a[Page 76]        
get:aSeptember 1981   
get:aFor any state
get:athe user "err:or
get:aand for any o
get:astate and ret
get:aRETRANSMISSION 
get:aFor any state
get:athe retransmi
get:aretransmissio
get:aTIME-WAIT TIMEO
get:aIf the time-w
get:aenter the CLO
get:aTransmission Cont
get:a[Page 78]        
get:aSeptember 1981   
get:aBBN Rep
get:aa Host 
get:ahost an
get:aA contr
get:aindicat
get:aspecifi
get:ais expe
get:apreviou
get:aThe uni
get:aARPANET
get:aA unit 
get:aIMPs.  
get:aA logic
get:aA messa
get:anetwork
get:aDestination Addre
get:aThe des
get:aidentif
get:aA contr
get:aindicat
get:aoccupyi
get:aA porti
get:afragmen
get:aA file 
get:aTransmission Cont
get:aControl
get:afragmen
get:aA compu
get:afrom th
get:aAn Inte
get:aby the 
get:aThe Int
get:aARPANET
get:aA sourc
get:ainternet datagram
get:aThe uni
get:ahigher 
get:ainternet fragment
get:aA porti
get:aheader.
get:aInterne
get:aThe Ini
get:anumber 
get:aThe Ini
get:aon a co
get:abased p
get:aThe Ini
get:aused by
get:aControl
get:adata.  
get:aon an A
get:a[Page 80]        
get:aSeptember 1981   
get:aThis is
get:adata re
get:asequenc
get:aof the 
get:aThe uni
get:aAn impl
get:aprocedu
get:aMaximum
get:athe int
get:aAn eigh
get:aAn Opti
get:amay be 
get:aprimari
get:atimesta
get:aoptions
get:aA packa
get:alogical
get:alogical
get:aThe por
get:aoutput 
get:aA progr
get:athe poi
get:aA contr
get:athis se
get:areceivi
get:areceive
get:aTransmission Cont
get:areceive
get:areceive
get:areceive next sequ
get:aThis is
get:areceive
get:aThis re
get:ais will
get:asegment
get:aRCV.NXT
get:aSegment
get:arange a
get:aA contr
get:athat th
get:ainterac
get:asequenc
get:asegment
get:ait.  In
get:arise to
get:aReal Ti:me Protocol
get:aof time
get:asegment
get:asegment
get:asegment
get:asegment
get:asegment
get:a[Page 82]        
get:aSeptember 1981   
get:asegment
get:aA logic
get:aunit of
get:asegment acknowled
get:aThe seq
get:aarrivin
get:aThe amo
get:aincludi
get:aThe num
get:aThis is
get:ause on 
get:ainitial
get:aeach oc
get:aThis re
get:a(receiv
get:awindow 
get:areceivi
get:abe emit
get:aSND.UNA
get:abetween
get:asend se
get:aleft se
get:asend ur
get:asegment
get:asegment
get:aTransmission Cont
get:asend wi
get:aAn addr
get:ais, the
get:aThe sou
get:aA contr
get:anumber,
get:awhere t
get:aTransmi
get:athe sta
get:aThe pre
get:aTransmi:ssion Control Protocol
get:areliabl
get:aType of
get:aAn Inte
get:afor thi
get:aA contr
get:aindicat
get:aurgent 
get:asequenc
get:apointer
get:aA contr
get:afield c
get:aindicat
get:aurgent 
get:a[Page 84]        
get:aSeptember 1981   
get:a[1]  Cerf, V., an
get:aIntercommuni
get:aVol. COM-22,
get:a[2]  Postel, J. (
get:aProtocol Spe
get:aInstitute, S
get:a[3]  Dalal, Y. an
get:aProtocols", 
get:aDecember 197
get:a[4]  Postel, J., 
get:aInstitute, S
get:bRFC
get:bDe
get:bI
get:bSeptember 1981   
get:bPREFACE .....
get:b1.  INTRODUCTION 
get:b1.1  Motivation
get:b1.2  Scope ....
get:b1.3  About This
get:b1.4  Interfaces
get:b1.5  Operation 
get:b2.  PHILOSOPHY ..
get:b2.1  Elements o
get:b2.2  Model of O
get:b2.3  The Host E
get:b2.4  Interfaces
get:b2.5  Relation t
get:b2.6  Reliable C
get:b2.7  Connection
get:b2.8  Data Commu
get:b2.9  Precedence
get:b2.10 Robustness
get:b3.  FUNCTIONAL SP
get:b3.1  Header For
get:b3.2  Terminolog
get:b3.3  Sequence N
get:b3.4  Establishi
get:b3.5  Closing a 
get:b3.6  Precedence
get:b3.7  Data Commu
get:b3.8  Interfaces
get:b3.9  Event Proc
get:bGLOSSARY ........
get:bREFERENCES ......
get:bTransmission Cont
get:b[Page ii]        
get:bSeptember 1981   
get:bThis document des
get:b(TCP).  There hav
get:bspecification on 
get:bdraws heavily fro
get:bboth in terms of 
get:bseveral details a
get:band redescribes t
get:bRFC
get:bReplaces: RFC 761
get:bIENs:  129, 124, 
get:b55, 44, 40, 27, 2
get:bThe Transmission 
get:breliable host-to-
get:bcommunication net
get:bThis document des
get:bTransmission Cont
get:binterface to prog
get:bComputer commun
get:brole in militar
get:bdocument focuse
get:bcommunication r
get:bcommunication u
get:bcongestion, but
get:bgovernment sect
get:bAs strategic an
get:bdeveloped and d
get:binterconnecting
get:bcommunication p
get:bapplications.  
get:bDeputy Undersec
get:bdeclared the Tr
get:bbe a basis for 
get:bstandardization
get:bTCP is a connec
get:bfit into a laye
get:bapplications.  
get:bcommunication b
get:bdistinct but in
get:bassumptions are
get:bprotocols below
get:bpotentially unr
get:bprotocols.  In 
get:bwide spectrum o
get:bconnections to 
get:bTransmission Cont
get:bTCP is based on
get:bTCP fits into a
get:bInternet Protoc
get:breceive variabl
get:bdatagram "envel
get:baddressing sour
get:binternet protoc
get:bthe TCP segment
get:bmultiple networ
get:balso carries in
get:band compartment
get:bcommunicated en
get:bMuch of this do
get:bwhich are co-re
get:bcomputer.  Some
get:bfront-end compu
get:bas well as netw
get:ban interface to
get:bimplementable e
get:bhost-to-front e
get:bThe TCP is inte
get:bcommunication s
get:bintended to be 
get:b1.3.  About this 
get:bThis document r
get:bany TCP impleme
get:bprotocols and i
get:b[Page 2]         
get:bSeptember 1981   
get:bsection offers 
get:boperation.  Sec
get:bdesign.  Sectio
get:brequired of TCP
get:buser calls, err
get:bThe TCP interfa
get:bthe other side 
get:bThe interface b
get:billustrated in 
get:bcalls much like
get:bapplication pro
get:bcalls to open a
get:bestablished con
get:basynchronously 
get:bconsiderable fr
get:binterfaces whic
get:benvironment, a 
get:binterface for a
get:bThe interface b
get:bunspecified exc
get:btwo levels can 
get:bTypically, one 
get:binterface.  TCP
get:binterconnected 
get:bthroughout this
get:bAs noted above,
get:bsecurable logic
get:bprocesses.  To 
get:bcommunication s:ystem requires facilities in the following areas
get:bBasic Data Tr
get:bPrecedence an
get:bThe basic opera
get:bthe following p
get:bTransmission Cont
get:bBasic Data Tran:sfer
get:bThe TCP is ab
get:bdirection bet
get:bsegments for 
get:bthe TCPs deci
get:bSometimes use
get:bsubmitted to 
get:bfunction is d
get:bactually tran
get:bpushed throug
get:bpromptly forw
get:bThe exact pus
get:bthe push func
get:bReliability
get:bThe TCP must 
get:bdelivered out
get:bis achieved b
get:btransmitted, 
get:breceiving TCP
get:binterval, the
get:bnumbers are u
get:bout of order 
get:badding a chec
get:breceiver, and
get:bAs long as th
get:bsystem does n
get:berrors will a
get:binternet comm
get:bFlow Control
get:bTCP provides 
get:bsent by the s
get:bevery ACK ind
get:bthe last segm
get:ballowed numbe
get:breceiving fur
get:b[Page 4]         
get:bSeptember 1981   
get:bMultiplexing
get:bTo allow for 
get:bcommunication
get:baddresses or 
get:band host addr
get:ba socket.  A 
get:bThat is, a so
get:bThe binding o
get:bHost.  Howeve
get:b(e.g., a "log
get:bmade known to
get:bthrough the k
get:baddresses of 
get:bConnections
get:bThe reliabili
get:bthat TCPs ini
get:beach data str
get:bsockets, sequ
get:bEach connecti
get:bidentifying i
get:bWhen two proc
get:bestablish a c
get:bside).  When 
get:bterminated or
get:bSince connect
get:bover the unre
get:bmechanism wit
get:berroneous ini
get:bPrecedence and :Security
get:bThe users of 
get:bcommunication
get:bthese feature
get:bTransmission Cont
get:b[Page 6]         
get:bSeptember 1981   
get:b2.1.  Elements of
get:bThe internetwor
get:bwhich are in tu
get:bthat the networ
get:blarge networks 
get:bpacket switchin
get:bconsume message
get:bnetworks, the g
get:bcommunication s
get:bconnections bet
get:bThe term packet
get:btransaction bet
get:bexchanged withi
get:bHosts are compu
get:bnetwork's point
get:bProcesses are v
get:baccordance with
get:bin execution). 
get:bviewed as commu
get:bThus, all commu
get:bSince a process
get:bstreams between
get:bthat each proce
get:bcommunicates wi
get:b2.2.  Model of Op
get:bProcesses trans
get:bdata as argumen
get:bsegments and ca
get:bthe destination
get:binto the receiv
get:bTCPs include co
get:bensure reliable
get:bThe model of in
get:bprotocol module
get:bto the local ne
get:binside internet
get:binternet module
get:bthrough the loc
get:bThe packet swit
get:bTransmission Cont
get:bother operation
get:bdestination int
get:bAt a gateway be
get:bfrom its local 
get:bthe internet da
get:bthen "wrapped" 
get:brouted to the n
get:bA gateway is pe
get:binternet datagr
get:bthrough the nex
get:binternet datagr
get:bfurther broken 
get:binternet datagr
get:binternet module
get:bA destination i
get:b(after reassemb
get:bdestination TCP
get:bThis simple mod
get:bimportant featu
get:bto the gateway 
get:bservice paramet
get:bIncluded in the
get:bdatagram.  Data
get:bhost and gatewa
get:bproperly segreg
get:b2.3.  The Host En
get:bThe TCP is assu
get:baccess the TCP 
get:bmay call on oth
get:bdata structures
get:bcontrolled by a
get:bnetwork device 
get:bdatagram protoc
get:bThe mechanisms 
get:bfront-end proce
get:bhost-to-front-e
get:bthe type of TCP
get:b[Page 8]         
get:bSeptember 1981   
get:bThe TCP/user in
get:bto OPEN or CLOS
get:bSTATUS about a 
get:bprograms on the
get:bfrom, and close
get:bThe TCP/interne
get:bdatagrams addre
get:bsystem.  These 
get:bservice, preced
get:b2.5.  Relation to
get:bThe following d
get:bhierarchy
get:b+------+ +
get:b|Telnet| |
get:b+------+ +
get:b|   
get:b+----
get:b| TCP
get:b+----
get:b| 
get:b+----
get:b|    
get:b+----
get:b+--
get:b|  
get:b+--
get:bIt is expected 
get:bprotocols effic
get:bprotocols like 
get:b2.6.  Reliable Co
get:bA stream of dat
get:border at the de
get:bTransmission Cont
get:bTransmission is
get:backnowledgments
get:bsequence number
get:bsegment is tran
get:bsequence number
get:bis the sequence
get:btransmissions i
get:bsegment contain
get:bstarts a timer;
get:bsegment is dele
get:breceived before
get:bAn acknowledgme
get:bdelivered to th
get:bthe responsibil
get:bTo govern the f
get:bemployed.  The 
get:bThis window spe
get:backnowledgment 
get:b2.7.  Connection 
get:bTo identify the
get:bprovides a port
get:bindependently b
get:bunique addresse
get:bidentifying the
get:bwill be unique 
get:bA connection is
get:blocal socket ma
get:bsockets.  A con
get:bthat is, it is 
get:bTCPs are free t
get:bHowever, severa
get:bThere must be w
get:bthe "appropriat
get:bmay "own" ports
get:bthe ports they 
get:bissue, but we e
get:buniquely alloca
get:bassociating the
get:bA connection is
get:bforeign socket 
get:b[Page 10]        
get:bSeptember 1981   
get:bconnection name
get:bsubsequent call
get:babout a connect
get:bis a data struc
get:bimplementation 
get:bpointer to the 
get:bwhether the con
get:bbe passively wa
get:bA passive OPEN 
get:bconnection requ
get:bOften the proce
get:brequest from an
get:bis used to deno
get:bare allowed onl
get:bA service proce
get:bprocesses would
get:bforeign socket.
get:brequested a con
get:blocal socket we
get:bWell-known sock
get:ba socket addres
get:b"Telnet-Server"
get:bsocket, and oth
get:bEntry, Text Gen
get:bbeing for test 
get:baccess to a "Lo
get:bat which a newl
get:bwell-known sock
get:bof sockets to s
get:bProcesses can i
get:bfrom other proc
get:bbeen establishe
get:bother at the sa
get:bis critical for
get:bcomponents act 
get:bThere are two p
get:bpassive OPENs a
get:blocal passive O
get:bcase, the match
get:bOPENs has left 
get:bforeign socket 
get:bOther possibili
get:bTransmission Cont
get:bIf there are se
get:bsame local sock
get:bwith the specif
get:bTCB exists, bef
get:bThe procedures 
get:bcontrol flag an
get:bexchange has be
get:bA connection is
get:bcontaining a SY
get:bcommand.  The m
get:bconnection has 
get:bwhen sequence n
get:bThe clearing of
get:bin this case ca
get:b2.8.  Data Commun
get:bThe data that f
get:boctets.  The se
get:bin that call (a
get:bthrough to the 
get:bA sending TCP i
get:bsend that data 
get:bfunction is sig
get:breceiving TCP s
get:bthe sending TCP
get:bThere is no nec
get:bboundaries.  Th
get:bsingle SEND cal
get:bThe purpose of 
get:bfrom the sendin
get:brecord service.
get:bThere is a coup
get:bof data that cr
get:bassociated with
get:bbuffer is retur
get:bnot filled.  If
get:bPUSH is seen, t
get:bTCP also provid
get:bat some point f
get:b[Page 12]        
get:bSeptember 1981   
get:bcurrently readi
get:bdefine what the
get:burgent data, bu
get:btake action to 
get:b2.9.  Precedence 
get:bThe TCP makes u
get:bsecurity option
get:bbasis to TCP us
get:ba multilevel se
get:buse only, and o
get:bcompartment.  C
get:busers may be li
get:bTCP modules whi
get:bproperly mark o
get:bprecedence.  Su
get:bhigher level pr
get:bthem to specify
get:bprecedence of c
get:b2.10.  Robustness
get:bTCP implementat:ions will follow a general principle of robustness
get:bconservative in
get:bTransmission Cont
get:b[Page 14]        
get:bSeptember 1981   
get:b3.1.  Header Form
get:bTCP segments ar
get:bheader carries 
get:bdestination hos
get:bheader, supplyi
get:bdivision allows
get:bTCP Header Form
get:b0            
get:b0 1 2 3 4 5 6
get:b+-+-+-+-+-+-+-
get:b|          Sou
get:b+-+-+-+-+-+-+-
get:b|             
get:b+-+-+-+-+-+-+-
get:b|             
get:b+-+-+-+-+-+-+-
get:b|  Data |     
get:b| Offset| Rese
get:b|       |     
get:b+-+-+-+-+-+-+-
get:b|           Ch
get:b+-+-+-+-+-+-+-
get:b|             
get:b+-+-+-+-+-+-+-
get:b|             
get:b+-+-+-+-+-+-+-
get:bNote th
get:bSource Port:  1
get:bThe source po
get:bDestination Por:t
get:bThe destinati
get:bTransmission Cont
get:bFunctional Specif
get:bSequence Number:
get:bThe sequence 
get:bwhen SYN is p
get:binitial seque
get:bAcknowledgment :Number
get:bIf the ACK co
get:bnext sequence
get:breceive.  Onc
get:bData Offset:  4
get:bThe number of
get:bthe data begi
get:bintegral numb
get:bReserved:  6 bi
get:bReserved for 
get:bControl Bits:  :6 bits (from left to right)
get:bURG:  Urgent 
get:bACK:  Acknowl
get:bPSH:  Push Fu
get:bRST:  Reset t
get:bSYN:  Synchro
get:bFIN:  No more
get:bWindow:  16 bit
get:bThe number of
get:backnowledgmen
get:bChecksum:  16 b
get:bThe checksum 
get:bcomplement su
get:bsegment conta
get:bchecksummed, 
get:bform a 16 bit
get:btransmitted a
get:bthe checksum 
get:bThe checksum 
get:b[Page 16]        
get:bSeptember 1981   
get:bprefixed to t
get:bAddress, the 
get:bThis gives th
get:binformation i
get:bacross the TC
get:bcalls by the 
get:bThe TCP Len
get:boctets (thi
get:bcomputed), 
get:bUrgent Pointer:
get:bThis field co
get:bpositive offs
get:burgent pointe
get:bthe urgent da
get:bthe URG contr
get:bOptions:  varia
get:bOptions may o
get:bmultiple of 8
get:bchecksum.  An
get:bcases for the: format of an option
get:bCase 1:  A 
get:bCase 2:  An
get:bth
get:bThe option-le
get:boption-length
get:bNote that the
get:bfield might i
get:bEnd-of-Option
get:bA TCP must im
get:bTransmission Cont
get:bFunctional Specif
get:bCurrently def:ined options include (kind indicated in octal)
get:bKind     Le
get:b----     --
get:b0         
get:b1         
get:b2         
get:bSpecific Opti
get:bEnd of Opti
get:b+--------
get:b|00000000
get:b+--------
get:bThis opti
get:bmight not
get:bthe Data 
get:bnot the e
get:bthe optio
get:bNo-Operatio
get:b+--------
get:b|00000001
get:b+--------
get:bThis opti
get:balign the
get:bThere is 
get:breceivers
get:bnot begin
get:bMaximum Seg
get:b+--------
get:b|00000010
get:b+--------
get:bKind=2  
get:b[Page 18]        
get:bSeptember 1981   
get:bMaximum S:egment Size Option Data
get:bIf this
get:breceive
get:bThis fi
get:b(i.e., 
get:boption 
get:bPadding:  varia
get:bThe TCP heade
get:band data begi
get:b3.2.  Terminology
get:bBefore we can d
get:bto introduce so
get:bconnection requ
get:bof these variab
get:bTransmission Co
get:bTCB are the loc
get:bprecedence of t
get:bbuffers, pointe
get:bIn addition sev
get:bsequence number
get:bSend Sequence
get:bSND.UNA - s
get:bSND.NXT - s
get:bSND.WND - s
get:bSND.UP  - s
get:bSND.WL1 - s
get:bSND.WL2 - s
get:bu
get:bISS     - i
get:bReceive Seque
get:bRCV.NXT - r
get:bRCV.WND - r
get:bRCV.UP  - r
get:bIRS     - i
get:bTransmission Cont
get:bFunctional Specif
get:bThe following d
get:bthe sequence sp
get:bSend Sequence S
get:b---
get:b1 - old s
get:b2 - seque
get:b3 - seque
get:b4 - futur
get:bThe send window
get:bReceive Sequenc
get:b1 - old s
get:b2 - seque
get:b3 - futur
get:bThe receive win
get:bThere are also 
get:btake their valu
get:b[Page 20]        
get:bSeptember 1981   
get:bCurrent Segme
get:bSEG.SEQ - s
get:bSEG.ACK - s
get:bSEG.LEN - s
get:bSEG.WND - s
get:bSEG.UP  - s
get:bSEG.PRC - s
get:bA connection pr
get:blifetime.  The :states are
get:bESTABLISHED, FI
get:bTIME-WAIT, and 
get:bbecause it repr
get:bno connection. : Briefly the meanings of the states are
get:bLISTEN - repr
get:bTCP and port.
get:bSYN-SENT - re
get:bafter having 
get:bSYN-RECEIVED 
get:brequest ackno
get:bconnection re
get:bESTABLISHED -
get:bdelivered to 
get:bof the connec
get:bFIN-WAIT-1 - 
get:bfrom the remo
get:btermination r
get:bFIN-WAIT-2 - 
get:bfrom the remo
get:bCLOSE-WAIT - 
get:bfrom the loca
get:bCLOSING - rep
get:backnowledgmen
get:bLAST-ACK - re
get:bconnection te
get:b(which includ
get:bTransmission Cont
get:bFunctional Specif
get:bTIME-WAIT - r
get:bthe remote TC
get:btermination r
get:bCLOSED - repr
get:bA TCP connectio
get:bevents.  The ev
get:bABORT, and STAT
get:bcontaining the 
get:bThe state diagr
get:bwith the causin
get:berror condition
get:bchanges.  In a 
get:bthe reaction of
get:bNOTE BENE:  thi
get:bthe total speci
get:b[Page 22]        
get:bSeptember 1981   
get:b+---------+     
get:b|         |<----
get:b|   SYN   |     
get:b|   RCVD  |<----
get:b|         |     
get:b|         |-----
get:b+---------+   rc
get:b|           --
get:b|             
get:b|             
get:b|  CLOSE      
get:b| -------     
get:b| snd FIN     
get:b|             
get:bV             
get:b+---------+     
get:b|  FIN    |<----
get:b| WAIT-1  |-----
get:b+---------+     
get:b| rcv ACK of F
get:b| ------------
get:bV        x    
get:b+---------+     
get:b|FINWAIT-2|     
get:b+---------+     
get:b|             
get:b|  rcv FIN    
get:b|  -------    
get:b\ snd ACK    
get:b------------
get:bTransmission Cont
get:bFunctional Specif
get:b3.3.  Sequence Nu
get:bA fundamental n
get:bover a TCP conn
get:bsequenced, each
get:bmechanism emplo
get:bnumber X indica
get:breceived.  This
get:bdetection in th
get:bwithin a segmen
get:bthe header is t
get:bnumbered consec
get:bIt is essential
get:bfinite, though 
get:bSince the space
get:bnumbers must be
get:bpreserves the r
get:b2**32 - 1 to 0 
get:barithmetic, so 
get:bcomparison of s
get:b(modulo 2**32).
get:bThe typical kin
get:bperform include:
get:b(a)  Determin
get:bnumber s
get:b(b)  Determin
get:bhave bee
get:bretransm
get:b(c)  Determin
get:bwhich ar
get:breceive 
get:b[Page 24]        
get:bSeptember 1981   
get:bIn response to 
get:bfollowing compa
get:bSND.UNA = old
get:bSND.NXT = nex
get:bSEG.ACK = ack
get:bnum
get:bSEG.SEQ = fir
get:bSEG.LEN = the
get:b(co
get:bSEG.SEQ+SEG.L
get:bA new acknowled
get:bthe inequality :below holds
get:bSND.UNA < SEG
get:bA segment on th
get:bof its sequence
get:backnowledgment 
get:bWhen data is re:ceived the following comparisons are needed
get:bRCV.NXT = nex
get:bis the le
get:bRCV.NXT+RCV.W
get:bsegment, 
get:bSEG.SEQ = fir
get:bSEG.SEQ+SEG.L
get:bA segment is ju
get:bRCV.NXT =< SE
get:bRCV.NXT =< SE
get:bTransmission Cont
get:bFunctional Specif
get:bThe first part 
get:bsegment falls i
get:bif the end of t
get:beither part of 
get:bActually, it is
get:bwindows and zer
get:bacceptability o:f an incoming segment
get:bSegment Recei
get:bLength  Windo
get:b------- -----
get:b0       0 
get:b0      >0 
get:b>0       0 
get:b>0      >0 
get:bNote that when 
get:bacceptable exce
get:bmaintain a zero
get:bACKs.  However,
get:bprocess the RST
get:bWe have taken a
get:bcontrol informa
get:bsome control fl
get:band acknowledge
get:bcontrol will be
get:bcarried in the 
get:bfor implicitly 
get:bare the only co
get:bare used only a
get:bpurposes, the S
get:boctet of the se
get:bto occur after 
get:boccurs.  The se
get:bspace occupying
get:bsequence number
get:b[Page 26]        
get:bSeptember 1981   
get:bInitial Sequenc
get:bThe protocol pl
get:bused over and o
get:bsockets.  New i
get:bincarnations of
get:b-- "how does th
get:bincarnations of
get:bconnection is b
get:bconnection brea
get:bTo avoid confus
get:bconnection from
get:bbe present in t
get:bassure this, ev
get:bsequence number
get:ban initial sequ
get:bnew 32 bit ISN.
get:bbit clock whose
get:bmicroseconds.  
get:bSince we assume
get:bthe Maximum Seg
get:bhours we can re
get:bFor each connec
get:bsequence number
get:bthe data sendin
get:blearned during 
get:bFor a connectio
get:bsynchronize on 
get:ban exchange of 
get:bcalled "SYN" (f
get:bshorthand, segm
get:bHence, the solu
get:binitial sequenc
get:bThe synchroniza
get:bsequence number
get:bfrom the other 
get:binitial sequenc
get:b1) A --> B  S
get:b2) A <-- B  A
get:b3) A <-- B  S
get:b4) A --> B  A
get:bTransmission Cont
get:bFunctional Specif
get:bBecause steps 2
get:bcalled the thre
get:bA three way han
get:btied to a globa
get:bmechanisms for 
get:bno way of knowi
get:bunless it remem
get:b(which is not a
get:bverify this SYN
get:bclock-driven sc
get:bKnowing When to
get:bTo be sure that
get:bsequence number
get:bthe network, th
get:b(MSL) before as
get:brecovering from
get:blost.  For this
get:bis an engineeri
get:bit is desirable
get:bsense, yet reta
get:bnot wait at all
get:bthan those rece
get:bThe TCP Quiet T
get:bThis specific
get:bretaining any
get:beach active (
get:bTCP segments 
get:bin the intern
get:bparagraphs be
get:bTCP implement
get:bat the risk o
get:bdata rejected
get:bTCPs consume 
get:bentered into 
get:bduplicate det
get:brelies on the
get:bthe extent th
get:bvalues before
get:bbeen delivere
get:bcopies of the
get:bsuch an assum
get:b[Page 28]        
get:bSeptember 1981   
get:bassigned the 
get:bat the receiv
get:bthat each seg
get:bas there are 
get:bUnder normal 
get:bto emit and t
get:bmistakenly us
get:bbeen acknowle
get:bdata is drain
get:bvery large to
get:bcause trouble
get:bto use up 2**
get:blifetime in t
get:bthis is deeme
get:brates escalat
get:bcycle time is
get:bwithin reason
get:bThe basic dup
get:bdefeated, how
get:bsequence numb
get:bthe TCP were 
get:bupon crashing
get:bconnection (p
get:bpackets with 
get:bpackets still
get:bincarnation o
get:babout the seq
get:bspecification
get:bbefore emitti
get:bsegments from
get:bEven hosts wh
get:binitial seque
get:b(i.e., even i
get:bnumber for ea
get:bSuppose, for 
get:bsequence numb
get:band that even
get:btakes on a va
get:bsegment sent 
get:bat this insta
get:bincarnation o
get:bS1 = ISN(t) -
get:bconnection!  
get:bTransmission Cont
get:bFunctional Specif
get:bduplicates in
get:bof S1 may arr
get:bthe new incar
get:bThe problem i
get:bcrashed nor d
get:bthe system fr
get:bOne way to de
get:bsegments for 
get:btime" specifi
get:bwilling to ri
get:bdestination m
get:bImplementors 
get:bconnection by
get:binformally im
get:bObviously, ev
get:bnecessary aft
get:bTo summarize:
get:bnumbers in th
get:b"busy" or "in
get:bblock of spac
get:bsegment, if a
get:bsequence numb
get:bthe previous 
get:bnumber overla
get:b3.4.  Establishin
get:bThe "three-way 
get:bconnection.  Th
get:bresponded to by
get:bsimultaneously 
get:boccurs, each TC
get:backnowledgment 
get:ban old duplicat
get:brecipient, that
get:bProper use of "
get:bSeveral example
get:bexamples do not
get:bsegments, this 
get:bdoesn't deliver
get:bvalid (i.e., th
get:bconnection reac
get:breduces the pos
get:b[Page 30]        
get:bSeptember 1981   
get:bimplementation 
get:binformation for
get:bThe simplest th
get:bfigures should 
get:bnumbered for re
get:bdeparture of a 
get:bsegment at B fr
get:bEllipsis (...) 
get:b(delayed).  An 
get:bComments appear
get:bthe departure o
get:bthe center of e
get:bform, with sequ
get:bfields such as 
get:bin the interest
get:bTCP A      
get:b1.  CLOSED     
get:b2.  SYN-SENT   
get:b3.  ESTABLISHED
get:b4.  ESTABLISHED
get:b5.  ESTABLISHED
get:bBasic 3
get:bIn line 2 of fi
get:bindicating that
get:bnumber 100.  In
get:breceived from T
get:bB is now expect
get:boccupied sequen
get:bAt line 4, TCP 
get:bTCP B's SYN; an
get:bsequence number
get:bbecause the ACK
get:bwould wind up A
get:bTransmission Cont
get:bFunctional Specif
get:bSimultaneous in
get:bfigure 8.  Each
get:bTCP A      
get:b1.  CLOSED     
get:b2.  SYN-SENT   
get:b3.  SYN-RECEIVE
get:b4.             
get:b5.  SYN-RECEIVE
get:b6.  ESTABLISHED
get:b7.             
get:bS
get:bThe principle r
get:bduplicate conne
get:bthis, a special
get:breceiving TCP i
get:bSYN-RECEIVED), 
get:bIf the TCP is i
get:bFIN-WAIT-1, FIN
get:baborts the conn
get:bcase under "hal
get:b[Page 32]        
get:bSeptember 1981   
get:bTCP A      
get:b1.  CLOSED     
get:b2.  SYN-SENT   
get:b3.  (duplicate)
get:b4.  SYN-SENT   
get:b5.  SYN-SENT   
get:b6.             
get:b7.  SYN-SENT   
get:b8.  ESTABLISHED
get:bAs a simple exa
get:bfigure 9.  At l
get:bcannot tell tha
get:b(line 4).  TCP 
get:bRST (reset) wit
get:bbelievable.  TC
get:bWhen the origin
get:bsynchronization
get:bbefore the RST,
get:bsent in both di
get:bHalf-Open Conne
get:bAn established 
get:bTCPs has closed
get:bknowledge of th
get:bbecome desynchr
get:bmemory.  Such c
get:battempt is made
get:bconnections are
get:bmildly involved
get:bIf at site A th
get:bTransmission Cont
get:bFunctional Specif
get:buser at site B 
get:breceiving a res
get:bsite B TCP that
get:bAssume that two
get:banother when a 
get:bDepending on th
get:bthat some error
get:bA is likely to 
get:bpoint.  As a re
get:bor try to SEND 
get:bcase, it receiv
get:blocal (A's) TCP
get:bwill send a seg
get:bexample shown i
get:bre-open the con
get:bTCP A      
get:b1.  (CRASH)    
get:b2.  CLOSED     
get:b3.  SYN-SENT --
get:b4.  (!!)     <-
get:b5.  SYN-SENT --
get:b6.  SYN-SENT   
get:b7.  SYN-SENT --
get:bWhen the SYN ar
get:band the incomin
get:backnowledgment 
get:b100).  TCP A se
get:bsent and, being
get:bdetected a half
get:b[Page 34]        
get:bSeptember 1981   
get:bcontinue to try
get:breduced to the 
get:bAn interesting 
get:btries to send d
get:bThis is illustr
get:bTCP A from TCP 
get:bexists, so TCP 
get:bprocesses it an
get:bTCP A    
get:b1.  (CRASH)    
get:b2.  (??)    <--
get:b3.          -->
get:bActive
get:bIn figure 12, w
get:bwaiting for SYN
get:binto action.  A
get:bgenerate a RST 
get:bthe reset and r
get:bTCP A      
get:b1.  LISTEN     
get:b2.       ... <S
get:b3.  (??) <-- <S
get:b4.       --> <S
get:b5.  LISTEN     
get:bOld Duplic
get:bTransmission Cont
get:bFunctional Specif
get:bA variety of ot
get:bby the followin
get:bReset Generatio
get:bAs a general ru
get:bwhich apparentl
get:bmust not be sen
get:bThere are three: groups of states
get:b1.  If the co
get:bin response t
get:bparticular, S
get:bby this means
get:bIf the incomi
get:bsequence numb
get:breset has seq
get:bof the sequen
get:bThe connectio
get:b2.  If the co
get:bSYN-SENT, SYN
get:bsomething not
get:bif an incomin
get:bdoes not exac
get:bconnection, a
get:bIf our SYN ha
get:bincoming segm
get:beither raise 
get:bthe system) o
get:bincoming segm
get:bcontinue as i
get:bcannot raise 
get:bdetected in t
get:bterminated th
get:bincoming segm
get:bmatch the loc
get:bmust be sent.
get:bIf the incomi
get:bsequence numb
get:breset has seq
get:bof the sequen
get:bThe connectio
get:b[Page 36]        
get:bSeptember 1981   
get:b3.  If the co
get:bFIN-WAIT-1, F
get:bany unaccepta
get:bunacceptible 
get:backnowledgmen
get:band an acknow
get:bto be receive
get:bIf an incomin
get:bprecedence wh
get:band precedenc
get:bconnection go
get:bnumber from t
get:bReset Processin
get:bIn all states e
get:bby checking the
get:bis in the windo
get:bto an initial S
get:backnowledges th
get:bThe receiver of
get:breceiver was in
get:bin SYN-RECEIVED
get:bthen the receiv
get:baborts the conn
get:bwas in any othe
get:band goes to the
get:b3.5.  Closing a C
get:bCLOSE is an ope
get:bnotion of closi
get:binterpretation,
get:bthe receiving s
get:bin a simplex fa
get:buntil he is tol
get:bcould initiate 
get:bRECEIVE until s
get:bhas CLOSED.  We
get:bRECEIVEs are ou
get:bcan terminate h
get:bbuffers SENT be
get:bdata in return 
get:bsuccessfully to
get:bTCP.  Users mus
get:bthe TCP says no
get:bTransmission Cont
get:bFunctional Specif
get:bThere are essen:tially three cases
get:b1) The user i
get:b2) The remote
get:b3) Both users
get:bCase 1:  Local 
get:bIn this case,
get:boutgoing segm
get:baccepted by t
get:bare allowed i
get:bwill be retra
get:bboth acknowle
get:bcan ACK this 
get:bsend its own 
get:bCase 2:  TCP re
get:bIf an unsolic
get:bcan ACK it an
get:buser will res
get:bthe other TCP
get:buntil its own
get:bconnection.  
get:bthe connectio
get:bCase 3:  both u
get:bA simultaneou
get:bFIN segments 
get:bhave been pro
get:bhas received.
get:b[Page 38]        
get:bSeptember 1981   
get:bTCP A      
get:b1.  ESTABLISHED
get:bFIN-WAIT-1 
get:b3.  FIN-WAIT-2 
get:b4.             
get:bTIME-WAIT  
get:b5.  TIME-WAIT  
get:bCLOSED     
get:bTCP A      
get:b1.  ESTABLISHED
get:b2.  (Close)    
get:bFIN-WAIT-1 
get:b3.  CLOSING    
get:b4.  TIME-WAIT  
get:b(2 MSL)    
get:bCLOSED     
get:bTransmission Cont
get:bFunctional Specif
get:b3.6.  Precedence 
get:bThe intent is t
get:bwith exactly th
get:bhigher of the p
get:bThe precedence 
get:bdefined in the 
get:bspecification t
get:bthe security pa
get:buser group, and
get:bA connection at
get:blower precedenc
get:ba connection du
get:backnowledgment 
get:bNote that TCP m
get:bprecedence will
get:bsegments and po
get:bThe security pa
get:b(the values wou
get:bnon-secure envi
get:bparameters, tho
get:b3.7.  Data Commun
get:bOnce the connec
get:bexchange of seg
get:b(checksum test 
get:bretransmission 
get:bDuplicate segme
get:bAs discussed in
get:bcertain tests o
get:bsegments to ver
get:bThe sender of d
get:bthe variable SN
get:bsequence number
get:bkeeps track of 
get:bvariable SND.UN
get:bsent has been a
get:bWhen the sender
get:bSND.NXT.  When 
get:bsends an acknow
get:b[Page 40]        
get:bSeptember 1981   
get:backnowledgment 
get:bthese variables
get:bThe amount by w
get:bdata in the seg
get:bsegments must c
get:bThe CLOSE user 
get:bflag in an inco
get:bRetransmission 
get:bBecause of the 
get:binternetwork sy
get:bretransmission 
get:bfor determining
get:bAn Example Re
get:bMeasure the
get:bparticular 
get:bcovers that
get:bsegments re
get:bTime (RTT).:  Next compute a Smoothed Round Trip Time (SRTT) as
get:bSRTT = ( 
get:band based o:n this, compute the retransmission timeout (RTO) as
get:bRTO = min
get:bwhere UBOUN
get:bLBOUND is a
get:ba smoothing
get:bfactor (e.g
get:bThe Communicati
get:bThe objective o
get:bto stimulate th
get:bpermit the rece
get:bthe currently k
get:bThis mechanism 
get:bthe end of urge
get:bthe receive seq
get:bmust tell the u
get:bnumber catches 
get:bTransmission Cont
get:bFunctional Specif
get:binto "normal mo
get:bis in "urgent m
get:bThe method empl
get:btransmitted.  T
get:bmeaningful and 
get:bthe urgent poin
get:bno urgent data 
get:bTo send an urge
get:boctet.  If the 
get:bthe urgent info
get:bManaging the Wi
get:bThe window sent
get:bnumbers the sen
get:bprepared to acc
get:bthe currently a
get:bIndicating a la
get:barrives than ca
get:bin excessive re
get:bnetwork and the
get:btransmission of
get:bbetween each ne
get:bThe mechanisms 
get:bsubsequently ad
get:bthat much data.
get:bdiscouraged.  T
get:bshrink the wind
get:bon the part of 
get:bThe sending TCP
get:bleast one octet
get:bsending TCP mus
get:bthe window is z
get:binterval when t
get:bguarantee that 
get:bwindow will be 
get:bWhen the receiv
get:bstill send an a
get:band current win
get:bThe sending TCP
get:b[Page 42]        
get:bSeptember 1981   
get:bwhich fit the c
get:bretransmission 
get:bIn a connection
get:bbe carried in a
get:bnumber so there
get:border.  This is
get:binformation to 
get:bthe data receiv
get:bthe window info
get:backnowledgment 
get:bequal or greate
get:bThe window mana
get:bcommunication p
get:bWindow Manage
get:bAllocating 
get:bmany small 
get:bfewer large
get:bOne suggest
get:bdefer updat
get:bleast X per
get:bconnection 
get:bAnother sug
get:bsegments by
get:bsending dat
get:bdata must b
get:bNote that t
get:bretransmiss
get:backnowledgm
get:bwindow info
get:bnew window 
get:bThe segment
get:bof transmit
get:bsegment con
get:bis accepted
get:bIf the send
get:bwindow is n
get:balternating
get:bpauses in t
get:bTransmission Cont
get:bFunctional Specif
get:bresult in b
get:bbig pair. A
get:bmostly smal
get:bThe suggest
get:bactively at
get:bwindows, si
get:bto many sma
get:bThere are of co:urse two interfaces of concern
get:band the TCP/low
get:bof the user/TCP
get:bprotocol module
get:bin detail by th
get:bcase that the l
get:bthat TCPs might
get:bUser/TCP Interf
get:bThe following
get:bat best, fict
get:bfacilities.  
get:bimplementatio
get:bTCPs must pro
get:bthat all TCP 
get:bhierarchy.  T
get:brequired of a
get:bTCP User Comm
get:bThe followi
get:binterface. 
get:bfunction ca
get:bmeant to ru
get:bThe user co
get:bTCP must pe
get:bIndividual 
get:bmay provide
get:bsingle call
get:bautomatical
get:bissued by t
get:b[Page 44]        
get:bSeptember 1981   
get:bIn providin
get:bnot only ac
get:bprocesses i:t serves.  The latter consists of
get:b(a) gener
get:bremote cl
get:b(b) repli
get:bvarious t
get:bFormat:  
get:b[, timeou
get:b-> local 
get:bWe assume
get:bprocesses
get:bto use th
get:bimplement
get:bfor the s
get:blower lev
get:bresult of
get:bable to m
get:bprocess c
get:bIf the ac
get:bcall to L
get:bhave eith
get:bparticula
get:bfor any c
get:bby the su
get:bA transmi
get:bfilled in
get:bOn an act
get:bsynchroni
get:bThe timeo
get:bfor all d
get:bdelivered
get:bwill abor
get:bThe TCP o
get:bthe users
get:bTransmission Cont
get:bFunctional Specif
get:bprecedenc
get:bor securi
get:bthe defau
get:bTCP will 
get:bsecurity/
get:bthe prece
get:brequested
get:bThe prece
get:brequested
get:brequest, 
get:bconnectio
get:bthis prec
get:ballowed t
get:bor that a
get:bA local c
get:bThe local
get:bfor the c
get:bFormat:  
get:bcount, PU
get:bThis call
get:bto be sen
get:bnot been 
get:bimplement
get:bautomatic
get:bauthorize
get:bIf the PU
get:bto the re
get:bsegment c
get:bthe data 
get:btransmiss
get:bIf the UR
get:bwill have
get:bthe urgen
get:bpointer i
get:bbeen cons
get:bis to sti
get:bindicate 
get:b[Page 46]        
get:bSeptember 1981   
get:bdata has 
get:bTCP signa
get:bof times 
get:burgent da
get:bIf no for
get:bconnectio
get:bhas becom
get:blocal soc
get:bforeign s
get:bforeign s
get:bknowing t
get:bHowever, 
get:bbecomes s
get:bSTATUS ca
get:bimplement
get:bsocket is
get:bIf a time
get:bconnectio
get:bIn the si
get:bthe sendi
get:bor the ti
get:bis both s
get:bconnectio
get:boffers po
get:bsophistic
get:bthe proce
get:bfurthermo
get:bMultiple 
get:bthe TCP w
get:bWe have i
get:bwhich a S
get:bpseudo-in
get:breturn a 
get:bimmediate
get:bbeen ackn
get:bassume ev
get:bclose any
get:bkind (syn
get:bsignals, 
get:bwith spec
get:bIn order 
get:bindicatio
get:bTransmission Cont
get:bFunctional Specif
get:bbuffer ad
get:bthe SEND 
get:bindicatin
get:bcalling p
get:bFormat:  
get:bcount) ->
get:bThis comm
get:bspecified
get:bcalling p
get:berror is 
get:bIn the si
get:bcalling p
get:berror occ
get:bA more so
get:bRECEIVEs 
get:bsegments 
get:bthe cost 
get:bnotify th
get:bIf enough
get:bthe PUSH 
get:bThe buffe
get:ba PUSH is
get:breturned 
get:bIf there 
get:bas it arr
get:bshould th
get:badditiona
get:bcall to R
get:bmay now l
get:burgent po
get:bin the sa
get:bboundary 
get:bTo distin
get:bcare of t
get:breturn co
get:bcount ind
get:bAlternati
get:b[Page 48]        
get:bSeptember 1981   
get:ballocate 
get:bwith the 
get:bFormat:  
get:bThis comm
get:bthe conne
get:bauthorize
get:bClosing c
get:bthe sense
get:bretransmi
get:bserviced.
get:bcalls, fo
get:bto the de
get:bcontinue 
get:bmay be tr
get:bmeans "I 
get:breceive a
get:bnot well 
get:bof all it
get:binto ABOR
get:bThe user 
get:binitiativ
get:b(e.g., re
get:bdestinati
get:bBecause c
get:bforeign T
get:bshort tim
get:breplies t
get:bClose als
get:bFormat:  
get:bThis is a
get:bexcluded 
get:btypically
get:bThis comm
get:binformati:on
get:blocal s
get:bTransmission Cont
get:bFunctional Specif
get:bforeign
get:blocal c
get:breceive
get:bsend wi
get:bconnect
get:bnumber 
get:bnumber 
get:burgent 
get:bprecede
get:bsecurit
get:band tra
get:bDepending
get:bimplement
get:bavailable
get:bauthorize
get:bprevents 
get:bconnectio
get:bFormat:  
get:bThis comm
get:baborted, 
get:bbe sent t
get:bDepending
get:bindicatio
get:breceive a
get:bTCP-to-User M
get:bIt is assum
get:bmeans for t
get:bthe TCP doe
get:bto the user
get:ban error me
get:brelating to
get:bother user 
get:bThe followi:ng information is provided
get:bLocal Con
get:bResponse 
get:bBuffer Ad
get:bByte coun
get:bPush flag
get:bUrgent fl
get:b[Page 50]        
get:bSeptember 1981   
get:bTCP/Lower-Level
get:bThe TCP calls
get:breceive infor
get:binternetwork 
get:bProtocol (IP)
get:bIf the lower 
get:bof service an
get:bfor these par:ameters
get:bType of Ser:vice = Precedence: routine, Delay: normal, Throughput
get:bnormal, Rel:iability
get:bTime to Liv
get:bNote that
get:bHere we e
get:bbe delive
get:bIf the lower 
get:bfeature) and 
get:broute informa
get:bso that the s
get:bchecksum be t
get:balso importan
get:bAny lower lev
get:bdestination a
get:bthe "TCP leng
get:bof IP and to 
get:bTransmission Cont
get:bFunctional Specif
get:b3.9.  Event Proce
get:bThe processing 
get:bimplementation.
get:bprocessing sequ
get:bsection only in
get:bThe activity of
get:bThe events that: occur can be cast into three categories
get:barriving segmen
get:bprocessing the 
get:bcases the proce
get:bEvents that o:ccur
get:bArriving Se
get:bSEGMENT A
get:bUSER TIME
get:bRETRANSMI
get:bTIME-WAIT
get:bThe model of th
get:bimmediate retur
get:bpseudo interrup
get:bmeans cause a d
get:bError responses
get:bcommands refere:ncing connections that do not exist receive "error
get:bconnection not 
get:bPlease note in 
get:backnowledgment 
get:bof the sequence
get:bequal to (modul
get:b[Page 52]        
get:bSeptember 1981   
get:bA natural way t
get:bimagine that th
get:bthat their cont
get:bin the sequence
get:band processed i
get:bWhen a segment 
get:bthe segment to 
get:bto be consisten
get:bNote that if no
get:bTransmission Cont
get:bFunctional Specif
get:bCLOSED STATE 
get:bCreate a ne
get:bstate infor
get:bsocket, pre
get:binformation
get:bunspecified
get:bparameters 
get:bprecedence 
get:b"error:  pr:ecedence not allowed" or "error
get:bnot allowed
get:bactive and :the foreign socket is unspecified, return "error
get:bforeign soc
get:bspecified, 
get:b(ISS) is se
get:bis sent.  S
get:bstate, and 
get:bIf the call
get:breturn "err:or
get:bno room to :create a new connection, return "error
get:bresources".
get:bIf active a
get:bconnection 
get:bsegment, se
get:bstate.  Dat
get:bqueued for 
get:burgent bit 
get:bsegments se
get:bqueue the r:equest, respond with "error
get:bIf Foreign :socket was not specified, then return "error
get:bsocket unsp
get:b[Page 54]        
get:bSeptember 1981   
get:bSYN-SENT STAT
get:bSYN-RECEIVED 
get:bESTABLISHED S
get:bFIN-WAIT-1 ST
get:bFIN-WAIT-2 ST
get:bCLOSE-WAIT ST
get:bCLOSING STATE
get:bLAST-ACK STAT
get:bTIME-WAIT STA
get:bReturn "err:or
get:bTransmission Cont
get:bFunctional Specif
get:bCLOSED STATE 
get:bIf the user
get:b"error:  co
get:bOtherwise, :return "error
get:bIf the fore
get:bfrom passiv
get:bSND.UNA to 
get:bassociated 
get:btransmissio
get:brequested i
get:bas a result
get:brequest, re:spond with "error
get:bForeign soc:ket was not specified, then return "error
get:bsocket unsp
get:bSYN-SENT STAT
get:bSYN-RECEIVED 
get:bQueue the d
get:bIf no space: to queue, respond with "error
get:bresources".
get:bESTABLISHED S
get:bCLOSE-WAIT ST
get:bSegmentize 
get:backnowledgm
get:binsufficien:t space to remember this buffer, simply return "error
get:binsufficien
get:bIf the urge
get:burgent poin
get:b[Page 56]        
get:bSeptember 1981   
get:bFIN-WAIT-1 ST
get:bFIN-WAIT-2 ST
get:bCLOSING STATE
get:bLAST-ACK STAT
get:bTIME-WAIT STA
get:bReturn "err:or
get:bTransmission Cont
get:bFunctional Specif
get:bCLOSED STATE 
get:bIf the user
get:b"error:  co
get:bOtherwise r:eturn "error
get:bSYN-SENT STAT
get:bSYN-RECEIVED 
get:bQueue for p
get:bis no room :to queue this request, respond with "error
get:binsufficien
get:bESTABLISHED S
get:bFIN-WAIT-1 ST
get:bFIN-WAIT-2 ST
get:bIf insuffic
get:brequest, qu
get:bremember th:e RECEIVE, respond with "error
get:bresources".
get:bReassemble 
get:bto user.  M
get:bIf RCV.UP i
get:buser notify
get:bWhen the TC
get:bthat fact m
get:backnowledgm
get:bdescribed b
get:b[Page 58]        
get:bSeptember 1981   
get:bCLOSE-WAIT ST
get:bSince the r
get:bsatisfied b
get:buser.  If n
get:b"error:  co
get:btext can be
get:bCLOSING STATE
get:bLAST-ACK STAT
get:bTIME-WAIT STA
get:bReturn "err:or
get:bTransmission Cont
get:bFunctional Specif
get:bCLOSED STATE 
get:bIf the user
get:b"error:  co
get:bOtherwise, :return "error
get:bAny outstan:ding RECEIVEs are returned with "error
get:bresponses. 
get:bSYN-SENT STAT
get:bDelete the :TCB and return "error
get:bqueued SEND
get:bSYN-RECEIVED 
get:bIf no SENDs
get:bthen form a
get:botherwise q
get:bESTABLISHED S
get:bQueue this 
get:bform a FIN 
get:bFIN-WAIT-1 ST
get:bFIN-WAIT-2 ST
get:bStrictly sp:eaking, this is an error and should receive a "error
get:bconnection 
get:bacceptable,
get:bFIN may be 
get:b[Page 60]        
get:bSeptember 1981   
get:bCLOSE-WAIT ST
get:bQueue this 
get:bsegmentized
get:bCLOSING STATE
get:bLAST-ACK STAT
get:bTIME-WAIT STA
get:bRespond wit:h "error
get:bTransmission Cont
get:bFunctional Specif
get:bCLOSED STATE 
get:bIf the user
get:b"error:  co
get:bOtherwise r:eturn "error
get:bAny outstan:ding RECEIVEs should be returned with "error
get:bconnection 
get:bSYN-SENT STAT
get:bAll queued 
get:bnotificatio
get:bSYN-RECEIVED 
get:bESTABLISHED S
get:bFIN-WAIT-1 ST
get:bFIN-WAIT-2 ST
get:bCLOSE-WAIT ST
get:bSend a rese:t segment
get:b<SEQ=SND.
get:bAll queued 
get:bnotificatio
get:bRST formed 
get:bTCB, enter 
get:bCLOSING STATE
get:bLAST-ACK STAT
get:bTIME-WAIT STA
get:bRespond wit
get:b[Page 62]        
get:bSeptember 1981   
get:bCLOSED STATE 
get:bIf the user
get:b"error:  co
get:bOtherwise r:eturn "error
get:bReturn "sta
get:bSYN-SENT STAT
get:bReturn "sta
get:bSYN-RECEIVED 
get:bReturn "sta
get:bESTABLISHED S
get:bReturn "sta
get:bFIN-WAIT-1 ST
get:bReturn "sta
get:bFIN-WAIT-2 ST
get:bReturn "sta
get:bCLOSE-WAIT ST
get:bReturn "sta
get:bCLOSING STATE
get:bReturn "sta
get:bLAST-ACK STAT
get:bReturn "sta
get:bTransmission Cont
get:bFunctional Specif
get:bTIME-WAIT STA
get:bReturn "sta
get:b[Page 64]        
get:bSeptember 1981   
get:bSEGMENT ARRIVES
get:bIf the state 
get:ball data in
get:bsegment con
get:bcontaining 
get:backnowledgm
get:breset seque
get:bIf the ACK 
get:b<SEQ=0><A
get:bIf the ACK 
get:b<SEQ=SEG.
get:bIf the state 
get:bfirst check
get:bAn incomi
get:bsecond chec
get:bAny ackno
get:bthe LISTE
get:bfor any a
get:bformatted: as follows
get:b<SEQ=SE
get:bthird check
get:bIf the SY
get:bsecurity/
get:bmatch the
get:b<SEQ=SE
get:bTransmission Cont
get:bFunctional Specif
get:bIf the SE
get:bthe user 
get:bsend a re
get:b<SEQ=SE
get:bIf the SE
get:bSet RCV.N
get:bcontrol o
get:bshould be: selected and a SYN segment sent of the form
get:b<SEQ=IS
get:bSND.NXT i
get:bstate sho
get:bincoming 
get:bin the SY
get:bnot be re
get:bthe forei
get:bunspecifi
get:bfourth othe
get:bAny other
get:bmust have
get:bprocessin
get:bit could 
get:bincarnati
get:bbut if yo
get:bIf the state 
get:bfirst check
get:bIf the AC
get:bIf SEG.
get:bthe RST
get:b<SEQ=
get:band dis
get:bIf SND.
get:bsecond chec
get:b[Page 66]        
get:bSeptember 1981   
get:bIf the RS
get:bIf the :ACK was acceptable then signal the user "error
get:bconnect
get:bdelete 
get:band ret
get:bthird check
get:bIf the se
get:bmatch the
get:bIf ther
get:b<SEQ=
get:bOtherwi
get:b<SEQ=
get:bIf there 
get:bThe pre
get:bTCB, if
get:b<SEQ=
get:bIf there 
get:bIf the 
get:bin the 
get:bthe pre
get:ballowed
get:b<SEQ=
get:bIf the 
get:bin the 
get:bIf a rese
get:bfourth chec
get:bThis step
get:bno ACK, a
get:bIf the SY
get:bTransmission Cont
get:bFunctional Specif
get:bare accep
get:bSEG.SEQ. 
get:bis an ACK
get:bare there
get:bIf SND.UN
get:bstate to 
get:b<SEQ=SN
get:band send 
get:btransmiss
get:btext in t
get:bbelow whe
get:bOtherwise
get:b<SEQ=IS
get:band send 
get:bsegment, 
get:bhas been 
get:bfifth, if n
get:bsegment and
get:b[Page 68]        
get:bSeptember 1981   
get:bfirst check s
get:bSYN-RECEIVE
get:bESTABLISHED
get:bFIN-WAIT-1 
get:bFIN-WAIT-2 
get:bCLOSE-WAIT 
get:bCLOSING STA
get:bLAST-ACK ST
get:bTIME-WAIT S
get:bSegments 
get:bare used 
get:bdone in S
get:bboundary 
get:bprocessed
get:bThere are
get:bsegment
get:bSegment R
get:bLength  W
get:b------- -
get:b0     
get:b0     
get:b>0     
get:b>0     
get:bIf the RC
get:bspecial a
get:bIf an inc
get:bshould be
get:bthe segme:nt and return)
get:b<SEQ=SN
get:bAfter sen
get:band retur
get:bTransmission Cont
get:bFunctional Specif
get:bIn the fo
get:bsegment t
get:bOne could
get:btrimming 
get:bSYN and F
get:bbegins at
get:bnumbers m
get:bsecond check 
get:bSYN-RECEIVE
get:bIf the RS
get:bIf this
get:bcame fr
get:bLISTEN 
get:bthis co
get:bfrom SY
get:bthe use
get:bon the 
get:bactive 
get:band ret
get:bESTABLISHED
get:bIf the RS
get:bshould re
get:bflushed. 
get:b"connecti
get:bTCB, and 
get:bCLOSING STA
get:bLAST-ACK ST
get:bIf the RS
get:bTCB, and 
get:b[Page 70]        
get:bSeptember 1981   
get:bthird check s
get:bSYN-RECEIVE
get:bIf the se
get:bexactly m
get:bthen send
get:bESTABLISHED
get:bIf the se
get:bexactly m
get:bthen send
get:breceive "
get:bflushed. 
get:b"connecti
get:bTCB, and 
get:bNote this c
get:ba segment f
get:bdifferent s
get:bcurrent con
get:bfourth, check
get:bSYN-RECEIVE
get:bESTABLISHED
get:bFIN-WAIT ST
get:bFIN-WAIT ST
get:bCLOSE-WAIT 
get:bCLOSING STA
get:bLAST-ACK ST
get:bTIME-WAIT S
get:bIf the SY
get:boutstandi
get:ball segme
get:breceive a
get:bthe CLOSE
get:bIf the SY
get:band an ac
get:bnumber ch
get:bTransmission Cont
get:bFunctional Specif
get:bfifth check t
get:bif the ACK 
get:bif the ACK 
get:bSYN-RECEI
get:bIf SND.
get:band con
get:bIf th
get:breset
get:b<SE
get:band s
get:bESTABLISH
get:bIf SND.
get:bAny seg
get:bentirel
get:bpositiv
get:bfully a
get:b"ok" re
get:b(SEG.AC
get:bsomethi
get:bdrop th
get:bIf SND.
get:bupdated
get:bSND.WL2
get:bSND.WL1
get:bNote th
get:brecords
get:bSND.WND
get:bthe las
get:bprevent
get:b[Page 72]        
get:bSeptember 1981   
get:bFIN-WAIT-
get:bIn addi
get:bour FIN
get:bprocess
get:bFIN-WAIT-
get:bIn addi
get:bthe ret
get:backnowl
get:bCLOSE-WAI
get:bDo the 
get:bCLOSING S
get:bIn addi
get:bthe ACK
get:botherwi
get:bLAST-ACK 
get:bThe onl
get:backnowl
get:bdelete 
get:bTIME-WAIT
get:bThe onl
get:bretrans
get:bthe 2 M
get:bsixth, check 
get:bESTABLISHED
get:bFIN-WAIT-1 
get:bFIN-WAIT-2 
get:bIf the UR
get:bthe user 
get:bpointer (
get:buser has 
get:bmode") fo
get:bsignal th
get:bTransmission Cont
get:bFunctional Specif
get:bCLOSE-WAIT 
get:bCLOSING STA
get:bLAST-ACK ST
get:bThis shou
get:bremote si
get:bseventh, proc
get:bESTABLISHED
get:bFIN-WAIT-1 
get:bFIN-WAIT-2 
get:bOnce in t
get:btext to u
get:binto buff
get:bempty.  I
get:bthe user 
get:bhas been 
get:bWhen the 
get:buser it m
get:bOnce the 
get:bRCV.NXT o
get:bapporopri
get:bRCV.NXT a
get:bPlease no
get:bSend an a:cknowledgment of the form
get:b<SEQ=SN
get:bThis ackn
get:btransmitt
get:b[Page 74]        
get:bSeptember 1981   
get:bCLOSE-WAIT 
get:bCLOSING STA
get:bLAST-ACK ST
get:bTIME-WAIT S
get:bThis shou
get:bremote si
get:beighth, check
get:bDo not proc
get:bsince the S
get:bIf the FIN 
get:breturn any 
get:bover the FI
get:bFIN implies
get:bSYN-RECEI
get:bESTABLISH
get:bEnter t
get:bFIN-WAIT-
get:bIf our 
get:benter T
get:btimers;
get:bFIN-WAIT-
get:bEnter t
get:boff the
get:bCLOSE-WAI
get:bRemain 
get:bCLOSING S
get:bRemain 
get:bLAST-ACK 
get:bRemain 
get:bTransmission Cont
get:bFunctional Specif
get:bTIME-WAIT
get:bRemain 
get:btimeout
get:b[Page 76]        
get:bSeptember 1981   
get:bFor any state
get:bthe user "err:or
get:band for any o
get:bstate and ret
get:bRETRANSMISSION 
get:bFor any state
get:bthe retransmi
get:bretransmissio
get:bTIME-WAIT TIMEO
get:bIf the time-w
get:benter the CLO
get:bTransmission Cont
get:b[Page 78]        
get:bSeptember 1981   
get:bBBN Rep
get:ba Host 
get:bhost an
get:bA contr
get:bindicat
get:bspecifi
get:bis expe
get:bpreviou
get:bThe uni
get:bARPANET
get:bA unit 
get:bIMPs.  
get:bA logic
get:bA messa
get:bnetwork
get:bDestination Addre
get:bThe des
get:bidentif
get:bA contr
get:bindicat
get:boccupyi
get:bA porti
get:bfragmen
get:bA file 
get:bTransmission Cont
get:bControl
get:bfragmen
get:bA compu
get:bfrom th
get:bAn Inte
get:bby the 
get:bThe Int
get:bARPANET
get:bA sourc
get:binternet datagram
get:bThe uni
get:bhigher 
get:binternet fragment
get:bA porti
get:bheader.
get:bInterne
get:bThe Ini
get:bnumber 
get:bThe Ini
get:bon a co
get:bbased p
get:bThe Ini
get:bused by
get:bControl
get:bdata.  
get:bon an A
get:b[Page 80]        
get:bSeptember 1981   
get:bThis is
get:bdata re
get:bsequenc
get:bof the 
get:bThe uni
get:bAn impl
get:bprocedu
get:bMaximum
get:bthe int
get:bAn eigh
get:bAn Opti
get:bmay be 
get:bprimari
get:btimesta
get:boptions
get:bA packa
get:blogical
get:blogical
get:bThe por
get:boutput 
get:bA progr
get:bthe poi
get:bA contr
get:bthis se
get:breceivi
get:breceive
get:bTransmission Cont
get:breceive
get:breceive
get:breceive next sequ
get:bThis is
get:breceive
get:bThis re
get:bis will
get:bsegment
get:bRCV.NXT
get:bSegment
get:brange a
get:bA contr
get:bthat th
get:binterac
get:bsequenc
get:bsegment
get:bit.  In
get:brise to
get:bReal Ti:me Protocol
get:bof time
get:bsegment
get:bsegment
get:bsegment
get:bsegment
get:bsegment
get:b[Page 82]        
get:bSeptember 1981   
get:bsegment
get:bA logic
get:bunit of
get:bsegment acknowled
get:bThe seq
get:barrivin
get:bThe amo
get:bincludi
get:bThe num
get:bThis is
get:buse on 
get:binitial
get:beach oc
get:bThis re
get:b(receiv
get:bwindow 
get:breceivi
get:bbe emit
get:bSND.UNA
get:bbetween
get:bsend se
get:bleft se
get:bsend ur
get:bsegment
get:bsegment
get:bTransmission Cont
get:bsend wi
get:bAn addr
get:bis, the
get:bThe sou
get:bA contr
get:bnumber,
get:bwhere t
get:bTransmi
get:bthe sta
get:bThe pre
get:bTransmi:ssion Control Protocol
get:breliabl
get:bType of
get:bAn Inte
get:bfor thi
get:bA contr
get:bindicat
get:burgent 
get:bsequenc
get:bpointer
get:bA contr
get:bfield c
get:bindicat
get:burgent 
get:b[Page 84]        
get:bSeptember 1981   
get:b[1]  Cerf, V., an
get:bIntercommuni
get:bVol. COM-22,
get:b[2]  Postel, J. (
get:bProtocol Spe
get:bInstitute, S
get:b[3]  Dalal, Y. an
get:bProtocols", 
get:bDecember 197
get:b[4]  Postel, J., 
get:bInstitute, S
get:baRFC
get:baDe
get:baI
get:baSeptember 1981   
get:baPREFACE .....
get:ba1.  INTRODUCTION 
get:ba1.1  Motivation
get:ba1.2  Scope ....
get:ba1.3  About This
get:ba1.4  Interfaces
get:ba1.5  Operation 
get:ba2.  PHILOSOPHY ..
get:ba2.1  Elements o
get:ba2.2  Model of O
get:ba2.3  The Host E
get:ba2.4  Interfaces
get:ba2.5  Relation t
get:ba2.6  Reliable C
get:ba2.7  Connection
get:ba2.8  Data Commu
get:ba2.9  Precedence
get:ba2.10 Robustness
get:ba3.  FUNCTIONAL SP
get:ba3.1  Header For
get:ba3.2  Terminolog
get:ba3.3  Sequence N
get:ba3.4  Establishi
get:ba3.5  Closing a 
get:ba3.6  Precedence
get:ba3.7  Data Commu
get:ba3.8  Interfaces
get:ba3.9  Event Proc
get:baGLOSSARY ........
get:baREFERENCES ......
get:baTransmission Cont
get:ba[Page ii]        
get:baSeptember 1981   
get:baThis document des
get:ba(TCP).  There hav
get:baspecification on 
get:badraws heavily fro
get:baboth in terms of 
get:baseveral details a
get:baand redescribes t
get:baRFC
get:baReplaces: RFC 761
get:baIENs:  129, 124, 
get:ba55, 44, 40, 27, 2
get:baThe Transmission 
get:bareliable host-to-
get:bacommunication net
get:baThis document des
get:baTransmission Cont
get:bainterface to prog
get:baComputer commun
get:barole in militar
get:badocument focuse
get:bacommunication r
get:bacommunication u
get:bacongestion, but
get:bagovernment sect
get:baAs strategic an
get:badeveloped and d
get:bainterconnecting
get:bacommunication p
get:baapplications.  
get:baDeputy Undersec
get:badeclared the Tr
get:babe a basis for 
get:bastandardization
get:baTCP is a connec
get:bafit into a laye
get:baapplications.  
get:bacommunication b
get:badistinct but in
get:baassumptions are
get:baprotocols below
get:bapotentially unr
get:baprotocols.  In 
get:bawide spectrum o
get:baconnections to 
get:baTransmission Cont
get:baTCP is based on
get:baTCP fits into a
get:baInternet Protoc
get:bareceive variabl
get:badatagram "envel
get:baaddressing sour
get:bainternet protoc
get:bathe TCP segment
get:bamultiple networ
get:baalso carries in
get:baand compartment
get:bacommunicated en
get:baMuch of this do
get:bawhich are co-re
get:bacomputer.  Some
get:bafront-end compu
get:baas well as netw
get:baan interface to
get:baimplementable e
get:bahost-to-front e
get:baThe TCP is inte
get:bacommunication s
get:baintended to be 
get:ba1.3.  About this 
get:baThis document r
get:baany TCP impleme
get:baprotocols and i
get:ba[Page 2]         
get:baSeptember 1981   
get:basection offers 
get:baoperation.  Sec
get:badesign.  Sectio
get:barequired of TCP
get:bauser calls, err
get:baThe TCP interfa
get:bathe other side 
get:baThe interface b
get:baillustrated in 
get:bacalls much like
get:baapplication pro
get:bacalls to open a
get:baestablished con
get:baasynchronously 
get:baconsiderable fr
get:bainterfaces whic
get:baenvironment, a 
get:bainterface for a
get:baThe interface b
get:baunspecified exc
get:batwo levels can 
get:baTypically, one 
get:bainterface.  TCP
get:bainterconnected 
get:bathroughout this
get:baAs noted above,
get:basecurable logic
get:baprocesses.  To 
get:bacommunication s:ystem requires facilities in the following areas
get:baBasic Data Tr
get:baPrecedence an
get:baThe basic opera
get:bathe following p
get:baTransmission Cont
get:baBasic Data Tran:sfer
get:baThe TCP is ab
get:badirection bet
get:basegments for 
get:bathe TCPs deci
get:baSometimes use
get:basubmitted to 
get:bafunction is d
get:baactually tran
get:bapushed throug
get:bapromptly forw
get:baThe exact pus
get:bathe push func
get:baReliability
get:baThe TCP must 
get:badelivered out
get:bais achieved b
get:batransmitted, 
get:bareceiving TCP
get:bainterval, the
get:banumbers are u
get:baout of order 
get:baadding a chec
get:bareceiver, and
get:baAs long as th
get:basystem does n
get:baerrors will a
get:bainternet comm
get:baFlow Control
get:baTCP provides 
get:basent by the s
get:baevery ACK ind
get:bathe last segm
get:baallowed numbe
get:bareceiving fur
get:ba[Page 4]         
get:baSeptember 1981   
get:baMultiplexing
get:baTo allow for 
get:bacommunication
get:baaddresses or 
get:baand host addr
get:baa socket.  A 
get:baThat is, a so
get:baThe binding o
get:baHost.  Howeve
get:ba(e.g., a "log
get:bamade known to
get:bathrough the k
get:baaddresses of 
get:baConnections
get:baThe reliabili
get:bathat TCPs ini
get:baeach data str
get:basockets, sequ
get:baEach connecti
get:baidentifying i
get:baWhen two proc
get:baestablish a c
get:baside).  When 
get:baterminated or
get:baSince connect
get:baover the unre
get:bamechanism wit
get:baerroneous ini
get:baPrecedence and :Security
get:baThe users of 
get:bacommunication
get:bathese feature
get:baTransmission Cont
get:ba[Page 6]         
get:baSeptember 1981   
get:ba2.1.  Elements of
get:baThe internetwor
get:bawhich are in tu
get:bathat the networ
get:balarge networks 
get:bapacket switchin
get:baconsume message
get:banetworks, the g
get:bacommunication s
get:baconnections bet
get:baThe term packet
get:batransaction bet
get:baexchanged withi
get:baHosts are compu
get:banetwork's point
get:baProcesses are v
get:baaccordance with
get:bain execution). 
get:baviewed as commu
get:baThus, all commu
get:baSince a process
get:bastreams between
get:bathat each proce
get:bacommunicates wi
get:ba2.2.  Model of Op
get:baProcesses trans
get:badata as argumen
get:basegments and ca
get:bathe destination
get:bainto the receiv
get:baTCPs include co
get:baensure reliable
get:baThe model of in
get:baprotocol module
get:bato the local ne
get:bainside internet
get:bainternet module
get:bathrough the loc
get:baThe packet swit
get:baTransmission Cont
get:baother operation
get:badestination int
get:baAt a gateway be
get:bafrom its local 
get:bathe internet da
get:bathen "wrapped" 
get:barouted to the n
get:baA gateway is pe
get:bainternet datagr
get:bathrough the nex
get:bainternet datagr
get:bafurther broken 
get:bainternet datagr
get:bainternet module
get:baA destination i
get:ba(after reassemb
get:badestination TCP
get:baThis simple mod
get:baimportant featu
get:bato the gateway 
get:baservice paramet
get:baIncluded in the
get:badatagram.  Data
get:bahost and gatewa
get:baproperly segreg
get:ba2.3.  The Host En
get:baThe TCP is assu
get:baaccess the TCP 
get:bamay call on oth
get:badata structures
get:bacontrolled by a
get:banetwork device 
get:badatagram protoc
get:baThe mechanisms 
get:bafront-end proce
get:bahost-to-front-e
get:bathe type of TCP
get:ba[Page 8]         
get:baSeptember 1981   
get:baThe TCP/user in
get:bato OPEN or CLOS
get:baSTATUS about a 
get:baprograms on the
get:bafrom, and close
get:baThe TCP/interne
get:badatagrams addre
get:basystem.  These 
get:baservice, preced
get:ba2.5.  Relation to
get:baThe following d
get:bahierarchy
get:ba+------+ +
get:ba|Telnet| |
get:ba+------+ +
get:ba|   
get:ba+----
get:ba| TCP
get:ba+----
get:ba| 
get:ba+----
get:ba|    
get:ba+----
get:ba+--
get:ba|  
get:ba+--
get:baIt is expected 
get:baprotocols effic
get:baprotocols like 
get:ba2.6.  Reliable Co
get:baA stream of dat
get:baorder at the de
get:baTransmission Cont
get:baTransmission is
get:baacknowledgments
get:basequence number
get:basegment is tran
get:basequence number
get:bais the sequence
get:batransmissions i
get:basegment contain
get:bastarts a timer;
get:basegment is dele
get:bareceived before
get:baAn acknowledgme
get:badelivered to th
get:bathe responsibil
get:baTo govern the f
get:baemployed.  The 
get:baThis window spe
get:baacknowledgment 
get:ba2.7.  Connection 
get:baTo identify the
get:baprovides a port
get:baindependently b
get:baunique addresse
get:baidentifying the
get:bawill be unique 
get:baA connection is
get:balocal socket ma
get:basockets.  A con
get:bathat is, it is 
get:baTCPs are free t
get:baHowever, severa
get:baThere must be w
get:bathe "appropriat
get:bamay "own" ports
get:bathe ports they 
get:baissue, but we e
get:bauniquely alloca
get:baassociating the
get:baA connection is
get:baforeign socket 
get:ba[Page 10]        
get:baSeptember 1981   
get:baconnection name
get:basubsequent call
get:baabout a connect
get:bais a data struc
get:baimplementation 
get:bapointer to the 
get:bawhether the con
get:babe passively wa
get:baA passive OPEN 
get:baconnection requ
get:baOften the proce
get:barequest from an
get:bais used to deno
get:baare allowed onl
get:baA service proce
get:baprocesses would
get:baforeign socket.
get:barequested a con
get:balocal socket we
get:baWell-known sock
get:baa socket addres
get:ba"Telnet-Server"
get:basocket, and oth
get:baEntry, Text Gen
get:babeing for test 
get:baaccess to a "Lo
get:baat which a newl
get:bawell-known sock
get:baof sockets to s
get:baProcesses can i
get:bafrom other proc
get:babeen establishe
get:baother at the sa
get:bais critical for
get:bacomponents act 
get:baThere are two p
get:bapassive OPENs a
get:balocal passive O
get:bacase, the match
get:baOPENs has left 
get:baforeign socket 
get:baOther possibili
get:baTransmission Cont
get:baIf there are se
get:basame local sock
get:bawith the specif
get:baTCB exists, bef
get:baThe procedures 
get:bacontrol flag an
get:baexchange has be
get:baA connection is
get:bacontaining a SY
get:bacommand.  The m
get:baconnection has 
get:bawhen sequence n
get:baThe clearing of
get:bain this case ca
get:ba2.8.  Data Commun
get:baThe data that f
get:baoctets.  The se
get:bain that call (a
get:bathrough to the 
get:baA sending TCP i
get:basend that data 
get:bafunction is sig
get:bareceiving TCP s
get:bathe sending TCP
get:baThere is no nec
get:baboundaries.  Th
get:basingle SEND cal
get:baThe purpose of 
get:bafrom the sendin
get:barecord service.
get:baThere is a coup
get:baof data that cr
get:baassociated with
get:babuffer is retur
get:banot filled.  If
get:baPUSH is seen, t
get:baTCP also provid
get:baat some point f
get:ba[Page 12]        
get:baSeptember 1981   
get:bacurrently readi
get:badefine what the
get:baurgent data, bu
get:batake action to 
get:ba2.9.  Precedence 
get:baThe TCP makes u
get:basecurity option
get:babasis to TCP us
get:baa multilevel se
get:bause only, and o
get:bacompartment.  C
get:bausers may be li
get:baTCP modules whi
get:baproperly mark o
get:baprecedence.  Su
get:bahigher level pr
get:bathem to specify
get:baprecedence of c
get:ba2.10.  Robustness
get:baTCP implementat:ions will follow a general principle of robustness
get:baconservative in
get:baTransmission Cont
get:ba[Page 14]        
get:baSeptember 1981   
get:ba3.1.  Header Form
get:baTCP segments ar
get:baheader carries 
get:badestination hos
get:baheader, supplyi
get:badivision allows
get:baTCP Header Form
get:ba0            
get:ba0 1 2 3 4 5 6
get:ba+-+-+-+-+-+-+-
get:ba|          Sou
get:ba+-+-+-+-+-+-+-
get:ba|             
get:ba+-+-+-+-+-+-+-
get:ba|             
get:ba+-+-+-+-+-+-+-
get:ba|  Data |     
get:ba| Offset| Rese
get:ba|       |     
get:ba+-+-+-+-+-+-+-
get:ba|           Ch
get:ba+-+-+-+-+-+-+-
get:ba|             
get:ba+-+-+-+-+-+-+-
get:ba|             
get:ba+-+-+-+-+-+-+-
get:baNote th
get:baSource Port:  1
get:baThe source po
get:baDestination Por:t
get:baThe destinati
get:baTransmission Cont
get:baFunctional Specif
get:baSequence Number:
get:baThe sequence 
get:bawhen SYN is p
get:bainitial seque
get:baAcknowledgment :Number
get:baIf the ACK co
get:banext sequence
get:bareceive.  Onc
get:baData Offset:  4
get:baThe number of
get:bathe data begi
get:baintegral numb
get:baReserved:  6 bi
get:baReserved for 
get:baControl Bits:  :6 bits (from left to right)
get:baURG:  Urgent 
get:baACK:  Acknowl
get:baPSH:  Push Fu
get:baRST:  Reset t
get:baSYN:  Synchro
get:baFIN:  No more
get:baWindow:  16 bit
get:baThe number of
get:baacknowledgmen
get:baChecksum:  16 b
get:baThe checksum 
get:bacomplement su
get:basegment conta
get:bachecksummed, 
get:baform a 16 bit
get:batransmitted a
get:bathe checksum 
get:baThe checksum 
get:ba[Page 16]        
get:baSeptember 1981   
get:baprefixed to t
get:baAddress, the 
get:baThis gives th
get:bainformation i
get:baacross the TC
get:bacalls by the 
get:baThe TCP Len
get:baoctets (thi
get:bacomputed), 
get:baUrgent Pointer:
get:baThis field co
get:bapositive offs
get:baurgent pointe
get:bathe urgent da
get:bathe URG contr
get:baOptions:  varia
get:baOptions may o
get:bamultiple of 8
get:bachecksum.  An
get:bacases for the: format of an option
get:baCase 1:  A 
get:baCase 2:  An
get:bath
get:baThe option-le
get:baoption-length
get:baNote that the
get:bafield might i
get:baEnd-of-Option
get:baA TCP must im
get:baTransmission Cont
get:baFunctional Specif
get:baCurrently def:ined options include (kind indicated in octal)
get:baKind     Le
get:ba----     --
get:ba0         
get:ba1         
get:ba2         
get:baSpecific Opti
get:baEnd of Opti
get:ba+--------
get:ba|00000000
get:ba+--------
get:baThis opti
get:bamight not
get:bathe Data 
get:banot the e
get:bathe optio
get:baNo-Operatio
get:ba+--------
get:ba|00000001
get:ba+--------
get:baThis opti
get:baalign the
get:baThere is 
get:bareceivers
get:banot begin
get:baMaximum Seg
get:ba+--------
get:ba|00000010
get:ba+--------
get:baKind=2  
get:ba[Page 18]        
get:baSeptember 1981   
get:baMaximum S:egment Size Option Data
get:baIf this
get:bareceive
get:baThis fi
get:ba(i.e., 
get:baoption 
get:baPadding:  varia
get:baThe TCP heade
get:baand data begi
get:ba3.2.  Terminology
get:baBefore we can d
get:bato introduce so
get:baconnection requ
get:baof these variab
get:baTransmission Co
get:baTCB are the loc
get:baprecedence of t
get:babuffers, pointe
get:baIn addition sev
get:basequence number
get:baSend Sequence
get:baSND.UNA - s
get:baSND.NXT - s
get:baSND.WND - s
get:baSND.UP  - s
get:baSND.WL1 - s
get:baSND.WL2 - s
get:bau
get:baISS     - i
get:baReceive Seque
get:baRCV.NXT - r
get:baRCV.WND - r
get:baRCV.UP  - r
get:baIRS     - i
get:baTransmission Cont
get:baFunctional Specif
get:baThe following d
get:bathe sequence sp
get:baSend Sequence S
get:ba---
get:ba1 - old s
get:ba2 - seque
get:ba3 - seque
get:ba4 - futur
get:baThe send window
get:baReceive Sequenc
get:ba1 - old s
get:ba2 - seque
get:ba3 - futur
get:baThe receive win
get:baThere are also 
get:batake their valu
get:ba[Page 20]        
get:baSeptember 1981   
get:baCurrent Segme
get:baSEG.SEQ - s
get:baSEG.ACK - s
get:baSEG.LEN - s
get:baSEG.WND - s
get:baSEG.UP  - s
get:baSEG.PRC - s
get:baA connection pr
get:balifetime.  The :states are
get:baESTABLISHED, FI
get:baTIME-WAIT, and 
get:babecause it repr
get:bano connection. : Briefly the meanings of the states are
get:baLISTEN - repr
get:baTCP and port.
get:baSYN-SENT - re
get:baafter having 
get:baSYN-RECEIVED 
get:barequest ackno
get:baconnection re
get:baESTABLISHED -
get:badelivered to 
get:baof the connec
get:baFIN-WAIT-1 - 
get:bafrom the remo
get:batermination r
get:baFIN-WAIT-2 - 
get:bafrom the remo
get:baCLOSE-WAIT - 
get:bafrom the loca
get:baCLOSING - rep
get:baacknowledgmen
get:baLAST-ACK - re
get:baconnection te
get:ba(which includ
get:baTransmission Cont
get:baFunctional Specif
get:baTIME-WAIT - r
get:bathe remote TC
get:batermination r
get:baCLOSED - repr
get:baA TCP connectio
get:baevents.  The ev
get:baABORT, and STAT
get:bacontaining the 
get:baThe state diagr
get:bawith the causin
get:baerror condition
get:bachanges.  In a 
get:bathe reaction of
get:baNOTE BENE:  thi
get:bathe total speci
get:ba[Page 22]        
get:baSeptember 1981   
get:ba+---------+     
get:ba|         |<----
get:ba|   SYN   |     
get:ba|   RCVD  |<----
get:ba|         |     
get:ba|         |-----
get:ba+---------+   rc
get:ba|           --
get:ba|             
get:ba|             
get:ba|  CLOSE      
get:ba| -------     
get:ba| snd FIN     
get:ba|             
get:baV             
get:ba+---------+     
get:ba|  FIN    |<----
get:ba| WAIT-1  |-----
get:ba+---------+     
get:ba| rcv ACK of F
get:ba| ------------
get:baV        x    
get:ba+---------+     
get:ba|FINWAIT-2|     
get:ba+---------+     
get:ba|             
get:ba|  rcv FIN    
get:ba|  -------    
get:ba\ snd ACK    
get:ba------------
get:baTransmission Cont
get:baFunctional Specif
get:ba3.3.  Sequence Nu
get:baA fundamental n
get:baover a TCP conn
get:basequenced, each
get:bamechanism emplo
get:banumber X indica
get:bareceived.  This
get:badetection in th
get:bawithin a segmen
get:bathe header is t
get:banumbered consec
get:baIt is essential
get:bafinite, though 
get:baSince the space
get:banumbers must be
get:bapreserves the r
get:ba2**32 - 1 to 0 
get:baarithmetic, so 
get:bacomparison of s
get:ba(modulo 2**32).
get:baThe typical kin
get:baperform include:
get:ba(a)  Determin
get:banumber s
get:ba(b)  Determin
get:bahave bee
get:baretransm
get:ba(c)  Determin
get:bawhich ar
get:bareceive 
get:ba[Page 24]        
get:baSeptember 1981   
get:baIn response to 
get:bafollowing compa
get:baSND.UNA = old
get:baSND.NXT = nex
get:baSEG.ACK = ack
get:banum
get:baSEG.SEQ = fir
get:baSEG.LEN = the
get:ba(co
get:baSEG.SEQ+SEG.L
get:baA new acknowled
get:bathe inequality :below holds
get:baSND.UNA < SEG
get:baA segment on th
get:baof its sequence
get:baacknowledgment 
get:baWhen data is re:ceived the following comparisons are needed
get:baRCV.NXT = nex
get:bais the le
get:baRCV.NXT+RCV.W
get:basegment, 
get:baSEG.SEQ = fir
get:baSEG.SEQ+SEG.L
get:baA segment is ju
get:baRCV.NXT =< SE
get:baRCV.NXT =< SE
get:baTransmission Cont
get:baFunctional Specif
get:baThe first part 
get:basegment falls i
get:baif the end of t
get:baeither part of 
get:baActually, it is
get:bawindows and zer
get:baacceptability o:f an incoming segment
get:baSegment Recei
get:baLength  Windo
get:ba------- -----
get:ba0       0 
get:ba0      >0 
get:ba>0       0 
get:ba>0      >0 
get:baNote that when 
get:baacceptable exce
get:bamaintain a zero
get:baACKs.  However,
get:baprocess the RST
get:baWe have taken a
get:bacontrol informa
get:basome control fl
get:baand acknowledge
get:bacontrol will be
get:bacarried in the 
get:bafor implicitly 
get:baare the only co
get:baare used only a
get:bapurposes, the S
get:baoctet of the se
get:bato occur after 
get:baoccurs.  The se
get:baspace occupying
get:basequence number
get:ba[Page 26]        
get:baSeptember 1981   
get:baInitial Sequenc
get:baThe protocol pl
get:baused over and o
get:basockets.  New i
get:baincarnations of
get:ba-- "how does th
get:baincarnations of
get:baconnection is b
get:baconnection brea
get:baTo avoid confus
get:baconnection from
get:babe present in t
get:baassure this, ev
get:basequence number
get:baan initial sequ
get:banew 32 bit ISN.
get:babit clock whose
get:bamicroseconds.  
get:baSince we assume
get:bathe Maximum Seg
get:bahours we can re
get:baFor each connec
get:basequence number
get:bathe data sendin
get:balearned during 
get:baFor a connectio
get:basynchronize on 
get:baan exchange of 
get:bacalled "SYN" (f
get:bashorthand, segm
get:baHence, the solu
get:bainitial sequenc
get:baThe synchroniza
get:basequence number
get:bafrom the other 
get:bainitial sequenc
get:ba1) A --> B  S
get:ba2) A <-- B  A
get:ba3) A <-- B  S
get:ba4) A --> B  A
get:baTransmission Cont
get:baFunctional Specif
get:baBecause steps 2
get:bacalled the thre
get:baA three way han
get:batied to a globa
get:bamechanisms for 
get:bano way of knowi
get:baunless it remem
get:ba(which is not a
get:baverify this SYN
get:baclock-driven sc
get:baKnowing When to
get:baTo be sure that
get:basequence number
get:bathe network, th
get:ba(MSL) before as
get:barecovering from
get:balost.  For this
get:bais an engineeri
get:bait is desirable
get:basense, yet reta
get:banot wait at all
get:bathan those rece
get:baThe TCP Quiet T
get:baThis specific
get:baretaining any
get:baeach active (
get:baTCP segments 
get:bain the intern
get:baparagraphs be
get:baTCP implement
get:baat the risk o
get:badata rejected
get:baTCPs consume 
get:baentered into 
get:baduplicate det
get:barelies on the
get:bathe extent th
get:bavalues before
get:babeen delivere
get:bacopies of the
get:basuch an assum
get:ba[Page 28]        
get:baSeptember 1981   
get:baassigned the 
get:baat the receiv
get:bathat each seg
get:baas there are 
get:baUnder normal 
get:bato emit and t
get:bamistakenly us
get:babeen acknowle
get:badata is drain
get:bavery large to
get:bacause trouble
get:bato use up 2**
get:balifetime in t
get:bathis is deeme
get:barates escalat
get:bacycle time is
get:bawithin reason
get:baThe basic dup
get:badefeated, how
get:basequence numb
get:bathe TCP were 
get:baupon crashing
get:baconnection (p
get:bapackets with 
get:bapackets still
get:baincarnation o
get:baabout the seq
get:baspecification
get:babefore emitti
get:basegments from
get:baEven hosts wh
get:bainitial seque
get:ba(i.e., even i
get:banumber for ea
get:baSuppose, for 
get:basequence numb
get:baand that even
get:batakes on a va
get:basegment sent 
get:baat this insta
get:baincarnation o
get:baS1 = ISN(t) -
get:baconnection!  
get:baTransmission Cont
get:baFunctional Specif
get:baduplicates in
get:baof S1 may arr
get:bathe new incar
get:baThe problem i
get:bacrashed nor d
get:bathe system fr
get:baOne way to de
get:basegments for 
get:batime" specifi
get:bawilling to ri
get:badestination m
get:baImplementors 
get:baconnection by
get:bainformally im
get:baObviously, ev
get:banecessary aft
get:baTo summarize:
get:banumbers in th
get:ba"busy" or "in
get:bablock of spac
get:basegment, if a
get:basequence numb
get:bathe previous 
get:banumber overla
get:ba3.4.  Establishin
get:baThe "three-way 
get:baconnection.  Th
get:baresponded to by
get:basimultaneously 
get:baoccurs, each TC
get:baacknowledgment 
get:baan old duplicat
get:barecipient, that
get:baProper use of "
get:baSeveral example
get:baexamples do not
get:basegments, this 
get:badoesn't deliver
get:bavalid (i.e., th
get:baconnection reac
get:bareduces the pos
get:ba[Page 30]        
get:baSeptember 1981   
get:baimplementation 
get:bainformation for
get:baThe simplest th
get:bafigures should 
get:banumbered for re
get:badeparture of a 
get:basegment at B fr
get:baEllipsis (...) 
get:ba(delayed).  An 
get:baComments appear
get:bathe departure o
get:bathe center of e
get:baform, with sequ
get:bafields such as 
get:bain the interest
get:baTCP A      
get:ba1.  CLOSED     
get:ba2.  SYN-SENT   
get:ba3.  ESTABLISHED
get:ba4.  ESTABLISHED
get:ba5.  ESTABLISHED
get:baBasic 3
get:baIn line 2 of fi
get:baindicating that
get:banumber 100.  In
get:bareceived from T
get:baB is now expect
get:baoccupied sequen
get:baAt line 4, TCP 
get:baTCP B's SYN; an
get:basequence number
get:babecause the ACK
get:bawould wind up A
get:baTransmission Cont
get:baFunctional Specif
get:baSimultaneous in
get:bafigure 8.  Each
get:baTCP A      
get:ba1.  CLOSED     
get:ba2.  SYN-SENT   
get:ba3.  SYN-RECEIVE
get:ba4.             
get:ba5.  SYN-RECEIVE
get:ba6.  ESTABLISHED
get:ba7.             
get:baS
get:baThe principle r
get:baduplicate conne
get:bathis, a special
get:bareceiving TCP i
get:baSYN-RECEIVED), 
get:baIf the TCP is i
get:baFIN-WAIT-1, FIN
get:baaborts the conn
get:bacase under "hal
get:ba[Page 32]        
get:baSeptember 1981   
get:baTCP A      
get:ba1.  CLOSED     
get:ba2.  SYN-SENT   
get:ba3.  (duplicate)
get:ba4.  SYN-SENT   
get:ba5.  SYN-SENT   
get:ba6.             
get:ba7.  SYN-SENT   
get:ba8.  ESTABLISHED
get:baAs a simple exa
get:bafigure 9.  At l
get:bacannot tell tha
get:ba(line 4).  TCP 
get:baRST (reset) wit
get:babelievable.  TC
get:baWhen the origin
get:basynchronization
get:babefore the RST,
get:basent in both di
get:baHalf-Open Conne
get:baAn established 
get:baTCPs has closed
get:baknowledge of th
get:babecome desynchr
get:bamemory.  Such c
get:baattempt is made
get:baconnections are
get:bamildly involved
get:baIf at site A th
get:baTransmission Cont
get:baFunctional Specif
get:bauser at site B 
get:bareceiving a res
get:basite B TCP that
get:baAssume that two
get:baanother when a 
get:baDepending on th
get:bathat some error
get:baA is likely to 
get:bapoint.  As a re
get:baor try to SEND 
get:bacase, it receiv
get:balocal (A's) TCP
get:bawill send a seg
get:baexample shown i
get:bare-open the con
get:baTCP A      
get:ba1.  (CRASH)    
get:ba2.  CLOSED     
get:ba3.  SYN-SENT --
get:ba4.  (!!)     <-
get:ba5.  SYN-SENT --
get:ba6.  SYN-SENT   
get:ba7.  SYN-SENT --
get:baWhen the SYN ar
get:baand the incomin
get:baacknowledgment 
get:ba100).  TCP A se
get:basent and, being
get:badetected a half
get:ba[Page 34]        
get:baSeptember 1981   
get:bacontinue to try
get:bareduced to the 
get:baAn interesting 
get:batries to send d
get:baThis is illustr
get:baTCP A from TCP 
get:baexists, so TCP 
get:baprocesses it an
get:baTCP A    
get:ba1.  (CRASH)    
get:ba2.  (??)    <--
get:ba3.          -->
get:baActive
get:baIn figure 12, w
get:bawaiting for SYN
get:bainto action.  A
get:bagenerate a RST 
get:bathe reset and r
get:baTCP A      
get:ba1.  LISTEN     
get:ba2.       ... <S
get:ba3.  (??) <-- <S
get:ba4.       --> <S
get:ba5.  LISTEN     
get:baOld Duplic
get:baTransmission Cont
get:baFunctional Specif
get:baA variety of ot
get:baby the followin
get:baReset Generatio
get:baAs a general ru
get:bawhich apparentl
get:bamust not be sen
get:baThere are three: groups of states
get:ba1.  If the co
get:bain response t
get:baparticular, S
get:baby this means
get:baIf the incomi
get:basequence numb
get:bareset has seq
get:baof the sequen
get:baThe connectio
get:ba2.  If the co
get:baSYN-SENT, SYN
get:basomething not
get:baif an incomin
get:badoes not exac
get:baconnection, a
get:baIf our SYN ha
get:baincoming segm
get:baeither raise 
get:bathe system) o
get:baincoming segm
get:bacontinue as i
get:bacannot raise 
get:badetected in t
get:baterminated th
get:baincoming segm
get:bamatch the loc
get:bamust be sent.
get:baIf the incomi
get:basequence numb
get:bareset has seq
get:baof the sequen
get:baThe connectio
get:ba[Page 36]        
get:baSeptember 1981   
get:ba3.  If the co
get:baFIN-WAIT-1, F
get:baany unaccepta
get:baunacceptible 
get:baacknowledgmen
get:baand an acknow
get:bato be receive
get:baIf an incomin
get:baprecedence wh
get:baand precedenc
get:baconnection go
get:banumber from t
get:baReset Processin
get:baIn all states e
get:baby checking the
get:bais in the windo
get:bato an initial S
get:baacknowledges th
get:baThe receiver of
get:bareceiver was in
get:bain SYN-RECEIVED
get:bathen the receiv
get:baaborts the conn
get:bawas in any othe
get:baand goes to the
get:ba3.5.  Closing a C
get:baCLOSE is an ope
get:banotion of closi
get:bainterpretation,
get:bathe receiving s
get:bain a simplex fa
get:bauntil he is tol
get:bacould initiate 
get:baRECEIVE until s
get:bahas CLOSED.  We
get:baRECEIVEs are ou
get:bacan terminate h
get:babuffers SENT be
get:badata in return 
get:basuccessfully to
get:baTCP.  Users mus
get:bathe TCP says no
get:baTransmission Cont
get:baFunctional Specif
get:baThere are essen:tially three cases
get:ba1) The user i
get:ba2) The remote
get:ba3) Both users
get:baCase 1:  Local 
get:baIn this case,
get:baoutgoing segm
get:baaccepted by t
get:baare allowed i
get:bawill be retra
get:baboth acknowle
get:bacan ACK this 
get:basend its own 
get:baCase 2:  TCP re
get:baIf an unsolic
get:bacan ACK it an
get:bauser will res
get:bathe other TCP
get:bauntil its own
get:baconnection.  
get:bathe connectio
get:baCase 3:  both u
get:baA simultaneou
get:baFIN segments 
get:bahave been pro
get:bahas received.
get:ba[Page 38]        
get:baSeptember 1981   
get:baTCP A      
get:ba1.  ESTABLISHED
get:baFIN-WAIT-1 
get:ba3.  FIN-WAIT-2 
get:ba4.             
get:baTIME-WAIT  
get:ba5.  TIME-WAIT  
get:baCLOSED     
get:baTCP A      
get:ba1.  ESTABLISHED
get:ba2.  (Close)    
get:baFIN-WAIT-1 
get:ba3.  CLOSING    
get:ba4.  TIME-WAIT  
get:ba(2 MSL)    
get:baCLOSED     
get:baTransmission Cont
get:baFunctional Specif
get:ba3.6.  Precedence 
get:baThe intent is t
get:bawith exactly th
get:bahigher of the p
get:baThe precedence 
get:badefined in the 
get:baspecification t
get:bathe security pa
get:bauser group, and
get:baA connection at
get:balower precedenc
get:baa connection du
get:baacknowledgment 
get:baNote that TCP m
get:baprecedence will
get:basegments and po
get:baThe security pa
get:ba(the values wou
get:banon-secure envi
get:baparameters, tho
get:ba3.7.  Data Commun
get:baOnce the connec
get:baexchange of seg
get:ba(checksum test 
get:baretransmission 
get:baDuplicate segme
get:baAs discussed in
get:bacertain tests o
get:basegments to ver
get:baThe sender of d
get:bathe variable SN
get:basequence number
get:bakeeps track of 
get:bavariable SND.UN
get:basent has been a
get:baWhen the sender
get:baSND.NXT.  When 
get:basends an acknow
get:ba[Page 40]        
get:baSeptember 1981   
get:baacknowledgment 
get:bathese variables
get:baThe amount by w
get:badata in the seg
get:basegments must c
get:baThe CLOSE user 
get:baflag in an inco
get:baRetransmission 
get:baBecause of the 
get:bainternetwork sy
get:baretransmission 
get:bafor determining
get:baAn Example Re
get:baMeasure the
get:baparticular 
get:bacovers that
get:basegments re
get:baTime (RTT).:  Next compute a Smoothed Round Trip Time (SRTT) as
get:baSRTT = ( 
get:baand based o:n this, compute the retransmission timeout (RTO) as
get:baRTO = min
get:bawhere UBOUN
get:baLBOUND is a
get:baa smoothing
get:bafactor (e.g
get:baThe Communicati
get:baThe objective o
get:bato stimulate th
get:bapermit the rece
get:bathe currently k
get:baThis mechanism 
get:bathe end of urge
get:bathe receive seq
get:bamust tell the u
get:banumber catches 
get:baTransmission Cont
get:baFunctional Specif
get:bainto "normal mo
get:bais in "urgent m
get:baThe method empl
get:batransmitted.  T
get:bameaningful and 
get:bathe urgent poin
get:bano urgent data 
get:baTo send an urge
get:baoctet.  If the 
get:bathe urgent info
get:baManaging the Wi
get:baThe window sent
get:banumbers the sen
get:baprepared to acc
get:bathe currently a
get:baIndicating a la
get:baarrives than ca
get:bain excessive re
get:banetwork and the
get:batransmission of
get:babetween each ne
get:baThe mechanisms 
get:basubsequently ad
get:bathat much data.
get:badiscouraged.  T
get:bashrink the wind
get:baon the part of 
get:baThe sending TCP
get:baleast one octet
get:basending TCP mus
get:bathe window is z
get:bainterval when t
get:baguarantee that 
get:bawindow will be 
get:baWhen the receiv
get:bastill send an a
get:baand current win
get:baThe sending TCP
get:ba[Page 42]        
get:baSeptember 1981   
get:bawhich fit the c
get:baretransmission 
get:baIn a connection
get:babe carried in a
get:banumber so there
get:baorder.  This is
get:bainformation to 
get:bathe data receiv
get:bathe window info
get:baacknowledgment 
get:baequal or greate
get:baThe window mana
get:bacommunication p
get:baWindow Manage
get:baAllocating 
get:bamany small 
get:bafewer large
get:baOne suggest
get:badefer updat
get:baleast X per
get:baconnection 
get:baAnother sug
get:basegments by
get:basending dat
get:badata must b
get:baNote that t
get:baretransmiss
get:baacknowledgm
get:bawindow info
get:banew window 
get:baThe segment
get:baof transmit
get:basegment con
get:bais accepted
get:baIf the send
get:bawindow is n
get:baalternating
get:bapauses in t
get:baTransmission Cont
get:baFunctional Specif
get:baresult in b
get:babig pair. A
get:bamostly smal
get:baThe suggest
get:baactively at
get:bawindows, si
get:bato many sma
get:baThere are of co:urse two interfaces of concern
get:baand the TCP/low
get:baof the user/TCP
get:baprotocol module
get:bain detail by th
get:bacase that the l
get:bathat TCPs might
get:baUser/TCP Interf
get:baThe following
get:baat best, fict
get:bafacilities.  
get:baimplementatio
get:baTCPs must pro
get:bathat all TCP 
get:bahierarchy.  T
get:barequired of a
get:baTCP User Comm
get:baThe followi
get:bainterface. 
get:bafunction ca
get:bameant to ru
get:baThe user co
get:baTCP must pe
get:baIndividual 
get:bamay provide
get:basingle call
get:baautomatical
get:baissued by t
get:ba[Page 44]        
get:baSeptember 1981   
get:baIn providin
get:banot only ac
get:baprocesses i:t serves.  The latter consists of
get:ba(a) gener
get:baremote cl
get:ba(b) repli
get:bavarious t
get:baFormat:  
get:ba[, timeou
get:ba-> local 
get:baWe assume
get:baprocesses
get:bato use th
get:baimplement
get:bafor the s
get:balower lev
get:baresult of
get:baable to m
get:baprocess c
get:baIf the ac
get:bacall to L
get:bahave eith
get:baparticula
get:bafor any c
get:baby the su
get:baA transmi
get:bafilled in
get:baOn an act
get:basynchroni
get:baThe timeo
get:bafor all d
get:badelivered
get:bawill abor
get:baThe TCP o
get:bathe users
get:baTransmission Cont
get:baFunctional Specif
get:baprecedenc
get:baor securi
get:bathe defau
get:baTCP will 
get:basecurity/
get:bathe prece
get:barequested
get:baThe prece
get:barequested
get:barequest, 
get:baconnectio
get:bathis prec
get:baallowed t
get:baor that a
get:baA local c
get:baThe local
get:bafor the c
get:baFormat:  
get:bacount, PU
get:baThis call
get:bato be sen
get:banot been 
get:baimplement
get:baautomatic
get:baauthorize
get:baIf the PU
get:bato the re
get:basegment c
get:bathe data 
get:batransmiss
get:baIf the UR
get:bawill have
get:bathe urgen
get:bapointer i
get:babeen cons
get:bais to sti
get:baindicate 
get:ba[Page 46]        
get:baSeptember 1981   
get:badata has 
get:baTCP signa
get:baof times 
get:baurgent da
get:baIf no for
get:baconnectio
get:bahas becom
get:balocal soc
get:baforeign s
get:baforeign s
get:baknowing t
get:baHowever, 
get:babecomes s
get:baSTATUS ca
get:baimplement
get:basocket is
get:baIf a time
get:baconnectio
get:baIn the si
get:bathe sendi
get:baor the ti
get:bais both s
get:baconnectio
get:baoffers po
get:basophistic
get:bathe proce
get:bafurthermo
get:baMultiple 
get:bathe TCP w
get:baWe have i
get:bawhich a S
get:bapseudo-in
get:bareturn a 
get:baimmediate
get:babeen ackn
get:baassume ev
get:baclose any
get:bakind (syn
get:basignals, 
get:bawith spec
get:baIn order 
get:baindicatio
get:baTransmission Cont
get:baFunctional Specif
get:babuffer ad
get:bathe SEND 
get:baindicatin
get:bacalling p
get:baFormat:  
get:bacount) ->
get:baThis comm
get:baspecified
get:bacalling p
get:baerror is 
get:baIn the si
get:bacalling p
get:baerror occ
get:baA more so
get:baRECEIVEs 
get:basegments 
get:bathe cost 
get:banotify th
get:baIf enough
get:bathe PUSH 
get:baThe buffe
get:baa PUSH is
get:bareturned 
get:baIf there 
get:baas it arr
get:bashould th
get:baadditiona
get:bacall to R
get:bamay now l
get:baurgent po
get:bain the sa
get:baboundary 
get:baTo distin
get:bacare of t
get:bareturn co
get:bacount ind
get:baAlternati
get:ba[Page 48]        
get:baSeptember 1981   
get:baallocate 
get:bawith the 
get:baFormat:  
get:baThis comm
get:bathe conne
get:baauthorize
get:baClosing c
get:bathe sense
get:baretransmi
get:baserviced.
get:bacalls, fo
get:bato the de
get:bacontinue 
get:bamay be tr
get:bameans "I 
get:bareceive a
get:banot well 
get:baof all it
get:bainto ABOR
get:baThe user 
get:bainitiativ
get:ba(e.g., re
get:badestinati
get:baBecause c
get:baforeign T
get:bashort tim
get:bareplies t
get:baClose als
get:baFormat:  
get:baThis is a
get:baexcluded 
get:batypically
get:baThis comm
get:bainformati:on
get:balocal s
get:baTransmission Cont
get:baFunctional Specif
get:baforeign
get:balocal c
get:bareceive
get:basend wi
get:baconnect
get:banumber 
get:banumber 
get:baurgent 
get:baprecede
get:basecurit
get:baand tra
get:baDepending
get:baimplement
get:baavailable
get:baauthorize
get:baprevents 
get:baconnectio
get:baFormat:  
get:baThis comm
get:baaborted, 
get:babe sent t
get:baDepending
get:baindicatio
get:bareceive a
get:baTCP-to-User M
get:baIt is assum
get:bameans for t
get:bathe TCP doe
get:bato the user
get:baan error me
get:barelating to
get:baother user 
get:baThe followi:ng information is provided
get:baLocal Con
get:baResponse 
get:baBuffer Ad
get:baByte coun
get:baPush flag
get:baUrgent fl
get:ba[Page 50]        
get:baSeptember 1981   
get:baTCP/Lower-Level
get:baThe TCP calls
get:bareceive infor
get:bainternetwork 
get:baProtocol (IP)
get:baIf the lower 
get:baof service an
get:bafor these par:ameters
get:baType of Ser:vice = Precedence: routine, Delay: normal, Throughput
get:banormal, Rel:iability
get:baTime to Liv
get:baNote that
get:baHere we e
get:babe delive
get:baIf the lower 
get:bafeature) and 
get:baroute informa
get:baso that the s
get:bachecksum be t
get:baalso importan
get:baAny lower lev
get:badestination a
get:bathe "TCP leng
get:baof IP and to 
get:baTransmission Cont
get:baFunctional Specif
get:ba3.9.  Event Proce
get:baThe processing 
get:baimplementation.
get:baprocessing sequ
get:basection only in
get:baThe activity of
get:baThe events that: occur can be cast into three categories
get:baarriving segmen
get:baprocessing the 
get:bacases the proce
get:baEvents that o:ccur
get:baArriving Se
get:baSEGMENT A
get:baUSER TIME
get:baRETRANSMI
get:baTIME-WAIT
get:baThe model of th
get:baimmediate retur
get:bapseudo interrup
get:bameans cause a d
get:baError responses
get:bacommands refere:ncing connections that do not exist receive "error
get:baconnection not 
get:baPlease note in 
get:baacknowledgment 
get:baof the sequence
get:baequal to (modul
get:ba[Page 52]        
get:baSeptember 1981   
get:baA natural way t
get:baimagine that th
get:bathat their cont
get:bain the sequence
get:baand processed i
get:baWhen a segment 
get:bathe segment to 
get:bato be consisten
get:baNote that if no
get:baTransmission Cont
get:baFunctional Specif
get:baCLOSED STATE 
get:baCreate a ne
get:bastate infor
get:basocket, pre
get:bainformation
get:baunspecified
get:baparameters 
get:baprecedence 
get:ba"error:  pr:ecedence not allowed" or "error
get:banot allowed
get:baactive and :the foreign socket is unspecified, return "error
get:baforeign soc
get:baspecified, 
get:ba(ISS) is se
get:bais sent.  S
get:bastate, and 
get:baIf the call
get:bareturn "err:or
get:bano room to :create a new connection, return "error
get:baresources".
get:baIf active a
get:baconnection 
get:basegment, se
get:bastate.  Dat
get:baqueued for 
get:baurgent bit 
get:basegments se
get:baqueue the r:equest, respond with "error
get:baIf Foreign :socket was not specified, then return "error
get:basocket unsp
get:ba[Page 54]        
get:baSeptember 1981   
get:baSYN-SENT STAT
get:baSYN-RECEIVED 
get:baESTABLISHED S
get:baFIN-WAIT-1 ST
get:baFIN-WAIT-2 ST
get:baCLOSE-WAIT ST
get:baCLOSING STATE
get:baLAST-ACK STAT
get:baTIME-WAIT STA
get:baReturn "err:or
get:baTransmission Cont
get:baFunctional Specif
get:baCLOSED STATE 
get:baIf the user
get:ba"error:  co
get:baOtherwise, :return "error
get:baIf the fore
get:bafrom passiv
get:baSND.UNA to 
get:baassociated 
get:batransmissio
get:barequested i
get:baas a result
get:barequest, re:spond with "error
get:baForeign soc:ket was not specified, then return "error
get:basocket unsp
get:baSYN-SENT STAT
get:baSYN-RECEIVED 
get:baQueue the d
get:baIf no space: to queue, respond with "error
get:baresources".
get:baESTABLISHED S
get:baCLOSE-WAIT ST
get:baSegmentize 
get:baacknowledgm
get:bainsufficien:t space to remember this buffer, simply return "error
get:bainsufficien
get:baIf the urge
get:baurgent poin
get:ba[Page 56]        
get:baSeptember 1981   
get:baFIN-WAIT-1 ST
get:baFIN-WAIT-2 ST
get:baCLOSING STATE
get:baLAST-ACK STAT
get:baTIME-WAIT STA
get:baReturn "err:or
get:baTransmission Cont
get:baFunctional Specif
get:baCLOSED STATE 
get:baIf the user
get:ba"error:  co
get:baOtherwise r:eturn "error
get:baSYN-SENT STAT
get:baSYN-RECEIVED 
get:baQueue for p
get:bais no room :to queue this request, respond with "error
get:bainsufficien
get:baESTABLISHED S
get:baFIN-WAIT-1 ST
get:baFIN-WAIT-2 ST
get:baIf insuffic
get:barequest, qu
get:baremember th:e RECEIVE, respond with "error
get:baresources".
get:baReassemble 
get:bato user.  M
get:baIf RCV.UP i
get:bauser notify
get:baWhen the TC
get:bathat fact m
get:baacknowledgm
get:badescribed b
get:ba[Page 58]        
get:baSeptember 1981   
get:baCLOSE-WAIT ST
get:baSince the r
get:basatisfied b
get:bauser.  If n
get:ba"error:  co
get:batext can be
get:baCLOSING STATE
get:baLAST-ACK STAT
get:baTIME-WAIT STA
get:baReturn "err:or
get:baTransmission Cont
get:baFunctional Specif
get:baCLOSED STATE 
get:baIf the user
get:ba"error:  co
get:baOtherwise, :return "error
get:baAny outstan:ding RECEIVEs are returned with "error
get:baresponses. 
get:baSYN-SENT STAT
get:baDelete the :TCB and return "error
get:baqueued SEND
get:baSYN-RECEIVED 
get:baIf no SENDs
get:bathen form a
get:baotherwise q
get:baESTABLISHED S
get:baQueue this 
get:baform a FIN 
get:baFIN-WAIT-1 ST
get:baFIN-WAIT-2 ST
get:baStrictly sp:eaking, this is an error and should receive a "error
get:baconnection 
get:baacceptable,
get:baFIN may be 
get:ba[Page 60]        
get:baSeptember 1981   
get:baCLOSE-WAIT ST
get:baQueue this 
get:basegmentized
get:baCLOSING STATE
get:baLAST-ACK STAT
get:baTIME-WAIT STA
get:baRespond wit:h "error
get:baTransmission Cont
get:baFunctional Specif
get:baCLOSED STATE 
get:baIf the user
get:ba"error:  co
get:baOtherwise r:eturn "error
get:baAny outstan:ding RECEIVEs should be returned with "error
get:baconnection 
get:baSYN-SENT STAT
get:baAll queued 
get:banotificatio
get:baSYN-RECEIVED 
get:baESTABLISHED S
get:baFIN-WAIT-1 ST
get:baFIN-WAIT-2 ST
get:baCLOSE-WAIT ST
get:baSend a rese:t segment
get:ba<SEQ=SND.
get:baAll queued 
get:banotificatio
get:baRST formed 
get:baTCB, enter 
get:baCLOSING STATE
get:baLAST-ACK STAT
get:baTIME-WAIT STA
get:baRespond wit
get:ba[Page 62]        
get:baSeptember 1981   
get:baCLOSED STATE 
get:baIf the user
get:ba"error:  co
get:baOtherwise r:eturn "error
get:baReturn "sta
get:baSYN-SENT STAT
get:baReturn "sta
get:baSYN-RECEIVED 
get:baReturn "sta
get:baESTABLISHED S
get:baReturn "sta
get:baFIN-WAIT-1 ST
get:baReturn "sta
get:baFIN-WAIT-2 ST
get:baReturn "sta
get:baCLOSE-WAIT ST
get:baReturn "sta
get:baCLOSING STATE
get:baReturn "sta
get:baLAST-ACK STAT
get:baReturn "sta
get:baTransmission Cont
get:baFunctional Specif
get:baTIME-WAIT STA
get:baReturn "sta
get:ba[Page 64]        
get:baSeptember 1981   
get:baSEGMENT ARRIVES
get:baIf the state 
get:baall data in
get:basegment con
get:bacontaining 
get:baacknowledgm
get:bareset seque
get:baIf the ACK 
get:ba<SEQ=0><A
get:baIf the ACK 
get:ba<SEQ=SEG.
get:baIf the state 
get:bafirst check
get:baAn incomi
get:basecond chec
get:baAny ackno
get:bathe LISTE
get:bafor any a
get:baformatted: as follows
get:ba<SEQ=SE
get:bathird check
get:baIf the SY
get:basecurity/
get:bamatch the
get:ba<SEQ=SE
get:baTransmission Cont
get:baFunctional Specif
get:baIf the SE
get:bathe user 
get:basend a re
get:ba<SEQ=SE
get:baIf the SE
get:baSet RCV.N
get:bacontrol o
get:bashould be: selected and a SYN segment sent of the form
get:ba<SEQ=IS
get:baSND.NXT i
get:bastate sho
get:baincoming 
get:bain the SY
get:banot be re
get:bathe forei
get:baunspecifi
get:bafourth othe
get:baAny other
get:bamust have
get:baprocessin
get:bait could 
get:baincarnati
get:babut if yo
get:baIf the state 
get:bafirst check
get:baIf the AC
get:baIf SEG.
get:bathe RST
get:ba<SEQ=
get:baand dis
get:baIf SND.
get:basecond chec
get:ba[Page 66]        
get:baSeptember 1981   
get:baIf the RS
get:baIf the :ACK was acceptable then signal the user "error
get:baconnect
get:badelete 
get:baand ret
get:bathird check
get:baIf the se
get:bamatch the
get:baIf ther
get:ba<SEQ=
get:baOtherwi
get:ba<SEQ=
get:baIf there 
get:baThe pre
get:baTCB, if
get:ba<SEQ=
get:baIf there 
get:baIf the 
get:bain the 
get:bathe pre
get:baallowed
get:ba<SEQ=
get:baIf the 
get:bain the 
get:baIf a rese
get:bafourth chec
get:baThis step
get:bano ACK, a
get:baIf the SY
get:baTransmission Cont
get:baFunctional Specif
get:baare accep
get:baSEG.SEQ. 
get:bais an ACK
get:baare there
get:baIf SND.UN
get:bastate to 
get:ba<SEQ=SN
get:baand send 
get:batransmiss
get:batext in t
get:babelow whe
get:baOtherwise
get:ba<SEQ=IS
get:baand send 
get:basegment, 
get:bahas been 
get:bafifth, if n
get:basegment and
get:ba[Page 68]        
get:baSeptember 1981   
get:bafirst check s
get:baSYN-RECEIVE
get:baESTABLISHED
get:baFIN-WAIT-1 
get:baFIN-WAIT-2 
get:baCLOSE-WAIT 
get:baCLOSING STA
get:baLAST-ACK ST
get:baTIME-WAIT S
get:baSegments 
get:baare used 
get:badone in S
get:baboundary 
get:baprocessed
get:baThere are
get:basegment
get:baSegment R
get:baLength  W
get:ba------- -
get:ba0     
get:ba0     
get:ba>0     
get:ba>0     
get:baIf the RC
get:baspecial a
get:baIf an inc
get:bashould be
get:bathe segme:nt and return)
get:ba<SEQ=SN
get:baAfter sen
get:baand retur
get:baTransmission Cont
get:baFunctional Specif
get:baIn the fo
get:basegment t
get:baOne could
get:batrimming 
get:baSYN and F
get:babegins at
get:banumbers m
get:basecond check 
get:baSYN-RECEIVE
get:baIf the RS
get:baIf this
get:bacame fr
get:baLISTEN 
get:bathis co
get:bafrom SY
get:bathe use
get:baon the 
get:baactive 
get:baand ret
get:baESTABLISHED
get:baIf the RS
get:bashould re
get:baflushed. 
get:ba"connecti
get:baTCB, and 
get:baCLOSING STA
get:baLAST-ACK ST
get:baIf the RS
get:baTCB, and 
get:ba[Page 70]        
get:baSeptember 1981   
get:bathird check s
get:baSYN-RECEIVE
get:baIf the se
get:baexactly m
get:bathen send
get:baESTABLISHED
get:baIf the se
get:baexactly m
get:bathen send
get:bareceive "
get:baflushed. 
get:ba"connecti
get:baTCB, and 
get:baNote this c
get:baa segment f
get:badifferent s
get:bacurrent con
get:bafourth, check
get:baSYN-RECEIVE
get:baESTABLISHED
get:baFIN-WAIT ST
get:baFIN-WAIT ST
get:baCLOSE-WAIT 
get:baCLOSING STA
get:baLAST-ACK ST
get:baTIME-WAIT S
get:baIf the SY
get:baoutstandi
get:baall segme
get:bareceive a
get:bathe CLOSE
get:baIf the SY
get:baand an ac
get:banumber ch
get:baTransmission Cont
get:baFunctional Specif
get:bafifth check t
get:baif the ACK 
get:baif the ACK 
get:baSYN-RECEI
get:baIf SND.
get:baand con
get:baIf th
get:bareset
get:ba<SE
get:baand s
get:baESTABLISH
get:baIf SND.
get:baAny seg
get:baentirel
get:bapositiv
get:bafully a
get:ba"ok" re
get:ba(SEG.AC
get:basomethi
get:badrop th
get:baIf SND.
get:baupdated
get:baSND.WL2
get:baSND.WL1
get:baNote th
get:barecords
get:baSND.WND
get:bathe las
get:baprevent
get:ba[Page 72]        
get:baSeptember 1981   
get:baFIN-WAIT-
get:baIn addi
get:baour FIN
get:baprocess
get:baFIN-WAIT-
get:baIn addi
get:bathe ret
get:baacknowl
get:baCLOSE-WAI
get:baDo the 
get:baCLOSING S
get:baIn addi
get:bathe ACK
get:baotherwi
get:baLAST-ACK 
get:baThe onl
get:baacknowl
get:badelete 
get:baTIME-WAIT
get:baThe onl
get:baretrans
get:bathe 2 M
get:basixth, check 
get:baESTABLISHED
get:baFIN-WAIT-1 
get:baFIN-WAIT-2 
get:baIf the UR
get:bathe user 
get:bapointer (
get:bauser has 
get:bamode") fo
get:basignal th
get:baTransmission Cont
get:baFunctional Specif
get:baCLOSE-WAIT 
get:baCLOSING STA
get:baLAST-ACK ST
get:baThis shou
get:baremote si
get:baseventh, proc
get:baESTABLISHED
get:baFIN-WAIT-1 
get:baFIN-WAIT-2 
get:baOnce in t
get:batext to u
get:bainto buff
get:baempty.  I
get:bathe user 
get:bahas been 
get:baWhen the 
get:bauser it m
get:baOnce the 
get:baRCV.NXT o
get:baapporopri
get:baRCV.NXT a
get:baPlease no
get:baSend an a:cknowledgment of the form
get:ba<SEQ=SN
get:baThis ackn
get:batransmitt
get:ba[Page 74]        
get:baSeptember 1981   
get:baCLOSE-WAIT 
get:baCLOSING STA
get:baLAST-ACK ST
get:baTIME-WAIT S
get:baThis shou
get:baremote si
get:baeighth, check
get:baDo not proc
get:basince the S
get:baIf the FIN 
get:bareturn any 
get:baover the FI
get:baFIN implies
get:baSYN-RECEI
get:baESTABLISH
get:baEnter t
get:baFIN-WAIT-
get:baIf our 
get:baenter T
get:batimers;
get:baFIN-WAIT-
get:baEnter t
get:baoff the
get:baCLOSE-WAI
get:baRemain 
get:baCLOSING S
get:baRemain 
get:baLAST-ACK 
get:baRemain 
get:baTransmission Cont
get:baFunctional Specif
get:baTIME-WAIT
get:baRemain 
get:batimeout
get:ba[Page 76]        
get:baSeptember 1981   
get:baFor any state
get:bathe user "err:or
get:baand for any o
get:bastate and ret
get:baRETRANSMISSION 
get:baFor any state
get:bathe retransmi
get:baretransmissio
get:baTIME-WAIT TIMEO
get:baIf the time-w
get:baenter the CLO
get:baTransmission Cont
get:ba[Page 78]        
get:baSeptember 1981   
get:baBBN Rep
get:baa Host 
get:bahost an
get:baA contr
get:baindicat
get:baspecifi
get:bais expe
get:bapreviou
get:baThe uni
get:baARPANET
get:baA unit 
get:baIMPs.  
get:baA logic
get:baA messa
get:banetwork
get:baDestination Addre
get:baThe des
get:baidentif
get:baA contr
get:baindicat
get:baoccupyi
get:baA porti
get:bafragmen
get:baA file 
get:baTransmission Cont
get:baControl
get:bafragmen
get:baA compu
get:bafrom th
get:baAn Inte
get:baby the 
get:baThe Int
get:baARPANET
get:baA sourc
get:bainternet datagram
get:baThe uni
get:bahigher 
get:bainternet fragment
get:baA porti
get:baheader.
get:baInterne
get:baThe Ini
get:banumber 
get:baThe Ini
get:baon a co
get:babased p
get:baThe Ini
get:baused by
get:baControl
get:badata.  
get:baon an A
get:ba[Page 80]        
get:baSeptember 1981   
get:baThis is
get:badata re
get:basequenc
get:baof the 
get:baThe uni
get:baAn impl
get:baprocedu
get:baMaximum
get:bathe int
get:baAn eigh
get:baAn Opti
get:bamay be 
get:baprimari
get:batimesta
get:baoptions
get:baA packa
get:balogical
get:balogical
get:baThe por
get:baoutput 
get:baA progr
get:bathe poi
get:baA contr
get:bathis se
get:bareceivi
get:bareceive
get:baTransmission Cont
get:bareceive
get:RFC
get:De
get:I
get:September 1981   
get:PREFACE .....
get:1.  INTRODUCTION 
get:1.1  Motivation
get:1.2  Scope ....
get:1.3  About This
get:1.4  Interfaces
get:1.5  Operation 
get:2.  PHILOSOPHY ..
get:2.1  Elements o
get:2.2  Model of O
get:2.3  The Host E
get:2.4  Interfaces
get:2.5  Relation t
get:2.6  Reliable C
get:2.7  Connection
get:2.8  Data Commu
get:2.9  Precedence
get:2.10 Robustness
get:3.  FUNCTIONAL SP
get:3.1  Header For
get:3.2  Terminolog
get:3.3  Sequence N
get:3.4  Establishi
get:3.5  Closing a 
get:3.6  Precedence
get:3.7  Data Commu
get:3.8  Interfaces
get:3.9  Event Proc
get:GLOSSARY ........
get:REFERENCES ......
get:Transmission Cont
get:[Page ii]        
get:September 1981   
get:This document des
get:(TCP).  There hav
get:specification on 
get:draws heavily fro
get:both in terms of 
get:several details a
get:and redescribes t
get:RFC
get:Replaces: RFC 761
get:IENs:  129, 124, 
get:55, 44, 40, 27, 2
get:The Transmission 
get:reliable host-to-
get:communication net
get:This document des
get:Transmission Cont
get:interface to prog
get:Computer commun
get:role in militar
get:document focuse
get:communication r
get:communication u
get:congestion, but
get:government sect
get:As strategic an
get:developed and d
get:interconnecting
get:communication p
get:applications.  
get:Deputy Undersec
get:declared the Tr
get:be a basis for 
get:standardization
get:TCP is a connec
get:fit into a laye
get:applications.  
get:communication b
get:distinct but in
get:assumptions are
get:protocols below
get:potentially unr
get:protocols.  In 
get:wide spectrum o
get:connections to 
get:Transmission Cont
get:TCP is based on
get:TCP fits into a
get:Internet Protoc
get:receive variabl
get:datagram "envel
get:addressing sour
get:internet protoc
get:the TCP segment
get:multiple networ
get:also carries in
get:and compartment
get:communicated en
get:Much of this do
get:which are co-re
get:computer.  Some
get:front-end compu
get:as well as netw
get:an interface to
get:implementable e
get:host-to-front e
get:The TCP is inte
get:communication s
get:intended to be 
get:1.3.  About this 
get:This document r
get:any TCP impleme
get:protocols and i
get:[Page 2]         
get:September 1981   
get:section offers 
get:operation.  Sec
get:design.  Sectio
get:required of TCP
get:user calls, err
get:The TCP interfa
get:the other side 
get:The interface b
get:illustrated in 
get:calls much like
get:application pro
get:calls to open a
get:established con
get:asynchronously 
get:considerable fr
get:interfaces whic
get:environment, a 
get:interface for a
get:The interface b
get:unspecified exc
get:two levels can 
get:Typically, one 
get:interface.  TCP
get:interconnected 
get:throughout this
get:As noted above,
get:securable logic
get:processes.  To 
get:communication s:ystem requires facilities in the following areas
get:Basic Data Tr
get:Precedence an
get:The basic opera
get:the following p
get:Transmission Cont
get:Basic Data Tran:sfer
get:The TCP is ab
get:direction bet
get:segments for 
get:the TCPs deci
get:Sometimes use
get:submitted to 
get:function is d
get:actually tran
get:pushed throug
get:promptly forw
get:The exact pus
get:the push func
get:Reliability
get:The TCP must 
get:delivered out
get:is achieved b
get:transmitted, 
get:receiving TCP
get:interval, the
get:numbers are u
get:out of order 
get:adding a chec
get:receiver, and
get:As long as th
get:system does n
get:errors will a
get:internet comm
get:Flow Control
get:TCP provides 
get:sent by the s
get:every ACK ind
get:the last segm
get:allowed numbe
get:receiving fur
get:[Page 4]         
get:September 1981   
get:Multiplexing
get:To allow for 
get:communication
get:addresses or 
get:and host addr
get:a socket.  A 
get:That is, a so
get:The binding o
get:Host.  Howeve
get:(e.g., a "log
get:made known to
get:through the k
get:addresses of 
get:Connections
get:The reliabili
get:that TCPs ini
get:each data str
get:sockets, sequ
get:Each connecti
get:identifying i
get:When two proc
get:establish a c
get:side).  When 
get:terminated or
get:Since connect
get:over the unre
get:mechanism wit
get:erroneous ini
get:Precedence and :Security
get:The users of 
get:communication
get:these feature
get:Transmission Cont
get:[Page 6]         
get:September 1981   
get:2.1.  Elements of
get:The internetwor
get:which are in tu
get:that the networ
get:large networks 
get:packet switchin
get:consume message
get:networks, the g
get:communication s
get:connections bet
get:The term packet
get:transaction bet
get:exchanged withi
get:Hosts are compu
get:network's point
get:Processes are v
get:accordance with
get:in execution). 
get:viewed as commu
get:Thus, all commu
get:Since a process
get:streams between
get:that each proce
get:communicates wi
get:2.2.  Model of Op
get:Processes trans
get:data as argumen
get:segments and ca
get:the destination
get:into the receiv
get:TCPs include co
get:ensure reliable
get:The model of in
get:protocol module
get:to the local ne
get:inside internet
get:internet module
get:through the loc
get:The packet swit
get:Transmission Cont
get:other operation
get:destination int
get:At a gateway be
get:from its local 
get:the internet da
get:then "wrapped" 
get:routed to the n
get:A gateway is pe
get:internet datagr
get:through the nex
get:internet datagr
get:further broken 
get:internet datagr
get:internet module
get:A destination i
get:(after reassemb
get:destination TCP
get:This simple mod
get:important featu
get:to the gateway 
get:service paramet
get:Included in the
get:datagram.  Data
get:host and gatewa
get:properly segreg
get:2.3.  The Host En
get:The TCP is assu
get:access the TCP 
get:may call on oth
get:data structures
get:controlled by a
get:network device 
get:datagram protoc
get:The mechanisms 
get:front-end proce
get:host-to-front-e
get:the type of TCP
get:[Page 8]         
get:September 1981   
get:The TCP/user in
get:to OPEN or CLOS
get:STATUS about a 
get:programs on the
get:from, and close
get:The TCP/interne
get:datagrams addre
get:system.  These 
get:service, preced
get:2.5.  Relation to
get:The following d
get:hierarchy
get:+------+ +
get:|Telnet| |
get:+------+ +
get:|   
get:+----
get:| TCP
get:+----
get:| 
get:+----
get:|    
get:+----
get:+--
get:|  
get:+--
get:It is expected 
get:protocols effic
get:protocols like 
get:2.6.  Reliable Co
get:A stream of dat
get:order at the de
get:Transmission Cont
get:Transmission is
get:acknowledgments
get:sequence number
get:segment is tran
get:sequence number
get:is the sequence
get:transmissions i
get:segment contain
get:starts a timer;
get:segment is dele
get:received before
get:An acknowledgme
get:delivered to th
get:the responsibil
get:To govern the f
get:employed.  The 
get:This window spe
get:acknowledgment 
get:2.7.  Connection 
get:To identify the
get:provides a port
get:independently b
get:unique addresse
get:identifying the
get:will be unique 
get:A connection is
get:local socket ma
get:sockets.  A con
get:that is, it is 
get:TCPs are free t
get:However, severa
get:There must be w
get:the "appropriat
get:may "own" ports
get:the ports they 
get:issue, but we e
get:uniquely alloca
get:associating the
get:A connection is
get:foreign socket 
get:[Page 10]        
get:September 1981   
get:connection name
get:subsequent call
get:about a connect
get:is a data struc
get:implementation 
get:pointer to the 
get:whether the con
get:be passively wa
get:A passive OPEN 
get:connection requ
get:Often the proce
get:request from an
get:is used to deno
get:are allowed onl
get:A service proce
get:processes would
get:foreign socket.
get:requested a con
get:local socket we
get:Well-known sock
get:a socket addres
get:"Telnet-Server"
get:socket, and oth
get:Entry, Text Gen
get:being for test 
get:access to a "Lo
get:at which a newl
get:well-known sock
get:of sockets to s
get:Processes can i
get:from other proc
get:been establishe
get:other at the sa
get:is critical for
get:components act 
get:There are two p
get:passive OPENs a
get:local passive O
get:case, the match
get:OPENs has left 
get:foreign socket 
get:Other possibili
get:Transmission Cont
get:If there are se
get:same local sock
get:with the specif
get:TCB exists, bef
get:The procedures 
get:control flag an
get:exchange has be
get:A connection is
get:containing a SY
get:command.  The m
get:connection has 
get:when sequence n
get:The clearing of
get:in this case ca
get:2.8.  Data Commun
get:The data that f
get:octets.  The se
get:in that call (a
get:through to the 
get:A sending TCP i
get:send that data 
get:function is sig
get:receiving TCP s
get:the sending TCP
get:There is no nec
get:boundaries.  Th
get:single SEND cal
get:The purpose of 
get:from the sendin
get:record service.
get:There is a coup
get:of data that cr
get:associated with
get:buffer is retur
get:not filled.  If
get:PUSH is seen, t
get:TCP also provid
get:at some point f
get:[Page 12]        
get:September 1981   
get:currently readi
get:define what the
get:urgent data, bu
get:take action to 
get:2.9.  Precedence 
get:The TCP makes u
get:security option
get:basis to TCP us
get:a multilevel se
get:use only, and o
get:compartment.  C
get:users may be li
get:TCP modules whi
get:properly mark o
get:precedence.  Su
get:higher level pr
get:them to specify
get:precedence of c
get:2.10.  Robustness
get:TCP implementat:ions will follow a general principle of robustness
get:conservative in
get:Transmission Cont
get:[Page 14]        
get:September 1981   
get:3.1.  Header Form
get:TCP segments ar
get:header carries 
get:destination hos
get:header, supplyi
get:division allows
get:TCP Header Form
get:0            
get:0 1 2 3 4 5 6
get:+-+-+-+-+-+-+-
get:|          Sou
get:+-+-+-+-+-+-+-
get:|             
get:+-+-+-+-+-+-+-
get:|             
get:+-+-+-+-+-+-+-
get:|  Data |     
get:| Offset| Rese
get:|       |     
get:+-+-+-+-+-+-+-
get:|           Ch
get:+-+-+-+-+-+-+-
get:|             
get:+-+-+-+-+-+-+-
get:|             
get:+-+-+-+-+-+-+-
get:Note th
get:Source Port:  1
get:The source po
get:Destination Por:t
get:The destinati
get:Transmission Cont
get:Functional Specif
get:Sequence Number:
get:The sequence 
get:when SYN is p
get:initial seque
get:Acknowledgment :Number
get:If the ACK co
get:next sequence
get:receive.  Onc
get:Data Offset:  4
get:The number of
get:the data begi
get:integral numb
get:Reserved:  6 bi
get:Reserved for 
get:Control Bits:  :6 bits (from left to right)
get:URG:  Urgent 
get:ACK:  Acknowl
get:PSH:  Push Fu
get:RST:  Reset t
get:SYN:  Synchro
get:FIN:  No more
get:Window:  16 bit
get:The number of
get:acknowledgmen
get:Checksum:  16 b
get:The checksum 
get:complement su
get:segment conta
get:checksummed, 
get:form a 16 bit
get:transmitted a
get:the checksum 
get:The checksum 
get:[Page 16]        
get:September 1981   
get:prefixed to t
get:Address, the 
get:This gives th
get:information i
get:across the TC
get:calls by the 
get:The TCP Len
get:octets (thi
get:computed), 
get:Urgent Pointer:
get:This field co
get:positive offs
get:urgent pointe
get:the urgent da
get:the URG contr
get:Options:  varia
get:Options may o
get:multiple of 8
get:checksum.  An
get:cases for the: format of an option
get:Case 1:  A 
get:Case 2:  An
get:th
get:The option-le
get:option-length
get:Note that the
get:field might i
get:End-of-Option
get:A TCP must im
get:Transmission Cont
get:Functional Specif
get:Currently def:ined options include (kind indicated in octal)
get:Kind     Le
get:----     --
get:0         
get:1         
get:2         
get:Specific Opti
get:End of Opti
get:+--------
get:|00000000
get:+--------
get:This opti
get:might not
get:the Data 
get:not the e
get:the optio
get:No-Operatio
get:+--------
get:|00000001
get:+--------
get:This opti
get:align the
get:There is 
get:receivers
get:not begin
get:Maximum Seg
get:+--------
get:|00000010
get:+--------
get:Kind=2  
get:[Page 18]        
get:September 1981   
get:Maximum S:egment Size Option Data
get:If this
get:receive
get:This fi
get:(i.e., 
get:option 
get:Padding:  varia
get:The TCP heade
get:and data begi
get:3.2.  Terminology
get:Before we can d
get:to introduce so
get:connection requ
get:of these variab
get:Transmission Co
get:TCB are the loc
get:precedence of t
get:buffers, pointe
get:In addition sev
get:sequence number
get:Send Sequence
get:SND.UNA - s
get:SND.NXT - s
get:SND.WND - s
get:SND.UP  - s
get:SND.WL1 - s
get:SND.WL2 - s
get:u
get:ISS     - i
get:Receive Seque
get:RCV.NXT - r
get:RCV.WND - r
get:RCV.UP  - r
get:IRS     - i
get:Transmission Cont
get:Functional Specif
get:The following d
get:the sequence sp
get:Send Sequence S
get:---
get:1 - old s
get:2 - seque
get:3 - seque
get:4 - futur
get:The send window
get:Receive Sequenc
get:1 - old s
get:2 - seque
get:3 - futur
get:The receive win
get:There are also 
get:take their valu
get:[Page 20]        
get:September 1981   
get:Current Segme
get:SEG.SEQ - s
get:SEG.ACK - s
get:SEG.LEN - s
get:SEG.WND - s
get:SEG.UP  - s
get:SEG.PRC - s
get:A connection pr
get:lifetime.  The :states are
get:ESTABLISHED, FI
get:TIME-WAIT, and 
get:because it repr
get:no connection. : Briefly the meanings of the states are
get:LISTEN - repr
get:TCP and port.
get:SYN-SENT - re
get:after having 
get:SYN-RECEIVED 
get:request ackno
get:connection re
get:ESTABLISHED -
get:delivered to 
get:of the connec
get:FIN-WAIT-1 - 
get:from the remo
get:termination r
get:FIN-WAIT-2 - 
get:from the remo
get:CLOSE-WAIT - 
get:from the loca
get:CLOSING - rep
get:acknowledgmen
get:LAST-ACK - re
get:connection te
get:(which includ
get:Transmission Cont
get:Functional Specif
get:TIME-WAIT - r
get:the remote TC
get:termination r
get:CLOSED - repr
get:A TCP connectio
get:events.  The ev
get:ABORT, and STAT
get:containing the 
get:The state diagr
get:with the causin
get:error condition
get:changes.  In a 
get:the reaction of
get:NOTE BENE:  thi
get:the total speci
get:[Page 22]        
get:September 1981   
get:+---------+     
get:|         |<----
get:|   SYN   |     
get:|   RCVD  |<----
get:|         |     
get:|         |-----
get:+---------+   rc
get:|           --
get:|             
get:|             
get:|  CLOSE      
get:| -------     
get:| snd FIN     
get:|             
get:V             
get:+---------+     
get:|  FIN    |<----
get:| WAIT-1  |-----
get:+---------+     
get:| rcv ACK of F
get:| ------------
get:V        x    
get:+---------+     
get:|FINWAIT-2|     
get:+---------+     
get:|             
get:|  rcv FIN    
get:|  -------    
get:\ snd ACK    
get:------------
get:Transmission Cont
get:Functional Specif
get:3.3.  Sequence Nu
get:A fundamental n
get:over a TCP conn
get:sequenced, each
get:mechanism emplo
get:number X indica
get:received.  This
get:detection in th
get:within a segmen
get:the header is t
get:numbered consec
get:It is essential
get:finite, though 
get:Since the space
get:numbers must be
get:preserves the r
get:2**32 - 1 to 0 
get:arithmetic, so 
get:comparison of s
get:(modulo 2**32).
get:The typical kin
get:perform include:
get:(a)  Determin
get:number s
get:(b)  Determin
get:have bee
get:retransm
get:(c)  Determin
get:which ar
get:receive 
get:[Page 24]        
get:September 1981   
get:In response to 
get:following compa
get:SND.UNA = old
get:SND.NXT = nex
get:SEG.ACK = ack
get:num
get:SEG.SEQ = fir
get:SEG.LEN = the
get:(co
get:SEG.SEQ+SEG.L
get:A new acknowled
get:the inequality :below holds
get:SND.UNA < SEG
get:A segment on th
get:of its sequence
get:acknowledgment 
get:When data is re:ceived the following comparisons are needed
get:RCV.NXT = nex
get:is the le
get:RCV.NXT+RCV.W
get:segment, 
get:SEG.SEQ = fir
get:SEG.SEQ+SEG.L
get:A segment is ju
get:RCV.NXT =< SE
get:RCV.NXT =< SE
get:Transmission Cont
get:Functional Specif
get:The first part 
get:segment falls i
get:if the end of t
get:either part of 
get:Actually, it is
get:windows and zer
get:acceptability o:f an incoming segment
get:Segment Recei
get:Length  Windo
get:------- -----
get:0       0 
get:0      >0 
get:>0       0 
get:>0      >0 
get:Note that when 
get:acceptable exce
get:maintain a zero
get:ACKs.  However,
get:process the RST
get:We have taken a
get:control informa
get:some control fl
get:and acknowledge
get:control will be
get:carried in the 
get:for implicitly 
get:are the only co
get:are used only a
get:purposes, the S
get:octet of the se
get:to occur after 
get:occurs.  The se
get:space occupying
get:sequence number
get:[Page 26]        
get:September 1981   
get:Initial Sequenc
get:The protocol pl
get:used over and o
get:sockets.  New i
get:incarnations of
get:-- "how does th
get:incarnations of
get:connection is b
get:connection brea
get:To avoid confus
get:connection from
get:be present in t
get:assure this, ev
get:sequence number
get:an initial sequ
get:new 32 bit ISN.
get:bit clock whose
get:microseconds.  
get:Since we assume
get:the Maximum Seg
get:hours we can re
get:For each connec
get:sequence number
get:the data sendin
get:learned during 
get:For a connectio
get:synchronize on 
get:an exchange of 
get:called "SYN" (f
get:shorthand, segm
get:Hence, the solu
get:initial sequenc
get:The synchroniza
get:sequence number
get:from the other 
get:initial sequenc
get:1) A --> B  S
get:2) A <-- B  A
get:3) A <-- B  S
get:4) A --> B  A
get:Transmission Cont
get:Functional Specif
get:Because steps 2
get:called the thre
get:A three way han
get:tied to a globa
get:mechanisms for 
get:no way of knowi
get:unless it remem
get:(which is not a
get:verify this SYN
get:clock-driven sc
get:Knowing When to
get:To be sure that
get:sequence number
get:the network, th
get:(MSL) before as
get:recovering from
get:lost.  For this
get:is an engineeri
get:it is desirable
get:sense, yet reta
get:not wait at all
get:than those rece
get:The TCP Quiet T
get:This specific
get:retaining any
get:each active (
get:TCP segments 
get:in the intern
get:paragraphs be
get:TCP implement
get:at the risk o
get:data rejected
get:TCPs consume 
get:entered into 
get:duplicate det
get:relies on the
get:the extent th
get:values before
get:been delivere
get:copies of the
get:such an assum
get:[Page 28]        
get:September 1981   
get:assigned the 
get:at the receiv
get:that each seg
get:as there are 
get:Under normal 
get:to emit and t
get:mistakenly us
get:been acknowle
get:data is drain
get:very large to
get:cause trouble
get:to use up 2**
get:lifetime in t
get:this is deeme
get:rates escalat
get:cycle time is
get:within reason
get:The basic dup
get:defeated, how
get:sequence numb
get:the TCP were 
get:upon crashing
get:connection (p
get:packets with 
get:packets still
get:incarnation o
get:about the seq
get:specification
get:before emitti
get:segments from
get:Even hosts wh
get:initial seque
get:(i.e., even i
get:number for ea
get:Suppose, for 
get:sequence numb
get:and that even
get:takes on a va
get:segment sent 
get:at this insta
get:incarnation o
get:S1 = ISN(t) -
get:connection!  
get:Transmission Cont
get:Functional Specif
get:duplicates in
get:of S1 may arr
get:the new incar
get:The problem i
get:crashed nor d
get:the system fr
get:One way to de
get:segments for 
get:time" specifi
get:willing to ri
get:destination m
get:Implementors 
get:connection by
get:informally im
get:Obviously, ev
get:necessary aft
get:To summarize:
get:numbers in th
get:"busy" or "in
get:block of spac
get:segment, if a
get:sequence numb
get:the previous 
get:number overla
get:3.4.  Establishin
get:The "three-way 
get:connection.  Th
get:responded to by
get:simultaneously 
get:occurs, each TC
get:acknowledgment 
get:an old duplicat
get:recipient, that
get:Proper use of "
get:Several example
get:examples do not
get:segments, this 
get:doesn't deliver
get:valid (i.e., th
get:connection reac
get:reduces the pos
get:[Page 30]        
get:September 1981   
get:implementation 
get:information for
get:The simplest th
get:figures should 
get:numbered for re
get:departure of a 
get:segment at B fr
get:Ellipsis (...) 
get:(delayed).  An 
get:Comments appear
get:the departure o
get:the center of e
get:form, with sequ
get:fields such as 
get:in the interest
get:TCP A      
get:1.  CLOSED     
get:2.  SYN-SENT   
get:3.  ESTABLISHED
get:4.  ESTABLISHED
get:5.  ESTABLISHED
get:Basic 3
get:In line 2 of fi
get:indicating that
get:number 100.  In
get:received from T
get:B is now expect
get:occupied sequen
get:At line 4, TCP 
get:TCP B's SYN; an
get:sequence number
get:because the ACK
get:would wind up A
get:Transmission Cont
get:Functional Specif
get:Simultaneous in
get:figure 8.  Each
get:TCP A      
get:1.  CLOSED     
get:2.  SYN-SENT   
get:3.  SYN-RECEIVE
get:4.             
get:5.  SYN-RECEIVE
get:6.  ESTABLISHED
get:7.             
get:S
get:The principle r
get:duplicate conne
get:this, a special
get:receiving TCP i
get:SYN-RECEIVED), 
get:If the TCP is i
get:FIN-WAIT-1, FIN
get:aborts the conn
get:case under "hal
get:[Page 32]        
get:September 1981   
get:TCP A      
get:1.  CLOSED     
get:2.  SYN-SENT   
get:3.  (duplicate)
get:4.  SYN-SENT   
get:5.  SYN-SENT   
get:6.             
get:7.  SYN-SENT   
get:8.  ESTABLISHED
get:As a simple exa
get:figure 9.  At l
get:cannot tell tha
get:(line 4).  TCP 
get:RST (reset) wit
get:believable.  TC
get:When the origin
get:synchronization
get:before the RST,
get:sent in both di
get:Half-Open Conne
get:An established 
get:TCPs has closed
get:knowledge of th
get:become desynchr
get:memory.  Such c
get:attempt is made
get:connections are
get:mildly involved
get:If at site A th
get:Transmission Cont
get:Functional Specif
get:user at site B 
get:receiving a res
get:site B TCP that
get:Assume that two
get:another when a 
get:Depending on th
get:that some error
get:A is likely to 
get:point.  As a re
get:or try to SEND 
get:case, it receiv
get:local (A's) TCP
get:will send a seg
get:example shown i
get:re-open the con
get:TCP A      
get:1.  (CRASH)    
get:2.  CLOSED     
get:3.  SYN-SENT --
get:4.  (!!)     <-
get:5.  SYN-SENT --
get:6.  SYN-SENT   
get:7.  SYN-SENT --
get:When the SYN ar
get:and the incomin
get:acknowledgment 
get:100).  TCP A se
get:sent and, being
get:detected a half
get:[Page 34]        
get:September 1981   
get:continue to try
get:reduced to the 
get:An interesting 
get:tries to send d
get:This is illustr
get:TCP A from TCP 
get:exists, so TCP 
get:processes it an
get:TCP A    
get:1.  (CRASH)    
get:2.  (??)    <--
get:3.          -->
get:Active
get:In figure 12, w
get:waiting for SYN
get:into action.  A
get:generate a RST 
get:the reset and r
get:TCP A      
get:1.  LISTEN     
get:2.       ... <S
get:3.  (??) <-- <S
get:4.       --> <S
get:5.  LISTEN     
get:Old Duplic
get:Transmission Cont
get:Functional Specif
get:A variety of ot
get:by the followin
get:Reset Generatio
get:As a general ru
get:which apparentl
get:must not be sen
get:There are three: groups of states
get:1.  If the co
get:in response t
get:particular, S
get:by this means
get:If the incomi
get:sequence numb
get:reset has seq
get:of the sequen
get:The connectio
get:2.  If the co
get:SYN-SENT, SYN
get:something not
get:if an incomin
get:does not exac
get:connection, a
get:If our SYN ha
get:incoming segm
get:either raise 
get:the system) o
get:incoming segm
get:continue as i
get:cannot raise 
get:detected in t
get:terminated th
get:incoming segm
get:match the loc
get:must be sent.
get:If the incomi
get:sequence numb
get:reset has seq
get:of the sequen
get:The connectio
get:[Page 36]        
get:September 1981   
get:3.  If the co
get:FIN-WAIT-1, F
get:any unaccepta
get:unacceptible 
get:acknowledgmen
get:and an acknow
get:to be receive
get:If an incomin
get:precedence wh
get:and precedenc
get:connection go
get:number from t
get:Reset Processin
get:In all states e
get:by checking the
get:is in the windo
get:to an initial S
get:acknowledges th
get:The receiver of
get:receiver was in
get:in SYN-RECEIVED
get:then the receiv
get:aborts the conn
get:was in any othe
get:and goes to the
get:3.5.  Closing a C
get:CLOSE is an ope
get:notion of closi
get:interpretation,
get:the receiving s
get:in a simplex fa
get:until he is tol
get:could initiate 
get:RECEIVE until s
get:has CLOSED.  We
get:RECEIVEs are ou
get:can terminate h
get:buffers SENT be
get:data in return 
get:successfully to
get:TCP.  Users mus
get:the TCP says no
get:Transmission Cont
get:Functional Specif
get:There are essen:tially three cases
get:1) The user i
get:2) The remote
get:3) Both users
get:Case 1:  Local 
get:In this case,
get:outgoing segm
get:accepted by t
get:are allowed i
get:will be retra
get:both acknowle
get:can ACK this 
get:send its own 
get:Case 2:  TCP re
get:If an unsolic
get:can ACK it an
get:user will res
get:the other TCP
get:until its own
get:connection.  
get:the connectio
get:Case 3:  both u
get:A simultaneou
get:FIN segments 
get:have been pro
get:has received.
get:[Page 38]        
get:September 1981   
get:TCP A      
get:1.  ESTABLISHED
get:FIN-WAIT-1 
get:3.  FIN-WAIT-2 
get:4.             
get:TIME-WAIT  
get:5.  TIME-WAIT  
get:CLOSED     
get:TCP A      
get:1.  ESTABLISHED
get:2.  (Close)    
get:FIN-WAIT-1 
get:3.  CLOSING    
get:4.  TIME-WAIT  
get:(2 MSL)    
get:CLOSED     
get:Transmission Cont
get:Functional Specif
get:3.6.  Precedence 
get:The intent is t
get:with exactly th
get:higher of the p
get:The precedence 
get:defined in the 
get:specification t
get:the security pa
get:user group, and
get:A connection at
get:lower precedenc
get:a connection du
get:acknowledgment 
get:Note that TCP m
get:precedence will
get:segments and po
get:The security pa
get:(the values wou
get:non-secure envi
get:parameters, tho
get:3.7.  Data Commun
get:Once the connec
get:exchange of seg
get:(checksum test 
get:retransmission 
get:Duplicate segme
get:As discussed in
get:certain tests o
get:segments to ver
get:The sender of d
get:the variable SN
get:sequence number
get:keeps track of 
get:variable SND.UN
get:sent has been a
get:When the sender
get:SND.NXT.  When 
get:sends an acknow
get:[Page 40]        
get:September 1981   
get:acknowledgment 
get:these variables
get:The amount by w
get:data in the seg
get:segments must c
get:The CLOSE user 
get:flag in an inco
get:Retransmission 
get:Because of the 
get:internetwork sy
get:retransmission 
get:for determining
get:An Example Re
get:Measure the
get:particular 
get:covers that
get:segments re
get:Time (RTT).:  Next compute a Smoothed Round Trip Time (SRTT) as
get:SRTT = ( 
get:and based o:n this, compute the retransmission timeout (RTO) as
get:RTO = min
get:where UBOUN
get:LBOUND is a
get:a smoothing
get:factor (e.g
get:The Communicati
get:The objective o
get:to stimulate th
get:permit the rece
get:the currently k
get:This mechanism 
get:the end of urge
get:the receive seq
get:must tell the u
get:number catches 
get:Transmission Cont
get:Functional Specif
get:into "normal mo
get:is in "urgent m
get:The method empl
get:transmitted.  T
get:meaningful and 
get:the urgent poin
get:no urgent data 
get:To send an urge
get:octet.  If the 
get:the urgent info
get:Managing the Wi
get:The window sent
get:numbers the sen
get:prepared to acc
get:the currently a
get:Indicating a la
get:arrives than ca
get:in excessive re
get:network and the
get:transmission of
get:between each ne
get:The mechanisms 
get:subsequently ad
get:that much data.
get:discouraged.  T
get:shrink the wind
get:on the part of 
get:The sending TCP
get:least one octet
get:sending TCP mus
get:the window is z
get:interval when t
get:guarantee that 
get:window will be 
get:When the receiv
get:still send an a
get:and current win
get:The sending TCP
get:[Page 42]        
get:September 1981   
get:which fit the c
get:retransmission 
get:In a connection
get:be carried in a
get:number so there
get:order.  This is
get:information to 
get:the data receiv
get:the window info
get:acknowledgment 
get:equal or greate
get:The window mana
get:communication p
get:Window Manage
get:Allocating 
get:many small 
get:fewer large
get:One suggest
get:defer updat
get:least X per
get:connection 
get:Another sug
get:segments by
get:sending dat
get:data must b
get:Note that t
get:retransmiss
get:acknowledgm
get:window info
get:new window 
get:The segment
get:of transmit
get:segment con
get:is accepted
get:If the send
get:window is n
get:alternating
get:pauses in t
get:Transmission Cont
get:Functional Specif
get:result in b
get:big pair. A
get:mostly smal
get:The suggest
get:actively at
get:windows, si
get:to many sma
get:There are of co:urse two interfaces of concern
get:and the TCP/low
get:of the user/TCP
get:protocol module
get:in detail by th
get:case that the l
get:that TCPs might
get:User/TCP Interf
get:The following
get:at best, fict
get:facilities.  
get:implementatio
get:TCPs must pro
get:that all TCP 
get:hierarchy.  T
get:required of a
get:TCP User Comm
get:The followi
get:interface. 
get:function ca
get:meant to ru
get:The user co
get:TCP must pe
get:Individual 
get:may provide
get:single call
get:automatical
get:issued by t
get:[Page 44]        
get:September 1981   
get:In providin
get:not only ac
get:processes i:t serves.  The latter consists of
get:(a) gener
get:remote cl
get:(b) repli
get:various t
get:Format:  
get:[, timeou
get:-> local 
get:We assume
get:processes
get:to use th
get:implement
get:for the s
get:lower lev
get:result of
get:able to m
get:process c
get:If the ac
get:call to L
get:have eith
get:particula
get:for any c
get:by the su
get:A transmi
get:filled in
get:On an act
get:synchroni
get:The timeo
get:for all d
get:delivered
get:will abor
get:The TCP o
get:the users
get:Transmission Cont
get:Functional Specif
get:precedenc
get:or securi
get:the defau
get:TCP will 
get:security/
get:the prece
get:requested
get:The prece
get:requested
get:request, 
get:connectio
get:this prec
get:allowed t
get:or that a
get:A local c
get:The local
get:for the c
get:Format:  
get:count, PU
get:This call
get:to be sen
get:not been 
get:implement
get:automatic
get:authorize
get:If the PU
get:to the re
get:segment c
get:the data 
get:transmiss
get:If the UR
get:will have
get:the urgen
get:pointer i
get:been cons
get:is to sti
get:indicate 
get:[Page 46]        
get:September 1981   
get:data has 
get:TCP signa
get:of times 
get:urgent da
get:If no for
get:connectio
get:has becom
get:local soc
get:foreign s
get:foreign s
get:knowing t
get:However, 
get:becomes s
get:STATUS ca
get:implement
get:socket is
get:If a time
get:connectio
get:In the si
get:the sendi
get:or the ti
get:is both s
get:connectio
get:offers po
get:sophistic
get:the proce
get:furthermo
get:Multiple 
get:the TCP w
get:We have i
get:which a S
get:pseudo-in
get:return a 
get:immediate
get:been ackn
get:assume ev
get:close any
get:kind (syn
get:signals, 
get:with spec
get:In order 
get:indicatio
get:Transmission Cont
get:Functional Specif
get:buffer ad
get:the SEND 
get:indicatin
get:calling p
get:Format:  
get:count) ->
get:This comm
get:specified
get:calling p
get:error is 
get:In the si
get:calling p
get:error occ
get:A more so
get:RECEIVEs 
get:segments 
get:the cost 
get:notify th
get:If enough
get:the PUSH 
get:The buffe
get:a PUSH is
get:returned 
get:If there 
get:as it arr
get:should th
get:additiona
get:call to R
get:may now l
get:urgent po
get:in the sa
get:boundary 
get:To distin
get:care of t
get:return co
get:count ind
get:Alternati
get:[Page 48]        
get:September 1981   
get:allocate 
get:with the 
get:Format:  
get:This comm
get:the conne
get:authorize
get:Closing c
get:the sense
get:retransmi
get:serviced.
get:calls, fo
get:to the de
get:continue 
get:may be tr
get:means "I 
get:receive a
get:not well 
get:of all it
get:into ABOR
get:The user 
get:initiativ
get:(e.g., re
get:destinati
get:Because c
get:foreign T
get:short tim
get:replies t
get:Close als
get:Format:  
get:This is a
get:excluded 
get:typically
get:This comm
get:informati:on
get:local s
get:Transmission Cont
get:Functional Specif
get:foreign
get:local c
get:receive
get:send wi
get:connect
get:number 
get:number 
get:urgent 
get:precede
get:securit
get:and tra
get:Depending
get:implement
get:available
get:authorize
get:prevents 
get:connectio
get:Format:  
get:This comm
get:aborted, 
get:be sent t
get:Depending
get:indicatio
get:receive a
get:TCP-to-User M
get:It is assum
get:means for t
get:the TCP doe
get:to the user
get:an error me
get:relating to
get:other user 
get:The followi:ng information is provided
get:Local Con
get:Response 
get:Buffer Ad
get:Byte coun
get:Push flag
get:Urgent fl
get:[Page 50]        
get:September 1981   
get:TCP/Lower-Level
get:The TCP calls
get:receive infor
get:internetwork 
get:Protocol (IP)
get:If the lower 
get:of service an
get:for these par:ameters
get:Type of Ser:vice = Precedence: routine, Delay: normal, Throughput
get:normal, Rel:iability
get:Time to Liv
get:Note that
get:Here we e
get:be delive
get:If the lower 
get:feature) and 
get:route informa
get:so that the s
get:checksum be t
get:also importan
get:Any lower lev
get:destination a
get:the "TCP leng
get:of IP and to 
get:Transmission Cont
get:Functional Specif
get:3.9.  Event Proce
get:The processing 
get:implementation.
get:processing sequ
get:section only in
get:The activity of
get:The events that: occur can be cast into three categories
get:arriving segmen
get:processing the 
get:cases the proce
get:Events that o:ccur
get:Arriving Se
get:SEGMENT A
get:USER TIME
get:RETRANSMI
get:TIME-WAIT
get:The model of th
get:immediate retur
get:pseudo interrup
get:means cause a d
get:Error responses
get:commands refere:ncing connections that do not exist receive "error
get:connection not 
get:Please note in 
get:acknowledgment 
get:of the sequence
get:equal to (modul
get:[Page 52]        
get:September 1981   
get:A natural way t
get:imagine that th
get:that their cont
get:in the sequence
get:and processed i
get:When a segment 
get:the segment to 
get:to be consisten
get:Note that if no
get:Transmission Cont
get:Functional Specif
get:CLOSED STATE 
get:Create a ne
get:state infor
get:socket, pre
get:information
get:unspecified
get:parameters 
get:precedence 
get:"error:  pr:ecedence not allowed" or "error
get:not allowed
get:active and :the foreign socket is unspecified, return "error
get:foreign soc
get:specified, 
get:(ISS) is se
get:is sent.  S
get:state, and 
get:If the call
get:return "err:or
get:no room to :create a new connection, return "error
get:resources".
get:If active a
get:connection 
get:segment, se
get:state.  Dat
get:queued for 
get:urgent bit 
get:segments se
get:queue the r:equest, respond with "error
get:If Foreign :socket was not specified, then return "error
get:socket unsp
get:[Page 54]        
get:September 1981   
get:SYN-SENT STAT
get:SYN-RECEIVED 
get:ESTABLISHED S
get:FIN-WAIT-1 ST
get:FIN-WAIT-2 ST
get:CLOSE-WAIT ST
get:CLOSING STATE
get:LAST-ACK STAT
get:TIME-WAIT STA
get:Return "err:or
get:Transmission Cont
get:Functional Specif
get:CLOSED STATE 
get:If the user
get:"error:  co
get:Otherwise, :return "error
get:If the fore
get:from passiv
get:SND.UNA to 
get:associated 
get:transmissio
get:requested i
get:as a result
get:request, re:spond with "error
get:Foreign soc:ket was not specified, then return "error
get:socket unsp
get:SYN-SENT STAT
get:SYN-RECEIVED 
get:Queue the d
get:If no space: to queue, respond with "error
get:resources".
get:ESTABLISHED S
get:CLOSE-WAIT ST
get:Segmentize 
get:acknowledgm
get:insufficien:t space to remember this buffer, simply return "error
get:insufficien
get:If the urge
get:urgent poin
get:[Page 56]        
get:September 1981   
get:FIN-WAIT-1 ST
get:FIN-WAIT-2 ST
get:CLOSING STATE
get:LAST-ACK STAT
get:TIME-WAIT STA
get:Return "err:or
get:Transmission Cont
get:Functional Specif
get:CLOSED STATE 
get:If the user
get:"error:  co
get:Otherwise r:eturn "error
get:SYN-SENT STAT
get:SYN-RECEIVED 
get:Queue for p
get:is no room :to queue this request, respond with "error
get:insufficien
get:ESTABLISHED S
get:FIN-WAIT-1 ST
get:FIN-WAIT-2 ST
get:If insuffic
get:request, qu
get:remember th:e RECEIVE, respond with "error
get:resources".
get:Reassemble 
get:to user.  M
get:If RCV.UP i
get:user notify
get:When the TC
get:that fact m
get:acknowledgm
get:described b
get:[Page 58]        
get:September 1981   
get:CLOSE-WAIT ST
get:Since the r
get:satisfied b
get:user.  If n
get:"error:  co
get:text can be
get:CLOSING STATE
get:LAST-ACK STAT
get:TIME-WAIT STA
get:Return "err:or
get:Transmission Cont
get:Functional Specif
get:CLOSED STATE 
get:If the user
get:"error:  co
get:Otherwise, :return "error
get:Any outstan:ding RECEIVEs are returned with "error
get:responses. 
get:SYN-SENT STAT
get:Delete the :TCB and return "error
get:queued SEND
get:SYN-RECEIVED 
get:If no SENDs
get:then form a
get:otherwise q
get:ESTABLISHED S
get:Queue this 
get:form a FIN 
get:FIN-WAIT-1 ST
get:FIN-WAIT-2 ST
get:Strictly sp:eaking, this is an error and should receive a "error
get:connection 
get:acceptable,
get:FIN may be 
get:[Page 60]        
get:September 1981   
get:CLOSE-WAIT ST
get:Queue this 
get:segmentized
get:CLOSING STATE
get:LAST-ACK STAT
get:TIME-WAIT STA
get:Respond wit:h "error
get:Transmission Cont
get:Functional Specif
get:CLOSED STATE 
get:If the user
get:"error:  co
get:Otherwise r:eturn "error
get:Any outstan:ding RECEIVEs should be returned with "error
get:connection 
get:SYN-SENT STAT
get:All queued 
get:notificatio
get:SYN-RECEIVED 
get:ESTABLISHED S
get:FIN-WAIT-1 ST
get:FIN-WAIT-2 ST
get:CLOSE-WAIT ST
get:Send a rese:t segment
get:<SEQ=SND.
get:All queued 
get:notificatio
get:RST formed 
get:TCB, enter 
get:CLOSING STATE
get:LAST-ACK STAT
get:TIME-WAIT STA
get:Respond wit
get:[Page 62]        
get:September 1981   
get:CLOSED STATE 
get:If the user
get:"error:  co
get:Otherwise r:eturn "error
get:Return "sta
get:SYN-SENT STAT
get:Return "sta
get:SYN-RECEIVED 
get:Return "sta
get:ESTABLISHED S
get:Return "sta
get:FIN-WAIT-1 ST
get:Return "sta
get:FIN-WAIT-2 ST
get:Return "sta
get:CLOSE-WAIT ST
get:Return "sta
get:CLOSING STATE
get:Return "sta
get:LAST-ACK STAT
get:Return "sta
get:Transmission Cont
get:Functional Specif
get:TIME-WAIT STA
get:Return "sta
get:[Page 64]        
get:September 1981   
get:SEGMENT ARRIVES
get:If the state 
get:all data in
get:segment con
get:containing 
get:acknowledgm
get:reset seque
get:If the ACK 
get:<SEQ=0><A
get:If the ACK 
get:<SEQ=SEG.
get:If the state 
get:first check
get:An incomi
get:second chec
get:Any ackno
get:the LISTE
get:for any a
get:formatted: as follows
get:<SEQ=SE
get:third check
get:If the SY
get:security/
get:match the
get:<SEQ=SE
get:Transmission Cont
get:Functional Specif
get:If the SE
get:the user 
get:send a re
get:<SEQ=SE
get:If the SE
get:Set RCV.N
get:control o
get:should be: selected and a SYN segment sent of the form
get:<SEQ=IS
get:SND.NXT i
get:state sho
get:incoming 
get:in the SY
get:not be re
get:the forei
get:unspecifi
get:fourth othe
get:Any other
get:must have
get:processin
get:it could 
get:incarnati
get:but if yo
get:If the state 
get:first check
get:If the AC
get:If SEG.
get:the RST
get:<SEQ=
get:and dis
get:If SND.
get:second chec
get:[Page 66]        
get:September 1981   
get:If the RS
get:If the :ACK was acceptable then signal the user "error
get:connect
get:delete 
get:and ret
get:third check
get:If the se
get:match the
get:If ther
get:<SEQ=
get:Otherwi
get:<SEQ=
get:If there 
get:The pre
get:TCB, if
get:<SEQ=
get:If there 
get:If the 
get:in the 
get:the pre
get:allowed
get:<SEQ=
get:If the 
get:in the 
get:If a rese
get:fourth chec
get:This step
get:no ACK, a
get:If the SY
get:Transmission Cont
get:Functional Specif
get:are accep
get:SEG.SEQ. 
get:is an ACK
get:are there
get:If SND.UN
get:state to 
get:<SEQ=SN
get:and send 
get:transmiss
get:text in t
get:below whe
get:Otherwise
get:<SEQ=IS
get:and send 
get:segment, 
get:has been 
get:fifth, if n
get:segment and
get:[Page 68]        
get:September 1981   
get:first check s
get:SYN-RECEIVE
get:ESTABLISHED
get:FIN-WAIT-1 
get:FIN-WAIT-2 
get:CLOSE-WAIT 
get:CLOSING STA
get:LAST-ACK ST
get:TIME-WAIT S
get:Segments 
get:are used 
get:done in S
get:boundary 
get:processed
get:There are
get:segment
get:Segment R
get:Length  W
get:------- -
get:0     
get:0     
get:>0     
get:>0     
get:If the RC
get:special a
get:If an inc
get:should be
get:the segme:nt and return)
get:<SEQ=SN
get:After sen
get:and retur
get:Transmission Cont
get:Functional Specif
get:In the fo
get:segment t
get:One could
get:trimming 
get:SYN and F
get:begins at
get:numbers m
get:second check 
get:SYN-RECEIVE
get:If the RS
get:If this
get:came fr
get:LISTEN 
get:this co
get:from SY
get:the use
get:on the 
get:active 
get:and ret
get:ESTABLISHED
get:If the RS
get:should re
get:flushed. 
get:"connecti
get:TCB, and 
get:CLOSING STA
get:LAST-ACK ST
get:If the RS
get:TCB, and 
get:[Page 70]        
get:September 1981   
get:third check s
get:SYN-RECEIVE
get:If the se
get:exactly m
get:then send
get:ESTABLISHED
get:If the se
get:exactly m
get:then send
get:receive "
get:flushed. 
get:"connecti
get:TCB, and 
get:Note this c
get:a segment f
get:different s
get:current con
get:fourth, check
get:SYN-RECEIVE
get:ESTABLISHED
get:FIN-WAIT ST
get:FIN-WAIT ST
get:CLOSE-WAIT 
get:CLOSING STA
get:LAST-ACK ST
get:TIME-WAIT S
get:If the SY
get:outstandi
get:all segme
get:receive a
get:the CLOSE
get:If the SY
get:and an ac
get:number ch
get:Transmission Cont
get:Functional Specif
get:fifth check t
get:if the ACK 
get:if the ACK 
get:SYN-RECEI
get:If SND.
get:and con
get:If th
get:reset
get:<SE
get:and s
get:ESTABLISH
get:If SND.
get:Any seg
get:entirel
get:positiv
get:fully a
get:"ok" re
get:(SEG.AC
get:somethi
get:drop th
get:If SND.
get:updated
get:SND.WL2
get:SND.WL1
get:Note th
get:records
get:SND.WND
get:the las
get:prevent
get:[Page 72]        
get:September 1981   
get:FIN-WAIT-
get:In addi
get:our FIN
get:process
get:FIN-WAIT-
get:In addi
get:the ret
get:acknowl
get:CLOSE-WAI
get:Do the 
get:CLOSING S
get:In addi
get:the ACK
get:otherwi
get:LAST-ACK 
get:The onl
get:acknowl
get:delete 
get:TIME-WAIT
get:The onl
get:retrans
get:the 2 M
get:sixth, check 
get:ESTABLISHED
get:FIN-WAIT-1 
get:FIN-WAIT-2 
get:If the UR
get:the user 
get:pointer (
get:user has 
get:mode") fo
get:signal th
get:Transmission Cont
get:Functional Specif
get:CLOSE-WAIT 
get:CLOSING STA
get:LAST-ACK ST
get:This shou
get:remote si
get:seventh, proc
get:ESTABLISHED
get:FIN-WAIT-1 
get:FIN-WAIT-2 
get:Once in t
get:text to u
get:into buff
get:empty.  I
get:the user 
get:has been 
get:When the 
get:user it m
get:Once the 
get:RCV.NXT o
get:apporopri
get:RCV.NXT a
get:Please no
get:Send an a:cknowledgment of the form
get:<SEQ=SN
get:This ackn
get:transmitt
get:[Page 74]        
get:September 1981   
get:CLOSE-WAIT 
get:CLOSING STA
get:LAST-ACK ST
get:TIME-WAIT S
get:This shou
get:remote si
get:eighth, check
get:Do not proc
get:since the S
get:If the FIN 
get:return any 
get:over the FI
get:FIN implies
get:SYN-RECEI
get:ESTABLISH
get:Enter t
get:FIN-WAIT-
get:If our 
get:enter T
get:timers;
get:FIN-WAIT-
get:Enter t
get:off the
get:CLOSE-WAI
get:Remain 
get:CLOSING S
get:Remain 
get:LAST-ACK 
get:Remain 
get:Transmission Cont
get:Functional Specif
get:TIME-WAIT
get:Remain 
get:timeout
get:[Page 76]        
get:September 1981   
get:For any state
get:the user "err:or
get:and for any o
get:state and ret
get:RETRANSMISSION 
get:For any state
get:the retransmi
get:retransmissio
get:TIME-WAIT TIMEO
get:If the time-w
get:enter the CLO
get:Transmission Cont
get:[Page 78]        
get:September 1981   
get:BBN Rep
get:a Host 
get:host an
get:A contr
get:indicat
get:specifi
get:is expe
get:previou
get:The uni
get:ARPANET
get:A unit 
get:IMPs.  
get:A logic
get:A messa
get:network
get:Destination Addre
get:The des
get:identif
get:A contr
get:indicat
get:occupyi
get:A porti
get:fragmen
get:A file 
get:Transmission Cont
get:Control
get:fragmen
get:A compu
get:from th
get:An Inte
get:by the 
get:The Int
get:ARPANET
get:A sourc
get:internet datagram
get:The uni
get:higher 
get:internet fragment
get:A porti
get:header.
get:Interne
get:The Ini
get:number 
get:The Ini
get:on a co
get:based p
get:The Ini
get:used by
get:Control
get:data.  
get:on an A
get:[Page 80]        
get:September 1981   
get:This is
get:data re
get:sequenc
get:of the 
get:The uni
get:An impl
get:procedu
get:Maximum
get:the int
get:An eigh
get:An Opti
get:may be 
get:primari
get:timesta
get:options
get:A packa
get:logical
get:logical
get:The por
get:output 
get:A progr
get:the poi
get:A contr
get:this se
get:receivi
get:receive
get:Transmission Cont
get:receive
get:receive
get:receive next sequ
get:This is
get:receive
get:This re
get:is will
get:segment
get:RCV.NXT
get:Segment
get:range a
get:A contr
get:that th
get:interac
get:sequenc
get:segment
get:it.  In
get:rise to
get:Real Ti:me Protocol
get:of time
get:segment
get:segment
get:segment
get:segment
get:segment
get:[Page 82]        
get:September 1981   
get:segment
get:A logic
get:unit of
get:segment acknowled
get:The seq
get:arrivin
get:The amo
get:includi
get:The num
get:This is
get:use on 
get:initial
get:each oc
get:This re
get:(receiv
get:window 
get:receivi
get:be emit
get:SND.UNA
get:between
get:send se
get:left se
get:send ur
get:segment
get:segment
get:Transmission Cont
get:send wi
get:An addr
get:is, the
get:The sou
get:A contr
get:number,
get:where t
get:Transmi
get:the sta
get:The pre
get:Transmi:ssion Control Protocol
get:reliabl
get:Type of
get:An Inte
get:for thi
get:A contr
get:indicat
get:urgent 
get:sequenc
get:pointer
get:A contr
get:field c
get:indicat
get:urgent 
get:[Page 84]        
get:September 1981   
get:[1]  Cerf, V., an
get:Intercommuni
get:Vol. COM-22,
get:[2]  Postel, J. (
get:Protocol Spe
get:Institute, S
get:[3]  Dalal, Y. an
get:Protocols", 
get:December 197
get:[4]  Postel, J., 
get:Institute, S
get:aRFC
get:aDe
get:aI
get:aSeptember 1981   
get:aPREFACE .....
get:a1.  INTRODUCTION 
get:a1.1  Motivation
get:a1.2  Scope ....
get:a1.3  About This
get:a1.4  Interfaces
get:a1.5  Operation 
get:a2.  PHILOSOPHY ..
get:a2.1  Elements o
get:a2.2  Model of O
get:a2.3  The Host E
get:a2.4  Interfaces
get:a2.5  Relation t
get:a2.6  Reliable C
get:a2.7  Connection
get:a2.8  Data Commu
get:a2.9  Precedence
get:a2.10 Robustness
get:a3.  FUNCTIONAL SP
get:a3.1  Header For
get:a3.2  Terminolog
get:a3.3  Sequence N
get:a3.4  Establishi
get:a3.5  Closing a 
get:a3.6  Precedence
get:a3.7  Data Commu
get:a3.8  Interfaces
get:a3.9  Event Proc
get:aGLOSSARY ........
get:aREFERENCES ......
get:aTransmission Cont
get:a[Page ii]        
get:aSeptember 1981   
get:aThis document des
get:a(TCP).  There hav
get:aspecification on 
get:adraws heavily fro
get:aboth in terms of 
get:aseveral details a
get:aand redescribes t
get:aRFC
get:aReplaces: RFC 761
get:aIENs:  129, 124, 
get:a55, 44, 40, 27, 2
get:aThe Transmission 
get:areliable host-to-
get:acommunication net
get:aThis document des
get:aTransmission Cont
get:ainterface to prog
get:aComputer commun
get:arole in militar
get:adocument focuse
get:acommunication r
get:acommunication u
get:acongestion, but
get:agovernment sect
get:aAs strategic an
get:adeveloped and d
get:ainterconnecting
get:acommunication p
get:aapplications.  
get:aDeputy Undersec
get:adeclared the Tr
get:abe a basis for 
get:astandardization
get:aTCP is a connec
get:afit into a laye
get:aapplications.  
get:acommunication b
get:adistinct but in
get:aassumptions are
get:aprotocols below
get:apotentially unr
get:aprotocols.  In 
get:awide spectrum o
get:aconnections to 
get:aTransmission Cont
get:aTCP is based on
get:aTCP fits into a
get:aInternet Protoc
get:areceive variabl
get:adatagram "envel
get:aaddressing sour
get:ainternet protoc
get:athe TCP segment
get:amultiple networ
get:aalso carries in
get:aand compartment
get:acommunicated en
get:aMuch of this do
get:awhich are co-re
get:acomputer.  Some
get:afront-end compu
get:aas well as netw
get:aan interface to
get:aimplementable e
get:ahost-to-front e
get:aThe TCP is inte
get:acommunication s
get:aintended to be 
get:a1.3.  About this 
get:aThis document r
get:aany TCP impleme
get:aprotocols and i
get:a[Page 2]         
get:aSeptember 1981   
get:asection offers 
get:aoperation.  Sec
get:adesign.  Sectio
get:arequired of TCP
get:auser calls, err
get:aThe TCP interfa
get:athe other side 
get:aThe interface b
get:aillustrated in 
get:acalls much like
get:aapplication pro
get:acalls to open a
get:aestablished con
get:aasynchronously 
get:aconsiderable fr
get:ainterfaces whic
get:aenvironment, a 
get:ainterface for a
get:aThe interface b
get:aunspecified exc
get:atwo levels can 
get:aTypically, one 
get:ainterface.  TCP
get:ainterconnected 
get:athroughout this
get:aAs noted above,
get:asecurable logic
get:aprocesses.  To 
get:acommunication s:ystem requires facilities in the following areas
get:aBasic Data Tr
get:aPrecedence an
get:aThe basic opera
get:athe following p
get:aTransmission Cont
get:aBasic Data Tran:sfer
get:aThe TCP is ab
get:adirection bet
get:asegments for 
get:athe TCPs deci
get:aSometimes use
get:asubmitted to 
get:afunction is d
get:aactually tran
get:apushed throug
get:apromptly forw
get:aThe exact pus
get:athe push func
get:aReliability
get:aThe TCP must 
get:adelivered out
get:ais achieved b
get:atransmitted, 
get:areceiving TCP
get:ainterval, the
get:anumbers are u
get:aout of order 
get:aadding a chec
get:areceiver, and
get:aAs long as th
get:asystem does n
get:aerrors will a
get:ainternet comm
get:aFlow Control
get:aTCP provides 
get:asent by the s
get:aevery ACK ind
get:athe last segm
get:aallowed numbe
get:areceiving fur
get:a[Page 4]         
get:aSeptember 1981   
get:aMultiplexing
get:aTo allow for 
get:acommunication
get:aaddresses or 
get:aand host addr
get:aa socket.  A 
get:aThat is, a so
get:aThe binding o
get:aHost.  Howeve
get:a(e.g., a "log
get:amade known to
get:athrough the k
get:aaddresses of 
get:aConnections
get:aThe reliabili
get:athat TCPs ini
get:aeach data str
get:asockets, sequ
get:aEach connecti
get:aidentifying i
get:aWhen two proc
get:aestablish a c
get:aside).  When 
get:aterminated or
get:aSince connect
get:aover the unre
get:amechanism wit
get:aerroneous ini
get:aPrecedence and :Security
get:aThe users of 
get:acommunication
get:athese feature
get:aTransmission Cont
get:a[Page 6]         
get:aSeptember 1981   
get:a2.1.  Elements of
get:aThe internetwor
get:awhich are in tu
get:athat the networ
get:alarge networks 
get:apacket switchin
get:aconsume message
get:anetworks, the g
get:acommunication s
get:aconnections bet
get:aThe term packet
get:atransaction bet
get:aexchanged withi
get:aHosts are compu
get:anetwork's point
get:aProcesses are v
get:aaccordance with
get:ain execution). 
get:aviewed as commu
get:aThus, all commu
get:aSince a process
get:astreams between
get:athat each proce
get:acommunicates wi
get:a2.2.  Model of Op
get:aProcesses trans
get:adata as argumen
get:asegments and ca
get:athe destination
get:ainto the receiv
get:aTCPs include co
get:aensure reliable
get:aThe model of in
get:aprotocol module
get:ato the local ne
get:ainside internet
get:ainternet module
get:athrough the loc
get:aThe packet swit
get:aTransmission Cont
get:aother operation
get:adestination int
get:aAt a gateway be
get:afrom its local 
get:athe internet da
get:athen "wrapped" 
get:arouted to the n
get:aA gateway is pe
get:ainternet datagr
get:athrough the nex
get:ainternet datagr
get:afurther broken 
get:ainternet datagr
get:ainternet module
get:aA destination i
get:a(after reassemb
get:adestination TCP
get:aThis simple mod
get:aimportant featu
get:ato the gateway 
get:aservice paramet
get:aIncluded in the
get:adatagram.  Data
get:ahost and gatewa
get:aproperly segreg
get:a2.3.  The Host En
get:aThe TCP is assu
get:aaccess the TCP 
get:amay call on oth
get:adata structures
get:acontrolled by a
get:anetwork device 
get:adatagram protoc
get:aThe mechanisms 
get:afront-end proce
get:ahost-to-front-e
get:athe type of TCP
get:a[Page 8]         
get:aSeptember 1981   
get:aThe TCP/user in
get:ato OPEN or CLOS
get:aSTATUS about a 
get:aprograms on the
get:afrom, and close
get:aThe TCP/interne
get:adatagrams addre
get:asystem.  These 
get:aservice, preced
get:a2.5.  Relation to
get:aThe following d
get:ahierarchy
get:a+------+ +
get:a|Telnet| |
get:a+------+ +
get:a|   
get:a+----
get:a| TCP
get:a+----
get:a| 
get:a+----
get:a|    
get:a+----
get:a+--
get:a|  
get:a+--
get:aIt is expected 
get:aprotocols effic
get:aprotocols like 
get:a2.6.  Reliable Co
get:aA stream of dat
get:aorder at the de
get:aTransmission Cont
get:aTransmission is
get:aacknowledgments
get:asequence number
get:asegment is tran
get:asequence number
get:ais the sequence
get:atransmissions i
get:asegment contain
get:astarts a timer;
get:asegment is dele
get:areceived before
get:aAn acknowledgme
get:adelivered to th
get:athe responsibil
get:aTo govern the f
get:aemployed.  The 
get:aThis window spe
get:aacknowledgment 
get:a2.7.  Connection 
get:aTo identify the
get:aprovides a port
get:aindependently b
get:aunique addresse
get:aidentifying the
get:awill be unique 
get:aA connection is
get:alocal socket ma
get:asockets.  A con
get:athat is, it is 
get:aTCPs are free t
get:aHowever, severa
get:aThere must be w
get:athe "appropriat
get:amay "own" ports
get:athe ports they 
get:aissue, but we e
get:auniquely alloca
get:aassociating the
get:aA connection is
get:aforeign socket 
get:a[Page 10]        
get:aSeptember 1981   
get:aconnection name
get:asubsequent call
get:aabout a connect
get:ais a data struc
get:aimplementation 
get:apointer to the 
get:awhether the con
get:abe passively wa
get:aA passive OPEN 
get:aconnection requ
get:aOften the proce
get:arequest from an
get:ais used to deno
get:aare allowed onl
get:aA service proce
get:aprocesses would
get:aforeign socket.
get:arequested a con
get:alocal socket we
get:aWell-known sock
get:aa socket addres
get:a"Telnet-Server"
get:asocket, and oth
get:aEntry, Text Gen
get:abeing for test 
get:aaccess to a "Lo
get:aat which a newl
get:awell-known sock
get:aof sockets to s
get:aProcesses can i
get:afrom other proc
get:abeen establishe
get:aother at the sa
get:ais critical for
get:acomponents act 
get:aThere are two p
get:apassive OPENs a
get:alocal passive O
get:acase, the match
get:aOPENs has left 
get:aforeign socket 
get:aOther possibili
get:aTransmission Cont
get:aIf there are se
get:asame local sock
get:awith the specif
get:aTCB exists, bef
get:aThe procedures 
get:acontrol flag an
get:aexchange has be
get:aA connection is
get:acontaining a SY
get:acommand.  The m
get:aconnection has 
get:awhen sequence n
get:aThe clearing of
get:ain this case ca
get:a2.8.  Data Commun
get:aThe data that f
get:aoctets.  The se
get:ain that call (a
get:athrough to the 
get:aA sending TCP i
get:asend that data 
get:afunction is sig
get:areceiving TCP s
get:athe sending TCP
get:aThere is no nec
get:aboundaries.  Th
get:asingle SEND cal
get:aThe purpose of 
get:afrom the sendin
get:arecord service.
get:aThere is a coup
get:aof data that cr
get:aassociated with
get:abuffer is retur
get:anot filled.  If
get:aPUSH is seen, t
get:aTCP also provid
get:aat some point f
get:a[Page 12]        
get:aSeptember 1981   
get:acurrently readi
get:adefine what the
get:aurgent data, bu
get:atake action to 
get:a2.9.  Precedence 
get:aThe TCP makes u
get:asecurity option
get:abasis to TCP us
get:aa multilevel se
get:ause only, and o
get:acompartment.  C
get:ausers may be li
get:aTCP modules whi
get:aproperly mark o
get:aprecedence.  Su
get:ahigher level pr
get:athem to specify
get:aprecedence of c
get:a2.10.  Robustness
get:aTCP implementat:ions will follow a general principle of robustness
get:aconservative in
get:aTransmission Cont
get:a[Page 14]        
get:aSeptember 1981   
get:a3.1.  Header Form
get:aTCP segments ar
get:aheader carries 
get:adestination hos
get:aheader, supplyi
get:adivision allows
get:aTCP Header Form
get:a0            
get:a0 1 2 3 4 5 6
get:a+-+-+-+-+-+-+-
get:a|          Sou
get:a+-+-+-+-+-+-+-
get:a|             
get:a+-+-+-+-+-+-+-
get:a|             
get:a+-+-+-+-+-+-+-
get:a|  Data |     
get:a| Offset| Rese
get:a|       |     
get:a+-+-+-+-+-+-+-
get:a|           Ch
get:a+-+-+-+-+-+-+-
get:a|             
get:a+-+-+-+-+-+-+-
get:a|             
get:a+-+-+-+-+-+-+-
get:aNote th
get:aSource Port:  1
get:aThe source po
get:aDestination Por:t
get:aThe destinati
get:aTransmission Cont
get:aFunctional Specif
get:aSequence Number:
get:aThe sequence 
get:awhen SYN is p
get:ainitial seque
get:aAcknowledgment :Number
get:aIf the ACK co
get:anext sequence
get:areceive.  Onc
get:aData Offset:  4
get:aThe number of
get:athe data begi
get:aintegral numb
get:aReserved:  6 bi
get:aReserved for 
get:aControl Bits:  :6 bits (from left to right)
get:aURG:  Urgent 
get:aACK:  Acknowl
get:aPSH:  Push Fu
get:aRST:  Reset t
get:aSYN:  Synchro
get:aFIN:  No more
get:aWindow:  16 bit
get:aThe number of
get:aacknowledgmen
get:aChecksum:  16 b
get:aThe checksum 
get:acomplement su
get:asegment conta
get:achecksummed, 
get:aform a 16 bit
get:atransmitted a
get:athe checksum 
get:aThe checksum 
get:a[Page 16]        
get:aSeptember 1981   
get:aprefixed to t
get:aAddress, the 
get:aThis gives th
get:ainformation i
get:aacross the TC
get:acalls by the 
get:aThe TCP Len
get:aoctets (thi
get:acomputed), 
get:aUrgent Pointer:
get:aThis field co
get:apositive offs
get:aurgent pointe
get:athe urgent da
get:athe URG contr
get:aOptions:  varia
get:aOptions may o
get:amultiple of 8
get:achecksum.  An
get:acases for the: format of an option
get:aCase 1:  A 
get:aCase 2:  An
get:ath
get:aThe option-le
get:aoption-length
get:aNote that the
get:afield might i
get:aEnd-of-Option
get:aA TCP must im
get:aTransmission Cont
get:aFunctional Specif
get:aCurrently def:ined options include (kind indicated in octal)
get:aKind     Le
get:a----     --
get:a0         
get:a1         
get:a2         
get:aSpecific Opti
get:aEnd of Opti
get:a+--------
get:a|00000000
get:a+--------
get:aThis opti
get:amight not
get:athe Data 
get:anot the e
get:athe optio
get:aNo-Operatio
get:a+--------
get:a|00000001
get:a+--------
get:aThis opti
get:aalign the
get:aThere is 
get:areceivers
get:anot begin
get:aMaximum Seg
get:a+--------
get:a|00000010
get:a+--------
get:aKind=2  
get:a[Page 18]        
get:aSeptember 1981   
get:aMaximum S:egment Size Option Data
get:aIf this
get:areceive
get:aThis fi
get:a(i.e., 
get:aoption 
get:aPadding:  varia
get:aThe TCP heade
get:aand data begi
get:a3.2.  Terminology
get:aBefore we can d
get:ato introduce so
get:aconnection requ
get:aof these variab
get:aTransmission Co
get:aTCB are the loc
get:aprecedence of t
get:abuffers, pointe
get:aIn addition sev
get:asequence number
get:aSend Sequence
get:aSND.UNA - s
get:aSND.NXT - s
get:aSND.WND - s
get:aSND.UP  - s
get:aSND.WL1 - s
get:aSND.WL2 - s
get:au
get:aISS     - i
get:aReceive Seque
get:aRCV.NXT - r
get:aRCV.WND - r
get:aRCV.UP  - r
get:aIRS     - i
get:aTransmission Cont
get:aFunctional Specif
get:aThe following d
get:athe sequence sp
get:aSend Sequence S
get:a---
get:a1 - old s
get:a2 - seque
get:a3 - seque
get:a4 - futur
get:aThe send window
get:aReceive Sequenc
get:a1 - old s
get:a2 - seque
get:a3 - futur
get:aThe receive win
get:aThere are also 
get:atake their valu
get:a[Page 20]        
get:aSeptember 1981   
get:aCurrent Segme
get:aSEG.SEQ - s
get:aSEG.ACK - s
get:aSEG.LEN - s
get:aSEG.WND - s
get:aSEG.UP  - s
get:aSEG.PRC - s
get:aA connection pr
get:alifetime.  The :states are
get:aESTABLISHED, FI
get:aTIME-WAIT, and 
get:abecause it repr
get:ano connection. : Briefly the meanings of the states are
get:aLISTEN - repr
get:aTCP and port.
get:aSYN-SENT - re
get:aafter having 
get:aSYN-RECEIVED 
get:arequest ackno
get:aconnection re
get:aESTABLISHED -
get:adelivered to 
get:aof the connec
get:aFIN-WAIT-1 - 
get:afrom the remo
get:atermination r
get:aFIN-WAIT-2 - 
get:afrom the remo
get:aCLOSE-WAIT - 
get:afrom the loca
get:aCLOSING - rep
get:aacknowledgmen
get:aLAST-ACK - re
get:aconnection te
get:a(which includ
get:aTransmission Cont
get:aFunctional Specif
get:aTIME-WAIT - r
get:athe remote TC
get:atermination r
get:aCLOSED - repr
get:aA TCP connectio
get:aevents.  The ev
get:aABORT, and STAT
get:acontaining the 
get:aThe state diagr
get:awith the causin
get:aerror condition
get:achanges.  In a 
get:athe reaction of
get:aNOTE BENE:  thi
get:athe total speci
get:a[Page 22]        
get:aSeptember 1981   
get:a+---------+     
get:a|         |<----
get:a|   SYN   |     
get:a|   RCVD  |<----
get:a|         |     
get:a|         |-----
get:a+---------+   rc
get:a|           --
get:a|             
get:a|             
get:a|  CLOSE      
get:a| -------     
get:a| snd FIN     
get:a|             
get:aV             
get:a+---------+     
get:a|  FIN    |<----
get:a| WAIT-1  |-----
get:a+---------+     
get:a| rcv ACK of F
get:a| ------------
get:aV        x    
get:a+---------+     
get:a|FINWAIT-2|     
get:a+---------+     
get:a|             
get:a|  rcv FIN    
get:a|  -------    
get:a\ snd ACK    
get:a------------
get:aTransmission Cont
get:aFunctional Specif
get:a3.3.  Sequence Nu
get:aA fundamental n
get:aover a TCP conn
get:asequenced, each
get:amechanism emplo
get:anumber X indica
get:areceived.  This
get:adetection in th
get:awithin a segmen
get:athe header is t
get:anumbered consec
get:aIt is essential
get:afinite, though 
get:aSince the space
get:anumbers must be
get:apreserves the r
get:a2**32 - 1 to 0 
get:aarithmetic, so 
get:acomparison of s
get:a(modulo 2**32).
get:aThe typical kin
get:aperform include:
get:a(a)  Determin
get:anumber s
get:a(b)  Determin
get:ahave bee
get:aretransm
get:a(c)  Determin
get:awhich ar
get:areceive 
get:a[Page 24]        
get:aSeptember 1981   
get:aIn response to 
get:afollowing compa
get:aSND.UNA = old
get:aSND.NXT = nex
get:aSEG.ACK = ack
get:anum
get:aSEG.SEQ = fir
get:aSEG.LEN = the
get:a(co
get:aSEG.SEQ+SEG.L
get:aA new acknowled
get:athe inequality :below holds
get:aSND.UNA < SEG
get:aA segment on th
get:aof its sequence
get:aacknowledgment 
get:aWhen data is re:ceived the following comparisons are needed
get:aRCV.NXT = nex
get:ais the le
get:aRCV.NXT+RCV.W
get:asegment, 
get:aSEG.SEQ = fir
get:aSEG.SEQ+SEG.L
get:aA segment is ju
get:aRCV.NXT =< SE
get:aRCV.NXT =< SE
get:aTransmission Cont
get:aFunctional Specif
get:aThe first part 
get:asegment falls i
get:aif the end of t
get:aeither part of 
get:aActually, it is
get:awindows and zer
get:aacceptability o:f an incoming segment
get:aSegment Recei
get:aLength  Windo
get:a------- -----
get:a0       0 
get:a0      >0 
get:a>0       0 
get:a>0      >0 
get:aNote that when 
get:aacceptable exce
get:amaintain a zero
get:aACKs.  However,
get:aprocess the RST
get:aWe have taken a
get:acontrol informa
get:asome control fl
get:aand acknowledge
get:acontrol will be
get:acarried in the 
get:afor implicitly 
get:aare the only co
get:aare used only a
get:apurposes, the S
get:aoctet of the se
get:ato occur after 
get:aoccurs.  The se
get:aspace occupying
get:asequence number
get:a[Page 26]        
get:aSeptember 1981   
get:aInitial Sequenc
get:aThe protocol pl
get:aused over and o
get:asockets.  New i
get:aincarnations of
get:a-- "how does th
get:aincarnations of
get:aconnection is b
get:aconnection brea
get:aTo avoid confus
get:aconnection from
get:abe present in t
get:aassure this, ev
get:asequence number
get:aan initial sequ
get:anew 32 bit ISN.
get:abit clock whose
get:amicroseconds.  
get:aSince we assume
get:athe Maximum Seg
get:ahours we can re
get:aFor each connec
get:asequence number
get:athe data sendin
get:alearned during 
get:aFor a connectio
get:asynchronize on 
get:aan exchange of 
get:acalled "SYN" (f
get:ashorthand, segm
get:aHence, the solu
get:ainitial sequenc
get:aThe synchroniza
get:asequence number
get:afrom the other 
get:ainitial sequenc
get:a1) A --> B  S
get:a2) A <-- B  A
get:a3) A <-- B  S
get:a4) A --> B  A
get:aTransmission Cont
get:aFunctional Specif
get:aBecause steps 2
get:acalled the thre
get:aA three way han
get:atied to a globa
get:amechanisms for 
get:ano way of knowi
get:aunless it remem
get:a(which is not a
get:averify this SYN
get:aclock-driven sc
get:aKnowing When to
get:aTo be sure that
get:asequence number
get:athe network, th
get:a(MSL) before as
get:arecovering from
get:alost.  For this
get:ais an engineeri
get:ait is desirable
get:asense, yet reta
get:anot wait at all
get:athan those rece
get:aThe TCP Quiet T
get:aThis specific
get:aretaining any
get:aeach active (
get:aTCP segments 
get:ain the intern
get:aparagraphs be
get:aTCP implement
get:aat the risk o
get:adata rejected
get:aTCPs consume 
get:aentered into 
get:aduplicate det
get:arelies on the
get:athe extent th
get:avalues before
get:abeen delivere
get:acopies of the
get:asuch an assum
get:a[Page 28]        
get:aSeptember 1981   
get:aassigned the 
get:aat the receiv
get:athat each seg
get:aas there are 
get:aUnder normal 
get:ato emit and t
get:amistakenly us
get:abeen acknowle
get:adata is drain
get:avery large to
get:acause trouble
get:ato use up 2**
get:alifetime in t
get:athis is deeme
get:arates escalat
get:acycle time is
get:awithin reason
get:aThe basic dup
get:adefeated, how
get:asequence numb
get:athe TCP were 
get:aupon crashing
get:aconnection (p
get:apackets with 
get:apackets still
get:aincarnation o
get:aabout the seq
get:aspecification
get:abefore emitti
get:asegments from
get:aEven hosts wh
get:ainitial seque
get:a(i.e., even i
get:anumber for ea
get:aSuppose, for 
get:asequence numb
get:aand that even
get:atakes on a va
get:asegment sent 
get:aat this insta
get:aincarnation o
get:aS1 = ISN(t) -
get:aconnection!  
get:aTransmission Cont
get:aFunctional Specif
get:aduplicates in
get:aof S1 may arr
get:athe new incar
get:aThe problem i
get:acrashed nor d
get:athe system fr
get:aOne way to de
get:asegments for 
get:atime" specifi
get:awilling to ri
get:adestination m
get:aImplementors 
get:aconnection by
get:ainformally im
get:aObviously, ev
get:anecessary aft
get:aTo summarize:
get:anumbers in th
get:a"busy" or "in
get:ablock of spac
get:asegment, if a
get:asequence numb
get:athe previous 
get:anumber overla
get:a3.4.  Establishin
get:aThe "three-way 
get:aconnection.  Th
get:aresponded to by
get:asimultaneously 
get:aoccurs, each TC
get:aacknowledgment 
get:aan old duplicat
get:arecipient, that
get:aProper use of "
get:aSeveral example
get:aexamples do not
get:asegments, this 
get:adoesn't deliver
get:avalid (i.e., th
get:aconnection reac
get:areduces the pos
get:a[Page 30]        
get:aSeptember 1981   
get:aimplementation 
get:ainformation for
get:aThe simplest th
get:afigures should 
get:anumbered for re
get:adeparture of a 
get:asegment at B fr
get:aEllipsis (...) 
get:a(delayed).  An 
get:aComments appear
get:athe departure o
get:athe center of e
get:aform, with sequ
get:afields such as 
get:ain the interest
get:aTCP A      
get:a1.  CLOSED     
get:a2.  SYN-SENT   
get:a3.  ESTABLISHED
get:a4.  ESTABLISHED
get:a5.  ESTABLISHED
get:aBasic 3
get:aIn line 2 of fi
get:aindicating that
get:anumber 100.  In
get:areceived from T
get:aB is now expect
get:aoccupied sequen
get:aAt line 4, TCP 
get:aTCP B's SYN; an
get:asequence number
get:abecause the ACK
get:awould wind up A
get:aTransmission Cont
get:aFunctional Specif
get:aSimultaneous in
get:afigure 8.  Each
get:aTCP A      
get:a1.  CLOSED     
get:a2.  SYN-SENT   
get:a3.  SYN-RECEIVE
get:a4.             
get:a5.  SYN-RECEIVE
get:a6.  ESTABLISHED
get:a7.             
get:aS
get:aThe principle r
get:aduplicate conne
get:athis, a special
get:areceiving TCP i
get:aSYN-RECEIVED), 
get:aIf the TCP is i
get:aFIN-WAIT-1, FIN
get:aaborts the conn
get:acase under "hal
get:a[Page 32]        
get:aSeptember 1981   
get:aTCP A      
get:a1.  CLOSED     
get:a2.  SYN-SENT   
get:a3.  (duplicate)
get:a4.  SYN-SENT   
get:a5.  SYN-SENT   
get:a6.             
get:a7.  SYN-SENT   
get:a8.  ESTABLISHED
get:aAs a simple exa
get:afigure 9.  At l
get:acannot tell tha
get:a(line 4).  TCP 
get:aRST (reset) wit
get:abelievable.  TC
get:aWhen the origin
get:asynchronization
get:abefore the RST,
get:asent in both di
get:aHalf-Open Conne
get:aAn established 
get:aTCPs has closed
get:aknowledge of th
get:abecome desynchr
get:amemory.  Such c
get:aattempt is made
get:aconnections are
get:amildly involved
get:aIf at site A th
get:aTransmission Cont
get:aFunctional Specif
get:auser at site B 
get:areceiving a res
get:asite B TCP that
get:aAssume that two
get:aanother when a 
get:aDepending on th
get:athat some error
get:aA is likely to 
get:apoint.  As a re
get:aor try to SEND 
get:acase, it receiv
get:alocal (A's) TCP
get:awill send a seg
get:aexample shown i
get:are-open the con
get:aTCP A      
get:a1.  (CRASH)    
get:a2.  CLOSED     
get:a3.  SYN-SENT --
get:a4.  (!!)     <-
get:a5.  SYN-SENT --
get:a6.  SYN-SENT   
get:a7.  SYN-SENT --
get:aWhen the SYN ar
get:aand the incomin
get:aacknowledgment 
get:a100).  TCP A se
get:asent and, being
get:adetected a half
get:a[Page 34]        
get:aSeptember 1981   
get:acontinue to try
get:areduced to the 
get:aAn interesting 
get:atries to send d
get:aThis is illustr
get:aTCP A from TCP 
get:aexists, so TCP 
get:aprocesses it an
get:aTCP A    
get:a1.  (CRASH)    
get:a2.  (??)    <--
get:a3.          -->
get:aActive
get:aIn figure 12, w
get:awaiting for SYN
get:ainto action.  A
get:agenerate a RST 
get:athe reset and r
get:aTCP A      
get:a1.  LISTEN     
get:a2.       ... <S
get:a3.  (??) <-- <S
get:a4.       --> <S
get:a5.  LISTEN     
get:aOld Duplic
get:aTransmission Cont
get:aFunctional Specif
get:aA variety of ot
get:aby the followin
get:aReset Generatio
get:aAs a general ru
get:awhich apparentl
get:amust not be sen
get:aThere are three: groups of states
get:a1.  If the co
get:ain response t
get:aparticular, S
get:aby this means
get:aIf the incomi
get:asequence numb
get:areset has seq
get:aof the sequen
get:aThe connectio
get:a2.  If the co
get:aSYN-SENT, SYN
get:asomething not
get:aif an incomin
get:adoes not exac
get:aconnection, a
get:aIf our SYN ha
get:aincoming segm
get:aeither raise 
get:athe system) o
get:aincoming segm
get:acontinue as i
get:acannot raise 
get:adetected in t
get:aterminated th
get:aincoming segm
get:amatch the loc
get:amust be sent.
get:aIf the incomi
get:asequence numb
get:areset has seq
get:aof the sequen
get:aThe connectio
get:a[Page 36]        
get:aSeptember 1981   
get:a3.  If the co
get:aFIN-WAIT-1, F
get:aany unaccepta
get:aunacceptible 
get:aacknowledgmen
get:aand an acknow
get:ato be receive
get:aIf an incomin
get:aprecedence wh
get:aand precedenc
get:aconnection go
get:anumber from t
get:aReset Processin
get:aIn all states e
get:aby checking the
get:ais in the windo
get:ato an initial S
get:aacknowledges th
get:aThe receiver of
get:areceiver was in
get:ain SYN-RECEIVED
get:athen the receiv
get:aaborts the conn
get:awas in any othe
get:aand goes to the
get:a3.5.  Closing a C
get:aCLOSE is an ope
get:anotion of closi
get:ainterpretation,
get:athe receiving s
get:ain a simplex fa
get:auntil he is tol
get:acould initiate 
get:aRECEIVE until s
get:ahas CLOSED.  We
get:aRECEIVEs are ou
get:acan terminate h
get:abuffers SENT be
get:adata in return 
get:asuccessfully to
get:aTCP.  Users mus
get:athe TCP says no
get:aTransmission Cont
get:aFunctional Specif
get:aThere are essen:tially three cases
get:a1) The user i
get:a2) The remote
get:a3) Both users
get:aCase 1:  Local 
get:aIn this case,
get:aoutgoing segm
get:aaccepted by t
get:aare allowed i
get:awill be retra
get:aboth acknowle
get:acan ACK this 
get:asend its own 
get:aCase 2:  TCP re
get:aIf an unsolic
get:acan ACK it an
get:auser will res
get:athe other TCP
get:auntil its own
get:aconnection.  
get:athe connectio
get:aCase 3:  both u
get:aA simultaneou
get:aFIN segments 
get:ahave been pro
get:ahas received.
get:a[Page 38]        
get:aSeptember 1981   
get:aTCP A      
get:a1.  ESTABLISHED
get:aFIN-WAIT-1 
get:a3.  FIN-WAIT-2 
get:a4.             
get:aTIME-WAIT  
get:a5.  TIME-WAIT  
get:aCLOSED     
get:aTCP A      
get:a1.  ESTABLISHED
get:a2.  (Close)    
get:aFIN-WAIT-1 
get:a3.  CLOSING    
get:a4.  TIME-WAIT  
get:a(2 MSL)    
get:aCLOSED     
get:aTransmission Cont
get:aFunctional Specif
get:a3.6.  Precedence 
get:aThe intent is t
get:awith exactly th
get:ahigher of the p
get:aThe precedence 
get:adefined in the 
get:aspecification t
get:athe security pa
get:auser group, and
get:aA connection at
get:alower precedenc
get:aa connection du
get:aacknowledgment 
get:aNote that TCP m
get:aprecedence will
get:asegments and po
get:aThe security pa
get:a(the values wou
get:anon-secure envi
get:aparameters, tho
get:a3.7.  Data Commun
get:aOnce the connec
get:aexchange of seg
get:a(checksum test 
get:aretransmission 
get:aDuplicate segme
get:aAs discussed in
get:acertain tests o
get:asegments to ver
get:aThe sender of d
get:athe variable SN
get:asequence number
get:akeeps track of 
get:avariable SND.UN
get:asent has been a
get:aWhen the sender
get:aSND.NXT.  When 
get:asends an acknow
get:a[Page 40]        
get:aSeptember 1981   
get:aacknowledgment 
get:athese variables
get:aThe amount by w
get:adata in the seg
get:asegments must c
get:aThe CLOSE user 
get:aflag in an inco
get:aRetransmission 
get:aBecause of the 
get:ainternetwork sy
get:aretransmission 
get:afor determining
get:aAn Example Re
get:aMeasure the
get:aparticular 
get:acovers that
get:asegments re
get:aTime (RTT).:  Next compute a Smoothed Round Trip Time (SRTT) as
get:aSRTT = ( 
get:aand based o:n this, compute the retransmission timeout (RTO) as
get:aRTO = min
get:awhere UBOUN
get:aLBOUND is a
get:aa smoothing
get:afactor (e.g
get:aThe Communicati
get:aThe objective o
get:ato stimulate th
get:apermit the rece
get:athe currently k
get:aThis mechanism 
get:athe end of urge
get:athe receive seq
get:amust tell the u
get:anumber catches 
get:aTransmission Cont
get:aFunctional Specif
get:ainto "normal mo
get:ais in "urgent m
get:aThe method empl
get:atransmitted.  T
get:ameaningful and 
get:athe urgent poin
get:ano urgent data 
get:aTo send an urge
get:aoctet.  If the 
get:athe urgent info
get:aManaging the Wi
get:aThe window sent
get:anumbers the sen
get:aprepared to acc
get:athe currently a
get:aIndicating a la
get:aarrives than ca
get:ain excessive re
get:anetwork and the
get:atransmission of
get:abetween each ne
get:aThe mechanisms 
get:asubsequently ad
get:athat much data.
get:adiscouraged.  T
get:ashrink the wind
get:aon the part of 
get:aThe sending TCP
get:aleast one octet
get:asending TCP mus
get:athe window is z
get:ainterval when t
get:aguarantee that 
get:awindow will be 
get:aWhen the receiv
get:astill send an a
get:aand current win
get:aThe sending TCP
get:a[Page 42]        
get:aSeptember 1981   
get:awhich fit the c
get:aretransmission 
get:aIn a connection
get:abe carried in a
get:anumber so there
get:aorder.  This is
get:ainformation to 
get:athe data receiv
get:athe window info
get:aacknowledgment 
get:aequal or greate
get:aThe window mana
get:acommunication p
get:aWindow Manage
get:aAllocating 
get:amany small 
get:afewer large
get:aOne suggest
get:adefer updat
get:aleast X per
get:aconnection 
get:aAnother sug
get:asegments by
get:asending dat
get:adata must b
get:aNote that t
get:aretransmiss
get:aacknowledgm
get:awindow info
get:anew window 
get:aThe segment
get:aof transmit
get:asegment con
get:ais accepted
get:aIf the send
get:awindow is n
get:aalternating
get:apauses in t
get:aTransmission Cont
get:aFunctional Specif
get:aresult in b
get:abig pair. A
get:amostly smal
get:aThe suggest
get:aactively at
get:awindows, si
get:ato many sma
get:aThere are of co:urse two interfaces of concern
get:aand the TCP/low
get:aof the user/TCP
get:aprotocol module
get:ain detail by th
get:acase that the l
get:athat TCPs might
get:aUser/TCP Interf
get:aThe following
get:aat best, fict
get:afacilities.  
get:aimplementatio
get:aTCPs must pro
get:athat all TCP 
get:ahierarchy.  T
get:arequired of a
get:aTCP User Comm
get:aThe followi
get:ainterface. 
get:afunction ca
get:ameant to ru
get:aThe user co
get:aTCP must pe
get:aIndividual 
get:amay provide
get:asingle call
get:aautomatical
get:aissued by t
get:a[Page 44]        
get:aSeptember 1981   
get:aIn providin
get:anot only ac
get:aprocesses i:t serves.  The latter consists of
get:a(a) gener
get:aremote cl
get:a(b) repli
get:avarious t
get:aFormat:  
get:a[, timeou
get:a-> local 
get:aWe assume
get:aprocesses
get:ato use th
get:aimplement
get:afor the s
get:alower lev
get:aresult of
get:aable to m
get:aprocess c
get:aIf the ac
get:acall to L
get:ahave eith
get:aparticula
get:afor any c
get:aby the su
get:aA transmi
get:afilled in
get:aOn an act
get:asynchroni
get:aThe timeo
get:afor all d
get:adelivered
get:awill abor
get:aThe TCP o
get:athe users
get:aTransmission Cont
get:aFunctional Specif
get:aprecedenc
get:aor securi
get:athe defau
get:aTCP will 
get:asecurity/
get:athe prece
get:arequested
get:aThe prece
get:arequested
get:arequest, 
get:aconnectio
get:athis prec
get:aallowed t
get:aor that a
get:aA local c
get:aThe local
get:afor the c
get:aFormat:  
get:acount, PU
get:aThis call
get:ato be sen
get:anot been 
get:aimplement
get:aautomatic
get:aauthorize
get:aIf the PU
get:ato the re
get:asegment c
get:athe data 
get:atransmiss
get:aIf the UR
get:awill have
get:athe urgen
get:apointer i
get:abeen cons
get:ais to sti
get:aindicate 
get:a[Page 46]        
get:aSeptember 1981   
get:adata has 
get:aTCP signa
get:aof times 
get:aurgent da
get:aIf no for
get:aconnectio
get:ahas becom
get:alocal soc
get:aforeign s
get:aforeign s
get:aknowing t
get:aHowever, 
get:abecomes s
get:aSTATUS ca
get:aimplement
get:asocket is
get:aIf a time
get:aconnectio
get:aIn the si
get:athe sendi
get:aor the ti
get:ais both s
get:aconnectio
get:aoffers po
get:asophistic
get:athe proce
get:afurthermo
get:aMultiple 
get:athe TCP w
get:aWe have i
get:awhich a S
get:apseudo-in
get:areturn a 
get:aimmediate
get:abeen ackn
get:aassume ev
get:aclose any
get:akind (syn
get:asignals, 
get:awith spec
get:aIn order 
get:aindicatio
get:aTransmission Cont
get:aFunctional Specif
get:abuffer ad
get:athe SEND 
get:aindicatin
get:acalling p
get:aFormat:  
get:acount) ->
get:aThis comm
get:aspecified
get:acalling p
get:aerror is 
get:aIn the si
get:acalling p
get:aerror occ
get:aA more so
get:aRECEIVEs 
get:asegments 
get:athe cost 
get:anotify th
get:aIf enough
get:athe PUSH 
get:aThe buffe
get:aa PUSH is
get:areturned 
get:aIf there 
get:aas it arr
get:ashould th
get:aadditiona
get:acall to R
get:amay now l
get:aurgent po
get:ain the sa
get:aboundary 
get:aTo distin
get:acare of t
get:areturn co
get:acount ind
get:aAlternati
get:a[Page 48]        
get:aSeptember 1981   
get:aallocate 
get:awith the 
get:aFormat:  
get:aThis comm
get:athe conne
get:aauthorize
get:aClosing c
get:athe sense
get:aretransmi
get:aserviced.
get:acalls, fo
get:ato the de
get:acontinue 
get:amay be tr
get:ameans "I 
get:areceive a
get:anot well 
get:aof all it
get:ainto ABOR
get:aThe user 
get:ainitiativ
get:a(e.g., re
get:adestinati
get:aBecause c
get:aforeign T
get:ashort tim
get:areplies t
get:aClose als
get:aFormat:  
get:aThis is a
get:aexcluded 
get:atypically
get:aThis comm
get:ainformati:on
get:alocal s
get:aTransmission Cont
get:aFunctional Specif
get:aforeign
get:alocal c
get:areceive
get:asend wi
get:aconnect
get:anumber 
get:anumber 
get:aurgent 
get:aprecede
get:asecurit
get:aand tra
get:aDepending
get:aimplement
get:aavailable
get:aauthorize
get:aprevents 
get:aconnectio
get:aFormat:  
get:aThis comm
get:aaborted, 
get:abe sent t
get:aDepending
get:aindicatio
get:areceive a
get:aTCP-to-User M
get:aIt is assum
get:ameans for t
get:athe TCP doe
get:ato the user
get:aan error me
get:arelating to
get:aother user 
get:aThe followi:ng information is provided
get:aLocal Con
get:aResponse 
get:aBuffer Ad
get:aByte coun
get:aPush flag
get:aUrgent fl
get:a[Page 50]        
get:aSeptember 1981   
get:aTCP/Lower-Level
get:aThe TCP calls
get:areceive infor
get:ainternetwork 
get:aProtocol (IP)
get:aIf the lower 
get:aof service an
get:afor these par:ameters
get:aType of Ser:vice = Precedence: routine, Delay: normal, Throughput
get:anormal, Rel:iability
get:aTime to Liv
get:aNote that
get:aHere we e
get:abe delive
get:aIf the lower 
get:afeature) and 
get:aroute informa
get:aso that the s
get:achecksum be t
get:aalso importan
get:aAny lower lev
get:adestination a
get:athe "TCP leng
get:aof IP and to 
get:aTransmission Cont
get:aFunctional Specif
get:a3.9.  Event Proce
get:aThe processing 
get:aimplementation.
get:aprocessing sequ
get:asection only in
get:aThe activity of
get:aThe events that: occur can be cast into three categories
get:aarriving segmen
get:aprocessing the 
get:acases the proce
get:aEvents that o:ccur
get:aArriving Se
get:aSEGMENT A
get:aUSER TIME
get:aRETRANSMI
get:aTIME-WAIT
get:aThe model of th
get:aimmediate retur
get:apseudo interrup
get:ameans cause a d
get:aError responses
get:acommands refere:ncing connections that do not exist receive "error
get:aconnection not 
get:aPlease note in 
get:aacknowledgment 
get:aof the sequence
get:aequal to (modul
get:a[Page 52]        
get:aSeptember 1981   
get:aA natural way t
get:aimagine that th
get:athat their cont
get:ain the sequence
get:aand processed i
get:aWhen a segment 
get:athe segment to 
get:ato be consisten
get:aNote that if no
get:aTransmission Cont
get:aFunctional Specif
get:aCLOSED STATE 
get:aCreate a ne
get:astate infor
get:asocket, pre
get:ainformation
get:aunspecified
get:aparameters 
get:aprecedence 
get:a"error:  pr:ecedence not allowed" or "error
get:anot allowed
get:aactive and :the foreign socket is unspecified, return "error
get:aforeign soc
get:aspecified, 
get:a(ISS) is se
get:ais sent.  S
get:astate, and 
get:aIf the call
get:areturn "err:or
get:ano room to :create a new connection, return "error
get:aresources".
get:aIf active a
get:aconnection 
get:asegment, se
get:astate.  Dat
get:aqueued for 
get:aurgent bit 
get:asegments se
get:aqueue the r:equest, respond with "error
get:aIf Foreign :socket was not specified, then return "error
get:asocket unsp
get:a[Page 54]        
get:aSeptember 1981   
get:aSYN-SENT STAT
get:aSYN-RECEIVED 
get:aESTABLISHED S
get:aFIN-WAIT-1 ST
get:aFIN-WAIT-2 ST
get:aCLOSE-WAIT ST
get:aCLOSING STATE
get:aLAST-ACK STAT
get:aTIME-WAIT STA
get:aReturn "err:or
get:aTransmission Cont
get:aFunctional Specif
get:aCLOSED STATE 
get:aIf the user
get:a"error:  co
get:aOtherwise, :return "error
get:aIf the fore
get:afrom passiv
get:aSND.UNA to 
get:aassociated 
get:atransmissio
get:arequested i
get:aas a result
get:arequest, re:spond with "error
get:aForeign soc:ket was not specified, then return "error
get:asocket unsp
get:aSYN-SENT STAT
get:aSYN-RECEIVED 
get:aQueue the d
get:aIf no space: to queue, respond with "error
get:aresources".
get:aESTABLISHED S
get:aCLOSE-WAIT ST
get:aSegmentize 
get:aacknowledgm
get:ainsufficien:t space to remember this buffer, simply return "error
get:ainsufficien
get:aIf the urge
get:aurgent poin
get:a[Page 56]        
get:aSeptember 1981   
get:aFIN-WAIT-1 ST
get:aFIN-WAIT-2 ST
get:aCLOSING STATE
get:aLAST-ACK STAT
get:aTIME-WAIT STA
get:aReturn "err:or
get:aTransmission Cont
get:aFunctional Specif
get:aCLOSED STATE 
get:aIf the user
get:a"error:  co
get:aOtherwise r:eturn "error
get:aSYN-SENT STAT
get:aSYN-RECEIVED 
get:aQueue for p
get:ais no room :to queue this request, respond with "error
get:ainsufficien
get:aESTABLISHED S
get:aFIN-WAIT-1 ST
get:aFIN-WAIT-2 ST
get:aIf insuffic
get:arequest, qu
get:aremember th:e RECEIVE, respond with "error
get:aresources".
get:aReassemble 
get:ato user.  M
get:aIf RCV.UP i
get:auser notify
get:aWhen the TC
get:athat fact m
get:aacknowledgm
get:adescribed b
get:a[Page 58]        
get:aSeptember 1981   
get:aCLOSE-WAIT ST
get:aSince the r
get:asatisfied b
get:auser.  If n
get:a"error:  co
get:atext can be
get:aCLOSING STATE
get:aLAST-ACK STAT
get:aTIME-WAIT STA
get:aReturn "err:or
get:aTransmission Cont
get:aFunctional Specif
get:aCLOSED STATE 
get:aIf the user
get:a"error:  co
get:aOtherwise, :return "error
get:aAny outstan:ding RECEIVEs are returned with "error
get:aresponses. 
get:aSYN-SENT STAT
get:aDelete the :TCB and return "error
get:aqueued SEND
get:aSYN-RECEIVED 
get:aIf no SENDs
get:athen form a
get:aotherwise q
get:aESTABLISHED S
get:aQueue this 
get:aform a FIN 
get:aFIN-WAIT-1 ST
get:aFIN-WAIT-2 ST
get:aStrictly sp:eaking, this is an error and should receive a "error
get:aconnection 
get:aacceptable,
get:aFIN may be 
get:a[Page 60]        
get:aSeptember 1981   
get:aCLOSE-WAIT ST
get:aQueue this 
get:asegmentized
get:aCLOSING STATE
get:aLAST-ACK STAT
get:aTIME-WAIT STA
get:aRespond wit:h "error
get:aTransmission Cont
get:aFunctional Specif
get:aCLOSED STATE 
get:aIf the user
get:a"error:  co
get:aOtherwise r:eturn "error
get:aAny outstan:ding RECEIVEs should be returned with "error
get:aconnection 
get:aSYN-SENT STAT
get:aAll queued 
get:anotificatio
get:aSYN-RECEIVED 
get:aESTABLISHED S
get:aFIN-WAIT-1 ST
get:aFIN-WAIT-2 ST
get:aCLOSE-WAIT ST
get:aSend a rese:t segment
get:a<SEQ=SND.
get:aAll queued 
get:anotificatio
get:aRST formed 
get:aTCB, enter 
get:aCLOSING STATE
get:aLAST-ACK STAT
get:aTIME-WAIT STA
get:aRespond wit
get:a[Page 62]        
get:aSeptember 1981   
get:aCLOSED STATE 
get:aIf the user
get:a"error:  co
get:aOtherwise r:eturn "error
get:aReturn "sta
get:aSYN-SENT STAT
get:aReturn "sta
get:aSYN-RECEIVED 
get:aReturn "sta
get:aESTABLISHED S
get:aReturn "sta
get:aFIN-WAIT-1 ST
get:aReturn "sta
get:aFIN-WAIT-2 ST
get:aReturn "sta
get:aCLOSE-WAIT ST
get:aReturn "sta
get:aCLOSING STATE
get:aReturn "sta
get:aLAST-ACK STAT
get:aReturn "sta
get:aTransmission Cont
get:aFunctional Specif
get:aTIME-WAIT STA
get:aReturn "sta
get:a[Page 64]        
get:aSeptember 1981   
get:aSEGMENT ARRIVES
get:aIf the state 
get:aall data in
get:asegment con
get:acontaining 
get:aacknowledgm
get:areset seque
get:aIf the ACK 
get:a<SEQ=0><A
get:aIf the ACK 
get:a<SEQ=SEG.
get:aIf the state 
get:afirst check
get:aAn incomi
get:asecond chec
get:aAny ackno
get:athe LISTE
get:afor any a
get:aformatted: as follows
get:a<SEQ=SE
get:athird check
get:aIf the SY
get:asecurity/
get:amatch the
get:a<SEQ=SE
get:aTransmission Cont
get:aFunctional Specif
get:aIf the SE
get:athe user 
get:asend a re
get:a<SEQ=SE
get:aIf the SE
get:aSet RCV.N
get:acontrol o
get:ashould be: selected and a SYN segment sent of the form
get:a<SEQ=IS
get:aSND.NXT i
get:astate sho
get:aincoming 
get:ain the SY
get:anot be re
get:athe forei
get:aunspecifi
get:afourth othe
get:aAny other
get:amust have
get:aprocessin
get:ait could 
get:aincarnati
get:abut if yo
get:aIf the state 
get:afirst check
get:aIf the AC
get:aIf SEG.
get:athe RST
get:a<SEQ=
get:aand dis
get:aIf SND.
get:asecond chec
get:a[Page 66]        
get:aSeptember 1981   
get:aIf the RS
get:aIf the :ACK was acceptable then signal the user "error
get:aconnect
get:adelete 
get:aand ret
get:athird check
get:aIf the se
get:amatch the
get:aIf ther
get:a<SEQ=
get:aOtherwi
get:a<SEQ=
get:aIf there 
get:aThe pre
get:aTCB, if
get:a<SEQ=
get:aIf there 
get:aIf the 
get:ain the 
get:athe pre
get:aallowed
get:a<SEQ=
get:aIf the 
get:ain the 
get:aIf a rese
get:afourth chec
get:aThis step
get:ano ACK, a
get:aIf the SY
get:aTransmission Cont
get:aFunctional Specif
get:aare accep
get:aSEG.SEQ. 
get:ais an ACK
get:aare there
get:aIf SND.UN
get:astate to 
get:a<SEQ=SN
get:aand send 
get:atransmiss
get:atext in t
get:abelow whe
get:aOtherwise
get:a<SEQ=IS
get:aand send 
get:asegment, 
get:ahas been 
get:afifth, if n
get:asegment and
get:a[Page 68]        
get:aSeptember 1981   
get:afirst check s
get:aSYN-RECEIVE
get:aESTABLISHED
get:aFIN-WAIT-1 
get:aFIN-WAIT-2 
get:aCLOSE-WAIT 
get:aCLOSING STA
get:aLAST-ACK ST
get:aTIME-WAIT S
get:aSegments 
get:aare used 
get:adone in S
get:aboundary 
get:aprocessed
get:aThere are
get:asegment
get:aSegment R
get:aLength  W
get:a------- -
get:a0     
get:a0     
get:a>0     
get:a>0     
get:aIf the RC
get:aspecial a
get:aIf an inc
get:ashould be
get:athe segme:nt and return)
get:a<SEQ=SN
get:aAfter sen
get:aand retur
get:aTransmission Cont
get:aFunctional Specif
get:aIn the fo
get:asegment t
get:aOne could
get:atrimming 
get:aSYN and F
get:abegins at
get:anumbers m
get:asecond check 
get:aSYN-RECEIVE
get:aIf the RS
get:aIf this
get:acame fr
get:aLISTEN 
get:athis co
get:afrom SY
get:athe use
get:aon the 
get:aactive 
get:aand ret
get:aESTABLISHED
get:aIf the RS
get:ashould re
get:aflushed. 
get:a"connecti
get:aTCB, and 
get:aCLOSING STA
get:aLAST-ACK ST
get:aIf the RS
get:aTCB, and 
get:a[Page 70]        
get:aSeptember 1981   
get:athird check s
get:aSYN-RECEIVE
get:aIf the se
get:aexactly m
get:athen send
get:aESTABLISHED
get:aIf the se
get:aexactly m
get:athen send
get:areceive "
get:aflushed. 
get:a"connecti
get:aTCB, and 
get:aNote this c
get:aa segment f
get:adifferent s
get:acurrent con
get:afourth, check
get:aSYN-RECEIVE
get:aESTABLISHED
get:aFIN-WAIT ST
get:aFIN-WAIT ST
get:aCLOSE-WAIT 
get:aCLOSING STA
get:aLAST-ACK ST
get:aTIME-WAIT S
get:aIf the SY
get:aoutstandi
get:aall segme
get:areceive a
get:athe CLOSE
get:aIf the SY
get:aand an ac
get:anumber ch
get:aTransmission Cont
get:aFunctional Specif
get:afifth check t
get:aif the ACK 
get:aif the ACK 
get:aSYN-RECEI
get:aIf SND.
get:aand con
get:aIf th
get:areset
get:a<SE
get:aand s
get:aESTABLISH
get:aIf SND.
get:aAny seg
get:aentirel
get:apositiv
get:afully a
get:a"ok" re
get:a(SEG.AC
get:asomethi
get:adrop th
get:aIf SND.
get:aupdated
get:aSND.WL2
get:aSND.WL1
get:aNote th
get:arecords
get:aSND.WND
get:athe las
get:aprevent
get:a[Page 72]        
get:aSeptember 1981   
get:aFIN-WAIT-
get:aIn addi
get:aour FIN
get:aprocess
get:aFIN-WAIT-
get:aIn addi
get:athe ret
get:aacknowl
get:aCLOSE-WAI
get:aDo the 
get:aCLOSING S
get:aIn addi
get:athe ACK
get:aotherwi
get:aLAST-ACK 
get:aThe onl
get:aacknowl
get:adelete 
get:aTIME-WAIT
get:aThe onl
get:aretrans
get:athe 2 M
get:asixth, check 
get:aESTABLISHED
get:aFIN-WAIT-1 
get:aFIN-WAIT-2 
get:aIf the UR
get:athe user 
get:apointer (
get:auser has 
get:amode") fo
get:asignal th
get:aTransmission Cont
get:aFunctional Specif
get:aCLOSE-WAIT 
get:aCLOSING STA
get:aLAST-ACK ST
get:aThis shou
get:aremote si
get:aseventh, proc
get:aESTABLISHED
get:aFIN-WAIT-1 
get:aFIN-WAIT-2 
get:aOnce in t
get:atext to u
get:ainto buff
get:aempty.  I
get:athe user 
get:ahas been 
get:aWhen the 
get:auser it m
get:aOnce the 
get:aRCV.NXT o
get:aapporopri
get:aRCV.NXT a
get:aPlease no
get:aSend an a:cknowledgment of the form
get:a<SEQ=SN
get:aThis ackn
get:atransmitt
get:a[Page 74]        
get:aSeptember 1981   
get:aCLOSE-WAIT 
get:aCLOSING STA
get:aLAST-ACK ST
get:aTIME-WAIT S
get:aThis shou
get:aremote si
get:aeighth, check
get:aDo not proc
get:asince the S
get:aIf the FIN 
get:areturn any 
get:aover the FI
get:aFIN implies
get:aSYN-RECEI
get:aESTABLISH
get:aEnter t
get:aFIN-WAIT-
get:aIf our 
get:aenter T
get:atimers;
get:aFIN-WAIT-
get:aEnter t
get:aoff the
get:aCLOSE-WAI
get:aRemain 
get:aCLOSING S
get:aRemain 
get:aLAST-ACK 
get:aRemain 
get:aTransmission Cont
get:aFunctional Specif
get:aTIME-WAIT
get:aRemain 
get:atimeout
get:a[Page 76]        
get:aSeptember 1981   
get:aFor any state
get:athe user "err:or
get:aand for any o
get:astate and ret
get:aRETRANSMISSION 
get:aFor any state
get:athe retransmi
get:aretransmissio
get:aTIME-WAIT TIMEO
get:aIf the time-w
get:aenter the CLO
get:aTransmission Cont
get:a[Page 78]        
get:aSeptember 1981   
get:aBBN Rep
get:aa Host 
get:ahost an
get:aA contr
get:aindicat
get:aspecifi
get:ais expe
get:apreviou
get:aThe uni
get:aARPANET
get:aA unit 
get:aIMPs.  
get:aA logic
get:aA messa
get:anetwork
get:aDestination Addre
get:aThe des
get:aidentif
get:aA contr
get:aindicat
get:aoccupyi
get:aA porti
get:afragmen
get:aA file 
get:aTransmission Cont
get:aControl
get:afragmen
get:aA compu
get:afrom th
get:aAn Inte
get:aby the 
get:aThe Int
get:aARPANET
get:aA sourc
get:ainternet datagram
get:aThe uni
get:ahigher 
get:ainternet fragment
get:aA porti
get:aheader.
get:aInterne
get:aThe Ini
get:anumber 
get:aThe Ini
get:aon a co
get:abased p
get:aThe Ini
get:aused by
get:aControl
get:adata.  
get:aon an A
get:a[Page 80]        
get:aSeptember 1981   
get:aThis is
get:adata re
get:asequenc
get:aof the 
get:aThe uni
get:aAn impl
get:aprocedu
get:aMaximum
get:athe int
get:aAn eigh
get:aAn Opti
get:amay be 
get:aprimari
get:atimesta
get:aoptions
get:aA packa
get:alogical
get:alogical
get:aThe por
get:aoutput 
get:aA progr
get:athe poi
get:aA contr
get:athis se
get:areceivi
get:areceive
get:aTransmission Cont
get:areceive
get:areceive
get:areceive next sequ
get:aThis is
get:areceive
get:aThis re
get:ais will
get:asegment
get:aRCV.NXT
get:aSegment
get:arange a
get:aA contr
get:athat th
get:ainterac
get:asequenc
get:asegment
get:ait.  In
get:arise to
get:aReal Ti:me Protocol
get:aof time
get:asegment
get:asegment
get:asegment
get:asegment
get:asegment
get:a[Page 82]        
get:aSeptember 1981   
get:asegment
get:aA logic
get:aunit of
get:asegment acknowled
get:aThe seq
get:aarrivin
get:aThe amo
get:aincludi
get:aThe num
get:aThis is
get:ause on 
get:ainitial
get:aeach oc
get:aThis re
get:a(receiv
get:awindow 
get:areceivi
get:abe emit
get:aSND.UNA
get:abetween
get:asend se
get:aleft se
get:asend ur
get:asegment
get:asegment
get:aTransmission Cont
get:asend wi
get:aAn addr
get:ais, the
get:aThe sou
get:aA contr
get:anumber,
get:awhere t
get:aTransmi
get:athe sta
get:aThe pre
get:aTransmi:ssion Control Protocol
get:areliabl
get:aType of
get:aAn Inte
get:afor thi
get:aA contr
get:aindicat
get:aurgent 
get:asequenc
get:apointer
get:aA contr
get:afield c
get:aindicat
get:aurgent 
get:a[Page 84]        
get:aSeptember 1981   
get:a[1]  Cerf, V., an
get:aIntercommuni
get:aVol. COM-22,
get:a[2]  Postel, J. (
get:aProtocol Spe
get:aInstitute, S
get:a[3]  Dalal, Y. an
get:aProtocols", 
get:aDecember 197
get:a[4]  Postel, J., 
get:aInstitute, S
get:bRFC
get:bDe
get:bI
get:bSeptember 1981   
get:bPREFACE .....
get:b1.  INTRODUCTION 
get:b1.1  Motivation
get:b1.2  Scope ....
get:b1.3  About This
get:b1.4  Interfaces
get:b1.5  Operation 
get:b2.  PHILOSOPHY ..
get:b2.1  Elements o
get:b2.2  Model of O
get:b2.3  The Host E
get:b2.4  Interfaces
get:b2.5  Relation t
get:b2.6  Reliable C
get:b2.7  Connection
get:b2.8  Data Commu
get:b2.9  Precedence
get:b2.10 Robustness
get:b3.  FUNCTIONAL SP
get:b3.1  Header For
get:b3.2  Terminolog
get:b3.3  Sequence N
get:b3.4  Establishi
get:b3.5  Closing a 
get:b3.6  Precedence
get:b3.7  Data Commu
get:b3.8  Interfaces
get:b3.9  Event Proc
get:bGLOSSARY ........
get:bREFERENCES ......
get:bTransmission Cont
get:b[Page ii]        
get:bSeptember 1981   
get:bThis document des
get:b(TCP).  There hav
get:bspecification on 
get:bdraws heavily fro
get:bboth in terms of 
get:bseveral details a
get:band redescribes t
get:bRFC
get:bReplaces: RFC 761
get:bIENs:  129, 124, 
get:b55, 44, 40, 27, 2
get:bThe Transmission 
get:breliable host-to-
get:bcommunication net
get:bThis document des
get:bTransmission Cont
get:binterface to prog
get:bComputer commun
get:brole in militar
get:bdocument focuse
get:bcommunication r
get:bcommunication u
get:bcongestion, but
get:bgovernment sect
get:bAs strategic an
get:bdeveloped and d
get:binterconnecting
get:bcommunication p
get:bapplications.  
get:bDeputy Undersec
get:bdeclared the Tr
get:bbe a basis for 
get:bstandardization
get:bTCP is a connec
get:bfit into a laye
get:bapplications.  
get:bcommunication b
get:bdistinct but in
get:bassumptions are
get:bprotocols below
get:bpotentially unr
get:bprotocols.  In 
get:bwide spectrum o
get:bconnections to 
get:bTransmission Cont
get:bTCP is based on
get:bTCP fits into a
get:bInternet Protoc
get:breceive variabl
get:bdatagram "envel
get:baddressing sour
get:binternet protoc
get:bthe TCP segment
get:bmultiple networ
get:balso carries in
get:band compartment
get:bcommunicated en
get:bMuch of this do
get:bwhich are co-re
get:bcomputer.  Some
get:bfront-end compu
get:bas well as netw
get:ban interface to
get:bimplementable e
get:bhost-to-front e
get:bThe TCP is inte
get:bcommunication s
get:bintended to be 
get:b1.3.  About this 
get:bThis document r
get:bany TCP impleme
get:bprotocols and i
get:b[Page 2]         
get:bSeptember 1981   
get:bsection offers 
get:boperation.  Sec
get:bdesign.  Sectio
get:brequired of TCP
get:buser calls, err
get:bThe TCP interfa
get:bthe other side 
get:bThe interface b
get:billustrated in 
get:bcalls much like
get:bapplication pro
get:bcalls to open a
get:bestablished con
get:basynchronously 
get:bconsiderable fr
get:binterfaces whic
get:benvironment, a 
get:binterface for a
get:bThe interface b
get:bunspecified exc
get:btwo levels can 
get:bTypically, one 
get:binterface.  TCP
get:binterconnected 
get:bthroughout this
get:bAs noted above,
get:bsecurable logic
get:bprocesses.  To 
get:bcommunication s:ystem requires facilities in the following areas
get:bBasic Data Tr
get:bPrecedence an
get:bThe basic opera
get:bthe following p
get:bTransmission Cont
get:bBasic Data Tran:sfer
get:bThe TCP is ab
get:bdirection bet
get:bsegments for 
get:bthe TCPs deci
get:bSometimes use
get:bsubmitted to 
get:bfunction is d
get:bactually tran
get:bpushed throug
get:bpromptly forw
get:bThe exact pus
get:bthe push func
get:bReliability
get:bThe TCP must 
get:bdelivered out
get:bis achieved b
get:btransmitted, 
get:breceiving TCP
get:binterval, the
get:bnumbers are u
get:bout of order 
get:badding a chec
get:breceiver, and
get:bAs long as th
get:bsystem does n
get:berrors will a
get:binternet comm
get:bFlow Control
get:bTCP provides 
get:bsent by the s
get:bevery ACK ind
get:bthe last segm
get:ballowed numbe
get:breceiving fur
get:b[Page 4]         
get:bSeptember 1981   
get:bMultiplexing
get:bTo allow for 
get:bcommunication
get:baddresses or 
get:band host addr
get:ba socket.  A 
get:bThat is, a so
get:bThe binding o
get:bHost.  Howeve
get:b(e.g., a "log
get:bmade known to
get:bthrough the k
get:baddresses of 
get:bConnections
get:bThe reliabili
get:bthat TCPs ini
get:beach data str
get:bsockets, sequ
get:bEach connecti
get:bidentifying i
get:bWhen two proc
get:bestablish a c
get:bside).  When 
get:bterminated or
get:bSince connect
get:bover the unre
get:bmechanism wit
get:berroneous ini
get:bPrecedence and :Security
get:bThe users of 
get:bcommunication
get:bthese feature
get:bTransmission Cont
get:b[Page 6]         
get:bSeptember 1981   
get:b2.1.  Elements of
get:bThe internetwor
get:bwhich are in tu
get:bthat the networ
get:blarge networks 
get:bpacket switchin
get:bconsume message
get:bnetworks, the g
get:bcommunication s
get:bconnections bet
get:bThe term packet
get:btransaction bet
get:bexchanged withi
get:bHosts are compu
get:bnetwork's point
get:bProcesses are v
get:baccordance with
get:bin execution). 
get:bviewed as commu
get:bThus, all commu
get:bSince a process
get:bstreams between
get:bthat each proce
get:bcommunicates wi
get:b2.2.  Model of Op
get:bProcesses trans
get:bdata as argumen
get:bsegments and ca
get:bthe destination
get:binto the receiv
get:bTCPs include co
get:bensure reliable
get:bThe model of in
get:bprotocol module
get:bto the local ne
get:binside internet
get:binternet module
get:bthrough the loc
get:bThe packet swit
get:bTransmission Cont
get:bother operation
get:bdestination int
get:bAt a gateway be
get:bfrom its local 
get:bthe internet da
get:bthen "wrapped" 
get:brouted to the n
get:bA gateway is pe
get:binternet datagr
get:bthrough the nex
get:binternet datagr
get:bfurther broken 
get:binternet datagr
get:binternet module
get:bA destination i
get:b(after reassemb
get:bdestination TCP
get:bThis simple mod
get:bimportant featu
get:bto the gateway 
get:bservice paramet
get:bIncluded in the
get:bdatagram.  Data
get:bhost and gatewa
get:bproperly segreg
get:b2.3.  The Host En
get:bThe TCP is assu
get:baccess the TCP 
get:bmay call on oth
get:bdata structures
get:bcontrolled by a
get:bnetwork device 
get:bdatagram protoc
get:bThe mechanisms 
get:bfront-end proce
get:bhost-to-front-e
get:bthe type of TCP
get:b[Page 8]         
get:bSeptember 1981   
get:bThe TCP/user in
get:bto OPEN or CLOS
get:bSTATUS about a 
get:bprograms on the
get:bfrom, and close
get:bThe TCP/interne
get:bdatagrams addre
get:bsystem.  These 
get:bservice, preced
get:b2.5.  Relation to
get:bThe following d
get:bhierarchy
get:b+------+ +
get:b|Telnet| |
get:b+------+ +
get:b|   
get:b+----
get:b| TCP
get:b+----
get:b| 
get:b+----
get:b|    
get:b+----
get:b+--
get:b|  
get:b+--
get:bIt is expected 
get:bprotocols effic
get:bprotocols like 
get:b2.6.  Reliable Co
get:bA stream of dat
get:border at the de
get:bTransmission Cont
get:bTransmission is
get:backnowledgments
get:bsequence number
get:bsegment is tran
get:bsequence number
get:bis the sequence
get:btransmissions i
get:bsegment contain
get:bstarts a timer;
get:bsegment is dele
get:breceived before
get:bAn acknowledgme
get:bdelivered to th
get:bthe responsibil
get:bTo govern the f
get:bemployed.  The 
get:bThis window spe
get:backnowledgment 
get:b2.7.  Connection 
get:bTo identify the
get:bprovides a port
get:bindependently b
get:bunique addresse
get:bidentifying the
get:bwill be unique 
get:bA connection is
get:blocal socket ma
get:bsockets.  A con
get:bthat is, it is 
get:bTCPs are free t
get:bHowever, severa
get:bThere must be w
get:bthe "appropriat
get:bmay "own" ports
get:bthe ports they 
get:bissue, but we e
get:buniquely alloca
get:bassociating the
get:bA connection is
get:bforeign socket 
get:b[Page 10]        
get:bSeptember 1981   
get:bconnection name
get:bsubsequent call
get:babout a connect
get:bis a data struc
get:bimplementation 
get:bpointer to the 
get:bwhether the con
get:bbe passively wa
get:bA passive OPEN 
get:bconnection requ
get:bOften the proce
get:brequest from an
get:bis used to deno
get:bare allowed onl
get:bA service proce
get:bprocesses would
get:bforeign socket.
get:brequested a con
get:blocal socket we
get:bWell-known sock
get:ba socket addres
get:b"Telnet-Server"
get:bsocket, and oth
get:bEntry, Text Gen
get:bbeing for test 
get:baccess to a "Lo
get:bat which a newl
get:bwell-known sock
get:bof sockets to s
get:bProcesses can i
get:bfrom other proc
get:bbeen establishe
get:bother at the sa
get:bis critical for
get:bcomponents act 
get:bThere are two p
get:bpassive OPENs a
get:blocal passive O
get:bcase, the match
get:bOPENs has left 
get:bforeign socket 
get:bOther possibili
get:bTransmission Cont
get:bIf there are se
get:bsame local sock
get:bwith the specif
get:bTCB exists, bef
get:bThe procedures 
get:bcontrol flag an
get:bexchange has be
get:bA connection is
get:bcontaining a SY
get:bcommand.  The m
get:bconnection has 
get:bwhen sequence n
get:bThe clearing of
get:bin this case ca
get:b2.8.  Data Commun
get:bThe data that f
get:boctets.  The se
get:bin that call (a
get:bthrough to the 
get:bA sending TCP i
get:bsend that data 
get:bfunction is sig
get:breceiving TCP s
get:bthe sending TCP
get:bThere is no nec
get:bboundaries.  Th
get:bsingle SEND cal
get:bThe purpose of 
get:bfrom the sendin
get:brecord service.
get:bThere is a coup
get:bof data that cr
get:bassociated with
get:bbuffer is retur
get:bnot filled.  If
get:bPUSH is seen, t
get:bTCP also provid
get:bat some point f
get:b[Page 12]        
get:bSeptember 1981   
get:bcurrently readi
get:bdefine what the
get:burgent data, bu
get:btake action to 
get:b2.9.  Precedence 
get:bThe TCP makes u
get:bsecurity option
get:bbasis to TCP us
get:ba multilevel se
get:buse only, and o
get:bcompartment.  C
get:busers may be li
get:bTCP modules whi
get:bproperly mark o
get:bprecedence.  Su
get:bhigher level pr
get:bthem to specify
get:bprecedence of c
get:b2.10.  Robustness
get:bTCP implementat:ions will follow a general principle of robustness
get:bconservative in
get:bTransmission Cont
get:b[Page 14]        
get:bSeptember 1981   
get:b3.1.  Header Form
get:bTCP segments ar
get:bheader carries 
get:bdestination hos
get:bheader, supplyi
get:bdivision allows
get:bTCP Header Form
get:b0            
get:b0 1 2 3 4 5 6
get:b+-+-+-+-+-+-+-
get:b|          Sou
get:b+-+-+-+-+-+-+-
get:b|             
get:b+-+-+-+-+-+-+-
get:b|             
get:b+-+-+-+-+-+-+-
get:b|  Data |     
get:b| Offset| Rese
get:b|       |     
get:b+-+-+-+-+-+-+-
get:b|           Ch
get:b+-+-+-+-+-+-+-
get:b|             
get:b+-+-+-+-+-+-+-
get:b|             
get:b+-+-+-+-+-+-+-
get:bNote th
get:bSource Port:  1
get:bThe source po
get:bDestination Por:t
get:bThe destinati
get:bTransmission Cont
get:bFunctional Specif
get:bSequence Number:
get:bThe sequence 
get:bwhen SYN is p
get:binitial seque
get:bAcknowledgment :Number
get:bIf the ACK co
get:bnext sequence
get:breceive.  Onc
get:bData Offset:  4
get:bThe number of
get:bthe data begi
get:bintegral numb
get:bReserved:  6 bi
get:bReserved for 
get:bControl Bits:  :6 bits (from left to right)
get:bURG:  Urgent 
get:bACK:  Acknowl
get:bPSH:  Push Fu
get:bRST:  Reset t
get:bSYN:  Synchro
get:bFIN:  No more
get:bWindow:  16 bit
get:bThe number of
get:backnowledgmen
get:bChecksum:  16 b
get:bThe checksum 
get:bcomplement su
get:bsegment conta
get:bchecksummed, 
get:bform a 16 bit
get:btransmitted a
get:bthe checksum 
get:bThe checksum 
get:b[Page 16]        
get:bSeptember 1981   
get:bprefixed to t
get:bAddress, the 
get:bThis gives th
get:binformation i
get:bacross the TC
get:bcalls by the 
get:bThe TCP Len
get:boctets (thi
get:bcomputed), 
get:bUrgent Pointer:
get:bThis field co
get:bpositive offs
get:burgent pointe
get:bthe urgent da
get:bthe URG contr
get:bOptions:  varia
get:bOptions may o
get:bmultiple of 8
get:bchecksum.  An
get:bcases for the: format of an option
get:bCase 1:  A 
get:bCase 2:  An
get:bth
get:bThe option-le
get:boption-length
get:bNote that the
get:bfield might i
get:bEnd-of-Option
get:bA TCP must im
get:bTransmission Cont
get:bFunctional Specif
get:bCurrently def:ined options include (kind indicated in octal)
get:bKind     Le
get:b----     --
get:b0         
get:b1         
get:b2         
get:bSpecific Opti
get:bEnd of Opti
get:b+--------
get:b|00000000
get:b+--------
get:bThis opti
get:bmight not
get:bthe Data 
get:bnot the e
get:bthe optio
get:bNo-Operatio
get:b+--------
get:b|00000001
get:b+--------
get:bThis opti
get:balign the
get:bThere is 
get:breceivers
get:bnot begin
get:bMaximum Seg
get:b+--------
get:b|00000010
get:b+--------
get:bKind=2  
get:b[Page 18]        
get:bSeptember 1981   
get:bMaximum S:egment Size Option Data
get:bIf this
get:breceive
get:bThis fi
get:b(i.e., 
get:boption 
get:bPadding:  varia
get:bThe TCP heade
get:band data begi
get:b3.2.  Terminology
get:bBefore we can d
get:bto introduce so
get:bconnection requ
get:bof these variab
get:bTransmission Co
get:bTCB are the loc
get:bprecedence of t
get:bbuffers, pointe
get:bIn addition sev
get:bsequence number
get:bSend Sequence
get:bSND.UNA - s
get:bSND.NXT - s
get:bSND.WND - s
get:bSND.UP  - s
get:bSND.WL1 - s
get:bSND.WL2 - s
get:bu
get:bISS     - i
get:bReceive Seque
get:bRCV.NXT - r
get:bRCV.WND - r
get:bRCV.UP  - r
get:bIRS     - i
get:bTransmission Cont
get:bFunctional Specif
get:bThe following d
get:bthe sequence sp
get:bSend Sequence S
get:b---
get:b1 - old s
get:b2 - seque
get:b3 - seque
get:b4 - futur
get:bThe send window
get:bReceive Sequenc
get:b1 - old s
get:b2 - seque
get:b3 - futur
get:bThe receive win
get:bThere are also 
get:btake their valu
get:b[Page 20]        
get:bSeptember 1981   
get:bCurrent Segme
get:bSEG.SEQ - s
get:bSEG.ACK - s
get:bSEG.LEN - s
get:bSEG.WND - s
get:bSEG.UP  - s
get:bSEG.PRC - s
get:bA connection pr
get:blifetime.  The :states are
get:bESTABLISHED, FI
get:bTIME-WAIT, and 
get:bbecause it repr
get:bno connection. : Briefly the meanings of the states are
get:bLISTEN - repr
get:bTCP and port.
get:bSYN-SENT - re
get:bafter having 
get:bSYN-RECEIVED 
get:brequest ackno
get:bconnection re
get:bESTABLISHED -
get:bdelivered to 
get:bof the connec
get:bFIN-WAIT-1 - 
get:bfrom the remo
get:btermination r
get:bFIN-WAIT-2 - 
get:bfrom the remo
get:bCLOSE-WAIT - 
get:bfrom the loca
get:bCLOSING - rep
get:backnowledgmen
get:bLAST-ACK - re
get:bconnection te
get:b(which includ
get:bTransmission Cont
get:bFunctional Specif
get:bTIME-WAIT - r
get:bthe remote TC
get:btermination r
get:bCLOSED - repr
get:bA TCP connectio
get:bevents.  The ev
get:bABORT, and STAT
get:bcontaining the 
get:bThe state diagr
get:bwith the causin
get:berror condition
get:bchanges.  In a 
get:bthe reaction of
get:bNOTE BENE:  thi
get:bthe total speci
get:b[Page 22]        
get:bSeptember 1981   
get:b+---------+     
get:b|         |<----
get:b|   SYN   |     
get:b|   RCVD  |<----
get:b|         |     
get:b|         |-----
get:b+---------+   rc
get:b|           --
get:b|             
get:b|             
get:b|  CLOSE      
get:b| -------     
get:b| snd FIN     
get:b|             
get:bV             
get:b+---------+     
get:b|  FIN    |<----
get:b| WAIT-1  |-----
get:b+---------+     
get:b| rcv ACK of F
get:b| ------------
get:bV        x    
get:b+---------+     
get:b|FINWAIT-2|     
get:b+---------+     
get:b|             
get:b|  rcv FIN    
get:b|  -------    
get:b\ snd ACK    
get:b------------
get:bTransmission Cont
get:bFunctional Specif
get:b3.3.  Sequence Nu
get:bA fundamental n
get:bover a TCP conn
get:bsequenced, each
get:bmechanism emplo
get:bnumber X indica
get:breceived.  This
get:bdetection in th
get:bwithin a segmen
get:bthe header is t
get:bnumbered consec
get:bIt is essential
get:bfinite, though 
get:bSince the space
get:bnumbers must be
get:bpreserves the r
get:b2**32 - 1 to 0 
get:barithmetic, so 
get:bcomparison of s
get:b(modulo 2**32).
get:bThe typical kin
get:bperform include:
get:b(a)  Determin
get:bnumber s
get:b(b)  Determin
get:bhave bee
get:bretransm
get:b(c)  Determin
get:bwhich ar
get:breceive 
get:b[Page 24]        
get:bSeptember 1981   
get:bIn response to 
get:bfollowing compa
get:bSND.UNA = old
get:bSND.NXT = nex
get:bSEG.ACK = ack
get:bnum
get:bSEG.SEQ = fir
get:bSEG.LEN = the
get:b(co
get:bSEG.SEQ+SEG.L
get:bA new acknowled
get:bthe inequality :below holds
get:bSND.UNA < SEG
get:bA segment on th
get:bof its sequence
get:backnowledgment 
get:bWhen data is re:ceived the following comparisons are needed
get:bRCV.NXT = nex
get:bis the le
get:bRCV.NXT+RCV.W
get:bsegment, 
get:bSEG.SEQ = fir
get:bSEG.SEQ+SEG.L
get:bA segment is ju
get:bRCV.NXT =< SE
get:bRCV.NXT =< SE
get:bTransmission Cont
get:bFunctional Specif
get:bThe first part 
get:bsegment falls i
get:bif the end of t
get:beither part of 
get:bActually, it is
get:bwindows and zer
get:bacceptability o:f an incoming segment
get:bSegment Recei
get:bLength  Windo
get:b------- -----
get:b0       0 
get:b0      >0 
get:b>0       0 
get:b>0      >0 
get:bNote that when 
get:bacceptable exce
get:bmaintain a zero
get:bACKs.  However,
get:bprocess the RST
get:bWe have taken a
get:bcontrol informa
get:bsome control fl
get:band acknowledge
get:bcontrol will be
get:bcarried in the 
get:bfor implicitly 
get:bare the only co
get:bare used only a
get:bpurposes, the S
get:boctet of the se
get:bto occur after 
get:boccurs.  The se
get:bspace occupying
get:bsequence number
get:b[Page 26]        
get:bSeptember 1981   
get:bInitial Sequenc
get:bThe protocol pl
get:bused over and o
get:bsockets.  New i
get:bincarnations of
get:b-- "how does th
get:bincarnations of
get:bconnection is b
get:bconnection brea
get:bTo avoid confus
get:bconnection from
get:bbe present in t
get:bassure this, ev
get:bsequence number
get:ban initial sequ
get:bnew 32 bit ISN.
get:bbit clock whose
get:bmicroseconds.  
get:bSince we assume
get:bthe Maximum Seg
get:bhours we can re
get:bFor each connec
get:bsequence number
get:bthe data sendin
get:blearned during 
get:bFor a connectio
get:bsynchronize on 
get:ban exchange of 
get:bcalled "SYN" (f
get:bshorthand, segm
get:bHence, the solu
get:binitial sequenc
get:bThe synchroniza
get:bsequence number
get:bfrom the other 
get:binitial sequenc
get:b1) A --> B  S
get:b2) A <-- B  A
get:b3) A <-- B  S
get:b4) A --> B  A
get:bTransmission Cont
get:bFunctional Specif
get:bBecause steps 2
get:bcalled the thre
get:bA three way han
get:btied to a globa
get:bmechanisms for 
get:bno way of knowi
get:bunless it remem
get:b(which is not a
get:bverify this SYN
get:bclock-driven sc
get:bKnowing When to
get:bTo be sure that
get:bsequence number
get:bthe network, th
get:b(MSL) before as
get:brecovering from
get:blost.  For this
get:bis an engineeri
get:bit is desirable
get:bsense, yet reta
get:bnot wait at all
get:bthan those rece
get:bThe TCP Quiet T
get:bThis specific
get:bretaining any
get:beach active (
get:bTCP segments 
get:bin the intern
get:bparagraphs be
get:bTCP implement
get:bat the risk o
get:bdata rejected
get:bTCPs consume 
get:bentered into 
get:bduplicate det
get:brelies on the
get:bthe extent th
get:bvalues before
get:bbeen delivere
get:bcopies of the
get:bsuch an assum
get:b[Page 28]        
get:bSeptember 1981   
get:bassigned the 
get:bat the receiv
get:bthat each seg
get:bas there are 
get:bUnder normal 
get:bto emit and t
get:bmistakenly us
get:bbeen acknowle
get:bdata is drain
get:bvery large to
get:bcause trouble
get:bto use up 2**
get:blifetime in t
get:bthis is deeme
get:brates escalat
get:bcycle time is
get:bwithin reason
get:bThe basic dup
get:bdefeated, how
get:bsequence numb
get:bthe TCP were 
get:bupon crashing
get:bconnection (p
get:bpackets with 
get:bpackets still
get:bincarnation o
get:babout the seq
get:bspecification
get:bbefore emitti
get:bsegments from
get:bEven hosts wh
get:binitial seque
get:b(i.e., even i
get:bnumber for ea
get:bSuppose, for 
get:bsequence numb
get:band that even
get:btakes on a va
get:bsegment sent 
get:bat this insta
get:bincarnation o
get:bS1 = ISN(t) -
get:bconnection!  
get:bTransmission Cont
get:bFunctional Specif
get:bduplicates in
get:bof S1 may arr
get:bthe new incar
get:bThe problem i
get:bcrashed nor d
get:bthe system fr
get:bOne way to de
get:bsegments for 
get:btime" specifi
get:bwilling to ri
get:bdestination m
get:bImplementors 
get:bconnection by
get:binformally im
get:bObviously, ev
get:bnecessary aft
get:bTo summarize:
get:bnumbers in th
get:b"busy" or "in
get:bblock of spac
get:bsegment, if a
get:bsequence numb
get:bthe previous 
get:bnumber overla
get:b3.4.  Establishin
get:bThe "three-way 
get:bconnection.  Th
get:bresponded to by
get:bsimultaneously 
get:boccurs, each TC
get:backnowledgment 
get:ban old duplicat
get:brecipient, that
get:bProper use of "
get:bSeveral example
get:bexamples do not
get:bsegments, this 
get:bdoesn't deliver
get:bvalid (i.e., th
get:bconnection reac
get:breduces the pos
get:b[Page 30]        
get:bSeptember 1981   
get:bimplementation 
get:binformation for
get:bThe simplest th
get:bfigures should 
get:bnumbered for re
get:bdeparture of a 
get:bsegment at B fr
get:bEllipsis (...) 
get:b(delayed).  An 
get:bComments appear
get:bthe departure o
get:bthe center of e
get:bform, with sequ
get:bfields such as 
get:bin the interest
get:bTCP A      
get:b1.  CLOSED     
get:b2.  SYN-SENT   
get:b3.  ESTABLISHED
get:b4.  ESTABLISHED
get:b5.  ESTABLISHED
get:bBasic 3
get:bIn line 2 of fi
get:bindicating that
get:bnumber 100.  In
get:breceived from T
get:bB is now expect
get:boccupied sequen
get:bAt line 4, TCP 
get:bTCP B's SYN; an
get:bsequence number
get:bbecause the ACK
get:bwould wind up A
get:bTransmission Cont
get:bFunctional Specif
get:bSimultaneous in
get:bfigure 8.  Each
get:bTCP A      
get:b1.  CLOSED     
get:b2.  SYN-SENT   
get:b3.  SYN-RECEIVE
get:b4.             
get:b5.  SYN-RECEIVE
get:b6.  ESTABLISHED
get:b7.             
get:bS
get:bThe principle r
get:bduplicate conne
get:bthis, a special
get:breceiving TCP i
get:bSYN-RECEIVED), 
get:bIf the TCP is i
get:bFIN-WAIT-1, FIN
get:baborts the conn
get:bcase under "hal
get:b[Page 32]        
get:bSeptember 1981   
get:bTCP A      
get:b1.  CLOSED     
get:b2.  SYN-SENT   
get:b3.  (duplicate)
get:b4.  SYN-SENT   
get:b5.  SYN-SENT   
get:b6.             
get:b7.  SYN-SENT   
get:b8.  ESTABLISHED
get:bAs a simple exa
get:bfigure 9.  At l
get:bcannot tell tha
get:b(line 4).  TCP 
get:bRST (reset) wit
get:bbelievable.  TC
get:bWhen the origin
get:bsynchronization
get:bbefore the RST,
get:bsent in both di
get:bHalf-Open Conne
get:bAn established 
get:bTCPs has closed
get:bknowledge of th
get:bbecome desynchr
get:bmemory.  Such c
get:battempt is made
get:bconnections are
get:bmildly involved
get:bIf at site A th
get:bTransmission Cont
get:bFunctional Specif
get:buser at site B 
get:breceiving a res
get:bsite B TCP that
get:bAssume that two
get:banother when a 
get:bDepending on th
get:bthat some error
get:bA is likely to 
get:bpoint.  As a re
get:bor try to SEND 
get:bcase, it receiv
get:blocal (A's) TCP
get:bwill send a seg
get:bexample shown i
get:bre-open the con
get:bTCP A      
get:b1.  (CRASH)    
get:b2.  CLOSED     
get:b3.  SYN-SENT --
get:b4.  (!!)     <-
get:b5.  SYN-SENT --
get:b6.  SYN-SENT   
get:b7.  SYN-SENT --
get:bWhen the SYN ar
get:band the incomin
get:backnowledgment 
get:b100).  TCP A se
get:bsent and, being
get:bdetected a half
get:b[Page 34]        
get:bSeptember 1981   
get:bcontinue to try
get:breduced to the 
get:bAn interesting 
get:btries to send d
get:bThis is illustr
get:bTCP A from TCP 
get:bexists, so TCP 
get:bprocesses it an
get:bTCP A    
get:b1.  (CRASH)    
get:b2.  (??)    <--
get:b3.          -->
get:bActive
get:bIn figure 12, w
get:bwaiting for SYN
get:binto action.  A
get:bgenerate a RST 
get:bthe reset and r
get:bTCP A      
get:b1.  LISTEN     
get:b2.       ... <S
get:b3.  (??) <-- <S
get:b4.       --> <S
get:b5.  LISTEN     
get:bOld Duplic
get:bTransmission Cont
get:bFunctional Specif
get:bA variety of ot
get:bby the followin
get:bReset Generatio
get:bAs a general ru
get:bwhich apparentl
get:bmust not be sen
get:bThere are three: groups of states
get:b1.  If the co
get:bin response t
get:bparticular, S
get:bby this means
get:bIf the incomi
get:bsequence numb
get:breset has seq
get:bof the sequen
get:bThe connectio
get:b2.  If the co
get:bSYN-SENT, SYN
get:bsomething not
get:bif an incomin
get:bdoes not exac
get:bconnection, a
get:bIf our SYN ha
get:bincoming segm
get:beither raise 
get:bthe system) o
get:bincoming segm
get:bcontinue as i
get:bcannot raise 
get:bdetected in t
get:bterminated th
get:bincoming segm
get:bmatch the loc
get:bmust be sent.
get:bIf the incomi
get:bsequence numb
get:breset has seq
get:bof the sequen
get:bThe connectio
get:b[Page 36]        
get:bSeptember 1981   
get:b3.  If the co
get:bFIN-WAIT-1, F
get:bany unaccepta
get:bunacceptible 
get:backnowledgmen
get:band an acknow
get:bto be receive
get:bIf an incomin
get:bprecedence wh
get:band precedenc
get:bconnection go
get:bnumber from t
get:bReset Processin
get:bIn all states e
get:bby checking the
get:bis in the windo
get:bto an initial S
get:backnowledges th
get:bThe receiver of
get:breceiver was in
get:bin SYN-RECEIVED
get:bthen the receiv
get:baborts the conn
get:bwas in any othe
get:band goes to the
get:b3.5.  Closing a C
get:bCLOSE is an ope
get:bnotion of closi
get:binterpretation,
get:bthe receiving s
get:bin a simplex fa
get:buntil he is tol
get:bcould initiate 
get:bRECEIVE until s
get:bhas CLOSED.  We
get:bRECEIVEs are ou
get:bcan terminate h
get:bbuffers SENT be
get:bdata in return 
get:bsuccessfully to
get:bTCP.  Users mus
get:bthe TCP says no
get:bTransmission Cont
get:bFunctional Specif
get:bThere are essen:tially three cases
get:b1) The user i
get:b2) The remote
get:b3) Both users
get:bCase 1:  Local 
get:bIn this case,
get:boutgoing segm
get:baccepted by t
get:bare allowed i
get:bwill be retra
get:bboth acknowle
get:bcan ACK this 
get:bsend its own 
get:bCase 2:  TCP re
get:bIf an unsolic
get:bcan ACK it an
get:buser will res
get:bthe other TCP
get:buntil its own
get:bconnection.  
get:bthe connectio
get:bCase 3:  both u
get:bA simultaneou
get:bFIN segments 
get:bhave been pro
get:bhas received.
get:b[Page 38]        
get:bSeptember 1981   
get:bTCP A      
get:b1.  ESTABLISHED
get:bFIN-WAIT-1 
get:b3.  FIN-WAIT-2 
get:b4.             
get:bTIME-WAIT  
get:b5.  TIME-WAIT  
get:bCLOSED     
get:bTCP A      
get:b1.  ESTABLISHED
get:b2.  (Close)    
get:bFIN-WAIT-1 
get:b3.  CLOSING    
get:b4.  TIME-WAIT  
get:b(2 MSL)    
get:bCLOSED     
get:bTransmission Cont
get:bFunctional Specif
get:b3.6.  Precedence 
get:bThe intent is t
get:bwith exactly th
get:bhigher of the p
get:bThe precedence 
get:bdefined in the 
get:bspecification t
get:bthe security pa
get:buser group, and
get:bA connection at
get:blower precedenc
get:ba connection du
get:backnowledgment 
get:bNote that TCP m
get:bprecedence will
get:bsegments and po
get:bThe security pa
get:b(the values wou
get:bnon-secure envi
get:bparameters, tho
get:b3.7.  Data Commun
get:bOnce the connec
get:bexchange of seg
get:b(checksum test 
get:bretransmission 
get:bDuplicate segme
get:bAs discussed in
get:bcertain tests o
get:bsegments to ver
get:bThe sender of d
get:bthe variable SN
get:bsequence number
get:bkeeps track of 
get:bvariable SND.UN
get:bsent has been a
get:bWhen the sender
get:bSND.NXT.  When 
get:bsends an acknow
get:b[Page 40]        
get:bSeptember 1981   
get:backnowledgment 
get:bthese variables
get:bThe amount by w
get:bdata in the seg
get:bsegments must c
get:bThe CLOSE user 
get:bflag in an inco
get:bRetransmission 
get:bBecause of the 
get:binternetwork sy
get:bretransmission 
get:bfor determining
get:bAn Example Re
get:bMeasure the
get:bparticular 
get:bcovers that
get:bsegments re
get:bTime (RTT).:  Next compute a Smoothed Round Trip Time (SRTT) as
get:bSRTT = ( 
get:band based o:n this, compute the retransmission timeout (RTO) as
get:bRTO = min
get:bwhere UBOUN
get:bLBOUND is a
get:ba smoothing
get:bfactor (e.g
get:bThe Communicati
get:bThe objective o
get:bto stimulate th
get:bpermit the rece
get:bthe currently k
get:bThis mechanism 
get:bthe end of urge
get:bthe receive seq
get:bmust tell the u
get:bnumber catches 
get:bTransmission Cont
get:bFunctional Specif
get:binto "normal mo
get:bis in "urgent m
get:bThe method empl
get:btransmitted.  T
get:bmeaningful and 
get:bthe urgent poin
get:bno urgent data 
get:bTo send an urge
get:boctet.  If the 
get:bthe urgent info
get:bManaging the Wi
get:bThe window sent
get:bnumbers the sen
get:bprepared to acc
get:bthe currently a
get:bIndicating a la
get:barrives than ca
get:bin excessive re
get:bnetwork and the
get:btransmission of
get:bbetween each ne
get:bThe mechanisms 
get:bsubsequently ad
get:bthat much data.
get:bdiscouraged.  T
get:bshrink the wind
get:bon the part of 
get:bThe sending TCP
get:bleast one octet
get:bsending TCP mus
get:bthe window is z
get:binterval when t
get:bguarantee that 
get:bwindow will be 
get:bWhen the receiv
get:bstill send an a
get:band current win
get:bThe sending TCP
get:b[Page 42]        
get:bSeptember 1981   
get:bwhich fit the c
get:bretransmission 
get:bIn a connection
get:bbe carried in a
get:bnumber so there
get:border.  This is
get:binformation to 
get:bthe data receiv
get:bthe window info
get:backnowledgment 
get:bequal or greate
get:bThe window mana
get:bcommunication p
get:bWindow Manage
get:bAllocating 
get:bmany small 
get:bfewer large
get:bOne suggest
get:bdefer updat
get:bleast X per
get:bconnection 
get:bAnother sug
get:bsegments by
get:bsending dat
get:bdata must b
get:bNote that t
get:bretransmiss
get:backnowledgm
get:bwindow info
get:bnew window 
get:bThe segment
get:bof transmit
get:bsegment con
get:bis accepted
get:bIf the send
get:bwindow is n
get:balternating
get:bpauses in t
get:bTransmission Cont
get:bFunctional Specif
get:bresult in b
get:bbig pair. A
get:bmostly smal
get:bThe suggest
get:bactively at
get:bwindows, si
get:bto many sma
get:bThere are of co:urse two interfaces of concern
get:band the TCP/low
get:bof the user/TCP
get:bprotocol module
get:bin detail by th
get:bcase that the l
get:bthat TCPs might
get:bUser/TCP Interf
get:bThe following
get:bat best, fict
get:bfacilities.  
get:bimplementatio
get:bTCPs must pro
get:bthat all TCP 
get:bhierarchy.  T
get:brequired of a
get:bTCP User Comm
get:bThe followi
get:binterface. 
get:bfunction ca
get:bmeant to ru
get:bThe user co
get:bTCP must pe
get:bIndividual 
get:bmay provide
get:bsingle call
get:bautomatical
get:bissued by t
get:b[Page 44]        
get:bSeptember 1981   
get:bIn providin
get:bnot only ac
get:bprocesses i:t serves.  The latter consists of
get:b(a) gener
get:bremote cl
get:b(b) repli
get:bvarious t
get:bFormat:  
get:b[, timeou
get:b-> local 
get:bWe assume
get:bprocesses
get:bto use th
get:bimplement
get:bfor the s
get:blower lev
get:bresult of
get:bable to m
get:bprocess c
get:bIf the ac
get:bcall to L
get:bhave eith
get:bparticula
get:bfor any c
get:bby the su
get:bA transmi
get:bfilled in
get:bOn an act
get:bsynchroni
get:bThe timeo
get:bfor all d
get:bdelivered
get:bwill abor
get:bThe TCP o
get:bthe users
get:bTransmission Cont
get:bFunctional Specif
get:bprecedenc
get:bor securi
get:bthe defau
get:bTCP will 
get:bsecurity/
get:bthe prece
get:brequested
get:bThe prece
get:brequested
get:brequest, 
get:bconnectio
get:bthis prec
get:ballowed t
get:bor that a
get:bA local c
get:bThe local
get:bfor the c
get:bFormat:  
get:bcount, PU
get:bThis call
get:bto be sen
get:bnot been 
get:bimplement
get:bautomatic
get:bauthorize
get:bIf the PU
get:bto the re
get:bsegment c
get:bthe data 
get:btransmiss
get:bIf the UR
get:bwill have
get:bthe urgen
get:bpointer i
get:bbeen cons
get:bis to sti
get:bindicate 
get:b[Page 46]        
get:bSeptember 1981   
get:bdata has 
get:bTCP signa
get:bof times 
get:burgent da
get:bIf no for
get:bconnectio
get:bhas becom
get:blocal soc
get:bforeign s
get:bforeign s
get:bknowing t
get:bHowever, 
get:bbecomes s
get:bSTATUS ca
get:bimplement
get:bsocket is
get:bIf a time
get:bconnectio
get:bIn the si
get:bthe sendi
get:bor the ti
get:bis both s
get:bconnectio
get:boffers po
get:bsophistic
get:bthe proce
get:bfurthermo
get:bMultiple 
get:bthe TCP w
get:bWe have i
get:bwhich a S
get:bpseudo-in
get:breturn a 
get:bimmediate
get:bbeen ackn
get:bassume ev
get:bclose any
get:bkind (syn
get:bsignals, 
get:bwith spec
get:bIn order 
get:bindicatio
get:bTransmission Cont
get:bFunctional Specif
get:bbuffer ad
get:bthe SEND 
get:bindicatin
get:bcalling p
get:bFormat:  
get:bcount) ->
get:bThis comm
get:bspecified
get:bcalling p
get:berror is 
get:bIn the si
get:bcalling p
get:berror occ
get:bA more so
get:bRECEIVEs 
get:bsegments 
get:bthe cost 
get:bnotify th
get:bIf enough
get:bthe PUSH 
get:bThe buffe
get:ba PUSH is
get:breturned 
get:bIf there 
get:bas it arr
get:bshould th
get:badditiona
get:bcall to R
get:bmay now l
get:burgent po
get:bin the sa
get:bboundary 
get:bTo distin
get:bcare of t
get:breturn co
get:bcount ind
get:bAlternati
get:b[Page 48]        
get:bSeptember 1981   
get:ballocate 
get:bwith the 
get:bFormat:  
get:bThis comm
get:bthe conne
get:bauthorize
get:bClosing c
get:bthe sense
get:bretransmi
get:bserviced.
get:bcalls, fo
get:bto the de
get:bcontinue 
get:bmay be tr
get:bmeans "I 
get:breceive a
get:bnot well 
get:bof all it
get:binto ABOR
get:bThe user 
get:binitiativ
get:b(e.g., re
get:bdestinati
get:bBecause c
get:bforeign T
get:bshort tim
get:breplies t
get:bClose als
get:bFormat:  
get:bThis is a
get:bexcluded 
get:btypically
get:bThis comm
get:binformati:on
get:blocal s
get:bTransmission Cont
get:bFunctional Specif
get:bforeign
get:blocal c
get:breceive
get:bsend wi
get:bconnect
get:bnumber 
get:bnumber 
get:burgent 
get:bprecede
get:bsecurit
get:band tra
get:bDepending
get:bimplement
get:bavailable
get:bauthorize
get:bprevents 
get:bconnectio
get:bFormat:  
get:bThis comm
get:baborted, 
get:bbe sent t
get:bDepending
get:bindicatio
get:breceive a
get:bTCP-to-User M
get:bIt is assum
get:bmeans for t
get:bthe TCP doe
get:bto the user
get:ban error me
get:brelating to
get:bother user 
get:bThe followi:ng information is provided
get:bLocal Con
get:bResponse 
get:bBuffer Ad
get:bByte coun
get:bPush flag
get:bUrgent fl
get:b[Page 50]        
get:bSeptember 1981   
get:bTCP/Lower-Level
get:bThe TCP calls
get:breceive infor
get:binternetwork 
get:bProtocol (IP)
get:bIf the lower 
get:bof service an
get:bfor these par:ameters
get:bType of Ser:vice = Precedence: routine, Delay: normal, Throughput
get:bnormal, Rel:iability
get:bTime to Liv
get:bNote that
get:bHere we e
get:bbe delive
get:bIf the lower 
get:bfeature) and 
get:broute informa
get:bso that the s
get:bchecksum be t
get:balso importan
get:bAny lower lev
get:bdestination a
get:bthe "TCP leng
get:bof IP and to 
get:bTransmission Cont
get:bFunctional Specif
get:b3.9.  Event Proce
get:bThe processing 
get:bimplementation.
get:bprocessing sequ
get:bsection only in
get:bThe activity of
get:bThe events that: occur can be cast into three categories
get:barriving segmen
get:bprocessing the 
get:bcases the proce
get:bEvents that o:ccur
get:bArriving Se
get:bSEGMENT A
get:bUSER TIME
get:bRETRANSMI
get:bTIME-WAIT
get:bThe model of th
get:bimmediate retur
get:bpseudo interrup
get:bmeans cause a d
get:bError responses
get:bcommands refere:ncing connections that do not exist receive "error
get:bconnection not 
get:bPlease note in 
get:backnowledgment 
get:bof the sequence
get:bequal to (modul
get:b[Page 52]        
get:bSeptember 1981   
get:bA natural way t
get:bimagine that th
get:bthat their cont
get:bin the sequence
get:band processed i
get:bWhen a segment 
get:bthe segment to 
get:bto be consisten
get:bNote that if no
get:bTransmission Cont
get:bFunctional Specif
get:bCLOSED STATE 
get:bCreate a ne
get:bstate infor
get:bsocket, pre
get:binformation
get:bunspecified
get:bparameters 
get:bprecedence 
get:b"error:  pr:ecedence not allowed" or "error
get:bnot allowed
get:bactive and :the foreign socket is unspecified, return "error
get:bforeign soc
get:bspecified, 
get:b(ISS) is se
get:bis sent.  S
get:bstate, and 
get:bIf the call
get:breturn "err:or
get:bno room to :create a new connection, return "error
get:bresources".
get:bIf active a
get:bconnection 
get:bsegment, se
get:bstate.  Dat
get:bqueued for 
get:burgent bit 
get:bsegments se
get:bqueue the r:equest, respond with "error
get:bIf Foreign :socket was not specified, then return "error
get:bsocket unsp
get:b[Page 54]        
get:bSeptember 1981   
get:bSYN-SENT STAT
get:bSYN-RECEIVED 
get:bESTABLISHED S
get:bFIN-WAIT-1 ST
get:bFIN-WAIT-2 ST
get:bCLOSE-WAIT ST
get:bCLOSING STATE
get:bLAST-ACK STAT
get:bTIME-WAIT STA
get:bReturn "err:or
get:bTransmission Cont
get:bFunctional Specif
get:bCLOSED STATE 
get:bIf the user
get:b"error:  co
get:bOtherwise, :return "error
get:bIf the fore
get:bfrom passiv
get:bSND.UNA to 
get:bassociated 
get:btransmissio
get:brequested i
get:bas a result
get:brequest, re:spond with "error
get:bForeign soc:ket was not specified, then return "error
get:bsocket unsp
get:bSYN-SENT STAT
get:bSYN-RECEIVED 
get:bQueue the d
get:bIf no space: to queue, respond with "error
get:bresources".
get:bESTABLISHED S
get:bCLOSE-WAIT ST
get:bSegmentize 
get:backnowledgm
get:binsufficien:t space to remember this buffer, simply return "error
get:binsufficien
get:bIf the urge
get:burgent poin
get:b[Page 56]        
get:bSeptember 1981   
get:bFIN-WAIT-1 ST
get:bFIN-WAIT-2 ST
get:bCLOSING STATE
get:bLAST-ACK STAT
get:bTIME-WAIT STA
get:bReturn "err:or
get:bTransmission Cont
get:bFunctional Specif
get:bCLOSED STATE 
get:bIf the user
get:b"error:  co
get:bOtherwise r:eturn "error
get:bSYN-SENT STAT
get:bSYN-RECEIVED 
get:bQueue for p
get:bis no room :to queue this request, respond with "error
get:binsufficien
get:bESTABLISHED S
get:bFIN-WAIT-1 ST
get:bFIN-WAIT-2 ST
get:bIf insuffic
get:brequest, qu
get:bremember th:e RECEIVE, respond with "error
get:bresources".
get:bReassemble 
get:bto user.  M
get:bIf RCV.UP i
get:buser notify
get:bWhen the TC
get:bthat fact m
get:backnowledgm
get:bdescribed b
get:b[Page 58]        
get:bSeptember 1981   
get:bCLOSE-WAIT ST
get:bSince the r
get:bsatisfied b
get:buser.  If n
get:b"error:  co
get:btext can be
get:bCLOSING STATE
get:bLAST-ACK STAT
get:bTIME-WAIT STA
get:bReturn "err:or
get:bTransmission Cont
get:bFunctional Specif
get:bCLOSED STATE 
get:bIf the user
get:b"error:  co
get:bOtherwise, :return "error
get:bAny outstan:ding RECEIVEs are returned with "error
get:bresponses. 
get:bSYN-SENT STAT
get:bDelete the :TCB and return "error
get:bqueued SEND
get:bSYN-RECEIVED 
get:bIf no SENDs
get:bthen form a
get:botherwise q
get:bESTABLISHED S
get:bQueue this 
get:bform a FIN 
get:bFIN-WAIT-1 ST
get:bFIN-WAIT-2 ST
get:bStrictly sp:eaking, this is an error and should receive a "error
get:bconnection 
get:bacceptable,
get:bFIN may be 
get:b[Page 60]        
get:bSeptember 1981   
get:bCLOSE-WAIT ST
get:bQueue this 
get:bsegmentized
get:bCLOSING STATE
get:bLAST-ACK STAT
get:bTIME-WAIT STA
get:bRespond wit:h "error
get:bTransmission Cont
get:bFunctional Specif
get:bCLOSED STATE 
get:bIf the user
get:b"error:  co
get:bOtherwise r:eturn "error
get:bAny outstan:ding RECEIVEs should be returned with "error
get:bconnection 
get:bSYN-SENT STAT
get:bAll queued 
get:bnotificatio
get:bSYN-RECEIVED 
get:bESTABLISHED S
get:bFIN-WAIT-1 ST
get:bFIN-WAIT-2 ST
get:bCLOSE-WAIT ST
get:bSend a rese:t segment
get:b<SEQ=SND.
get:bAll queued 
get:bnotificatio
get:bRST formed 
get:bTCB, enter 
get:bCLOSING STATE
get:bLAST-ACK STAT
get:bTIME-WAIT STA
get:bRespond wit
get:b[Page 62]        
get:bSeptember 1981   
get:bCLOSED STATE 
get:bIf the user
get:b"error:  co
get:bOtherwise r:eturn "error
get:bReturn "sta
get:bSYN-SENT STAT
get:bReturn "sta
get:bSYN-RECEIVED 
get:bReturn "sta
get:bESTABLISHED S
get:bReturn "sta
get:bFIN-WAIT-1 ST
get:bReturn "sta
get:bFIN-WAIT-2 ST
get:bReturn "sta
get:bCLOSE-WAIT ST
get:bReturn "sta
get:bCLOSING STATE
get:bReturn "sta
get:bLAST-ACK STAT
get:bReturn "sta
get:bTransmission Cont
get:bFunctional Specif
get:bTIME-WAIT STA
get:bReturn "sta
get:b[Page 64]        
get:bSeptember 1981   
get:bSEGMENT ARRIVES
get:bIf the state 
get:ball data in
get:bsegment con
get:bcontaining 
get:backnowledgm
get:breset seque
get:bIf the ACK 
get:b<SEQ=0><A
get:bIf the ACK 
get:b<SEQ=SEG.
get:bIf the state 
get:bfirst check
get:bAn incomi
get:bsecond chec
get:bAny ackno
get:bthe LISTE
get:bfor any a
get:bformatted: as follows
get:b<SEQ=SE
get:bthird check
get:bIf the SY
get:bsecurity/
get:bmatch the
get:b<SEQ=SE
get:bTransmission Cont
get:bFunctional Specif
get:bIf the SE
get:bthe user 
get:bsend a re
get:b<SEQ=SE
get:bIf the SE
get:bSet RCV.N
get:bcontrol o
get:bshould be: selected and a SYN segment sent of the form
get:b<SEQ=IS
get:bSND.NXT i
get:bstate sho
get:bincoming 
get:bin the SY
get:bnot be re
get:bthe forei
get:bunspecifi
get:bfourth othe
get:bAny other
get:bmust have
get:bprocessin
get:bit could 
get:bincarnati
get:bbut if yo
get:bIf the state 
get:bfirst check
get:bIf the AC
get:bIf SEG.
get:bthe RST
get:b<SEQ=
get:band dis
get:bIf SND.
get:bsecond chec
get:b[Page 66]        
get:bSeptember 1981   
get:bIf the RS
get:bIf the :ACK was acceptable then signal the user "error
get:bconnect
get:bdelete 
get:band ret
get:bthird check
get:bIf the se
get:bmatch the
get:bIf ther
get:b<SEQ=
get:bOtherwi
get:b<SEQ=
get:bIf there 
get:bThe pre
get:bTCB, if
get:b<SEQ=
get:bIf there 
get:bIf the 
get:bin the 
get:bthe pre
get:ballowed
get:b<SEQ=
get:bIf the 
get:bin the 
get:bIf a rese
get:bfourth chec
get:bThis step
get:bno ACK, a
get:bIf the SY
get:bTransmission Cont
get:bFunctional Specif
get:bare accep
get:bSEG.SEQ. 
get:bis an ACK
get:bare there
get:bIf SND.UN
get:bstate to 
get:b<SEQ=SN
get:band send 
get:btransmiss
get:btext in t
get:bbelow whe
get:bOtherwise
get:b<SEQ=IS
get:band send 
get:bsegment, 
get:bhas been 
get:bfifth, if n
get:bsegment and
get:b[Page 68]        
get:bSeptember 1981   
get:bfirst check s
get:bSYN-RECEIVE
get:bESTABLISHED
get:bFIN-WAIT-1 
get:bFIN-WAIT-2 
get:bCLOSE-WAIT 
get:bCLOSING STA
get:bLAST-ACK ST
get:bTIME-WAIT S
get:bSegments 
get:bare used 
get:bdone in S
get:bboundary 
get:bprocessed
get:bThere are
get:bsegment
get:bSegment R
get:bLength  W
get:b------- -
get:b0     
get:b0     
get:b>0     
get:b>0     
get:bIf the RC
get:bspecial a
get:bIf an inc
get:bshould be
get:bthe segme:nt and return)
get:b<SEQ=SN
get:bAfter sen
get:band retur
get:bTransmission Cont
get:bFunctional Specif
get:bIn the fo
get:bsegment t
get:bOne could
get:btrimming 
get:bSYN and F
get:bbegins at
get:bnumbers m
get:bsecond check 
get:bSYN-RECEIVE
get:bIf the RS
get:bIf this
get:bcame fr
get:bLISTEN 
get:bthis co
get:bfrom SY
get:bthe use
get:bon the 
get:bactive 
get:band ret
get:bESTABLISHED
get:bIf the RS
get:bshould re
get:bflushed. 
get:b"connecti
get:bTCB, and 
get:bCLOSING STA
get:bLAST-ACK ST
get:bIf the RS
get:bTCB, and 
get:b[Page 70]        
get:bSeptember 1981   
get:bthird check s
get:bSYN-RECEIVE
get:bIf the se
get:bexactly m
get:bthen send
get:bESTABLISHED
get:bIf the se
get:bexactly m
get:bthen send
get:breceive "
get:bflushed. 
get:b"connecti
get:bTCB, and 
get:bNote this c
get:ba segment f
get:bdifferent s
get:bcurrent con
get:bfourth, check
get:bSYN-RECEIVE
get:bESTABLISHED
get:bFIN-WAIT ST
get:bFIN-WAIT ST
get:bCLOSE-WAIT 
get:bCLOSING STA
get:bLAST-ACK ST
get:bTIME-WAIT S
get:bIf the SY
get:boutstandi
get:ball segme
get:breceive a
get:bthe CLOSE
get:bIf the SY
get:band an ac
get:bnumber ch
get:bTransmission Cont
get:bFunctional Specif
get:bfifth check t
get:bif the ACK 
get:bif the ACK 
get:bSYN-RECEI
get:bIf SND.
get:band con
get:bIf th
get:breset
get:b<SE
get:band s
get:bESTABLISH
get:bIf SND.
get:bAny seg
get:bentirel
get:bpositiv
get:bfully a
get:b"ok" re
get:b(SEG.AC
get:bsomethi
get:bdrop th
get:bIf SND.
get:bupdated
get:bSND.WL2
get:bSND.WL1
get:bNote th
get:brecords
get:bSND.WND
get:bthe las
get:bprevent
get:b[Page 72]        
get:bSeptember 1981   
get:bFIN-WAIT-
get:bIn addi
get:bour FIN
get:bprocess
get:bFIN-WAIT-
get:bIn addi
get:bthe ret
get:backnowl
get:bCLOSE-WAI
get:bDo the 
get:bCLOSING S
get:bIn addi
get:bthe ACK
get:botherwi
get:bLAST-ACK 
get:bThe onl
get:backnowl
get:bdelete 
get:bTIME-WAIT
get:bThe onl
get:bretrans
get:bthe 2 M
get:bsixth, check 
get:bESTABLISHED
get:bFIN-WAIT-1 
get:bFIN-WAIT-2 
get:bIf the UR
get:bthe user 
get:bpointer (
get:buser has 
get:bmode") fo
get:bsignal th
get:bTransmission Cont
get:bFunctional Specif
get:bCLOSE-WAIT 
get:bCLOSING STA
get:bLAST-ACK ST
get:bThis shou
get:bremote si
get:bseventh, proc
get:bESTABLISHED
get:bFIN-WAIT-1 
get:bFIN-WAIT-2 
get:bOnce in t
get:btext to u
get:binto buff
get:bempty.  I
get:bthe user 
get:bhas been 
get:bWhen the 
get:buser it m
get:bOnce the 
get:bRCV.NXT o
get:bapporopri
get:bRCV.NXT a
get:bPlease no
get:bSend an a:cknowledgment of the form
get:b<SEQ=SN
get:bThis ackn
get:btransmitt
get:b[Page 74]        
get:bSeptember 1981   
get:bCLOSE-WAIT 
get:bCLOSING STA
get:bLAST-ACK ST
get:bTIME-WAIT S
get:bThis shou
get:bremote si
get:beighth, check
get:bDo not proc
get:bsince the S
get:bIf the FIN 
get:breturn any 
get:bover the FI
get:bFIN implies
get:bSYN-RECEI
get:bESTABLISH
get:bEnter t
get:bFIN-WAIT-
get:bIf our 
get:benter T
get:btimers;
get:bFIN-WAIT-
get:bEnter t
get:boff the
get:bCLOSE-WAI
get:bRemain 
get:bCLOSING S
get:bRemain 
get:bLAST-ACK 
get:bRemain 
get:bTransmission Cont
get:bFunctional Specif
get:bTIME-WAIT
get:bRemain 
get:btimeout
get:b[Page 76]        
get:bSeptember 1981   
get:bFor any state
get:bthe user "err:or
get:band for any o
get:bstate and ret
get:bRETRANSMISSION 
get:bFor any state
get:bthe retransmi
get:bretransmissio
get:bTIME-WAIT TIMEO
get:bIf the time-w
get:benter the CLO
get:bTransmission Cont
get:b[Page 78]        
get:bSeptember 1981   
get:bBBN Rep
get:ba Host 
get:bhost an
get:bA contr
get:bindicat
get:bspecifi
get:bis expe
get:bpreviou
get:bThe uni
get:bARPANET
get:bA unit 
get:bIMPs.  
get:bA logic
get:bA messa
get:bnetwork
get:bDestination Addre
get:bThe des
get:bidentif
get:bA contr
get:bindicat
get:boccupyi
get:bA porti
get:bfragmen
get:bA file 
get:bTransmission Cont
get:bControl
get:bfragmen
get:bA compu
get:bfrom th
get:bAn Inte
get:bby the 
get:bThe Int
get:bARPANET
get:bA sourc
get:binternet datagram
get:bThe uni
get:bhigher 
get:binternet fragment
get:bA porti
get:bheader.
get:bInterne
get:bThe Ini
get:bnumber 
get:bThe Ini
get:bon a co
get:bbased p
get:bThe Ini
get:bused by
get:bControl
get:bdata.  
get:bon an A
get:b[Page 80]        
get:bSeptember 1981   
get:bThis is
get:bdata re
get:bsequenc
get:bof the 
get:bThe uni
get:bAn impl
get:bprocedu
get:bMaximum
get:bthe int
get:bAn eigh
get:bAn Opti
get:bmay be 
get:bprimari
get:btimesta
get:boptions
get:bA packa
get:blogical
get:blogical
get:bThe por
get:boutput 
get:bA progr
get:bthe poi
get:bA contr
get:bthis se
get:breceivi
get:breceive
get:bTransmission Cont
get:breceive
get:breceive
get:breceive next sequ
get:bThis is
get:breceive
get:bThis re
get:bis will
get:bsegment
get:bRCV.NXT
get:bSegment
get:brange a
get:bA contr
get:bthat th
get:binterac
get:bsequenc
get:bsegment
get:bit.  In
get:brise to
get:bReal Ti:me Protocol
get:bof time
get:bsegment
get:bsegment
get:bsegment
get:bsegment
get:bsegment
get:b[Page 82]        
get:bSeptember 1981   
get:bsegment
get:bA logic
get:bunit of
get:bsegment acknowled
get:bThe seq
get:barrivin
get:bThe amo
get:bincludi
get:bThe num
get:bThis is
get:buse on 
get:binitial
get:beach oc
get:bThis re
get:b(receiv
get:bwindow 
get:breceivi
get:bbe emit
get:bSND.UNA
get:bbetween
get:bsend se
get:bleft se
get:bsend ur
get:bsegment
get:bsegment
get:bTransmission Cont
get:bsend wi
get:bAn addr
get:bis, the
get:bThe sou
get:bA contr
get:bnumber,
get:bwhere t
get:bTransmi
get:bthe sta
get:bThe pre
get:bTransmi:ssion Control Protocol
get:breliabl
get:bType of
get:bAn Inte
get:bfor thi
get:bA contr
get:bindicat
get:burgent 
get:bsequenc
get:bpointer
get:bA contr
get:bfield c
get:bindicat
get:burgent 
get:b[Page 84]        
get:bSeptember 1981   
get:b[1]  Cerf, V., an
get:bIntercommuni
get:bVol. COM-22,
get:b[2]  Postel, J. (
get:bProtocol Spe
get:bInstitute, S
get:b[3]  Dalal, Y. an
get:bProtocols", 
get:bDecember 197
get:b[4]  Postel, J., 
get:bInstitute, S
get:baRFC
get:baDe
get:baI
get:baSeptember 1981   
get:baPREFACE .....
get:ba1.  INTRODUCTION 
get:ba1.1  Motivation
get:ba1.2  Scope ....
get:ba1.3  About This
get:ba1.4  Interfaces
get:ba1.5  Operation 
get:ba2.  PHILOSOPHY ..
get:ba2.1  Elements o
get:ba2.2  Model of O
get:ba2.3  The Host E
get:ba2.4  Interfaces
get:ba2.5  Relation t
get:ba2.6  Reliable C
get:ba2.7  Connection
get:ba2.8  Data Commu
get:ba2.9  Precedence
get:ba2.10 Robustness
get:ba3.  FUNCTIONAL SP
get:ba3.1  Header For
get:ba3.2  Terminolog
get:ba3.3  Sequence N
get:ba3.4  Establishi
get:ba3.5  Closing a 
get:ba3.6  Precedence
get:ba3.7  Data Commu
get:ba3.8  Interfaces
get:ba3.9  Event Proc
get:baGLOSSARY ........
get:baREFERENCES ......
get:baTransmission Cont
get:ba[Page ii]        
get:baSeptember 1981   
get:baThis document des
get:ba(TCP).  There hav
get:baspecification on 
get:badraws heavily fro
get:baboth in terms of 
get:baseveral details a
get:baand redescribes t
get:baRFC
get:baReplaces: RFC 761
get:baIENs:  129, 124, 
get:ba55, 44, 40, 27, 2
get:baThe Transmission 
get:bareliable host-to-
get:bacommunication net
get:baThis document des
get:baTransmission Cont
get:bainterface to prog
get:baComputer commun
get:barole in militar
get:badocument focuse
get:bacommunication r
get:bacommunication u
get:bacongestion, but
get:bagovernment sect
get:baAs strategic an
get:badeveloped and d
get:bainterconnecting
get:bacommunication p
get:baapplications.  
get:baDeputy Undersec
get:badeclared the Tr
get:babe a basis for 
get:bastandardization
get:baTCP is a connec
get:bafit into a laye
get:baapplications.  
get:bacommunication b
get:badistinct but in
get:baassumptions are
get:baprotocols below
get:bapotentially unr
get:baprotocols.  In 
get:bawide spectrum o
get:baconnections to 
get:baTransmission Cont
get:baTCP is based on
get:baTCP fits into a
get:baInternet Protoc
get:bareceive variabl
get:badatagram "envel
get:baaddressing sour
get:bainternet protoc
get:bathe TCP segment
get:bamultiple networ
get:baalso carries in
get:baand compartment
get:bacommunicated en
get:baMuch of this do
get:bawhich are co-re
get:bacomputer.  Some
get:bafront-end compu
get:baas well as netw
get:baan interface to
get:baimplementable e
get:bahost-to-front e
get:baThe TCP is inte
get:bacommunication s
get:baintended to be 
get:ba1.3.  About this 
get:baThis document r
get:baany TCP impleme
get:baprotocols and i
get:ba[Page 2]         
get:baSeptember 1981   
get:basection offers 
get:baoperation.  Sec
get:badesign.  Sectio
get:barequired of TCP
get:bauser calls, err
get:baThe TCP interfa
get:bathe other side 
get:baThe interface b
get:baillustrated in 
get:bacalls much like
get:baapplication pro
get:bacalls to open a
get:baestablished con
get:baasynchronously 
get:baconsiderable fr
get:bainterfaces whic
get:baenvironment, a 
get:bainterface for a
get:baThe interface b
get:baunspecified exc
get:batwo levels can 
get:baTypically, one 
get:bainterface.  TCP
get:bainterconnected 
get:bathroughout this
get:baAs noted above,
get:basecurable logic
get:baprocesses.  To 
get:bacommunication s:ystem requires facilities in the following areas
get:baBasic Data Tr
get:baPrecedence an
get:baThe basic opera
get:bathe following p
get:baTransmission Cont
get:baBasic Data Tran:sfer
get:baThe TCP is ab
get:badirection bet
get:basegments for 
get:bathe TCPs deci
get:baSometimes use
get:basubmitted to 
get:bafunction is d
get:baactually tran
get:bapushed throug
get:bapromptly forw
get:baThe exact pus
get:bathe push func
get:baReliability
get:baThe TCP must 
get:badelivered out
get:bais achieved b
get:batransmitted, 
get:bareceiving TCP
get:bainterval, the
get:banumbers are u
get:baout of order 
get:baadding a chec
get:bareceiver, and
get:baAs long as th
get:basystem does n
get:baerrors will a
get:bainternet comm
get:baFlow Control
get:baTCP provides 
get:basent by the s
get:baevery ACK ind
get:bathe last segm
get:baallowed numbe
get:bareceiving fur
get:ba[Page 4]         
get:baSeptember 1981   
get:baMultiplexing
get:baTo allow for 
get:bacommunication
get:baaddresses or 
get:baand host addr
get:baa socket.  A 
get:baThat is, a so
get:baThe binding o
get:baHost.  Howeve
get:ba(e.g., a "log
get:bamade known to
get:bathrough the k
get:baaddresses of 
get:baConnections
get:baThe reliabili
get:bathat TCPs ini
get:baeach data str
get:basockets, sequ
get:baEach connecti
get:baidentifying i
get:baWhen two proc
get:baestablish a c
get:baside).  When 
get:baterminated or
get:baSince connect
get:baover the unre
get:bamechanism wit
get:baerroneous ini
get:baPrecedence and :Security
get:baThe users of 
get:bacommunication
get:bathese feature
get:baTransmission Cont
get:ba[Page 6]         
get:baSeptember 1981   
get:ba2.1.  Elements of
get:baThe internetwor
get:bawhich are in tu
get:bathat the networ
get:balarge networks 
get:bapacket switchin
get:baconsume message
get:banetworks, the g
get:bacommunication s
get:baconnections bet
get:baThe term packet
get:batransaction bet
get:baexchanged withi
get:baHosts are compu
get:banetwork's point
get:baProcesses are v
get:baaccordance with
get:bain execution). 
get:baviewed as commu
get:baThus, all commu
get:baSince a process
get:bastreams between
get:bathat each proce
get:bacommunicates wi
get:ba2.2.  Model of Op
get:baProcesses trans
get:badata as argumen
get:basegments and ca
get:bathe destination
get:bainto the receiv
get:baTCPs include co
get:baensure reliable
get:baThe model of in
get:baprotocol module
get:bato the local ne
get:bainside internet
get:bainternet module
get:bathrough the loc
get:baThe packet swit
get:baTransmission Cont
get:baother operation
get:badestination int
get:baAt a gateway be
get:bafrom its local 
get:bathe internet da
get:bathen "wrapped" 
get:barouted to the n
get:baA gateway is pe
get:bainternet datagr
get:bathrough the nex
get:bainternet datagr
get:bafurther broken 
get:bainternet datagr
get:bainternet module
get:baA destination i
get:ba(after reassemb
get:badestination TCP
get:baThis simple mod
get:baimportant featu
get:bato the gateway 
get:baservice paramet
get:baIncluded in the
get:badatagram.  Data
get:bahost and gatewa
get:baproperly segreg
get:ba2.3.  The Host En
get:baThe TCP is assu
get:baaccess the TCP 
get:bamay call on oth
get:badata structures
get:bacontrolled by a
get:banetwork device 
get:badatagram protoc
get:baThe mechanisms 
get:bafront-end proce
get:bahost-to-front-e
get:bathe type of TCP
get:ba[Page 8]         
get:baSeptember 1981   
get:baThe TCP/user in
get:bato OPEN or CLOS
get:baSTATUS about a 
get:baprograms on the
get:bafrom, and close
get:baThe TCP/interne
get:badatagrams addre
get:basystem.  These 
get:baservice, preced
get:ba2.5.  Relation to
get:baThe following d
get:bahierarchy
get:ba+------+ +
get:ba|Telnet| |
get:ba+------+ +
get:ba|   
get:ba+----
get:ba| TCP
get:ba+----
get:ba| 
get:ba+----
get:ba|    
get:ba+----
get:ba+--
get:ba|  
get:ba+--
get:baIt is expected 
get:baprotocols effic
get:baprotocols like 
get:ba2.6.  Reliable Co
get:baA stream of dat
get:baorder at the de
get:baTransmission Cont
get:baTransmission is
get:baacknowledgments
get:basequence number
get:basegment is tran
get:basequence number
get:bais the sequence
get:batransmissions i
get:basegment contain
get:bastarts a timer;
get:basegment is dele
get:bareceived before
get:baAn acknowledgme
get:badelivered to th
get:bathe responsibil
get:baTo govern the f
get:baemployed.  The 
get:baThis window spe
get:baacknowledgment 
get:ba2.7.  Connection 
get:baTo identify the
get:baprovides a port
get:baindependently b
get:baunique addresse
get:baidentifying the
get:bawill be unique 
get:baA connection is
get:balocal socket ma
get:basockets.  A con
get:bathat is, it is 
get:baTCPs are free t
get:baHowever, severa
get:baThere must be w
get:bathe "appropriat
get:bamay "own" ports
get:bathe ports they 
get:baissue, but we e
get:bauniquely alloca
get:baassociating the
get:baA connection is
get:baforeign socket 
get:ba[Page 10]        
get:baSeptember 1981   
get:baconnection name
get:basubsequent call
get:baabout a connect
get:bais a data struc
get:baimplementation 
get:bapointer to the 
get:bawhether the con
get:babe passively wa
get:baA passive OPEN 
get:baconnection requ
get:baOften the proce
get:barequest from an
get:bais used to deno
get:baare allowed onl
get:baA service proce
get:baprocesses would
get:baforeign socket.
get:barequested a con
get:balocal socket we
get:baWell-known sock
get:baa socket addres
get:ba"Telnet-Server"
get:basocket, and oth
get:baEntry, Text Gen
get:babeing for test 
get:baaccess to a "Lo
get:baat which a newl
get:bawell-known sock
get:baof sockets to s
get:baProcesses can i
get:bafrom other proc
get:babeen establishe
get:baother at the sa
get:bais critical for
get:bacomponents act 
get:baThere are two p
get:bapassive OPENs a
get:balocal passive O
get:bacase, the match
get:baOPENs has left 
get:baforeign socket 
get:baOther possibili
get:baTransmission Cont
get:baIf there are se
get:basame local sock
get:bawith the specif
get:baTCB exists, bef
get:baThe procedures 
get:bacontrol flag an
get:baexchange has be
get:baA connection is
get:bacontaining a SY
get:bacommand.  The m
get:baconnection has 
get:bawhen sequence n
get:baThe clearing of
get:bain this case ca
get:ba2.8.  Data Commun
get:baThe data that f
get:baoctets.  The se
get:bain that call (a
get:bathrough to the 
get:baA sending TCP i
get:basend that data 
get:bafunction is sig
get:bareceiving TCP s
get:bathe sending TCP
get:baThere is no nec
get:baboundaries.  Th
get:basingle SEND cal
get:baThe purpose of 
get:bafrom the sendin
get:barecord service.
get:baThere is a coup
get:baof data that cr
get:baassociated with
get:babuffer is retur
get:banot filled.  If
get:baPUSH is seen, t
get:baTCP also provid
get:baat some point f
get:ba[Page 12]        
get:baSeptember 1981   
get:bacurrently readi
get:badefine what the
get:baurgent data, bu
get:batake action to 
get:ba2.9.  Precedence 
get:baThe TCP makes u
get:basecurity option
get:babasis to TCP us
get:baa multilevel se
get:bause only, and o
get:bacompartment.  C
get:bausers may be li
get:baTCP modules whi
get:baproperly mark o
get:baprecedence.  Su
get:bahigher level pr
get:bathem to specify
get:baprecedence of c
get:ba2.10.  Robustness
get:baTCP implementat:ions will follow a general principle of robustness
get:baconservative in
get:baTransmission Cont
get:ba[Page 14]        
get:baSeptember 1981   
get:ba3.1.  Header Form
get:baTCP segments ar
get:baheader carries 
get:badestination hos
get:baheader, supplyi
get:badivision allows
get:baTCP Header Form
get:ba0            
get:ba0 1 2 3 4 5 6
get:ba+-+-+-+-+-+-+-
get:ba|          Sou
get:ba+-+-+-+-+-+-+-
get:ba|             
get:ba+-+-+-+-+-+-+-
get:ba|             
get:ba+-+-+-+-+-+-+-
get:ba|  Data |     
get:ba| Offset| Rese
get:ba|       |     
get:ba+-+-+-+-+-+-+-
get:ba|           Ch
get:ba+-+-+-+-+-+-+-
get:ba|             
get:ba+-+-+-+-+-+-+-
get:ba|             
get:ba+-+-+-+-+-+-+-
get:baNote th
get:baSource Port:  1
get:baThe source po
get:baDestination Por:t
get:baThe destinati
get:baTransmission Cont
get:baFunctional Specif
get:baSequence Number:
get:baThe sequence 
get:bawhen SYN is p
get:bainitial seque
get:baAcknowledgment :Number
get:baIf the ACK co
get:banext sequence
get:bareceive.  Onc
get:baData Offset:  4
get:baThe number of
get:bathe data begi
get:baintegral numb
get:baReserved:  6 bi
get:baReserved for 
get:baControl Bits:  :6 bits (from left to right)
get:baURG:  Urgent 
get:baACK:  Acknowl
get:baPSH:  Push Fu
get:baRST:  Reset t
get:baSYN:  Synchro
get:baFIN:  No more
get:baWindow:  16 bit
get:baThe number of
get:baacknowledgmen
get:baChecksum:  16 b
get:baThe checksum 
get:bacomplement su
get:basegment conta
get:bachecksummed, 
get:baform a 16 bit
get:batransmitted a
get:bathe checksum 
get:baThe checksum 
get:ba[Page 16]        
get:baSeptember 1981   
get:baprefixed to t
get:baAddress, the 
get:baThis gives th
get:bainformation i
get:baacross the TC
get:bacalls by the 
get:baThe TCP Len
get:baoctets (thi
get:bacomputed), 
get:baUrgent Pointer:
get:baThis field co
get:bapositive offs
get:baurgent pointe
get:bathe urgent da
get:bathe URG contr
get:baOptions:  varia
get:baOptions may o
get:bamultiple of 8
get:bachecksum.  An
get:bacases for the: format of an option
get:baCase 1:  A 
get:baCase 2:  An
get:bath
get:baThe option-le
get:baoption-length
get:baNote that the
get:bafield might i
get:baEnd-of-Option
get:baA TCP must im
get:baTransmission Cont
get:baFunctional Specif
get:baCurrently def:ined options include (kind indicated in octal)
get:baKind     Le
get:ba----     --
get:ba0         
get:ba1         
get:ba2         
get:baSpecific Opti
get:baEnd of Opti
get:ba+--------
get:ba|00000000
get:ba+--------
get:baThis opti
get:bamight not
get:bathe Data 
get:banot the e
get:bathe optio
get:baNo-Operatio
get:ba+--------
get:ba|00000001
get:ba+--------
get:baThis opti
get:baalign the
get:baThere is 
get:bareceivers
get:banot begin
get:baMaximum Seg
get:ba+--------
get:ba|00000010
get:ba+--------
get:baKind=2  
get:ba[Page 18]        
get:baSeptember 1981   
get:baMaximum S:egment Size Option Data
get:baIf this
get:bareceive
get:baThis fi
get:ba(i.e., 
get:baoption 
get:baPadding:  varia
get:baThe TCP heade
get:baand data begi
get:ba3.2.  Terminology
get:baBefore we can d
get:bato introduce so
get:baconnection requ
get:baof these variab
get:baTransmission Co
get:baTCB are the loc
get:baprecedence of t
get:babuffers, pointe
get:baIn addition sev
get:basequence number
get:baSend Sequence
get:baSND.UNA - s
get:baSND.NXT - s
get:baSND.WND - s
get:baSND.UP  - s
get:baSND.WL1 - s
get:baSND.WL2 - s
get:bau
get:baISS     - i
get:baReceive Seque
get:baRCV.NXT - r
get:baRCV.WND - r
get:baRCV.UP  - r
get:baIRS     - i
get:baTransmission Cont
get:baFunctional Specif
get:baThe following d
get:bathe sequence sp
get:baSend Sequence S
get:ba---
get:ba1 - old s
get:ba2 - seque
get:ba3 - seque
get:ba4 - futur
get:baThe send window
get:baReceive Sequenc
get:ba1 - old s
get:ba2 - seque
get:ba3 - futur
get:baThe receive win
get:baThere are also 
get:batake their valu
get:ba[Page 20]        
get:baSeptember 1981   
get:baCurrent Segme
get:baSEG.SEQ - s
get:baSEG.ACK - s
get:baSEG.LEN - s
get:baSEG.WND - s
get:baSEG.UP  - s
get:baSEG.PRC - s
get:baA connection pr
get:balifetime.  The :states are
get:baESTABLISHED, FI
get:baTIME-WAIT, and 
get:babecause it repr
get:bano connection. : Briefly the meanings of the states are
get:baLISTEN - repr
get:baTCP and port.
get:baSYN-SENT - re
get:baafter having 
get:baSYN-RECEIVED 
get:barequest ackno
get:baconnection re
get:baESTABLISHED -
get:badelivered to 
get:baof the connec
get:baFIN-WAIT-1 - 
get:bafrom the remo
get:batermination r
get:baFIN-WAIT-2 - 
get:bafrom the remo
get:baCLOSE-WAIT - 
get:bafrom the loca
get:baCLOSING - rep
get:baacknowledgmen
get:baLAST-ACK - re
get:baconnection te
get:ba(which includ
get:baTransmission Cont
get:baFunctional Specif
get:baTIME-WAIT - r
get:bathe remote TC
get:batermination r
get:baCLOSED - repr
get:baA TCP connectio
get:baevents.  The ev
get:baABORT, and STAT
get:bacontaining the 
get:baThe state diagr
get:bawith the causin
get:baerror condition
get:bachanges.  In a 
get:bathe reaction of
get:baNOTE BENE:  thi
get:bathe total speci
get:ba[Page 22]        
get:baSeptember 1981   
get:ba+---------+     
get:ba|         |<----
get:ba|   SYN   |     
get:ba|   RCVD  |<----
get:ba|         |     
get:ba|         |-----
get:ba+---------+   rc
get:ba|           --
get:ba|             
get:ba|             
get:ba|  CLOSE      
get:ba| -------     
get:ba| snd FIN     
get:ba|             
get:baV             
get:ba+---------+     
get:ba|  FIN    |<----
get:ba| WAIT-1  |-----
get:ba+---------+     
get:ba| rcv ACK of F
get:ba| ------------
get:baV        x    
get:ba+---------+     
get:ba|FINWAIT-2|     
get:ba+---------+     
get:ba|             
get:ba|  rcv FIN    
get:ba|  -------    
get:ba\ snd ACK    
get:ba------------
get:baTransmission Cont
get:baFunctional Specif
get:ba3.3.  Sequence Nu
get:baA fundamental n
get:baover a TCP conn
get:basequenced, each
get:bamechanism emplo
get:banumber X indica
get:bareceived.  This
get:badetection in th
get:bawithin a segmen
get:bathe header is t
get:banumbered consec
get:baIt is essential
get:bafinite, though 
get:baSince the space
get:banumbers must be
get:bapreserves the r
get:ba2**32 - 1 to 0 
get:baarithmetic, so 
get:bacomparison of s
get:ba(modulo 2**32).
get:baThe typical kin
get:baperform include:
get:ba(a)  Determin
get:banumber s
get:ba(b)  Determin
get:bahave bee
get:baretransm
get:ba(c)  Determin
get:bawhich ar
get:bareceive 
get:ba[Page 24]        
get:baSeptember 1981   
get:baIn response to 
get:bafollowing compa
get:baSND.UNA = old
get:baSND.NXT = nex
get:baSEG.ACK = ack
get:banum
get:baSEG.SEQ = fir
get:baSEG.LEN = the
get:ba(co
get:baSEG.SEQ+SEG.L
get:baA new acknowled
get:bathe inequality :below holds
get:baSND.UNA < SEG
get:baA segment on th
get:baof its sequence
get:baacknowledgment 
get:baWhen data is re:ceived the following comparisons are needed
get:baRCV.NXT = nex
get:bais the le
get:baRCV.NXT+RCV.W
get:basegment, 
get:baSEG.SEQ = fir
get:baSEG.SEQ+SEG.L
get:baA segment is ju
get:baRCV.NXT =< SE
get:baRCV.NXT =< SE
get:baTransmission Cont
get:baFunctional Specif
get:baThe first part 
get:basegment falls i
get:baif the end of t
get:baeither part of 
get:baActually, it is
get:bawindows and zer
get:baacceptability o:f an incoming segment
get:baSegment Recei
get:baLength  Windo
get:ba------- -----
get:ba0       0 
get:ba0      >0 
get:ba>0       0 
get:ba>0      >0 
get:baNote that when 
get:baacceptable exce
get:bamaintain a zero
get:baACKs.  However,
get:baprocess the RST
get:baWe have taken a
get:bacontrol informa
get:basome control fl
get:baand acknowledge
get:bacontrol will be
get:bacarried in the 
get:bafor implicitly 
get:baare the only co
get:baare used only a
get:bapurposes, the S
get:baoctet of the se
get:bato occur after 
get:baoccurs.  The se
get:baspace occupying
get:basequence number
get:ba[Page 26]        
get:baSeptember 1981   
get:baInitial Sequenc
get:baThe protocol pl
get:baused over and o
get:basockets.  New i
get:baincarnations of
get:ba-- "how does th
get:baincarnations of
get:baconnection is b
get:baconnection brea
get:baTo avoid confus
get:baconnection from
get:babe present in t
get:baassure this, ev
get:basequence number
get:baan initial sequ
get:banew 32 bit ISN.
get:babit clock whose
get:bamicroseconds.  
get:baSince we assume
get:bathe Maximum Seg
get:bahours we can re
get:baFor each connec
get:basequence number
get:bathe data sendin
get:balearned during 
get:baFor a connectio
get:basynchronize on 
get:baan exchange of 
get:bacalled "SYN" (f
get:bashorthand, segm
get:baHence, the solu
get:bainitial sequenc
get:baThe synchroniza
get:basequence number
get:bafrom the other 
get:bainitial sequenc
get:ba1) A --> B  S
get:ba2) A <-- B  A
get:ba3) A <-- B  S
get:ba4) A --> B  A
get:baTransmission Cont
get:baFunctional Specif
get:baBecause steps 2
get:bacalled the thre
get:baA three way han
get:batied to a globa
get:bamechanisms for 
get:bano way of knowi
get:baunless it remem
get:ba(which is not a
get:baverify this SYN
get:baclock-driven sc
get:baKnowing When to
get:baTo be sure that
get:basequence number
get:bathe network, th
get:ba(MSL) before as
get:barecovering from
get:balost.  For this
get:bais an engineeri
get:bait is desirable
get:basense, yet reta
get:banot wait at all
get:bathan those rece
get:baThe TCP Quiet T
get:baThis specific
get:baretaining any
get:baeach active (
get:baTCP segments 
get:bain the intern
get:baparagraphs be
get:baTCP implement
get:baat the risk o
get:badata rejected
get:baTCPs consume 
get:baentered into 
get:baduplicate det
get:barelies on the
get:bathe extent th
get:bavalues before
get:babeen delivere
get:bacopies of the
get:basuch an assum
get:ba[Page 28]        
get:baSeptember 1981   
get:baassigned the 
get:baat the receiv
get:bathat each seg
get:baas there are 
get:baUnder normal 
get:bato emit and t
get:bamistakenly us
get:babeen acknowle
get:badata is drain
get:bavery large to
get:bacause trouble
get:bato use up 2**
get:balifetime in t
get:bathis is deeme
get:barates escalat
get:bacycle time is
get:bawithin reason
get:baThe basic dup
get:badefeated, how
get:basequence numb
get:bathe TCP were 
get:baupon crashing
get:baconnection (p
get:bapackets with 
get:bapackets still
get:baincarnation o
get:baabout the seq
get:baspecification
get:babefore emitti
get:basegments from
get:baEven hosts wh
get:bainitial seque
get:ba(i.e., even i
get:banumber for ea
get:baSuppose, for 
get:basequence numb
get:baand that even
get:batakes on a va
get:basegment sent 
get:baat this insta
get:baincarnation o
get:baS1 = ISN(t) -
get:baconnection!  
get:baTransmission Cont
get:baFunctional Specif
get:baduplicates in
get:baof S1 may arr
get:bathe new incar
get:baThe problem i
get:bacrashed nor d
get:bathe system fr
get:baOne way to de
get:basegments for 
get:batime" specifi
get:bawilling to ri
get:badestination m
get:baImplementors 
get:baconnection by
get:bainformally im
get:baObviously, ev
get:banecessary aft
get:baTo summarize:
get:banumbers in th
get:ba"busy" or "in
get:bablock of spac
get:basegment, if a
get:basequence numb
get:bathe previous 
get:banumber overla
get:ba3.4.  Establishin
get:baThe "three-way 
get:baconnection.  Th
get:baresponded to by
get:basimultaneously 
get:baoccurs, each TC
get:baacknowledgment 
get:baan old duplicat
get:barecipient, that
get:baProper use of "
get:baSeveral example
get:baexamples do not
get:basegments, this 
get:badoesn't deliver
get:bavalid (i.e., th
get:baconnection reac
get:bareduces the pos
get:ba[Page 30]        
get:baSeptember 1981   
get:baimplementation 
get:bainformation for
get:baThe simplest th
get:bafigures should 
get:banumbered for re
get:badeparture of a 
get:basegment at B fr
get:baEllipsis (...) 
get:ba(delayed).  An 
get:baComments appear
get:bathe departure o
get:bathe center of e
get:baform, with sequ
get:bafields such as 
get:bain the interest
get:baTCP A      
get:ba1.  CLOSED     
get:ba2.  SYN-SENT   
get:ba3.  ESTABLISHED
get:ba4.  ESTABLISHED
get:ba5.  ESTABLISHED
get:baBasic 3
get:baIn line 2 of fi
get:baindicating that
get:banumber 100.  In
get:bareceived from T
get:baB is now expect
get:baoccupied sequen
get:baAt line 4, TCP 
get:baTCP B's SYN; an
get:basequence number
get:babecause the ACK
get:bawould wind up A
get:baTransmission Cont
get:baFunctional Specif
get:baSimultaneous in
get:bafigure 8.  Each
get:baTCP A      
get:ba1.  CLOSED     
get:ba2.  SYN-SENT   
get:ba3.  SYN-RECEIVE
get:ba4.             
get:ba5.  SYN-RECEIVE
get:ba6.  ESTABLISHED
get:ba7.             
get:baS
get:baThe principle r
get:baduplicate conne
get:bathis, a special
get:bareceiving TCP i
get:baSYN-RECEIVED), 
get:baIf the TCP is i
get:baFIN-WAIT-1, FIN
get:baaborts the conn
get:bacase under "hal
get:ba[Page 32]        
get:baSeptember 1981   
get:baTCP A      
get:ba1.  CLOSED     
get:ba2.  SYN-SENT   
get:ba3.  (duplicate)
get:ba4.  SYN-SENT   
get:ba5.  SYN-SENT   
get:ba6.             
get:ba7.  SYN-SENT   
get:ba8.  ESTABLISHED
get:baAs a simple exa
get:bafigure 9.  At l
get:bacannot tell tha
get:ba(line 4).  TCP 
get:baRST (reset) wit
get:babelievable.  TC
get:baWhen the origin
get:basynchronization
get:babefore the RST,
get:basent in both di
get:baHalf-Open Conne
get:baAn established 
get:baTCPs has closed
get:baknowledge of th
get:babecome desynchr
get:bamemory.  Such c
get:baattempt is made
get:baconnections are
get:bamildly involved
get:baIf at site A th
get:baTransmission Cont
get:baFunctional Specif
get:bauser at site B 
get:bareceiving a res
get:basite B TCP that
get:baAssume that two
get:baanother when a 
get:baDepending on th
get:bathat some error
get:baA is likely to 
get:bapoint.  As a re
get:baor try to SEND 
get:bacase, it receiv
get:balocal (A's) TCP
get:bawill send a seg
get:baexample shown i
get:bare-open the con
get:baTCP A      
get:ba1.  (CRASH)    
get:ba2.  CLOSED     
get:ba3.  SYN-SENT --
get:ba4.  (!!)     <-
get:ba5.  SYN-SENT --
get:ba6.  SYN-SENT   
get:ba7.  SYN-SENT --
get:baWhen the SYN ar
get:baand the incomin
get:baacknowledgment 
get:ba100).  TCP A se
get:basent and, being
get:badetected a half
get:ba[Page 34]        
get:baSeptember 1981   
get:bacontinue to try
get:bareduced to the 
get:baAn interesting 
get:batries to send d
get:baThis is illustr
get:baTCP A from TCP 
get:baexists, so TCP 
get:baprocesses it an
get:baTCP A    
get:ba1.  (CRASH)    
get:ba2.  (??)    <--
get:ba3.          -->
get:baActive
get:baIn figure 12, w
get:bawaiting for SYN
get:bainto action.  A
get:bagenerate a RST 
get:bathe reset and r
get:baTCP A      
get:ba1.  LISTEN     
get:ba2.       ... <S
get:ba3.  (??) <-- <S
get:ba4.       --> <S
get:ba5.  LISTEN     
get:baOld Duplic
get:baTransmission Cont
get:baFunctional Specif
get:baA variety of ot
get:baby the followin
get:baReset Generatio
get:baAs a general ru
get:bawhich apparentl
get:bamust not be sen
get:baThere are three: groups of states
get:ba1.  If the co
get:bain response t
get:baparticular, S
get:baby this means
get:baIf the incomi
get:basequence numb
get:bareset has seq
get:baof the sequen
get:baThe connectio
get:ba2.  If the co
get:baSYN-SENT, SYN
get:basomething not
get:baif an incomin
get:badoes not exac
get:baconnection, a
get:baIf our SYN ha
get:baincoming segm
get:baeither raise 
get:bathe system) o
get:baincoming segm
get:bacontinue as i
get:bacannot raise 
get:badetected in t
get:baterminated th
get:baincoming segm
get:bamatch the loc
get:bamust be sent.
get:baIf the incomi
get:basequence numb
get:bareset has seq
get:baof the sequen
get:baThe connectio
get:ba[Page 36]        
get:baSeptember 1981   
get:ba3.  If the co
get:baFIN-WAIT-1, F
get:baany unaccepta
get:baunacceptible 
get:baacknowledgmen
get:baand an acknow
get:bato be receive
get:baIf an incomin
get:baprecedence wh
get:baand precedenc
get:baconnection go
get:banumber from t
get:baReset Processin
get:baIn all states e
get:baby checking the
get:bais in the windo
get:bato an initial S
get:baacknowledges th
get:baThe receiver of
get:bareceiver was in
get:bain SYN-RECEIVED
get:bathen the receiv
get:baaborts the conn
get:bawas in any othe
get:baand goes to the
get:ba3.5.  Closing a C
get:baCLOSE is an ope
get:banotion of closi
get:bainterpretation,
get:bathe receiving s
get:bain a simplex fa
get:bauntil he is tol
get:bacould initiate 
get:baRECEIVE until s
get:bahas CLOSED.  We
get:baRECEIVEs are ou
get:bacan terminate h
get:babuffers SENT be
get:badata in return 
get:basuccessfully to
get:baTCP.  Users mus
get:bathe TCP says no
get:baTransmission Cont
get:baFunctional Specif
get:baThere are essen:tially three cases
get:ba1) The user i
get:ba2) The remote
get:ba3) Both users
get:baCase 1:  Local 
get:baIn this case,
get:baoutgoing segm
get:baaccepted by t
get:baare allowed i
get:bawill be retra
get:baboth acknowle
get:bacan ACK this 
get:basend its own 
get:baCase 2:  TCP re
get:baIf an unsolic
get:bacan ACK it an
get:bauser will res
get:bathe other TCP
get:bauntil its own
get:baconnection.  
get:bathe connectio
get:baCase 3:  both u
get:baA simultaneou
get:baFIN segments 
get:bahave been pro
get:bahas received.
get:ba[Page 38]        
get:baSeptember 1981   
get:baTCP A      
get:ba1.  ESTABLISHED
get:baFIN-WAIT-1 
get:ba3.  FIN-WAIT-2 
get:ba4.             
get:baTIME-WAIT  
get:ba5.  TIME-WAIT  
get:baCLOSED     
get:baTCP A      
get:ba1.  ESTABLISHED
get:ba2.  (Close)    
get:baFIN-WAIT-1 
get:ba3.  CLOSING    
get:ba4.  TIME-WAIT  
get:ba(2 MSL)    
get:baCLOSED     
get:baTransmission Cont
get:baFunctional Specif
get:ba3.6.  Precedence 
get:baThe intent is t
get:bawith exactly th
get:bahigher of the p
get:baThe precedence 
get:badefined in the 
get:baspecification t
get:bathe security pa
get:bauser group, and
get:baA connection at
get:balower precedenc
get:baa connection du
get:baacknowledgment 
get:baNote that TCP m
get:baprecedence will
get:basegments and po
get:baThe security pa
get:ba(the values wou
get:banon-secure envi
get:baparameters, tho
get:ba3.7.  Data Commun
get:baOnce the connec
get:baexchange of seg
get:ba(checksum test 
get:baretransmission 
get:baDuplicate segme
get:baAs discussed in
get:bacertain tests o
get:basegments to ver
get:baThe sender of d
get:bathe variable SN
get:basequence number
get:bakeeps track of 
get:bavariable SND.UN
get:basent has been a
get:baWhen the sender
get:baSND.NXT.  When 
get:basends an acknow
get:ba[Page 40]        
get:baSeptember 1981   
get:baacknowledgment 
get:bathese variables
get:baThe amount by w
get:badata in the seg
get:basegments must c
get:baThe CLOSE user 
get:baflag in an inco
get:baRetransmission 
get:baBecause of the 
get:bainternetwork sy
get:baretransmission 
get:bafor determining
get:baAn Example Re
get:baMeasure the
get:baparticular 
get:bacovers that
get:basegments re
get:baTime (RTT).:  Next compute a Smoothed Round Trip Time (SRTT) as
get:baSRTT = ( 
get:baand based o:n this, compute the retransmission timeout (RTO) as
get:baRTO = min
get:bawhere UBOUN
get:baLBOUND is a
get:baa smoothing
get:bafactor (e.g
get:baThe Communicati
get:baThe objective o
get:bato stimulate th
get:bapermit the rece
get:bathe currently k
get:baThis mechanism 
get:bathe end of urge
get:bathe receive seq
get:bamust tell the u
get:banumber catches 
get:baTransmission Cont
get:baFunctional Specif
get:bainto "normal mo
get:bais in "urgent m
get:baThe method empl
get:batransmitted.  T
get:bameaningful and 
get:bathe urgent poin
get:bano urgent data 
get:baTo send an urge
get:baoctet.  If the 
get:bathe urgent info
get:baManaging the Wi
get:baThe window sent
get:banumbers the sen
get:baprepared to acc
get:bathe currently a
get:baIndicating a la
get:baarrives than ca
get:bain excessive re
get:banetwork and the
get:batransmission of
get:babetween each ne
get:baThe mechanisms 
get:basubsequently ad
get:bathat much data.
get:badiscouraged.  T
get:bashrink the wind
get:baon the part of 
get:baThe sending TCP
get:baleast one octet
get:basending TCP mus
get:bathe window is z
get:bainterval when t
get:baguarantee that 
get:bawindow will be 
get:baWhen the receiv
get:bastill send an a
get:baand current win
get:baThe sending TCP
get:ba[Page 42]        
get:baSeptember 1981   
get:bawhich fit the c
get:baretransmission 
get:baIn a connection
get:babe carried in a
get:banumber so there
get:baorder.  This is
get:bainformation to 
get:bathe data receiv
get:bathe window info
get:baacknowledgment 
get:baequal or greate
get:baThe window mana
get:bacommunication p
get:baWindow Manage
get:baAllocating 
get:bamany small 
get:bafewer large
get:baOne suggest
get:badefer updat
get:baleast X per
get:baconnection 
get:baAnother sug
get:basegments by
get:basending dat
get:badata must b
get:baNote that t
get:baretransmiss
get:baacknowledgm
get:bawindow info
get:banew window 
get:baThe segment
get:baof transmit
get:basegment con
get:bais accepted
get:baIf the send
get:bawindow is n
get:baalternating
get:bapauses in t
get:baTransmission Cont
get:baFunctional Specif
get:baresult in b
get:babig pair. A
get:bamostly smal
get:baThe suggest
get:baactively at
get:bawindows, si
get:bato many sma
get:baThere are of co:urse two interfaces of concern
get:baand the TCP/low
get:baof the user/TCP
get:baprotocol module
get:bain detail by th
get:bacase that the l
get:bathat TCPs might
get:baUser/TCP Interf
get:baThe following
get:baat best, fict
get:bafacilities.  
get:baimplementatio
get:baTCPs must pro
get:bathat all TCP 
get:bahierarchy.  T
get:barequired of a
get:baTCP User Comm
get:baThe followi
get:bainterface. 
get:bafunction ca
get:bameant to ru
get:baThe user co
get:baTCP must pe
get:baIndividual 
get:bamay provide
get:basingle call
get:baautomatical
get:baissued by t
get:ba[Page 44]        
get:baSeptember 1981   
get:baIn providin
get:banot only ac
get:baprocesses i:t serves.  The latter consists of
get:ba(a) gener
get:baremote cl
get:ba(b) repli
get:bavarious t
get:baFormat:  
get:ba[, timeou
get:ba-> local 
get:baWe assume
get:baprocesses
get:bato use th
get:baimplement
get:bafor the s
get:balower lev
get:baresult of
get:baable to m
get:baprocess c
get:baIf the ac
get:bacall to L
get:bahave eith
get:baparticula
get:bafor any c
get:baby the su
get:baA transmi
get:bafilled in
get:baOn an act
get:basynchroni
get:baThe timeo
get:bafor all d
get:badelivered
get:bawill abor
get:baThe TCP o
get:bathe users
get:baTransmission Cont
get:baFunctional Specif
get:baprecedenc
get:baor securi
get:bathe defau
get:baTCP will 
get:basecurity/
get:bathe prece
get:barequested
get:baThe prece
get:barequested
get:barequest, 
get:baconnectio
get:bathis prec
get:baallowed t
get:baor that a
get:baA local c
get:baThe local
get:bafor the c
get:baFormat:  
get:bacount, PU
get:baThis call
get:bato be sen
get:banot been 
get:baimplement
get:baautomatic
get:baauthorize
get:baIf the PU
get:bato the re
get:basegment c
get:bathe data 
get:batransmiss
get:baIf the UR
get:bawill have
get:bathe urgen
get:bapointer i
get:babeen cons
get:bais to sti
get:baindicate 
get:ba[Page 46]        
get:baSeptember 1981   
get:badata has 
get:baTCP signa
get:baof times 
get:baurgent da
get:baIf no for
get:baconnectio
get:bahas becom
get:balocal soc
get:baforeign s
get:baforeign s
get:baknowing t
get:baHowever, 
get:babecomes s
get:baSTATUS ca
get:baimplement
get:basocket is
get:baIf a time
get:baconnectio
get:baIn the si
get:bathe sendi
get:baor the ti
get:bais both s
get:baconnectio
get:baoffers po
get:basophistic
get:bathe proce
get:bafurthermo
get:baMultiple 
get:bathe TCP w
get:baWe have i
get:bawhich a S
get:bapseudo-in
get:bareturn a 
get:baimmediate
get:babeen ackn
get:baassume ev
get:baclose any
get:bakind (syn
get:basignals, 
get:bawith spec
get:baIn order 
get:baindicatio
get:baTransmission Cont
get:baFunctional Specif
get:babuffer ad
get:bathe SEND 
get:baindicatin
get:bacalling p
get:baFormat:  
get:bacount) ->
get:baThis comm
get:baspecified
get:bacalling p
get:baerror is 
get:baIn the si
get:bacalling p
get:baerror occ
get:baA more so
get:baRECEIVEs 
get:basegments 
get:bathe cost 
get:banotify th
get:baIf enough
get:bathe PUSH 
get:baThe buffe
get:baa PUSH is
get:bareturned 
get:baIf there 
get:baas it arr
get:bashould th
get:baadditiona
get:bacall to R
get:bamay now l
get:baurgent po
get:bain the sa
get:baboundary 
get:baTo distin
get:bacare of t
get:bareturn co
get:bacount ind
get:baAlternati
get:ba[Page 48]        
get:baSeptember 1981   
get:baallocate 
get:bawith the 
get:baFormat:  
get:baThis comm
get:bathe conne
get:baauthorize
get:baClosing c
get:bathe sense
get:baretransmi
get:baserviced.
get:bacalls, fo
get:bato the de
get:bacontinue 
get:bamay be tr
get:bameans "I 
get:bareceive a
get:banot well 
get:baof all it
get:bainto ABOR
get:baThe user 
get:bainitiativ
get:ba(e.g., re
get:badestinati
get:baBecause c
get:baforeign T
get:bashort tim
get:bareplies t
get:baClose als
get:baFormat:  
get:baThis is a
get:baexcluded 
get:batypically
get:baThis comm
get:bainformati:on
get:balocal s
get:baTransmission Cont
get:baFunctional Specif
get:baforeign
get:balocal c
get:bareceive
get:basend wi
get:baconnect
get:banumber 
get:banumber 
get:baurgent 
get:baprecede
get:basecurit
get:baand tra
get:baDepending
get:baimplement
get:baavailable
get:baauthorize
get:baprevents 
get:baconnectio
get:baFormat:  
get:baThis comm
get:baaborted, 
get:babe sent t
get:baDepending
get:baindicatio
get:bareceive a
get:baTCP-to-User M
get:baIt is assum
get:bameans for t
get:bathe TCP doe
get:bato the user
get:baan error me
get:barelating to
get:baother user 
get:baThe followi:ng information is provided
get:baLocal Con
get:baResponse 
get:baBuffer Ad
get:baByte coun
get:baPush flag
get:baUrgent fl
get:ba[Page 50]        
get:baSeptember 1981   
get:baTCP/Lower-Level
get:baThe TCP calls
get:bareceive infor
get:bainternetwork 
get:baProtocol (IP)
get:baIf the lower 
get:baof service an
get:bafor these par:ameters
get:baType of Ser:vice = Precedence: routine, Delay: normal, Throughput
get:banormal, Rel:iability
get:baTime to Liv
get:baNote that
get:baHere we e
get:babe delive
get:baIf the lower 
get:bafeature) and 
get:baroute informa
get:baso that the s
get:bachecksum be t
get:baalso importan
get:baAny lower lev
get:badestination a
get:bathe "TCP leng
get:baof IP and to 
get:baTransmission Cont
get:baFunctional Specif
get:ba3.9.  Event Proce
get:baThe processing 
get:baimplementation.
get:baprocessing sequ
get:basection only in
get:baThe activity of
get:baThe events that: occur can be cast into three categories
get:baarriving segmen
get:baprocessing the 
get:bacases the proce
get:baEvents that o:ccur
get:baArriving Se
get:baSEGMENT A
get:baUSER TIME
get:baRETRANSMI
get:baTIME-WAIT
get:baThe model of th
get:baimmediate retur
get:bapseudo interrup
get:bameans cause a d
get:baError responses
get:bacommands refere:ncing connections that do not exist receive "error
get:baconnection not 
get:baPlease note in 
get:baacknowledgment 
get:baof the sequence
get:baequal to (modul
get:ba[Page 52]        
get:baSeptember 1981   
get:baA natural way t
get:baimagine that th
get:bathat their cont
get:bain the sequence
get:baand processed i
get:baWhen a segment 
get:bathe segment to 
get:bato be consisten
get:baNote that if no
get:baTransmission Cont
get:baFunctional Specif
get:baCLOSED STATE 
get:baCreate a ne
get:bastate infor
get:basocket, pre
get:bainformation
get:baunspecified
get:baparameters 
get:baprecedence 
get:ba"error:  pr:ecedence not allowed" or "error
get:banot allowed
get:baactive and :the foreign socket is unspecified, return "error
get:baforeign soc
get:baspecified, 
get:ba(ISS) is se
get:bais sent.  S
get:bastate, and 
get:baIf the call
get:bareturn "err:or
get:bano room to :create a new connection, return "error
get:baresources".
get:baIf active a
get:baconnection 
get:basegment, se
get:bastate.  Dat
get:baqueued for 
get:baurgent bit 
get:basegments se
get:baqueue the r:equest, respond with "error
get:baIf Foreign :socket was not specified, then return "error
get:basocket unsp
get:ba[Page 54]        
get:baSeptember 1981   
get:baSYN-SENT STAT
get:baSYN-RECEIVED 
get:baESTABLISHED S
get:baFIN-WAIT-1 ST
get:baFIN-WAIT-2 ST
get:baCLOSE-WAIT ST
get:baCLOSING STATE
get:baLAST-ACK STAT
get:baTIME-WAIT STA
get:baReturn "err:or
get:baTransmission Cont
get:baFunctional Specif
get:baCLOSED STATE 
get:baIf the user
get:ba"error:  co
get:baOtherwise, :return "error
get:baIf the fore
get:bafrom passiv
get:baSND.UNA to 
get:baassociated 
get:batransmissio
get:barequested i
get:baas a result
get:barequest, re:spond with "error
get:baForeign soc:ket was not specified, then return "error
get:basocket unsp
get:baSYN-SENT STAT
get:baSYN-RECEIVED 
get:baQueue the d
get:baIf no space: to queue, respond with "error
get:baresources".
get:baESTABLISHED S
get:baCLOSE-WAIT ST
get:baSegmentize 
get:baacknowledgm
get:bainsufficien:t space to remember this buffer, simply return "error
get:bainsufficien
get:baIf the urge
get:baurgent poin
get:ba[Page 56]        
get:baSeptember 1981   
get:baFIN-WAIT-1 ST
get:baFIN-WAIT-2 ST
get:baCLOSING STATE
get:baLAST-ACK STAT
get:baTIME-WAIT STA
get:baReturn "err:or
get:baTransmission Cont
get:baFunctional Specif
get:baCLOSED STATE 
get:baIf the user
get:ba"error:  co
get:baOtherwise r:eturn "error
get:baSYN-SENT STAT
get:baSYN-RECEIVED 
get:baQueue for p
get:bais no room :to queue this request, respond with "error
get:bainsufficien
get:baESTABLISHED S
get:baFIN-WAIT-1 ST
get:baFIN-WAIT-2 ST
get:baIf insuffic
get:barequest, qu
get:baremember th:e RECEIVE, respond with "error
get:baresources".
get:baReassemble 
get:bato user.  M
get:baIf RCV.UP i
get:bauser notify
get:baWhen the TC
get:bathat fact m
get:baacknowledgm
get:badescribed b
get:ba[Page 58]        
get:baSeptember 1981   
get:baCLOSE-WAIT ST
get:baSince the r
get:basatisfied b
get:bauser.  If n
get:ba"error:  co
get:batext can be
get:baCLOSING STATE
get:baLAST-ACK STAT
get:baTIME-WAIT STA
get:baReturn "err:or
get:baTransmission Cont
get:baFunctional Specif
get:baCLOSED STATE 
get:baIf the user
get:ba"error:  co
get:baOtherwise, :return "error
get:baAny outstan:ding RECEIVEs are returned with "error
get:baresponses. 
get:baSYN-SENT STAT
get:baDelete the :TCB and return "error
get:baqueued SEND
get:baSYN-RECEIVED 
get:baIf no SENDs
get:bathen form a
get:baotherwise q
get:baESTABLISHED S
get:baQueue this 
get:baform a FIN 
get:baFIN-WAIT-1 ST
get:baFIN-WAIT-2 ST
get:baStrictly sp:eaking, this is an error and should receive a "error
get:baconnection 
get:baacceptable,
get:baFIN may be 
get:ba[Page 60]        
get:baSeptember 1981   
get:baCLOSE-WAIT ST
get:baQueue this 
get:basegmentized
get:baCLOSING STATE
get:baLAST-ACK STAT
get:baTIME-WAIT STA
get:baRespond wit:h "error
get:baTransmission Cont
get:baFunctional Specif
get:baCLOSED STATE 
get:baIf the user
get:ba"error:  co
get:baOtherwise r:eturn "error
get:baAny outstan:ding RECEIVEs should be returned with "error
get:baconnection 
get:baSYN-SENT STAT
get:baAll queued 
get:banotificatio
get:baSYN-RECEIVED 
get:baESTABLISHED S
get:baFIN-WAIT-1 ST
get:baFIN-WAIT-2 ST
get:baCLOSE-WAIT ST
get:baSend a rese:t segment
get:ba<SEQ=SND.
get:baAll queued 
get:banotificatio
get:baRST formed 
get:baTCB, enter 
get:baCLOSING STATE
get:baLAST-ACK STAT
get:baTIME-WAIT STA
get:baRespond wit
get:ba[Page 62]        
get:baSeptember 1981   
get:baCLOSED STATE 
get:baIf the user
get:ba"error:  co
get:baOtherwise r:eturn "error
get:baReturn "sta
get:baSYN-SENT STAT
get:baReturn "sta
get:baSYN-RECEIVED 
get:baReturn "sta
get:baESTABLISHED S
get:baReturn "sta
get:baFIN-WAIT-1 ST
get:baReturn "sta
get:baFIN-WAIT-2 ST
get:baReturn "sta
get:baCLOSE-WAIT ST
get:baReturn "sta
get:baCLOSING STATE
get:baReturn "sta
get:baLAST-ACK STAT
get:baReturn "sta
get:baTransmission Cont
get:baFunctional Specif
get:baTIME-WAIT STA
get:baReturn "sta
get:ba[Page 64]        
get:baSeptember 1981   
get:baSEGMENT ARRIVES
get:baIf the state 
get:baall data in
get:basegment con
get:bacontaining 
get:baacknowledgm
get:bareset seque
get:baIf the ACK 
get:ba<SEQ=0><A
get:baIf the ACK 
get:ba<SEQ=SEG.
get:baIf the state 
get:bafirst check
get:baAn incomi
get:basecond chec
get:baAny ackno
get:bathe LISTE
get:bafor any a
get:baformatted: as follows
get:ba<SEQ=SE
get:bathird check
get:baIf the SY
get:basecurity/
get:bamatch the
get:ba<SEQ=SE
get:baTransmission Cont
get:baFunctional Specif
get:baIf the SE
get:bathe user 
get:basend a re
get:ba<SEQ=SE
get:baIf the SE
get:baSet RCV.N
get:bacontrol o
get:bashould be: selected and a SYN segment sent of the form
get:ba<SEQ=IS
get:baSND.NXT i
get:bastate sho
get:baincoming 
get:bain the SY
get:banot be re
get:bathe forei
get:baunspecifi
get:bafourth othe
get:baAny other
get:bamust have
get:baprocessin
get:bait could 
get:baincarnati
get:babut if yo
get:baIf the state 
get:bafirst check
get:baIf the AC
get:baIf SEG.
get:bathe RST
get:ba<SEQ=
get:baand dis
get:baIf SND.
get:basecond chec
get:ba[Page 66]        
get:baSeptember 1981   
get:baIf the RS
get:baIf the :ACK was acceptable then signal the user "error
get:baconnect
get:badelete 
get:baand ret
get:bathird check
get:baIf the se
get:bamatch the
get:baIf ther
get:ba<SEQ=
get:baOtherwi
get:ba<SEQ=
get:baIf there 
get:baThe pre
get:baTCB, if
get:ba<SEQ=
get:baIf there 
get:baIf the 
get:bain the 
get:bathe pre
get:baallowed
get:ba<SEQ=
get:baIf the 
get:bain the 
get:baIf a rese
get:bafourth chec
get:baThis step
get:bano ACK, a
get:baIf the SY
get:baTransmission Cont
get:baFunctional Specif
get:baare accep
get:baSEG.SEQ. 
get:bais an ACK
get:baare there
get:baIf SND.UN
get:bastate to 
get:ba<SEQ=SN
get:baand send 
get:batransmiss
get:batext in t
get:babelow whe
get:baOtherwise
get:ba<SEQ=IS
get:baand send 
get:basegment, 
get:bahas been 
get:bafifth, if n
get:basegment and
get:ba[Page 68]        
get:baSeptember 1981   
get:bafirst check s
get:baSYN-RECEIVE
get:baESTABLISHED
get:baFIN-WAIT-1 
get:baFIN-WAIT-2 
get:baCLOSE-WAIT 
get:baCLOSING STA
get:baLAST-ACK ST
get:baTIME-WAIT S
get:baSegments 
get:baare used 
get:badone in S
get:baboundary 
get:baprocessed
get:baThere are
get:basegment
get:baSegment R
get:baLength  W
get:ba------- -
get:ba0     
get:ba0     
get:ba>0     
get:ba>0     
get:baIf the RC
get:baspecial a
get:baIf an inc
get:bashould be
get:bathe segme:nt and return)
get:ba<SEQ=SN
get:baAfter sen
get:baand retur
get:baTransmission Cont
get:baFunctional Specif
get:baIn the fo
get:basegment t
get:baOne could
get:batrimming 
get:baSYN and F
get:babegins at
get:banumbers m
get:basecond check 
get:baSYN-RECEIVE
get:baIf the RS
get:baIf this
get:bacame fr
get:baLISTEN 
get:bathis co
get:bafrom SY
get:bathe use
get:baon the 
get:baactive 
get:baand ret
get:baESTABLISHED
get:baIf the RS
get:bashould re
get:baflushed. 
get:ba"connecti
get:baTCB, and 
get:baCLOSING STA
get:baLAST-ACK ST
get:baIf the RS
get:baTCB, and 
get:ba[Page 70]        
get:baSeptember 1981   
get:bathird check s
get:baSYN-RECEIVE
get:baIf the se
get:baexactly m
get:bathen send
get:baESTABLISHED
get:baIf the se
get:baexactly m
get:bathen send
get:bareceive "
get:baflushed. 
get:ba"connecti
get:baTCB, and 
get:baNote this c
get:baa segment f
get:badifferent s
get:bacurrent con
get:bafourth, check
get:baSYN-RECEIVE
get:baESTABLISHED
get:baFIN-WAIT ST
get:baFIN-WAIT ST
get:baCLOSE-WAIT 
get:baCLOSING STA
get:baLAST-ACK ST
get:baTIME-WAIT S
get:baIf the SY
get:baoutstandi
get:baall segme
get:bareceive a
get:bathe CLOSE
get:baIf the SY
get:baand an ac
get:banumber ch
get:baTransmission Cont
get:baFunctional Specif
get:bafifth check t
get:baif the ACK 
get:baif the ACK 
get:baSYN-RECEI
get:baIf SND.
get:baand con
get:baIf th
get:bareset
get:ba<SE
get:baand s
get:baESTABLISH
get:baIf SND.
get:baAny seg
get:baentirel
get:bapositiv
get:bafully a
get:ba"ok" re
get:ba(SEG.AC
get:basomethi
get:badrop th
get:baIf SND.
get:baupdated
get:baSND.WL2
get:baSND.WL1
get:baNote th
get:barecords
get:baSND.WND
get:bathe las
get:baprevent
get:ba[Page 72]        
get:baSeptember 1981   
get:baFIN-WAIT-
get:baIn addi
get:baour FIN
get:baprocess
get:baFIN-WAIT-
get:baIn addi
get:bathe ret
get:baacknowl
get:baCLOSE-WAI
get:baDo the 
get:baCLOSING S
get:baIn addi
get:bathe ACK
get:baotherwi
get:baLAST-ACK 
get:baThe onl
get:baacknowl
get:badelete 
get:baTIME-WAIT
get:baThe onl
get:baretrans
get:bathe 2 M
get:basixth, check 
get:baESTABLISHED
get:baFIN-WAIT-1 
get:baFIN-WAIT-2 
get:baIf the UR
get:bathe user 
get:bapointer (
get:bauser has 
get:bamode") fo
get:basignal th
get:baTransmission Cont
get:baFunctional Specif
get:baCLOSE-WAIT 
get:baCLOSING STA
get:baLAST-ACK ST
get:baThis shou
get:baremote si
get:baseventh, proc
get:baESTABLISHED
get:baFIN-WAIT-1 
get:baFIN-WAIT-2 
get:baOnce in t
get:batext to u
get:bainto buff
get:baempty.  I
get:bathe user 
get:bahas been 
get:baWhen the 
get:bauser it m
get:baOnce the 
get:baRCV.NXT o
get:baapporopri
get:baRCV.NXT a
get:baPlease no
get:baSend an a:cknowledgment of the form
get:ba<SEQ=SN
get:baThis ackn
get:batransmitt
get:ba[Page 74]        
get:baSeptember 1981   
get:baCLOSE-WAIT 
get:baCLOSING STA
get:baLAST-ACK ST
get:baTIME-WAIT S
get:baThis shou
get:baremote si
get:baeighth, check
get:baDo not proc
get:basince the S
get:baIf the FIN 
get:bareturn any 
get:baover the FI
get:baFIN implies
get:baSYN-RECEI
get:baESTABLISH
get:baEnter t
get:baFIN-WAIT-
get:baIf our 
get:baenter T
get:batimers;
get:baFIN-WAIT-
get:baEnter t
get:baoff the
get:baCLOSE-WAI
get:baRemain 
get:baCLOSING S
get:baRemain 
get:baLAST-ACK 
get:baRemain 
get:baTransmission Cont
get:baFunctional Specif
get:baTIME-WAIT
get:baRemain 
get:batimeout
get:ba[Page 76]        
get:baSeptember 1981   
get:baFor any state
get:bathe user "err:or
get:baand for any o
get:bastate and ret
get:baRETRANSMISSION 
get:baFor any state
get:bathe retransmi
get:baretransmissio
get:baTIME-WAIT TIMEO
get:baIf the time-w
get:baenter the CLO
get:baTransmission Cont
get:ba[Page 78]        
get:baSeptember 1981   
get:baBBN Rep
get:baa Host 
get:bahost an
get:baA contr
get:baindicat
get:baspecifi
get:bais expe
get:bapreviou
get:baThe uni
get:baARPANET
get:baA unit 
get:baIMPs.  
get:baA logic
get:baA messa
get:banetwork
get:baDestination Addre
get:baThe des
get:baidentif
get:baA contr
get:baindicat
get:baoccupyi
get:baA porti
get:bafragmen
get:baA file 
get:baTransmission Cont
get:baControl
get:bafragmen
get:baA compu
get:bafrom th
get:baAn Inte
get:baby the 
get:baThe Int
get:baARPANET
get:baA sourc
get:bainternet datagram
get:baThe uni
get:bahigher 
get:bainternet fragment
get:baA porti
get:baheader.
get:baInterne
get:baThe Ini
get:banumber 
get:baThe Ini
get:baon a co
get:babased p
get:baThe Ini
get:baused by
get:baControl
get:badata.  
get:baon an A
get:ba[Page 80]        
get:baSeptember 1981   
get:baThis is
get:badata re
get:basequenc
get:baof the 
get:baThe uni
get:baAn impl
get:baprocedu
get:baMaximum
get:bathe int
get:baAn eigh
get:baAn Opti
get:bamay be 
get:baprimari
get:batimesta
get:baoptions
get:baA packa
get:balogical
get:balogical
get:baThe por
get:baoutput 
get:baA progr
get:bathe poi
get:baA contr
get:bathis se
get:bareceivi
get:bareceive
get:baTransmission Cont
get:bareceive
get:RFC
get:De
get:I
get:September 1981   
get:PREFACE .....
get:1.  INTRODUCTION 
get:1.1  Motivation
get:1.2  Scope ....
get:1.3  About This
get:1.4  Interfaces
get:1.5  Operation 
get:2.  PHILOSOPHY ..
get:2.1  Elements o
get:2.2  Model of O
get:2.3  The Host E
get:2.4  Interfaces
get:2.5  Relation t
get:2.6  Reliable C
get:2.7  Connection
get:2.8  Data Commu
get:2.9  Precedence
get:2.10 Robustness
get:3.  FUNCTIONAL SP
get:3.1  Header For
get:3.2  Terminolog
get:3.3  Sequence N
get:3.4  Establishi
get:3.5  Closing a 
get:3.6  Precedence
get:3.7  Data Commu
get:3.8  Interfaces
get:3.9  Event Proc
get:GLOSSARY ........
get:REFERENCES ......
get:Transmission Cont
get:[Page ii]        
get:September 1981   
get:This document des
get:(TCP).  There hav
get:specification on 
get:draws heavily fro
get:both in terms of 
get:several details a
get:and redescribes t
get:RFC
get:Replaces: RFC 761
get:IENs:  129, 124, 
get:55, 44, 40, 27, 2
get:The Transmission 
get:reliable host-to-
get:communication net
get:This document des
get:Transmission Cont
get:interface to prog
get:Computer commun
get:role in militar
get:document focuse
get:communication r
get:communication u
get:congestion, but
get:government sect
get:As strategic an
get:developed and d
get:interconnecting
get:communication p
get:applications.  
get:Deputy Undersec
get:declared the Tr
get:be a basis for 
get:standardization
get:TCP is a connec
get:fit into a laye
get:applications.  
get:communication b
get:distinct but in
get:assumptions are
get:protocols below
get:potentially unr
get:protocols.  In 
get:wide spectrum o
get:connections to 
get:Transmission Cont
get:TCP is based on
get:TCP fits into a
get:Internet Protoc
get:receive variabl
get:datagram "envel
get:addressing sour
get:internet protoc
get:the TCP segment
get:multiple networ
get:also carries in
get:and compartment
get:communicated en
get:Much of this do
get:which are co-re
get:computer.  Some
get:front-end compu
get:as well as netw
get:an interface to
get:implementable e
get:host-to-front e
get:The TCP is inte
get:communication s
get:intended to be 
get:1.3.  About this 
get:This document r
get:any TCP impleme
get:protocols and i
get:[Page 2]         
get:September 1981   
get:section offers 
get:operation.  Sec
get:design.  Sectio
get:required of TCP
get:user calls, err
get:The TCP interfa
get:the other side 
get:The interface b
get:illustrated in 
get:calls much like
get:application pro
get:calls to open a
get:established con
get:asynchronously 
get:considerable fr
get:interfaces whic
get:environment, a 
get:interface for a
get:The interface b
get:unspecified exc
get:two levels can 
get:Typically, one 
get:interface.  TCP
get:interconnected 
get:throughout this
get:As noted above,
get:securable logic
get:processes.  To 
get:communication s:ystem requires facilities in the following areas
get:Basic Data Tr
get:Precedence an
get:The basic opera
get:the following p
get:Transmission Cont
get:Basic Data Tran:sfer
get:The TCP is ab
get:direction bet
get:segments for 
get:the TCPs deci
get:Sometimes use
get:submitted to 
get:function is d
get:actually tran
get:pushed throug
get:promptly forw
get:The exact pus
get:the push func
get:Reliability
get:The TCP must 
get:delivered out
get:is achieved b
get:transmitted, 
get:receiving TCP
get:interval, the
get:numbers are u
get:out of order 
get:adding a chec
get:receiver, and
get:As long as th
get:system does n
get:errors will a
get:internet comm
get:Flow Control
get:TCP provides 
get:sent by the s
get:every ACK ind
get:the last segm
get:allowed numbe
get:receiving fur
get:[Page 4]         
get:September 1981   
get:Multiplexing
get:To allow for 
get:communication
get:addresses or 
get:and host addr
get:a socket.  A 
get:That is, a so
get:The binding o
get:Host.  Howeve
get:(e.g., a "log
get:made known to
get:through the k
get:addresses of 
get:Connections
get:The reliabili
get:that TCPs ini
get:each data str
get:sockets, sequ
get:Each connecti
get:identifying i
get:When two proc
get:establish a c
get:side).  When 
get:terminated or
get:Since connect
get:over the unre
get:mechanism wit
get:erroneous ini
get:Precedence and :Security
get:The users of 
get:communication
get:these feature
get:Transmission Cont
get:[Page 6]         
get:September 1981   
get:2.1.  Elements of
get:The internetwor
get:which are in tu
get:that the networ
get:large networks 
get:packet switchin
get:consume message
get:networks, the g
get:communication s
get:connections bet
get:The term packet
get:transaction bet
get:exchanged withi
get:Hosts are compu
get:network's point
get:Processes are v
get:accordance with
get:in execution). 
get:viewed as commu
get:Thus, all commu
get:Since a process
get:streams between
get:that each proce
get:communicates wi
get:2.2.  Model of Op
get:Processes trans
get:data as argumen
get:segments and ca
get:the destination
get:into the receiv
get:TCPs include co
get:ensure reliable
get:The model of in
get:protocol module
get:to the local ne
get:inside internet
get:internet module
get:through the loc
get:The packet swit
get:Transmission Cont
get:other operation
get:destination int
get:At a gateway be
get:from its local 
get:the internet da
get:then "wrapped" 
get:routed to the n
get:A gateway is pe
get:internet datagr
get:through the nex
get:internet datagr
get:further broken 
get:internet datagr
get:internet module
get:A destination i
get:(after reassemb
get:destination TCP
get:This simple mod
get:important featu
get:to the gateway 
get:service paramet
get:Included in the
get:datagram.  Data
get:host and gatewa
get:properly segreg
get:2.3.  The Host En
get:The TCP is assu
get:access the TCP 
get:may call on oth
get:data structures
get:controlled by a
get:network device 
get:datagram protoc
get:The mechanisms 
get:front-end proce
get:host-to-front-e
get:the type of TCP
get:[Page 8]         
get:September 1981   
get:The TCP/user in
get:to OPEN or CLOS
get:STATUS about a 
get:programs on the
get:from, and close
get:The TCP/interne
get:datagrams addre
get:system.  These 
get:service, preced
get:2.5.  Relation to
get:The following d
get:hierarchy
get:+------+ +
get:|Telnet| |
get:+------+ +
get:|   
get:+----
get:| TCP
get:+----
get:| 
get:+----
get:|    
get:+----
get:+--
get:|  
get:+--
get:It is expected 
get:protocols effic
get:protocols like 
get:2.6.  Reliable Co
get:A stream of dat
get:order at the de
get:Transmission Cont
get:Transmission is
get:acknowledgments
get:sequence number
get:segment is tran
get:sequence number
get:is the sequence
get:transmissions i
get:segment contain
get:starts a timer;
get:segment is dele
get:received before
get:An acknowledgme
get:delivered to th
get:the responsibil
get:To govern the f
get:employed.  The 
get:This window spe
get:acknowledgment 
get:2.7.  Connection 
get:To identify the
get:provides a port
get:independently b
get:unique addresse
get:identifying the
get:will be unique 
get:A connection is
get:local socket ma
get:sockets.  A con
get:that is, it is 
get:TCPs are free t
get:However, severa
get:There must be w
get:the "appropriat
get:may "own" ports
get:the ports they 
get:issue, but we e
get:uniquely alloca
get:associating the
get:A connection is
get:foreign socket 
get:[Page 10]        
get:September 1981   
get:connection name
get:subsequent call
get:about a connect
get:is a data struc
get:implementation 
get:pointer to the 
get:whether the con
get:be passively wa
get:A passive OPEN 
get:connection requ
get:Often the proce
get:request from an
get:is used to deno
get:are allowed onl
get:A service proce
get:processes would
get:foreign socket.
get:requested a con
get:local socket we
get:Well-known sock
get:a socket addres
get:"Telnet-Server"
get:socket, and oth
get:Entry, Text Gen
get:being for test 
get:access to a "Lo
get:at which a newl
get:well-known sock
get:of sockets to s
get:Processes can i
get:from other proc
get:been establishe
get:other at the sa
get:is critical for
get:components act 
get:There are two p
get:passive OPENs a
get:local passive O
get:case, the match
get:OPENs has left 
get:foreign socket 
get:Other possibili
get:Transmission Cont
get:If there are se
get:same local sock
get:with the specif
get:TCB exists, bef
get:The procedures 
get:control flag an
get:exchange has be
get:A connection is
get:containing a SY
get:command.  The m
get:connection has 
get:when sequence n
get:The clearing of
get:in this case ca
get:2.8.  Data Commun
get:The data that f
get:octets.  The se
get:in that call (a
get:through to the 
get:A sending TCP i
get:send that data 
get:function is sig
get:receiving TCP s
get:the sending TCP
get:There is no nec
get:boundaries.  Th
get:single SEND cal
get:The purpose of 
get:from the sendin
get:record service.
get:There is a coup
get:of data that cr
get:associated with
get:buffer is retur
get:not filled.  If
get:PUSH is seen, t
get:TCP also provid
get:at some point f
get:[Page 12]        
get:September 1981   
get:currently readi
get:define what the
get:urgent data, bu
get:take action to 
get:2.9.  Precedence 
get:The TCP makes u
get:security option
get:basis to TCP us
get:a multilevel se
get:use only, and o
get:compartment.  C
get:users may be li
get:TCP modules whi
get:properly mark o
get:precedence.  Su
get:higher level pr
get:them to specify
get:precedence of c
get:2.10.  Robustness
get:TCP implementat:ions will follow a general principle of robustness
get:conservative in
get:Transmission Cont
get:[Page 14]        
get:September 1981   
get:3.1.  Header Form
get:TCP segments ar
get:header carries 
get:destination hos
get:header, supplyi
get:division allows
get:TCP Header Form
get:0            
get:0 1 2 3 4 5 6
get:+-+-+-+-+-+-+-
get:|          Sou
get:+-+-+-+-+-+-+-
get:|             
get:+-+-+-+-+-+-+-
get:|             
get:+-+-+-+-+-+-+-
get:|  Data |     
get:| Offset| Rese
get:|       |     
get:+-+-+-+-+-+-+-
get:|           Ch
get:+-+-+-+-+-+-+-
get:|             
get:+-+-+-+-+-+-+-
get:|             
get:+-+-+-+-+-+-+-
get:Note th
get:Source Port:  1
get:The source po
get:Destination Por:t
get:The destinati
get:Transmission Cont
get:Functional Specif
get:Sequence Number:
get:The sequence 
get:when SYN is p
get:initial seque
get:Acknowledgment :Number
get:If the ACK co
get:next sequence
get:receive.  Onc
get:Data Offset:  4
get:The number of
get:the data begi
get:integral numb
get:Reserved:  6 bi
get:Reserved for 
get:Control Bits:  :6 bits (from left to right)
get:URG:  Urgent 
get:ACK:  Acknowl
get:PSH:  Push Fu
get:RST:  Reset t
get:SYN:  Synchro
get:FIN:  No more
get:Window:  16 bit
get:The number of
get:acknowledgmen
get:Checksum:  16 b
get:The checksum 
get:complement su
get:segment conta
get:checksummed, 
get:form a 16 bit
get:transmitted a
get:the checksum 
get:The checksum 
get:[Page 16]        
get:September 1981   
get:prefixed to t
get:Address, the 
get:This gives th
get:information i
get:across the TC
get:calls by the 
get:The TCP Len
get:octets (thi
get:computed), 
get:Urgent Pointer:
get:This field co
get:positive offs
get:urgent pointe
get:the urgent da
get:the URG contr
get:Options:  varia
get:Options may o
get:multiple of 8
get:checksum.  An
get:cases for the: format of an option
get:Case 1:  A 
get:Case 2:  An
get:th
get:The option-le
get:option-length
get:Note that the
get:field might i
get:End-of-Option
get:A TCP must im
get:Transmission Cont
get:Functional Specif
get:Currently def:ined options include (kind indicated in octal)
get:Kind     Le
get:----     --
get:0         
get:1         
get:2         
get:Specific Opti
get:End of Opti
get:+--------
get:|00000000
get:+--------
get:This opti
get:might not
get:the Data 
get:not the e
get:the optio
get:No-Operatio
get:+--------
get:|00000001
get:+--------
get:This opti
get:align the
get:There is 
get:receivers
get:not begin
get:Maximum Seg
get:+--------
get:|00000010
get:+--------
get:Kind=2  
get:[Page 18]        
get:September 1981   
get:Maximum S:egment Size Option Data
get:If this
get:receive
get:This fi
get:(i.e., 
get:option 
get:Padding:  varia
get:The TCP heade
get:and data begi
get:3.2.  Terminology
get:Before we can d
get:to introduce so
get:connection requ
get:of these variab
get:Transmission Co
get:TCB are the loc
get:precedence of t
get:buffers, pointe
get:In addition sev
get:sequence number
get:Send Sequence
get:SND.UNA - s
get:SND.NXT - s
get:SND.WND - s
get:SND.UP  - s
get:SND.WL1 - s
get:SND.WL2 - s
get:u
get:ISS     - i
get:Receive Seque
get:RCV.NXT - r
get:RCV.WND - r
get:RCV.UP  - r
get:IRS     - i
get:Transmission Cont
get:Functional Specif
get:The following d
get:the sequence sp
get:Send Sequence S
get:---
get:1 - old s
get:2 - seque
get:3 - seque
get:4 - futur
get:The send window
get:Receive Sequenc
get:1 - old s
get:2 - seque
get:3 - futur
get:The receive win
get:There are also 
get:take their valu
get:[Page 20]        
get:September 1981   
get:Current Segme
get:SEG.SEQ - s
get:SEG.ACK - s
get:SEG.LEN - s
get:SEG.WND - s
get:SEG.UP  - s
get:SEG.PRC - s
get:A connection pr
get:lifetime.  The :states are
get:ESTABLISHED, FI
get:TIME-WAIT, and 
get:because it repr
get:no connection. : Briefly the meanings of the states are
get:LISTEN - repr
get:TCP and port.
get:SYN-SENT - re
get:after having 
get:SYN-RECEIVED 
get:request ackno
get:connection re
get:ESTABLISHED -
get:delivered to 
get:of the connec
get:FIN-WAIT-1 - 
get:from the remo
get:termination r
get:FIN-WAIT-2 - 
get:from the remo
get:CLOSE-WAIT - 
get:from the loca
get:CLOSING - rep
get:acknowledgmen
get:LAST-ACK - re
get:connection te
get:(which includ
get:Transmission Cont
get:Functional Specif
get:TIME-WAIT - r
get:the remote TC
get:termination r
get:CLOSED - repr
get:A TCP connectio
get:events.  The ev
get:ABORT, and STAT
get:containing the 
get:The state diagr
get:with the causin
get:error condition
get:changes.  In a 
get:the reaction of
get:NOTE BENE:  thi
get:the total speci
get:[Page 22]        
get:September 1981   
get:+---------+     
get:|         |<----
get:|   SYN   |     
get:|   RCVD  |<----
get:|         |     
get:|         |-----
get:+---------+   rc
get:|           --
get:|             
get:|             
get:|  CLOSE      
get:| -------     
get:| snd FIN     
get:|             
get:V             
get:+---------+     
get:|  FIN    |<----
get:| WAIT-1  |-----
get:+---------+     
get:| rcv ACK of F
get:| ------------
get:V        x    
get:+---------+     
get:|FINWAIT-2|     
get:+---------+     
get:|             
get:|  rcv FIN    
get:|  -------    
get:\ snd ACK    
get:------------
get:Transmission Cont
get:Functional Specif
get:3.3.  Sequence Nu
get:A fundamental n
get:over a TCP conn
get:sequenced, each
get:mechanism emplo
get:number X indica
get:received.  This
get:detection in th
get:within a segmen
get:the header is t
get:numbered consec
get:It is essential
get:finite, though 
get:Since the space
get:numbers must be
get:preserves the r
get:2**32 - 1 to 0 
get:arithmetic, so 
get:comparison of s
get:(modulo 2**32).
get:The typical kin
get:perform include:
get:(a)  Determin
get:number s
get:(b)  Determin
get:have bee
get:retransm
get:(c)  Determin
get:which ar
get:receive 
get:[Page 24]        
get:September 1981   
get:In response to 
get:following compa
get:SND.UNA = old
get:SND.NXT = nex
get:SEG.ACK = ack
get:num
get:SEG.SEQ = fir
get:SEG.LEN = the
get:(co
get:SEG.SEQ+SEG.L
get:A new acknowled
get:the inequality :below holds
get:SND.UNA < SEG
get:A segment on th
get:of its sequence
get:acknowledgment 
get:When data is re:ceived the following comparisons are needed
get:RCV.NXT = nex
get:is the le
get:RCV.NXT+RCV.W
get:segment, 
get:SEG.SEQ = fir
get:SEG.SEQ+SEG.L
get:A segment is ju
get:RCV.NXT =< SE
get:RCV.NXT =< SE
get:Transmission Cont
get:Functional Specif
get:The first part 
get:segment falls i
get:if the end of t
get:either part of 
get:Actually, it is
get:windows and zer
get:acceptability o:f an incoming segment
get:Segment Recei
get:Length  Windo
get:------- -----
get:0       0 
get:0      >0 
get:>0       0 
get:>0      >0 
get:Note that when 
get:acceptable exce
get:maintain a zero
get:ACKs.  However,
get:process the RST
get:We have taken a
get:control informa
get:some control fl
get:and acknowledge
get:control will be
get:carried in the 
get:for implicitly 
get:are the only co
get:are used only a
get:purposes, the S
get:octet of the se
get:to occur after 
get:occurs.  The se
get:space occupying
get:sequence number
get:[Page 26]        
get:September 1981   
get:Initial Sequenc
get:The protocol pl
get:used over and o
get:sockets.  New i
get:incarnations of
get:-- "how does th
get:incarnations of
get:connection is b
get:connection brea
get:To avoid confus
get:connection from
get:be present in t
get:assure this, ev
get:sequence number
get:an initial sequ
get:new 32 bit ISN.
get:bit clock whose
get:microseconds.  
get:Since we assume
get:the Maximum Seg
get:hours we can re
get:For each connec
get:sequence number
get:the data sendin
get:learned during 
get:For a connectio
get:synchronize on 
get:an exchange of 
get:called "SYN" (f
get:shorthand, segm
get:Hence, the solu
get:initial sequenc
get:The synchroniza
get:sequence number
get:from the other 
get:initial sequenc
get:1) A --> B  S
get:2) A <-- B  A
get:3) A <-- B  S
get:4) A --> B  A
get:Transmission Cont
get:Functional Specif
get:Because steps 2
get:called the thre
get:A three way han
get:tied to a globa
get:mechanisms for 
get:no way of knowi
get:unless it remem
get:(which is not a
get:verify this SYN
get:clock-driven sc
get:Knowing When to
get:To be sure that
get:sequence number
get:the network, th
get:(MSL) before as
get:recovering from
get:lost.  For this
get:is an engineeri
get:it is desirable
get:sense, yet reta
get:not wait at all
get:than those rece
get:The TCP Quiet T
get:This specific
get:retaining any
get:each active (
get:TCP segments 
get:in the intern
get:paragraphs be
get:TCP implement
get:at the risk o
get:data rejected
get:TCPs consume 
get:entered into 
get:duplicate det
get:relies on the
get:the extent th
get:values before
get:been delivere
get:copies of the
get:such an assum
get:[Page 28]        
get:September 1981   
get:assigned the 
get:at the receiv
get:that each seg
get:as there are 
get:Under normal 
get:to emit and t
get:mistakenly us
get:been acknowle
get:data is drain
get:very large to
get:cause trouble
get:to use up 2**
get:lifetime in t
get:this is deeme
get:rates escalat
get:cycle time is
get:within reason
get:The basic dup
get:defeated, how
get:sequence numb
get:the TCP were 
get:upon crashing
get:connection (p
get:packets with 
get:packets still
get:incarnation o
get:about the seq
get:specification
get:before emitti
get:segments from
get:Even hosts wh
get:initial seque
get:(i.e., even i
get:number for ea
get:Suppose, for 
get:sequence numb
get:and that even
get:takes on a va
get:segment sent 
get:at this insta
get:incarnation o
get:S1 = ISN(t) -
get:connection!  
get:Transmission Cont
get:Functional Specif
get:duplicates in
get:of S1 may arr
get:the new incar
get:The problem i
get:crashed nor d
get:the system fr
get:One way to de
get:segments for 
get:time" specifi
get:willing to ri
get:destination m
get:Implementors 
get:connection by
get:informally im
get:Obviously, ev
get:necessary aft
get:To summarize:
get:numbers in th
get:"busy" or "in
get:block of spac
get:segment, if a
get:sequence numb
get:the previous 
get:number overla
get:3.4.  Establishin
get:The "three-way 
get:connection.  Th
get:responded to by
get:simultaneously 
get:occurs, each TC
get:acknowledgment 
get:an old duplicat
get:recipient, that
get:Proper use of "
get:Several example
get:examples do not
get:segments, this 
get:doesn't deliver
get:valid (i.e., th
get:connection reac
get:reduces the pos
get:[Page 30]        
get:September 1981   
get:implementation 
get:information for
get:The simplest th
get:figures should 
get:numbered for re
get:departure of a 
get:segment at B fr
get:Ellipsis (...) 
get:(delayed).  An 
get:Comments appear
get:the departure o
get:the center of e
get:form, with sequ
get:fields such as 
get:in the interest
get:TCP A      
get:1.  CLOSED     
get:2.  SYN-SENT   
get:3.  ESTABLISHED
get:4.  ESTABLISHED
get:5.  ESTABLISHED
get:Basic 3
get:In line 2 of fi
get:indicating that
get:number 100.  In
get:received from T
get:B is now expect
get:occupied sequen
get:At line 4, TCP 
get:TCP B's SYN; an
get:sequence number
get:because the ACK
get:would wind up A
get:Transmission Cont
get:Functional Specif
get:Simultaneous in
get:figure 8.  Each
get:TCP A      
get:1.  CLOSED     
get:2.  SYN-SENT   
get:3.  SYN-RECEIVE
get:4.             
get:5.  SYN-RECEIVE
get:6.  ESTABLISHED
get:7.             
get:S
get:The principle r
get:duplicate conne
get:this, a special
get:receiving TCP i
get:SYN-RECEIVED), 
get:If the TCP is i
get:FIN-WAIT-1, FIN
get:aborts the conn
get:case under "hal
get:[Page 32]        
get:September 1981   
get:TCP A      
get:1.  CLOSED     
get:2.  SYN-SENT   
get:3.  (duplicate)
get:4.  SYN-SENT   
get:5.  SYN-SENT   
get:6.             
get:7.  SYN-SENT   
get:8.  ESTABLISHED
get:As a simple exa
get:figure 9.  At l
get:cannot tell tha
get:(line 4).  TCP 
get:RST (reset) wit
get:believable.  TC
get:When the origin
get:synchronization
get:before the RST,
get:sent in both di
get:Half-Open Conne
get:An established 
get:TCPs has closed
get:knowledge of th
get:become desynchr
get:memory.  Such c
get:attempt is made
get:connections are
get:mildly involved
get:If at site A th
get:Transmission Cont
get:Functional Specif
get:user at site B 
get:receiving a res
get:site B TCP that
get:Assume that two
get:another when a 
get:Depending on th
get:that some error
get:A is likely to 
get:point.  As a re
get:or try to SEND 
get:case, it receiv
get:local (A's) TCP
get:will send a seg
get:example shown i
get:re-open the con
get:TCP A      
get:1.  (CRASH)    
get:2.  CLOSED     
get:3.  SYN-SENT --
get:4.  (!!)     <-
get:5.  SYN-SENT --
get:6.  SYN-SENT   
get:7.  SYN-SENT --
get:When the SYN ar
get:and the incomin
get:acknowledgment 
get:100).  TCP A se
get:sent and, being
get:detected a half
get:[Page 34]        
get:September 1981   
get:continue to try
get:reduced to the 
get:An interesting 
get:tries to send d
get:This is illustr
get:TCP A from TCP 
get:exists, so TCP 
get:processes it an
get:TCP A    
get:1.  (CRASH)    
get:2.  (??)    <--
get:3.          -->
get:Active
get:In figure 12, w
get:waiting for SYN
get:into action.  A
get:generate a RST 
get:the reset and r
get:TCP A      
get:1.  LISTEN     
get:2.       ... <S
get:3.  (??) <-- <S
get:4.       --> <S
get:5.  LISTEN     
get:Old Duplic
get:Transmission Cont
get:Functional Specif
get:A variety of ot
get:by the followin
get:Reset Generatio
get:As a general ru
get:which apparentl
get:must not be sen
get:There are three: groups of states
get:1.  If the co
get:in response t
get:particular, S
get:by this means
get:If the incomi
get:sequence numb
get:reset has seq
get:of the sequen
get:The connectio
get:2.  If the co
get:SYN-SENT, SYN
get:something not
get:if an incomin
get:does not exac
get:connection, a
get:If our SYN ha
get:incoming segm
get:either raise 
get:the system) o
get:incoming segm
get:continue as i
get:cannot raise 
get:detected in t
get:terminated th
get:incoming segm
get:match the loc
get:must be sent.
get:If the incomi
get:sequence numb
get:reset has seq
get:of the sequen
get:The connectio
get:[Page 36]        
get:September 1981   
get:3.  If the co
get:FIN-WAIT-1, F
get:any unaccepta
get:unacceptible 
get:acknowledgmen
get:and an acknow
get:to be receive
get:If an incomin
get:precedence wh
get:and precedenc
get:connection go
get:number from t
get:Reset Processin
get:In all states e
get:by checking the
get:is in the windo
get:to an initial S
get:acknowledges th
get:The receiver of
get:receiver was in
get:in SYN-RECEIVED
get:then the receiv
get:aborts the conn
get:was in any othe
get:and goes to the
get:3.5.  Closing a C
get:CLOSE is an ope
get:notion of closi
get:interpretation,
get:the receiving s
get:in a simplex fa
get:until he is tol
get:could initiate 
get:RECEIVE until s
get:has CLOSED.  We
get:RECEIVEs are ou
get:can terminate h
get:buffers SENT be
get:data in return 
get:successfully to
get:TCP.  Users mus
get:the TCP says no
get:Transmission Cont
get:Functional Specif
get:There are essen:tially three cases
get:1) The user i
get:2) The remote
get:3) Both users
get:Case 1:  Local 
get:In this case,
get:outgoing segm
get:accepted by t
get:are allowed i
get:will be retra
get:both acknowle
get:can ACK this 
get:send its own 
get:Case 2:  TCP re
get:If an unsolic
get:can ACK it an
get:user will res
get:the other TCP
get:until its own
get:connection.  
get:the connectio
get:Case 3:  both u
get:A simultaneou
get:FIN segments 
get:have been pro
get:has received.
get:[Page 38]        
get:September 1981   
get:TCP A      
get:1.  ESTABLISHED
get:FIN-WAIT-1 
get:3.  FIN-WAIT-2 
get:4.             
get:TIME-WAIT  
get:5.  TIME-WAIT  
get:CLOSED     
get:TCP A      
get:1.  ESTABLISHED
get:2.  (Close)    
get:FIN-WAIT-1 
get:3.  CLOSING    
get:4.  TIME-WAIT  
get:(2 MSL)    
get:CLOSED     
get:Transmission Cont
get:Functional Specif
get:3.6.  Precedence 
get:The intent is t
get:with exactly th
get:higher of the p
get:The precedence 
get:defined in the 
get:specification t
get:the security pa
get:user group, and
get:A connection at
get:lower precedenc
get:a connection du
get:acknowledgment 
get:Note that TCP m
get:precedence will
get:segments and po
get:The security pa
get:(the values wou
get:non-secure envi
get:parameters, tho
get:3.7.  Data Commun
get:Once the connec
get:exchange of seg
get:(checksum test 
get:retransmission 
get:Duplicate segme
get:As discussed in
get:certain tests o
get:segments to ver
get:The sender of d
get:the variable SN
get:sequence number
get:keeps track of 
get:variable SND.UN
get:sent has been a
get:When the sender
get:SND.NXT.  When 
get:sends an acknow
get:[Page 40]        
get:September 1981   
get:acknowledgment 
get:these variables
get:The amount by w
get:data in the seg
get:segments must c
get:The CLOSE user 
get:flag in an inco
get:Retransmission 
get:Because of the 
get:internetwork sy
get:retransmission 
get:for determining
get:An Example Re
get:Measure the
get:particular 
get:covers that
get:segments re
get:Time (RTT).:  Next compute a Smoothed Round Trip Time (SRTT) as
get:SRTT = ( 
get:and based o:n this, compute the retransmission timeout (RTO) as
get:RTO = min
get:where UBOUN
get:LBOUND is a
get:a smoothing
get:factor (e.g
get:The Communicati
get:The objective o
get:to stimulate th
get:permit the rece
get:the currently k
get:This mechanism 
get:the end of urge
get:the receive seq
get:must tell the u
get:number catches 
get:Transmission Cont
get:Functional Specif
get:into "normal mo
get:is in "urgent m
get:The method empl
get:transmitted.  T
get:meaningful and 
get:the urgent poin
get:no urgent data 
get:To send an urge
get:octet.  If the 
get:the urgent info
get:Managing the Wi
get:The window sent
get:numbers the sen
get:prepared to acc
get:the currently a
get:Indicating a la
get:arrives than ca
get:in excessive re
get:network and the
get:transmission of
get:between each ne
get:The mechanisms 
get:subsequently ad
get:that much data.
get:discouraged.  T
get:shrink the wind
get:on the part of 
get:The sending TCP
get:least one octet
get:sending TCP mus
get:the window is z
get:interval when t
get:guarantee that 
get:window will be 
get:When the receiv
get:still send an a
get:and current win
get:The sending TCP
get:[Page 42]        
get:September 1981   
get:which fit the c
get:retransmission 
get:In a connection
get:be carried in a
get:number so there
get:order.  This is
get:information to 
get:the data receiv
get:the window info
get:acknowledgment 
get:equal or greate
get:The window mana
get:communication p
get:Window Manage
get:Allocating 
get:many small 
get:fewer large
get:One suggest
get:defer updat
get:least X per
get:connection 
get:Another sug
get:segments by
get:sending dat
get:data must b
get:Note that t
get:retransmiss
get:acknowledgm
get:window info
get:new window 
get:The segment
get:of transmit
get:segment con
get:is accepted
get:If the send
get:window is n
get:alternating
get:pauses in t
get:Transmission Cont
get:Functional Specif
get:result in b
get:big pair. A
get:mostly smal
get:The suggest
get:actively at
get:windows, si
get:to many sma
get:There are of co:urse two interfaces of concern
get:and the TCP/low
get:of the user/TCP
get:protocol module
get:in detail by th
get:case that the l
get:that TCPs might
get:User/TCP Interf
get:The following
get:at best, fict
get:facilities.  
get:implementatio
get:TCPs must pro
get:that all TCP 
get:hierarchy.  T
get:required of a
get:TCP User Comm
get:The followi
get:interface. 
get:function ca
get:meant to ru
get:The user co
get:TCP must pe
get:Individual 
get:may provide
get:single call
get:automatical
get:issued by t
get:[Page 44]        
get:September 1981   
get:In providin
get:not only ac
get:processes i:t serves.  The latter consists of
get:(a) gener
get:remote cl
get:(b) repli
get:various t
get:Format:  
get:[, timeou
get:-> local 
get:We assume
get:processes
get:to use th
get:implement
get:for the s
get:lower lev
get:result of
get:able to m
get:process c
get:If the ac
get:call to L
get:have eith
get:particula
get:for any c
get:by the su
get:A transmi
get:filled in
get:On an act
get:synchroni
get:The timeo
get:for all d
get:delivered
get:will abor
get:The TCP o
get:the users
get:Transmission Cont
get:Functional Specif
get:precedenc
get:or securi
get:the defau
get:TCP will 
get:security/
get:the prece
get:requested
get:The prece
get:requested
get:request, 
get:connectio
get:this prec
get:allowed t
get:or that a
get:A local c
get:The local
get:for the c
get:Format:  
get:count, PU
get:This call
get:to be sen
get:not been 
get:implement
get:automatic
get:authorize
get:If the PU
get:to the re
get:segment c
get:the data 
get:transmiss
get:If the UR
get:will have
get:the urgen
get:pointer i
get:been cons
get:is to sti
get:indicate 
get:[Page 46]        
get:September 1981   
get:data has 
get:TCP signa
get:of times 
get:urgent da
get:If no for
get:connectio
get:has becom
get:local soc
get:foreign s
get:foreign s
get:knowing t
get:However, 
get:becomes s
get:STATUS ca
get:implement
get:socket is
get:If a time
get:connectio
get:In the si
get:the sendi
get:or the ti
get:is both s
get:connectio
get:offers po
get:sophistic
get:the proce
get:furthermo
get:Multiple 
get:the TCP w
get:We have i
get:which a S
get:pseudo-in
get:return a 
get:immediate
get:been ackn
get:assume ev
get:close any
get:kind (syn
get:signals, 
get:with spec
get:In order 
get:indicatio
get:Transmission Cont
get:Functional Specif
get:buffer ad
get:the SEND 
get:indicatin
get:calling p
get:Format:  
get:count) ->
get:This comm
get:specified
get:calling p
get:error is 
get:In the si
get:calling p
get:error occ
get:A more so
get:RECEIVEs 
get:segments 
get:the cost 
get:notify th
get:If enough
get:the PUSH 
get:The buffe
get:a PUSH is
get:returned 
get:If there 
get:as it arr
get:should th
get:additiona
get:call to R
get:may now l
get:urgent po
get:in the sa
get:boundary 
get:To distin
get:care of t
get:return co
get:count ind
get:Alternati
get:[Page 48]        
get:September 1981   
get:allocate 
get:with the 
get:Format:  
get:This comm
get:the conne
get:authorize
get:Closing c
get:the sense
get:retransmi
get:serviced.
get:calls, fo
get:to the de
get:continue 
get:may be tr
get:means "I 
get:receive a
get:not well 
get:of all it
get:into ABOR
get:The user 
get:initiativ
get:(e.g., re
get:destinati
get:Because c
get:foreign T
get:short tim
get:replies t
get:Close als
get:Format:  
get:This is a
get:excluded 
get:typically
get:This comm
get:informati:on
get:local s
get:Transmission Cont
get:Functional Specif
get:foreign
get:local c
get:receive
get:send wi
get:connect
get:number 
get:number 
get:urgent 
get:precede
get:securit
get:and tra
get:Depending
get:implement
get:available
get:authorize
get:prevents 
get:connectio
get:Format:  
get:This comm
get:aborted, 
get:be sent t
get:Depending
get:indicatio
get:receive a
get:TCP-to-User M
get:It is assum
get:means for t
get:the TCP doe
get:to the user
get:an error me
get:relating to
get:other user 
get:The followi:ng information is provided
get:Local Con
get:Response 
get:Buffer Ad
get:Byte coun
get:Push flag
get:Urgent fl
get:[Page 50]        
get:September 1981   
get:TCP/Lower-Level
get:The TCP calls
get:receive infor
get:internetwork 
get:Protocol (IP)
get:If the lower 
get:of service an
get:for these par:ameters
get:Type of Ser:vice = Precedence: routine, Delay: normal, Throughput
get:normal, Rel:iability
get:Time to Liv
get:Note that
get:Here we e
get:be delive
get:If the lower 
get:feature) and 
get:route informa
get:so that the s
get:checksum be t
get:also importan
get:Any lower lev
get:destination a
get:the "TCP leng
get:of IP and to 
get:Transmission Cont
get:Functional Specif
get:3.9.  Event Proce
get:The processing 
get:implementation.
get:processing sequ
get:section only in
get:The activity of
get:The events that: occur can be cast into three categories
get:arriving segmen
get:processing the 
get:cases the proce
get:Events that o:ccur
get:Arriving Se
get:SEGMENT A
get:USER TIME
get:RETRANSMI
get:TIME-WAIT
get:The model of th
get:immediate retur
get:pseudo interrup
get:means cause a d
get:Error responses
get:commands refere:ncing connections that do not exist receive "error
get:connection not 
get:Please note in 
get:acknowledgment 
get:of the sequence
get:equal to (modul
get:[Page 52]        
get:September 1981   
get:A natural way t
get:imagine that th
get:that their cont
get:in the sequence
get:and processed i
get:When a segment 
get:the segment to 
get:to be consisten
get:Note that if no
get:Transmission Cont
get:Functional Specif
get:CLOSED STATE 
get:Create a ne
get:state infor
get:socket, pre
get:information
get:unspecified
get:parameters 
get:precedence 
get:"error:  pr:ecedence not allowed" or "error
get:not allowed
get:active and :the foreign socket is unspecified, return "error
get:foreign soc
get:specified, 
get:(ISS) is se
get:is sent.  S
get:state, and 
get:If the call
get:return "err:or
get:no room to :create a new connection, return "error
get:resources".
get:If active a
get:connection 
get:segment, se
get:state.  Dat
get:queued for 
get:urgent bit 
get:segments se
get:queue the r:equest, respond with "error
get:If Foreign :socket was not specified, then return "error
get:socket unsp
get:[Page 54]        
get:September 1981   
get:SYN-SENT STAT
get:SYN-RECEIVED 
get:ESTABLISHED S
get:FIN-WAIT-1 ST
get:FIN-WAIT-2 ST
get:CLOSE-WAIT ST
get:CLOSING STATE
get:LAST-ACK STAT
get:TIME-WAIT STA
get:Return "err:or
get:Transmission Cont
get:Functional Specif
get:CLOSED STATE 
get:If the user
get:"error:  co
get:Otherwise, :return "error
get:If the fore
get:from passiv
get:SND.UNA to 
get:associated 
get:transmissio
get:requested i
get:as a result
get:request, re:spond with "error
get:Foreign soc:ket was not specified, then return "error
get:socket unsp
get:SYN-SENT STAT
get:SYN-RECEIVED 
get:Queue the d
get:If no space: to queue, respond with "error
get:resources".
get:ESTABLISHED S
get:CLOSE-WAIT ST
get:Segmentize 
get:acknowledgm
get:insufficien:t space to remember this buffer, simply return "error
get:insufficien
get:If the urge
get:urgent poin
get:[Page 56]        
get:September 1981   
get:FIN-WAIT-1 ST
get:FIN-WAIT-2 ST
get:CLOSING STATE
get:LAST-ACK STAT
get:TIME-WAIT STA
get:Return "err:or
get:Transmission Cont
get:Functional Specif
get:CLOSED STATE 
get:If the user
get:"error:  co
get:Otherwise r:eturn "error
get:SYN-SENT STAT
get:SYN-RECEIVED 
get:Queue for p
get:is no room :to queue this request, respond with "error
get:insufficien
get:ESTABLISHED S
get:FIN-WAIT-1 ST
get:FIN-WAIT-2 ST
get:If insuffic
get:request, qu
get:remember th:e RECEIVE, respond with "error
get:resources".
get:Reassemble 
get:to user.  M
get:If RCV.UP i
get:user notify
get:When the TC
get:that fact m
get:acknowledgm
get:described b
get:[Page 58]        
get:September 1981   
get:CLOSE-WAIT ST
get:Since the r
get:satisfied b
get:user.  If n
get:"error:  co
get:text can be
get:CLOSING STATE
get:LAST-ACK STAT
get:TIME-WAIT STA
get:Return "err:or
get:Transmission Cont
get:Functional Specif
get:CLOSED STATE 
get:If the user
get:"error:  co
get:Otherwise, :return "error
get:Any outstan:ding RECEIVEs are returned with "error
get:responses. 
get:SYN-SENT STAT
get:Delete the :TCB and return "error
get:queued SEND
get:SYN-RECEIVED 
get:If no SENDs
get:then form a
get:otherwise q
get:ESTABLISHED S
get:Queue this 
get:form a FIN 
get:FIN-WAIT-1 ST
get:FIN-WAIT-2 ST
get:Strictly sp:eaking, this is an error and should receive a "error
get:connection 
get:acceptable,
get:FIN may be 
get:[Page 60]        
get:September 1981   
get:CLOSE-WAIT ST
get:Queue this 
get:segmentized
get:CLOSING STATE
get:LAST-ACK STAT
get:TIME-WAIT STA
get:Respond wit:h "error
get:Transmission Cont
get:Functional Specif
get:CLOSED STATE 
get:If the user
get:"error:  co
get:Otherwise r:eturn "error
get:Any outstan:ding RECEIVEs should be returned with "error
get:connection 
get:SYN-SENT STAT
get:All queued 
get:notificatio
get:SYN-RECEIVED 
get:ESTABLISHED S
get:FIN-WAIT-1 ST
get:FIN-WAIT-2 ST
get:CLOSE-WAIT ST
get:Send a rese:t segment
get:<SEQ=SND.
get:All queued 
get:notificatio
get:RST formed 
get:TCB, enter 
get:CLOSING STATE
get:LAST-ACK STAT
get:TIME-WAIT STA
get:Respond wit
get:[Page 62]        
get:September 1981   
get:CLOSED STATE 
get:If the user
get:"error:  co
get:Otherwise r:eturn "error
get:Return "sta
get:SYN-SENT STAT
get:Return "sta
get:SYN-RECEIVED 
get:Return "sta
get:ESTABLISHED S
get:Return "sta
get:FIN-WAIT-1 ST
get:Return "sta
get:FIN-WAIT-2 ST
get:Return "sta
get:CLOSE-WAIT ST
get:Return "sta
get:CLOSING STATE
get:Return "sta
get:LAST-ACK STAT
get:Return "sta
get:Transmission Cont
get:Functional Specif
get:TIME-WAIT STA
get:Return "sta
get:[Page 64]        
get:September 1981   
get:SEGMENT ARRIVES
get:If the state 
get:all data in
get:segment con
get:containing 
get:acknowledgm
get:reset seque
get:If the ACK 
get:<SEQ=0><A
get:If the ACK 
get:<SEQ=SEG.
get:If the state 
get:first check
get:An incomi
get:second chec
get:Any ackno
get:the LISTE
get:for any a
get:formatted: as follows
get:<SEQ=SE
get:third check
get:If the SY
get:security/
get:match the
get:<SEQ=SE
get:Transmission Cont
get:Functional Specif
get:If the SE
get:the user 
get:send a re
get:<SEQ=SE
get:If the SE
get:Set RCV.N
get:control o
get:should be: selected and a SYN segment sent of the form
get:<SEQ=IS
get:SND.NXT i
get:state sho
get:incoming 
get:in the SY
get:not be re
get:the forei
get:unspecifi
get:fourth othe
get:Any other
get:must have
get:processin
get:it could 
get:incarnati
get:but if yo
get:If the state 
get:first check
get:If the AC
get:If SEG.
get:the RST
get:<SEQ=
get:and dis
get:If SND.
get:second chec
get:[Page 66]        
get:September 1981   
get:If the RS
get:If the :ACK was acceptable then signal the user "error
get:connect
get:delete 
get:and ret
get:third check
get:If the se
get:match the
get:If ther
get:<SEQ=
get:Otherwi
get:<SEQ=
get:If there 
get:The pre
get:TCB, if
get:<SEQ=
get:If there 
get:If the 
get:in the 
get:the pre
get:allowed
get:<SEQ=
get:If the 
get:in the 
get:If a rese
get:fourth chec
get:This step
get:no ACK, a
get:If the SY
get:Transmission Cont
get:Functional Specif
get:are accep
get:SEG.SEQ. 
get:is an ACK
get:are there
get:If SND.UN
get:state to 
get:<SEQ=SN
get:and send 
get:transmiss
get:text in t
get:below whe
get:Otherwise
get:<SEQ=IS
get:and send 
get:segment, 
get:has been 
get:fifth, if n
get:segment and
get:[Page 68]        
get:September 1981   
get:first check s
get:SYN-RECEIVE
get:ESTABLISHED
get:FIN-WAIT-1 
get:FIN-WAIT-2 
get:CLOSE-WAIT 
get:CLOSING STA
get:LAST-ACK ST
get:TIME-WAIT S
get:Segments 
get:are used 
get:done in S
get:boundary 
get:processed
get:There are
get:segment
get:Segment R
get:Length  W
get:------- -
get:0     
get:0     
get:>0     
get:>0     
get:If the RC
get:special a
get:If an inc
get:should be
get:the segme:nt and return)
get:<SEQ=SN
get:After sen
get:and retur
get:Transmission Cont
get:Functional Specif
get:In the fo
get:segment t
get:One could
get:trimming 
get:SYN and F
get:begins at
get:numbers m
get:second check 
get:SYN-RECEIVE
get:If the RS
get:If this
get:came fr
get:LISTEN 
get:this co
get:from SY
get:the use
get:on the 
get:active 
get:and ret
get:ESTABLISHED
get:If the RS
get:should re
get:flushed. 
get:"connecti
get:TCB, and 
get:CLOSING STA
get:LAST-ACK ST
get:If the RS
get:TCB, and 
get:[Page 70]        
get:September 1981   
get:third check s
get:SYN-RECEIVE
get:If the se
get:exactly m
get:then send
get:ESTABLISHED
get:If the se
get:exactly m
get:then send
get:receive "
get:flushed. 
get:"connecti
get:TCB, and 
get:Note this c
get:a segment f
get:different s
get:current con
get:fourth, check
get:SYN-RECEIVE
get:ESTABLISHED
get:FIN-WAIT ST
get:FIN-WAIT ST
get:CLOSE-WAIT 
get:CLOSING STA
get:LAST-ACK ST
get:TIME-WAIT S
get:If the SY
get:outstandi
get:all segme
get:receive a
get:the CLOSE
get:If the SY
get:and an ac
get:number ch
get:Transmission Cont
get:Functional Specif
get:fifth check t
get:if the ACK 
get:if the ACK 
get:SYN-RECEI
get:If SND.
get:and con
get:If th
get:reset
get:<SE
get:and s
get:ESTABLISH
get:If SND.
get:Any seg
get:entirel
get:positiv
get:fully a
get:"ok" re
get:(SEG.AC
get:somethi
get:drop th
get:If SND.
get:updated
get:SND.WL2
get:SND.WL1
get:Note th
get:records
get:SND.WND
get:the las
get:prevent
get:[Page 72]        
get:September 1981   
get:FIN-WAIT-
get:In addi
get:our FIN
get:process
get:FIN-WAIT-
get:In addi
get:the ret
get:acknowl
get:CLOSE-WAI
get:Do the 
get:CLOSING S
get:In addi
get:the ACK
get:otherwi
get:LAST-ACK 
get:The onl
get:acknowl
get:delete 
get:TIME-WAIT
get:The onl
get:retrans
get:the 2 M
get:sixth, check 
get:ESTABLISHED
get:FIN-WAIT-1 
get:FIN-WAIT-2 
get:If the UR
get:the user 
get:pointer (
get:user has 
get:mode") fo
get:signal th
get:Transmission Cont
get:Functional Specif
get:CLOSE-WAIT 
get:CLOSING STA
get:LAST-ACK ST
get:This shou
get:remote si
get:seventh, proc
get:ESTABLISHED
get:FIN-WAIT-1 
get:FIN-WAIT-2 
get:Once in t
get:text to u
get:into buff
get:empty.  I
get:the user 
get:has been 
get:When the 
get:user it m
get:Once the 
get:RCV.NXT o
get:apporopri
get:RCV.NXT a
get:Please no
get:Send an a:cknowledgment of the form
get:<SEQ=SN
get:This ackn
get:transmitt
get:[Page 74]        
get:September 1981   
get:CLOSE-WAIT 
get:CLOSING STA
get:LAST-ACK ST
get:TIME-WAIT S
get:This shou
get:remote si
get:eighth, check
get:Do not proc
get:since the S
get:If the FIN 
get:return any 
get:over the FI
get:FIN implies
get:SYN-RECEI
get:ESTABLISH
get:Enter t
get:FIN-WAIT-
get:If our 
get:enter T
get:timers;
get:FIN-WAIT-
get:Enter t
get:off the
get:CLOSE-WAI
get:Remain 
get:CLOSING S
get:Remain 
get:LAST-ACK 
get:Remain 
get:Transmission Cont
get:Functional Specif
get:TIME-WAIT
get:Remain 
get:timeout
get:[Page 76]        
get:September 1981   
get:For any state
get:the user "err:or
get:and for any o
get:state and ret
get:RETRANSMISSION 
get:For any state
get:the retransmi
get:retransmissio
get:TIME-WAIT TIMEO
get:If the time-w
get:enter the CLO
get:Transmission Cont
get:[Page 78]        
get:September 1981   
get:BBN Rep
get:a Host 
get:host an
get:A contr
get:indicat
get:specifi
get:is expe
get:previou
get:The uni
get:ARPANET
get:A unit 
get:IMPs.  
get:A logic
get:A messa
get:network
get:Destination Addre
get:The des
get:identif
get:A contr
get:indicat
get:occupyi
get:A porti
get:fragmen
get:A file 
get:Transmission Cont
get:Control
get:fragmen
get:A compu
get:from th
get:An Inte
get:by the 
get:The Int
get:ARPANET
get:A sourc
get:internet datagram
get:The uni
get:higher 
get:internet fragment
get:A porti
get:header.
get:Interne
get:The Ini
get:number 
get:The Ini
get:on a co
get:based p
get:The Ini
get:used by
get:Control
get:data.  
get:on an A
get:[Page 80]        
get:September 1981   
get:This is
get:data re
get:sequenc
get:of the 
get:The uni
get:An impl
get:procedu
get:Maximum
get:the int
get:An eigh
get:An Opti
get:may be 
get:primari
get:timesta
get:options
get:A packa
get:logical
get:logical
get:The por
get:output 
get:A progr
get:the poi
get:A contr
get:this se
get:receivi
get:receive
get:Transmission Cont
get:receive
get:receive
get:receive next sequ
get:This is
get:receive
get:This re
get:is will
get:segment
get:RCV.NXT
get:Segment
get:range a
get:A contr
get:that th
get:interac
get:sequenc
get:segment
get:it.  In
get:rise to
get:Real Ti:me Protocol
get:of time
get:segment
get:segment
get:segment
get:segment
get:segment
get:[Page 82]        
get:September 1981   
get:segment
get:A logic
get:unit of
get:segment acknowled
get:The seq
get:arrivin
get:The amo
get:includi
get:The num
get:This is
get:use on 
get:initial
get:each oc
get:This re
get:(receiv
get:window 
get:receivi
get:be emit
get:SND.UNA
get:between
get:send se
get:left se
get:send ur
get:segment
get:segment
get:Transmission Cont
get:send wi
get:An addr
get:is, the
get:The sou
get:A contr
get:number,
get:where t
get:Transmi
get:the sta
get:The pre
get:Transmi:ssion Control Protocol
get:reliabl
get:Type of
get:An Inte
get:for thi
get:A contr
get:indicat
get:urgent 
get:sequenc
get:pointer
get:A contr
get:field c
get:indicat
get:urgent 
get:[Page 84]        
get:September 1981   
get:[1]  Cerf, V., an
get:Intercommuni
get:Vol. COM-22,
get:[2]  Postel, J. (
get:Protocol Spe
get:Institute, S
get:[3]  Dalal, Y. an
get:Protocols", 
get:December 197
get:[4]  Postel, J., 
get:Institute, S
get:aRFC
get:aDe
get:aI
get:aSeptember 1981   
get:aPREFACE .....
get:a1.  INTRODUCTION 
get:a1.1  Motivation
get:a1.2  Scope ....
get:a1.3  About This
get:a1.4  Interfaces
get:a1.5  Operation 
get:a2.  PHILOSOPHY ..
get:a2.1  Elements o
get:a2.2  Model of O
get:a2.3  The Host E
get:a2.4  Interfaces
get:a2.5  Relation t
get:a2.6  Reliable C
get:a2.7  Connection
get:a2.8  Data Commu
get:a2.9  Precedence
get:a2.10 Robustness
get:a3.  FUNCTIONAL SP
get:a3.1  Header For
get:a3.2  Terminolog
get:a3.3  Sequence N
get:a3.4  Establishi
get:a3.5  Closing a 
get:a3.6  Precedence
get:a3.7  Data Commu
get:a3.8  Interfaces
get:a3.9  Event Proc
get:aGLOSSARY ........
get:aREFERENCES ......
get:aTransmission Cont
get:a[Page ii]        
get:aSeptember 1981   
get:aThis document des
get:a(TCP).  There hav
get:aspecification on 
get:adraws heavily fro
get:aboth in terms of 
get:aseveral details a
get:aand redescribes t
get:aRFC
get:aReplaces: RFC 761
get:aIENs:  129, 124, 
get:a55, 44, 40, 27, 2
get:aThe Transmission 
get:areliable host-to-
get:acommunication net
get:aThis document des
get:aTransmission Cont
get:ainterface to prog
get:aComputer commun
get:arole in militar
get:adocument focuse
get:acommunication r
get:acommunication u
get:acongestion, but
get:agovernment sect
get:aAs strategic an
get:adeveloped and d
get:ainterconnecting
get:acommunication p
get:aapplications.  
get:aDeputy Undersec
get:adeclared the Tr
get:abe a basis for 
get:astandardization
get:aTCP is a connec
get:afit into a laye
get:aapplications.  
get:acommunication b
get:adistinct but in
get:aassumptions are
get:aprotocols below
get:apotentially unr
get:aprotocols.  In 
get:awide spectrum o
get:aconnections to 
get:aTransmission Cont
get:aTCP is based on
get:aTCP fits into a
get:aInternet Protoc
get:areceive variabl
get:adatagram "envel
get:aaddressing sour
get:ainternet protoc
get:athe TCP segment
get:amultiple networ
get:aalso carries in
get:aand compartment
get:acommunicated en
get:aMuch of this do
get:awhich are co-re
get:acomputer.  Some
get:afront-end compu
get:aas well as netw
get:aan interface to
get:aimplementable e
get:ahost-to-front e
get:aThe TCP is inte
get:acommunication s
get:aintended to be 
get:a1.3.  About this 
get:aThis document r
get:aany TCP impleme
get:aprotocols and i
get:a[Page 2]         
get:aSeptember 1981   
get:asection offers 
get:aoperation.  Sec
get:adesign.  Sectio
get:arequired of TCP
get:auser calls, err
get:aThe TCP interfa
get:athe other side 
get:aThe interface b
get:aillustrated in 
get:acalls much like
get:aapplication pro
get:acalls to open a
get:aestablished con
get:aasynchronously 
get:aconsiderable fr
get:ainterfaces whic
get:aenvironment, a 
get:ainterface for a
get:aThe interface b
get:aunspecified exc
get:atwo levels can 
get:aTypically, one 
get:ainterface.  TCP
get:ainterconnected 
get:athroughout this
get:aAs noted above,
get:asecurable logic
get:aprocesses.  To 
get:acommunication s:ystem requires facilities in the following areas
get:aBasic Data Tr
get:aPrecedence an
get:aThe basic opera
get:athe following p
get:aTransmission Cont
get:aBasic Data Tran:sfer
get:aThe TCP is ab
get:adirection bet
get:asegments for 
get:athe TCPs deci
get:aSometimes use
get:asubmitted to 
get:afunction is d
get:aactually tran
get:apushed throug
get:apromptly forw
get:aThe exact pus
get:athe push func
get:aReliability
get:aThe TCP must 
get:adelivered out
get:ais achieved b
get:atransmitted, 
get:areceiving TCP
get:ainterval, the
get:anumbers are u
get:aout of order 
get:aadding a chec
get:areceiver, and
get:aAs long as th
get:asystem does n
get:aerrors will a
get:ainternet comm
get:aFlow Control
get:aTCP provides 
get:asent by the s
get:aevery ACK ind
get:athe last segm
get:aallowed numbe
get:areceiving fur
get:a[Page 4]         
get:aSeptember 1981   
get:aMultiplexing
get:aTo allow for 
get:acommunication
get:aaddresses or 
get:aand host addr
get:aa socket.  A 
get:aThat is, a so
get:aThe binding o
get:aHost.  Howeve
get:a(e.g., a "log
get:amade known to
get:athrough the k
get:aaddresses of 
get:aConnections
get:aThe reliabili
get:athat TCPs ini
get:aeach data str
get:asockets, sequ
get:aEach connecti
get:aidentifying i
get:aWhen two proc
get:aestablish a c
get:aside).  When 
get:aterminated or
get:aSince connect
get:aover the unre
get:amechanism wit
get:aerroneous ini
get:aPrecedence and :Security
get:aThe users of 
get:acommunication
get:athese feature
get:aTransmission Cont
get:a[Page 6]         
get:aSeptember 1981   
get:a2.1.  Elements of
get:aThe internetwor
get:awhich are in tu
get:athat the networ
get:alarge networks 
get:apacket switchin
get:aconsume message
get:anetworks, the g
get:acommunication s
get:aconnections bet
get:aThe term packet
get:atransaction bet
get:aexchanged withi
get:aHosts are compu
get:anetwork's point
get:aProcesses are v
get:aaccordance with
get:ain execution). 
get:aviewed as commu
get:aThus, all commu
get:aSince a process
get:astreams between
get:athat each proce
get:acommunicates wi
get:a2.2.  Model of Op
get:aProcesses trans
get:adata as argumen
get:asegments and ca
get:athe destination
get:ainto the receiv
get:aTCPs include co
get:aensure reliable
get:aThe model of in
get:aprotocol module
get:ato the local ne
get:ainside internet
get:ainternet module
get:athrough the loc
get:aThe packet swit
get:aTransmission Cont
get:aother operation
get:adestination int
get:aAt a gateway be
get:afrom its local 
get:athe internet da
get:athen "wrapped" 
get:arouted to the n
get:aA gateway is pe
get:ainternet datagr
get:athrough the nex
get:ainternet datagr
get:afurther broken 
get:ainternet datagr
get:ainternet module
get:aA destination i
get:a(after reassemb
get:adestination TCP
get:aThis simple mod
get:aimportant featu
get:ato the gateway 
get:aservice paramet
get:aIncluded in the
get:adatagram.  Data
get:ahost and gatewa
get:aproperly segreg
get:a2.3.  The Host En
get:aThe TCP is assu
get:aaccess the TCP 
get:amay call on oth
get:adata structures
get:acontrolled by a
get:anetwork device 
get:adatagram protoc
get:aThe mechanisms 
get:afront-end proce
get:ahost-to-front-e
get:athe type of TCP
get:a[Page 8]         
get:aSeptember 1981   
get:aThe TCP/user in
get:ato OPEN or CLOS
get:aSTATUS about a 
get:aprograms on the
get:afrom, and close
get:aThe TCP/interne
get:adatagrams addre
get:asystem.  These 
get:aservice, preced
get:a2.5.  Relation to
get:aThe following d
get:ahierarchy
get:a+------+ +
get:a|Telnet| |
get:a+------+ +
get:a|   
get:a+----
get:a| TCP
get:a+----
get:a| 
get:a+----
get:a|    
get:a+----
get:a+--
get:a|  
get:a+--
get:aIt is expected 
get:aprotocols effic
get:aprotocols like 
get:a2.6.  Reliable Co
get:aA stream of dat
get:aorder at the de
get:aTransmission Cont
get:aTransmission is
get:aacknowledgments
get:asequence number
get:asegment is tran
get:asequence number
get:ais the sequence
get:atransmissions i
get:asegment contain
get:astarts a timer;
get:asegment is dele
get:areceived before
get:aAn acknowledgme
get:adelivered to th
get:athe responsibil
get:aTo govern the f
get:aemployed.  The 
get:aThis window spe
get:aacknowledgment 
get:a2.7.  Connection 
get:aTo identify the
get:aprovides a port
get:aindependently b
get:aunique addresse
get:aidentifying the
get:awill be unique 
get:aA connection is
get:alocal socket ma
get:asockets.  A con
get:athat is, it is 
get:aTCPs are free t
get:aHowever, severa
get:aThere must be w
get:athe "appropriat
get:amay "own" ports
get:athe ports they 
get:aissue, but we e
get:auniquely alloca
get:aassociating the
get:aA connection is
get:aforeign socket 
get:a[Page 10]        
get:aSeptember 1981   
get:aconnection name
get:asubsequent call
get:aabout a connect
get:ais a data struc
get:aimplementation 
get:apointer to the 
get:awhether the con
get:abe passively wa
get:aA passive OPEN 
get:aconnection requ
get:aOften the proce
get:arequest from an
get:ais used to deno
get:aare allowed onl
get:aA service proce
get:aprocesses would
get:aforeign socket.
get:arequested a con
get:alocal socket we
get:aWell-known sock
get:aa socket addres
get:a"Telnet-Server"
get:asocket, and oth
get:aEntry, Text Gen
get:abeing for test 
get:aaccess to a "Lo
get:aat which a newl
get:awell-known sock
get:aof sockets to s
get:aProcesses can i
get:afrom other proc
get:abeen establishe
get:aother at the sa
get:ais critical for
get:acomponents act 
get:aThere are two p
get:apassive OPENs a
get:alocal passive O
get:acase, the match
get:aOPENs has left 
get:aforeign socket 
get:aOther possibili
get:aTransmission Cont
get:aIf there are se
get:asame local sock
get:awith the specif
get:aTCB exists, bef
get:aThe procedures 
get:acontrol flag an
get:aexchange has be
get:aA connection is
get:acontaining a SY
get:acommand.  The m
get:aconnection has 
get:awhen sequence n
get:aThe clearing of
get:ain this case ca
get:a2.8.  Data Commun
get:aThe data that f
get:aoctets.  The se
get:ain that call (a
get:athrough to the 
get:aA sending TCP i
get:asend that data 
get:afunction is sig
get:areceiving TCP s
get:athe sending TCP
get:aThere is no nec
get:aboundaries.  Th
get:asingle SEND cal
get:aThe purpose of 
get:afrom the sendin
get:arecord service.
get:aThere is a coup
get:aof data that cr
get:aassociated with
get:abuffer is retur
get:anot filled.  If
get:aPUSH is seen, t
get:aTCP also provid
get:aat some point f
get:a[Page 12]        
get:aSeptember 1981   
get:acurrently readi
get:adefine what the
get:aurgent data, bu
get:atake action to 
get:a2.9.  Precedence 
get:aThe TCP makes u
get:asecurity option
get:abasis to TCP us
get:aa multilevel se
get:ause only, and o
get:acompartment.  C
get:ausers may be li
get:aTCP modules whi
get:aproperly mark o
get:aprecedence.  Su
get:ahigher level pr
get:athem to specify
get:aprecedence of c
get:a2.10.  Robustness
get:aTCP implementat:ions will follow a general principle of robustness
get:aconservative in
get:aTransmission Cont
get:a[Page 14]        
get:aSeptember 1981   
get:a3.1.  Header Form
get:aTCP segments ar
get:aheader carries 
get:adestination hos
get:aheader, supplyi
get:adivision allows
get:aTCP Header Form
get:a0            
get:a0 1 2 3 4 5 6
get:a+-+-+-+-+-+-+-
get:a|          Sou
get:a+-+-+-+-+-+-+-
get:a|             
get:a+-+-+-+-+-+-+-
get:a|             
get:a+-+-+-+-+-+-+-
get:a|  Data |     
get:a| Offset| Rese
get:a|       |     
get:a+-+-+-+-+-+-+-
get:a|           Ch
get:a+-+-+-+-+-+-+-
get:a|             
get:a+-+-+-+-+-+-+-
get:a|             
get:a+-+-+-+-+-+-+-
get:aNote th
get:aSource Port:  1
get:aThe source po
get:aDestination Por:t
get:aThe destinati
get:aTransmission Cont
get:aFunctional Specif
get:aSequence Number:
get:aThe sequence 
get:awhen SYN is p
get:ainitial seque
get:aAcknowledgment :Number
get:aIf the ACK co
get:anext sequence
get:areceive.  Onc
get:aData Offset:  4
get:aThe number of
get:athe data begi
get:aintegral numb
get:aReserved:  6 bi
get:aReserved for 
get:aControl Bits:  :6 bits (from left to right)
get:aURG:  Urgent 
get:aACK:  Acknowl
get:aPSH:  Push Fu
get:aRST:  Reset t
get:aSYN:  Synchro
get:aFIN:  No more
get:aWindow:  16 bit
get:aThe number of
get:aacknowledgmen
get:aChecksum:  16 b
get:aThe checksum 
get:acomplement su
get:asegment conta
get:achecksummed, 
get:aform a 16 bit
get:atransmitted a
get:athe checksum 
get:aThe checksum 
get:a[Page 16]        
get:aSeptember 1981   
get:aprefixed to t
get:aAddress, the 
get:aThis gives th
get:ainformation i
get:aacross the TC
get:acalls by the 
get:aThe TCP Len
get:aoctets (thi
get:acomputed), 
get:aUrgent Pointer:
get:aThis field co
get:apositive offs
get:aurgent pointe
get:athe urgent da
get:athe URG contr
get:aOptions:  varia
get:aOptions may o
get:amultiple of 8
get:achecksum.  An
get:acases for the: format of an option
get:aCase 1:  A 
get:aCase 2:  An
get:ath
get:aThe option-le
get:aoption-length
get:aNote that the
get:afield might i
get:aEnd-of-Option
get:aA TCP must im
get:aTransmission Cont
get:aFunctional Specif
get:aCurrently def:ined options include (kind indicated in octal)
get:aKind     Le
get:a----     --
get:a0         
get:a1         
get:a2         
get:aSpecific Opti
get:aEnd of Opti
get:a+--------
get:a|00000000
get:a+--------
get:aThis opti
get:amight not
get:athe Data 
get:anot the e
get:athe optio
get:aNo-Operatio
get:a+--------
get:a|00000001
get:a+--------
get:aThis opti
get:aalign the
get:aThere is 
get:areceivers
get:anot begin
get:aMaximum Seg
get:a+--------
get:a|00000010
get:a+--------
get:aKind=2  
get:a[Page 18]        
get:aSeptember 1981   
get:aMaximum S:egment Size Option Data
get:aIf this
get:areceive
get:aThis fi
get:a(i.e., 
get:aoption 
get:aPadding:  varia
get:aThe TCP heade
get:aand data begi
get:a3.2.  Terminology
get:aBefore we can d
get:ato introduce so
get:aconnection requ
get:aof these variab
get:aTransmission Co
get:aTCB are the loc
get:aprecedence of t
get:abuffers, pointe
get:aIn addition sev
get:asequence number
get:aSend Sequence
get:aSND.UNA - s
get:aSND.NXT - s
get:aSND.WND - s
get:aSND.UP  - s
get:aSND.WL1 - s
get:aSND.WL2 - s
get:au
get:aISS     - i
get:aReceive Seque
get:aRCV.NXT - r
get:aRCV.WND - r
get:aRCV.UP  - r
get:aIRS     - i
get:aTransmission Cont
get:aFunctional Specif
get:aThe following d
get:athe sequence sp
get:aSend Sequence S
get:a---
get:a1 - old s
get:a2 - seque
get:a3 - seque
get:a4 - futur
get:aThe send window
get:aReceive Sequenc
get:a1 - old s
get:a2 - seque
get:a3 - futur
get:aThe receive win
get:aThere are also 
get:atake their valu
get:a[Page 20]        
get:aSeptember 1981   
get:aCurrent Segme
get:aSEG.SEQ - s
get:aSEG.ACK - s
get:aSEG.LEN - s
get:aSEG.WND - s
get:aSEG.UP  - s
get:aSEG.PRC - s
get:aA connection pr
get:alifetime.  The :states are
get:aESTABLISHED, FI
get:aTIME-WAIT, and 
get:abecause it repr
get:ano connection. : Briefly the meanings of the states are
get:aLISTEN - repr
get:aTCP and port.
get:aSYN-SENT - re
get:aafter having 
get:aSYN-RECEIVED 
get:arequest ackno
get:aconnection re
get:aESTABLISHED -
get:adelivered to 
get:aof the connec
get:aFIN-WAIT-1 - 
get:afrom the remo
get:atermination r
get:aFIN-WAIT-2 - 
get:afrom the remo
get:aCLOSE-WAIT - 
get:afrom the loca
get:aCLOSING - rep
get:aacknowledgmen
get:aLAST-ACK - re
get:aconnection te
get:a(which includ
get:aTransmission Cont
get:aFunctional Specif
get:aTIME-WAIT - r
get:athe remote TC
get:atermination r
get:aCLOSED - repr
get:aA TCP connectio
get:aevents.  The ev
get:aABORT, and STAT
get:acontaining the 
get:aThe state diagr
get:awith the causin
get:aerror condition
get:achanges.  In a 
get:athe reaction of
get:aNOTE BENE:  thi
get:athe total speci
get:a[Page 22]        
get:aSeptember 1981   
get:a+---------+     
get:a|         |<----
get:a|   SYN   |     
get:a|   RCVD  |<----
get:a|         |     
get:a|         |-----
get:a+---------+   rc
get:a|           --
get:a|             
get:a|             
get:a|  CLOSE      
get:a| -------     
get:a| snd FIN     
get:a|             
get:aV             
get:a+---------+     
get:a|  FIN    |<----
get:a| WAIT-1  |-----
get:a+---------+     
get:a| rcv ACK of F
get:a| ------------
get:aV        x    
get:a+---------+     
get:a|FINWAIT-2|     
get:a+---------+     
get:a|             
get:a|  rcv FIN    
get:a|  -------    
get:a\ snd ACK    
get:a------------
get:aTransmission Cont
get:aFunctional Specif
get:a3.3.  Sequence Nu
get:aA fundamental n
get:aover a TCP conn
get:asequenced, each
get:amechanism emplo
get:anumber X indica
get:areceived.  This
get:adetection in th
get:awithin a segmen
get:athe header is t
get:anumbered consec
get:aIt is essential
get:afinite, though 
get:aSince the space
get:anumbers must be
get:apreserves the r
get:a2**32 - 1 to 0 
get:aarithmetic, so 
get:acomparison of s
get:a(modulo 2**32).
get:aThe typical kin
get:aperform include:
get:a(a)  Determin
get:anumber s
get:a(b)  Determin
get:ahave bee
get:aretransm
get:a(c)  Determin
get:awhich ar
get:areceive 
get:a[Page 24]        
get:aSeptember 1981   
get:aIn response to 
get:afollowing compa
get:aSND.UNA = old
get:aSND.NXT = nex
get:aSEG.ACK = ack
get:anum
get:aSEG.SEQ = fir
get:aSEG.LEN = the
get:a(co
get:aSEG.SEQ+SEG.L
get:aA new acknowled
get:athe inequality :below holds
get:aSND.UNA < SEG
get:aA segment on th
get:aof its sequence
get:aacknowledgment 
get:aWhen data is re:ceived the following comparisons are needed
get:aRCV.NXT = nex
get:ais the le
get:aRCV.NXT+RCV.W
get:asegment, 
get:aSEG.SEQ = fir
get:aSEG.SEQ+SEG.L
get:aA segment is ju
get:aRCV.NXT =< SE
get:aRCV.NXT =< SE
get:aTransmission Cont
get:aFunctional Specif
get:aThe first part 
get:asegment falls i
get:aif the end of t
get:aeither part of 
get:aActually, it is
get:awindows and zer
get:aacceptability o:f an incoming segment
get:aSegment Recei
get:aLength  Windo
get:a------- -----
get:a0       0 
get:a0      >0 
get:a>0       0 
get:a>0      >0 
get:aNote that when 
get:aacceptable exce
get:amaintain a zero
get:aACKs.  However,
get:aprocess the RST
get:aWe have taken a
get:acontrol informa
get:asome control fl
get:aand acknowledge
get:acontrol will be
get:acarried in the 
get:afor implicitly 
get:aare the only co
get:aare used only a
get:apurposes, the S
get:aoctet of the se
get:ato occur after 
get:aoccurs.  The se
get:aspace occupying
get:asequence number
get:a[Page 26]        
get:aSeptember 1981   
get:aInitial Sequenc
get:aThe protocol pl
get:aused over and o
get:asockets.  New i
get:aincarnations of
get:a-- "how does th
get:aincarnations of
get:aconnection is b
get:aconnection brea
get:aTo avoid confus
get:aconnection from
get:abe present in t
get:aassure this, ev
get:asequence number
get:aan initial sequ
get:anew 32 bit ISN.
get:abit clock whose
get:amicroseconds.  
get:aSince we assume
get:athe Maximum Seg
get:ahours we can re
get:aFor each connec
get:asequence number
get:athe data sendin
get:alearned during 
get:aFor a connectio
get:asynchronize on 
get:aan exchange of 
get:acalled "SYN" (f
get:ashorthand, segm
get:aHence, the solu
get:ainitial sequenc
get:aThe synchroniza
get:asequence number
get:afrom the other 
get:ainitial sequenc
get:a1) A --> B  S
get:a2) A <-- B  A
get:a3) A <-- B  S
get:a4) A --> B  A
get:aTransmission Cont
get:aFunctional Specif
get:aBecause steps 2
get:acalled the thre
get:aA three way han
get:atied to a globa
get:amechanisms for 
get:ano way of knowi
get:aunless it remem
get:a(which is not a
get:averify this SYN
get:aclock-driven sc
get:aKnowing When to
get:aTo be sure that
get:asequence number
get:athe network, th
get:a(MSL) before as
get:arecovering from
get:alost.  For this
get:ais an engineeri
get:ait is desirable
get:asense, yet reta
get:anot wait at all
get:athan those rece
get:aThe TCP Quiet T
get:aThis specific
get:aretaining any
get:aeach active (
get:aTCP segments 
get:ain the intern
get:aparagraphs be
get:aTCP implement
get:aat the risk o
get:adata rejected
get:aTCPs consume 
get:aentered into 
get:aduplicate det
get:arelies on the
get:athe extent th
get:avalues before
get:abeen delivere
get:acopies of the
get:asuch an assum
get:a[Page 28]        
get:aSeptember 1981   
get:aassigned the 
get:aat the receiv
get:athat each seg
get:aas there are 
get:aUnder normal 
get:ato emit and t
get:amistakenly us
get:abeen acknowle
get:adata is drain
get:avery large to
get:acause trouble
get:ato use up 2**
get:alifetime in t
get:athis is deeme
get:arates escalat
get:acycle time is
get:awithin reason
get:aThe basic dup
get:adefeated, how
get:asequence numb
get:athe TCP were 
get:aupon crashing
get:aconnection (p
get:apackets with 
get:apackets still
get:aincarnation o
get:aabout the seq
get:aspecification
get:abefore emitti
get:asegments from
get:aEven hosts wh
get:ainitial seque
get:a(i.e., even i
get:anumber for ea
get:aSuppose, for 
get:asequence numb
get:aand that even
get:atakes on a va
get:asegment sent 
get:aat this insta
get:aincarnation o
get:aS1 = ISN(t) -
get:aconnection!  
get:aTransmission Cont
get:aFunctional Specif
get:aduplicates in
get:aof S1 may arr
get:athe new incar
get:aThe problem i
get:acrashed nor d
get:athe system fr
get:aOne way to de
get:asegments for 
get:atime" specifi
get:awilling to ri
get:adestination m
get:aImplementors 
get:aconnection by
get:ainformally im
get:aObviously, ev
get:anecessary aft
get:aTo summarize:
get:anumbers in th
get:a"busy" or "in
get:ablock of spac
get:asegment, if a
get:asequence numb
get:athe previous 
get:anumber overla
get:a3.4.  Establishin
get:aThe "three-way 
get:aconnection.  Th
get:aresponded to by
get:asimultaneously 
get:aoccurs, each TC
get:aacknowledgment 
get:aan old duplicat
get:arecipient, that
get:aProper use of "
get:aSeveral example
get:aexamples do not
get:asegments, this 
get:adoesn't deliver
get:avalid (i.e., th
get:aconnection reac
get:areduces the pos
get:a[Page 30]        
get:aSeptember 1981   
get:aimplementation 
get:ainformation for
get:aThe simplest th
get:afigures should 
get:anumbered for re
get:adeparture of a 
get:asegment at B fr
get:aEllipsis (...) 
get:a(delayed).  An 
get:aComments appear
get:athe departure o
get:athe center of e
get:aform, with sequ
get:afields such as 
get:ain the interest
get:aTCP A      
get:a1.  CLOSED     
get:a2.  SYN-SENT   
get:a3.  ESTABLISHED
get:a4.  ESTABLISHED
get:a5.  ESTABLISHED
get:aBasic 3
get:aIn line 2 of fi
get:aindicating that
get:anumber 100.  In
get:areceived from T
get:aB is now expect
get:aoccupied sequen
get:aAt line 4, TCP 
get:aTCP B's SYN; an
get:asequence number
get:abecause the ACK
get:awould wind up A
get:aTransmission Cont
get:aFunctional Specif
get:aSimultaneous in
get:afigure 8.  Each
get:aTCP A      
get:a1.  CLOSED     
get:a2.  SYN-SENT   
get:a3.  SYN-RECEIVE
get:a4.             
get:a5.  SYN-RECEIVE
get:a6.  ESTABLISHED
get:a7.             
get:aS
get:aThe principle r
get:aduplicate conne
get:athis, a special
get:areceiving TCP i
get:aSYN-RECEIVED), 
get:aIf the TCP is i
get:aFIN-WAIT-1, FIN
get:aaborts the conn
get:acase under "hal
get:a[Page 32]        
get:aSeptember 1981   
get:aTCP A      
get:a1.  CLOSED     
get:a2.  SYN-SENT   
get:a3.  (duplicate)
get:a4.  SYN-SENT   
get:a5.  SYN-SENT   
get:a6.             
get:a7.  SYN-SENT   
get:a8.  ESTABLISHED
get:aAs a simple exa
get:afigure 9.  At l
get:acannot tell tha
get:a(line 4).  TCP 
get:aRST (reset) wit
get:abelievable.  TC
get:aWhen the origin
get:asynchronization
get:abefore the RST,
get:asent in both di
get:aHalf-Open Conne
get:aAn established 
get:aTCPs has closed
get:aknowledge of th
get:abecome desynchr
get:amemory.  Such c
get:aattempt is made
get:aconnections are
get:amildly involved
get:aIf at site A th
get:aTransmission Cont
get:aFunctional Specif
get:auser at site B 
get:areceiving a res
get:asite B TCP that
get:aAssume that two
get:aanother when a 
get:aDepending on th
get:athat some error
get:aA is likely to 
get:apoint.  As a re
get:aor try to SEND 
get:acase, it receiv
get:alocal (A's) TCP
get:awill send a seg
get:aexample shown i
get:are-open the con
get:aTCP A      
get:a1.  (CRASH)    
get:a2.  CLOSED     
get:a3.  SYN-SENT --
get:a4.  (!!)     <-
get:a5.  SYN-SENT --
get:a6.  SYN-SENT   
get:a7.  SYN-SENT --
get:aWhen the SYN ar
get:aand the incomin
get:aacknowledgment 
get:a100).  TCP A se
get:asent and, being
get:adetected a half
get:a[Page 34]        
get:aSeptember 1981   
get:acontinue to try
get:areduced to the 
get:aAn interesting 
get:atries to send d
get:aThis is illustr
get:aTCP A from TCP 
get:aexists, so TCP 
get:aprocesses it an
get:aTCP A    
get:a1.  (CRASH)    
get:a2.  (??)    <--
get:a3.          -->
get:aActive
get:aIn figure 12, w
get:awaiting for SYN
get:ainto action.  A
get:agenerate a RST 
get:athe reset and r
get:aTCP A      
get:a1.  LISTEN     
get:a2.       ... <S
get:a3.  (??) <-- <S
get:a4.       --> <S
get:a5.  LISTEN     
get:aOld Duplic
get:aTransmission Cont
get:aFunctional Specif
get:aA variety of ot
get:aby the followin
get:aReset Generatio
get:aAs a general ru
get:awhich apparentl
get:amust not be sen
get:aThere are three: groups of states
get:a1.  If the co
get:ain response t
get:aparticular, S
get:aby this means
get:aIf the incomi
get:asequence numb
get:areset has seq
get:aof the sequen
get:aThe connectio
get:a2.  If the co
get:aSYN-SENT, SYN
get:asomething not
get:aif an incomin
get:adoes not exac
get:aconnection, a
get:aIf our SYN ha
get:aincoming segm
get:aeither raise 
get:athe system) o
get:aincoming segm
get:acontinue as i
get:acannot raise 
get:adetected in t
get:aterminated th
get:aincoming segm
get:amatch the loc
get:amust be sent.
get:aIf the incomi
get:asequence numb
get:areset has seq
get:aof the sequen
get:aThe connectio
get:a[Page 36]        
get:aSeptember 1981   
get:a3.  If the co
get:aFIN-WAIT-1, F
get:aany unaccepta
get:aunacceptible 
get:aacknowledgmen
get:aand an acknow
get:ato be receive
get:aIf an incomin
get:aprecedence wh
get:aand precedenc
get:aconnection go
get:anumber from t
get:aReset Processin
get:aIn all states e
get:aby checking the
get:ais in the windo
get:ato an initial S
get:aacknowledges th
get:aThe receiver of
get:areceiver was in
get:ain SYN-RECEIVED
get:athen the receiv
get:aaborts the conn
get:awas in any othe
get:aand goes to the
get:a3.5.  Closing a C
get:aCLOSE is an ope
get:anotion of closi
get:ainterpretation,
get:athe receiving s
get:ain a simplex fa
get:auntil he is tol
get:acould initiate 
get:aRECEIVE until s
get:ahas CLOSED.  We
get:aRECEIVEs are ou
get:acan terminate h
get:abuffers SENT be
get:adata in return 
get:asuccessfully to
get:aTCP.  Users mus
get:athe TCP says no
get:aTransmission Cont
get:aFunctional Specif
get:aThere are essen:tially three cases
get:a1) The user i
get:a2) The remote
get:a3) Both users
get:aCase 1:  Local 
get:aIn this case,
get:aoutgoing segm
get:aaccepted by t
get:aare allowed i
get:awill be retra
get:aboth acknowle
get:acan ACK this 
get:asend its own 
get:aCase 2:  TCP re
get:aIf an unsolic
get:acan ACK it an
get:auser will res
get:athe other TCP
get:auntil its own
get:aconnection.  
get:athe connectio
get:aCase 3:  both u
get:aA simultaneou
get:aFIN segments 
get:ahave been pro
get:ahas received.
get:a[Page 38]        
get:aSeptember 1981   
get:aTCP A      
get:a1.  ESTABLISHED
get:aFIN-WAIT-1 
get:a3.  FIN-WAIT-2 
get:a4.             
get:aTIME-WAIT  
get:a5.  TIME-WAIT  
get:aCLOSED     
get:aTCP A      
get:a1.  ESTABLISHED
get:a2.  (Close)    
get:aFIN-WAIT-1 
get:a3.  CLOSING    
get:a4.  TIME-WAIT  
get:a(2 MSL)    
get:aCLOSED     
get:aTransmission Cont
get:aFunctional Specif
get:a3.6.  Precedence 
get:aThe intent is t
get:awith exactly th
get:ahigher of the p
get:aThe precedence 
get:adefined in the 
get:aspecification t
get:athe security pa
get:auser group, and
get:aA connection at
get:alower precedenc
get:aa connection du
get:aacknowledgment 
get:aNote that TCP m
get:aprecedence will
get:asegments and po
get:aThe security pa
get:a(the values wou
get:anon-secure envi
get:aparameters, tho
get:a3.7.  Data Commun
get:aOnce the connec
get:aexchange of seg
get:a(checksum test 
get:aretransmission 
get:aDuplicate segme
get:aAs discussed in
get:acertain tests o
get:asegments to ver
get:aThe sender of d
get:athe variable SN
get:asequence number
get:akeeps track of 
get:avariable SND.UN
get:asent has been a
get:aWhen the sender
get:aSND.NXT.  When 
get:asends an acknow
get:a[Page 40]        
get:aSeptember 1981   
get:aacknowledgment 
get:athese variables
get:aThe amount by w
get:adata in the seg
get:asegments must c
get:aThe CLOSE user 
get:aflag in an inco
get:aRetransmission 
get:aBecause of the 
get:ainternetwork sy
get:aretransmission 
get:afor determining
get:aAn Example Re
get:aMeasure the
get:aparticular 
get:acovers that
get:asegments re
get:aTime (RTT).:  Next compute a Smoothed Round Trip Time (SRTT) as
get:aSRTT = ( 
get:aand based o:n this, compute the retransmission timeout (RTO) as
get:aRTO = min
get:awhere UBOUN
get:aLBOUND is a
get:aa smoothing
get:afactor (e.g
get:aThe Communicati
get:aThe objective o
get:ato stimulate th
get:apermit the rece
get:athe currently k
get:aThis mechanism 
get:athe end of urge
get:athe receive seq
get:amust tell the u
get:anumber catches 
get:aTransmission Cont
get:aFunctional Specif
get:ainto "normal mo
get:ais in "urgent m
get:aThe method empl
get:atransmitted.  T
get:ameaningful and 
get:athe urgent poin
get:ano urgent data 
get:aTo send an urge
get:aoctet.  If the 
get:athe urgent info
get:aManaging the Wi
get:aThe window sent
get:anumbers the sen
get:aprepared to acc
get:athe currently a
get:aIndicating a la
get:aarrives than ca
get:ain excessive re
get:anetwork and the
get:atransmission of
get:abetween each ne
get:aThe mechanisms 
get:asubsequently ad
get:athat much data.
get:adiscouraged.  T
get:ashrink the wind
get:aon the part of 
get:aThe sending TCP
get:aleast one octet
get:asending TCP mus
get:athe window is z
get:ainterval when t
get:aguarantee that 
get:awindow will be 
get:aWhen the receiv
get:astill send an a
get:aand current win
get:aThe sending TCP
get:a[Page 42]        
get:aSeptember 1981   
get:awhich fit the c
get:aretransmission 
get:aIn a connection
get:abe carried in a
get:anumber so there
get:aorder.  This is
get:ainformation to 
get:athe data receiv
get:athe window info
get:aacknowledgment 
get:aequal or greate
get:aThe window mana
get:acommunication p
get:aWindow Manage
get:aAllocating 
get:amany small 
get:afewer large
get:aOne suggest
get:adefer updat
get:aleast X per
get:aconnection 
get:aAnother sug
get:asegments by
get:asending dat
get:adata must b
get:aNote that t
get:aretransmiss
get:aacknowledgm
get:awindow info
get:anew window 
get:aThe segment
get:aof transmit
get:asegment con
get:ais accepted
get:aIf the send
get:awindow is n
get:aalternating
get:apauses in t
get:aTransmission Cont
get:aFunctional Specif
get:aresult in b
get:abig pair. A
get:amostly smal
get:aThe suggest
get:aactively at
get:awindows, si
get:ato many sma
get:aThere are of co:urse two interfaces of concern
get:aand the TCP/low
get:aof the user/TCP
get:aprotocol module
get:ain detail by th
get:acase that the l
get:athat TCPs might
get:aUser/TCP Interf
get:aThe following
get:aat best, fict
get:afacilities.  
get:aimplementatio
get:aTCPs must pro
get:athat all TCP 
get:ahierarchy.  T
get:arequired of a
get:aTCP User Comm
get:aThe followi
get:ainterface. 
get:afunction ca
get:ameant to ru
get:aThe user co
get:aTCP must pe
get:aIndividual 
get:amay provide
get:asingle call
get:aautomatical
get:aissued by t
get:a[Page 44]        
get:aSeptember 1981   
get:aIn providin
get:anot only ac
get:aprocesses i:t serves.  The latter consists of
get:a(a) gener
get:aremote cl
get:a(b) repli
get:avarious t
get:aFormat:  
get:a[, timeou
get:a-> local 
get:aWe assume
get:aprocesses
get:ato use th
get:aimplement
get:afor the s
get:alower lev
get:aresult of
get:aable to m
get:aprocess c
get:aIf the ac
get:acall to L
get:ahave eith
get:aparticula
get:afor any c
get:aby the su
get:aA transmi
get:afilled in
get:aOn an act
get:asynchroni
get:aThe timeo
get:afor all d
get:adelivered
get:awill abor
get:aThe TCP o
get:athe users
get:aTransmission Cont
get:aFunctional Specif
get:aprecedenc
get:aor securi
get:athe defau
get:aTCP will 
get:asecurity/
get:athe prece
get:arequested
get:aThe prece
get:arequested
get:arequest, 
get:aconnectio
get:athis prec
get:aallowed t
get:aor that a
get:aA local c
get:aThe local
get:afor the c
get:aFormat:  
get:acount, PU
get:aThis call
get:ato be sen
get:anot been 
get:aimplement
get:aautomatic
get:aauthorize
get:aIf the PU
get:ato the re
get:asegment c
get:athe data 
get:atransmiss
get:aIf the UR
get:awill have
get:athe urgen
get:apointer i
get:abeen cons
get:ais to sti
get:aindicate 
get:a[Page 46]        
get:aSeptember 1981   
get:adata has 
get:aTCP signa
get:aof times 
get:aurgent da
get:aIf no for
get:aconnectio
get:ahas becom
get:alocal soc
get:aforeign s
get:aforeign s
get:aknowing t
get:aHowever, 
get:abecomes s
get:aSTATUS ca
get:aimplement
get:asocket is
get:aIf a time
get:aconnectio
get:aIn the si
get:athe sendi
get:aor the ti
get:ais both s
get:aconnectio
get:aoffers po
get:asophistic
get:athe proce
get:afurthermo
get:aMultiple 
get:athe TCP w
get:aWe have i
get:awhich a S
get:apseudo-in
get:areturn a 
get:aimmediate
get:abeen ackn
get:aassume ev
get:aclose any
get:akind (syn
get:asignals, 
get:awith spec
get:aIn order 
get:aindicatio
get:aTransmission Cont
get:aFunctional Specif
get:abuffer ad
get:athe SEND 
get:aindicatin
get:acalling p
get:aFormat:  
get:acount) ->
get:aThis comm
get:aspecified
get:acalling p
get:aerror is 
get:aIn the si
get:acalling p
get:aerror occ
get:aA more so
get:aRECEIVEs 
get:asegments 
get:athe cost 
get:anotify th
get:aIf enough
get:athe PUSH 
get:aThe buffe
get:aa PUSH is
get:areturned 
get:aIf there 
get:aas it arr
get:ashould th
get:aadditiona
get:acall to R
get:amay now l
get:aurgent po
get:ain the sa
get:aboundary 
get:aTo distin
get:acare of t
get:areturn co
get:acount ind
get:aAlternati
get:a[Page 48]        
get:aSeptember 1981   
get:aallocate 
get:awith the 
get:aFormat:  
get:aThis comm
get:athe conne
get:aauthorize
get:aClosing c
get:athe sense
get:aretransmi
get:aserviced.
get:acalls, fo
get:ato the de
get:acontinue 
get:amay be tr
get:ameans "I 
get:areceive a
get:anot well 
get:aof all it
get:ainto ABOR
get:aThe user 
get:ainitiativ
get:a(e.g., re
get:adestinati
get:aBecause c
get:aforeign T
get:ashort tim
get:areplies t
get:aClose als
get:aFormat:  
get:aThis is a
get:aexcluded 
get:atypically
get:aThis comm
get:ainformati:on
get:alocal s
get:aTransmission Cont
get:aFunctional Specif
get:aforeign
get:alocal c
get:areceive
get:asend wi
get:aconnect
get:anumber 
get:anumber 
get:aurgent 
get:aprecede
get:asecurit
get:aand tra
get:aDepending
get:aimplement
get:aavailable
get:aauthorize
get:aprevents 
get:aconnectio
get:aFormat:  
get:aThis comm
get:aaborted, 
get:abe sent t
get:aDepending
get:aindicatio
get:areceive a
get:aTCP-to-User M
get:aIt is assum
get:ameans for t
get:athe TCP doe
get:ato the user
get:aan error me
get:arelating to
get:aother user 
get:aThe followi:ng information is provided
get:aLocal Con
get:aResponse 
get:aBuffer Ad
get:aByte coun
get:aPush flag
get:aUrgent fl
get:a[Page 50]        
get:aSeptember 1981   
get:aTCP/Lower-Level
get:aThe TCP calls
get:areceive infor
get:ainternetwork 
get:aProtocol (IP)
get:aIf the lower 
get:aof service an
get:afor these par:ameters
get:aType of Ser:vice = Precedence: routine, Delay: normal, Throughput
get:anormal, Rel:iability
get:aTime to Liv
get:aNote that
get:aHere we e
get:abe delive
get:aIf the lower 
get:afeature) and 
get:aroute informa
get:aso that the s
get:achecksum be t
get:aalso importan
get:aAny lower lev
get:adestination a
get:athe "TCP leng
get:aof IP and to 
get:aTransmission Cont
get:aFunctional Specif
get:a3.9.  Event Proce
get:aThe processing 
get:aimplementation.
get:aprocessing sequ
get:asection only in
get:aThe activity of
get:aThe events that: occur can be cast into three categories
get:aarriving segmen
get:aprocessing the 
get:acases the proce
get:aEvents that o:ccur
get:aArriving Se
get:aSEGMENT A
get:aUSER TIME
get:aRETRANSMI
get:aTIME-WAIT
get:aThe model of th
get:aimmediate retur
get:apseudo interrup
get:ameans cause a d
get:aError responses
get:acommands refere:ncing connections that do not exist receive "error
get:aconnection not 
get:aPlease note in 
get:aacknowledgment 
get:aof the sequence
get:aequal to (modul
get:a[Page 52]        
get:aSeptember 1981   
get:aA natural way t
get:aimagine that th
get:athat their cont
get:ain the sequence
get:aand processed i
get:aWhen a segment 
get:athe segment to 
get:ato be consisten
get:aNote that if no
get:aTransmission Cont
get:aFunctional Specif
get:aCLOSED STATE 
get:aCreate a ne
get:astate infor
get:asocket, pre
get:ainformation
get:aunspecified
get:aparameters 
get:aprecedence 
get:a"error:  pr:ecedence not allowed" or "error
get:anot allowed
get:aactive and :the foreign socket is unspecified, return "error
get:aforeign soc
get:aspecified, 
get:a(ISS) is se
get:ais sent.  S
get:astate, and 
get:aIf the call
get:areturn "err:or
get:ano room to :create a new connection, return "error
get:aresources".
get:aIf active a
get:aconnection 
get:asegment, se
get:astate.  Dat
get:aqueued for 
get:aurgent bit 
get:asegments se
get:aqueue the r:equest, respond with "error
get:aIf Foreign :socket was not specified, then return "error
get:asocket unsp
get:a[Page 54]        
get:aSeptember 1981   
get:aSYN-SENT STAT
get:aSYN-RECEIVED 
get:aESTABLISHED S
get:aFIN-WAIT-1 ST
get:aFIN-WAIT-2 ST
get:aCLOSE-WAIT ST
get:aCLOSING STATE
get:aLAST-ACK STAT
get:aTIME-WAIT STA
get:aReturn "err:or
get:aTransmission Cont
get:aFunctional Specif
get:aCLOSED STATE 
get:aIf the user
get:a"error:  co
get:aOtherwise, :return "error
get:aIf the fore
get:afrom passiv
get:aSND.UNA to 
get:aassociated 
get:atransmissio
get:arequested i
get:aas a result
get:arequest, re:spond with "error
get:aForeign soc:ket was not specified, then return "error
get:asocket unsp
get:aSYN-SENT STAT
get:aSYN-RECEIVED 
get:aQueue the d
get:aIf no space: to queue, respond with "error
get:aresources".
get:aESTABLISHED S
get:aCLOSE-WAIT ST
get:aSegmentize 
get:aacknowledgm
get:ainsufficien:t space to remember this buffer, simply return "error
get:ainsufficien
get:aIf the urge
get:aurgent poin
get:a[Page 56]        
get:aSeptember 1981   
get:aFIN-WAIT-1 ST
get:aFIN-WAIT-2 ST
get:aCLOSING STATE
get:aLAST-ACK STAT
get:aTIME-WAIT STA
get:aReturn "err:or
get:aTransmission Cont
get:aFunctional Specif
get:aCLOSED STATE 
get:aIf the user
get:a"error:  co
get:aOtherwise r:eturn "error
get:aSYN-SENT STAT
get:aSYN-RECEIVED 
get:aQueue for p
get:ais no room :to queue this request, respond with "error
get:ainsufficien
get:aESTABLISHED S
get:aFIN-WAIT-1 ST
get:aFIN-WAIT-2 ST
get:aIf insuffic
get:arequest, qu
get:aremember th:e RECEIVE, respond with "error
get:aresources".
get:aReassemble 
get:ato user.  M
get:aIf RCV.UP i
get:auser notify
get:aWhen the TC
get:athat fact m
get:aacknowledgm
get:adescribed b
get:a[Page 58]        
get:aSeptember 1981   
get:aCLOSE-WAIT ST
get:aSince the r
get:asatisfied b
get:auser.  If n
get:a"error:  co
get:atext can be
get:aCLOSING STATE
get:aLAST-ACK STAT
get:aTIME-WAIT STA
get:aReturn "err:or
get:aTransmission Cont
get:aFunctional Specif
get:aCLOSED STATE 
get:aIf the user
get:a"error:  co
get:aOtherwise, :return "error
get:aAny outstan:ding RECEIVEs are returned with "error
get:aresponses. 
get:aSYN-SENT STAT
get:aDelete the :TCB and return "error
get:aqueued SEND
get:aSYN-RECEIVED 
get:aIf no SENDs
get:athen form a
get:aotherwise q
get:aESTABLISHED S
get:aQueue this 
get:aform a FIN 
get:aFIN-WAIT-1 ST
get:aFIN-WAIT-2 ST
get:aStrictly sp:eaking, this is an error and should receive a "error
get:aconnection 
get:aacceptable,
get:aFIN may be 
get:a[Page 60]        
get:aSeptember 1981   
get:aCLOSE-WAIT ST
get:aQueue this 
get:asegmentized
get:aCLOSING STATE
get:aLAST-ACK STAT
get:aTIME-WAIT STA
get:aRespond wit:h "error
get:aTransmission Cont
get:aFunctional Specif
get:aCLOSED STATE 
get:aIf the user
get:a"error:  co
get:aOtherwise r:eturn "error
get:aAny outstan:ding RECEIVEs should be returned with "error
get:aconnection 
get:aSYN-SENT STAT
get:aAll queued 
get:anotificatio
get:aSYN-RECEIVED 
get:aESTABLISHED S
get:aFIN-WAIT-1 ST
get:aFIN-WAIT-2 ST
get:aCLOSE-WAIT ST
get:aSend a rese:t segment
get:a<SEQ=SND.
get:aAll queued 
get:anotificatio
get:aRST formed 
get:aTCB, enter 
get:aCLOSING STATE
get:aLAST-ACK STAT
get:aTIME-WAIT STA
get:aRespond wit
get:a[Page 62]        
get:aSeptember 1981   
get:aCLOSED STATE 
get:aIf the user
get:a"error:  co
get:aOtherwise r:eturn "error
get:aReturn "sta
get:aSYN-SENT STAT
get:aReturn "sta
get:aSYN-RECEIVED 
get:aReturn "sta
get:aESTABLISHED S
get:aReturn "sta
get:aFIN-WAIT-1 ST
get:aReturn "sta
get:aFIN-WAIT-2 ST
get:aReturn "sta
get:aCLOSE-WAIT ST
get:aReturn "sta
get:aCLOSING STATE
get:aReturn "sta
get:aLAST-ACK STAT
get:aReturn "sta
get:aTransmission Cont
get:aFunctional Specif
get:aTIME-WAIT STA
get:aReturn "sta
get:a[Page 64]        
get:aSeptember 1981   
get:aSEGMENT ARRIVES
get:aIf the state 
get:aall data in
get:asegment con
get:acontaining 
get:aacknowledgm
get:areset seque
get:aIf the ACK 
get:a<SEQ=0><A
get:aIf the ACK 
get:a<SEQ=SEG.
get:aIf the state 
get:afirst check
get:aAn incomi
get:asecond chec
get:aAny ackno
get:athe LISTE
get:afor any a
get:aformatted: as follows
get:a<SEQ=SE
get:athird check
get:aIf the SY
get:asecurity/
get:amatch the
get:a<SEQ=SE
get:aTransmission Cont
get:aFunctional Specif
get:aIf the SE
get:athe user 
get:asend a re
get:a<SEQ=SE
get:aIf the SE
get:aSet RCV.N
get:acontrol o
get:ashould be: selected and a SYN segment sent of the form
get:a<SEQ=IS
get:aSND.NXT i
get:astate sho
get:aincoming 
get:ain the SY
get:anot be re
get:athe forei
get:aunspecifi
get:afourth othe
get:aAny other
get:amust have
get:aprocessin
get:ait could 
get:aincarnati
get:abut if yo
get:aIf the state 
get:afirst check
get:aIf the AC
get:aIf SEG.
get:athe RST
get:a<SEQ=
get:aand dis
get:aIf SND.
get:asecond chec
get:a[Page 66]        
get:aSeptember 1981   
get:aIf the RS
get:aIf the :ACK was acceptable then signal the user "error
get:aconnect
get:adelete 
get:aand ret
get:athird check
get:aIf the se
get:amatch the
get:aIf ther
get:a<SEQ=
get:aOtherwi
get:a<SEQ=
get:aIf there 
get:aThe pre
get:aTCB, if
get:a<SEQ=
get:aIf there 
get:aIf the 
get:ain the 
get:athe pre
get:aallowed
get:a<SEQ=
get:aIf the 
get:ain the 
get:aIf a rese
get:afourth chec
get:aThis step
get:ano ACK, a
get:aIf the SY
get:aTransmission Cont
get:aFunctional Specif
get:aare accep
get:aSEG.SEQ. 
get:ais an ACK
get:aare there
get:aIf SND.UN
get:astate to 
get:a<SEQ=SN
get:aand send 
get:atransmiss
get:atext in t
get:abelow whe
get:aOtherwise
get:a<SEQ=IS
get:aand send 
get:asegment, 
get:ahas been 
get:afifth, if n
get:asegment and
get:a[Page 68]        
get:aSeptember 1981   
get:afirst check s
get:aSYN-RECEIVE
get:aESTABLISHED
get:aFIN-WAIT-1 
get:aFIN-WAIT-2 
get:aCLOSE-WAIT 
get:aCLOSING STA
get:aLAST-ACK ST
get:aTIME-WAIT S
get:aSegments 
get:aare used 
get:adone in S
get:aboundary 
get:aprocessed
get:aThere are
get:asegment
get:aSegment R
get:aLength  W
get:a------- -
get:a0     
get:a0     
get:a>0     
get:a>0     
get:aIf the RC
get:aspecial a
get:aIf an inc
get:ashould be
get:athe segme:nt and return)
get:a<SEQ=SN
get:aAfter sen
get:aand retur
get:aTransmission Cont
get:aFunctional Specif
get:aIn the fo
get:asegment t
get:aOne could
get:atrimming 
get:aSYN and F
get:abegins at
get:anumbers m
get:asecond check 
get:aSYN-RECEIVE
get:aIf the RS
get:aIf this
get:acame fr
get:aLISTEN 
get:athis co
get:afrom SY
get:athe use
get:aon the 
get:aactive 
get:aand ret
get:aESTABLISHED
get:aIf the RS
get:ashould re
get:aflushed. 
get:a"connecti
get:aTCB, and 
get:aCLOSING STA
get:aLAST-ACK ST
get:aIf the RS
get:aTCB, and 
get:a[Page 70]        
get:aSeptember 1981   
get:athird check s
get:aSYN-RECEIVE
get:aIf the se
get:aexactly m
get:athen send
get:aESTABLISHED
get:aIf the se
get:aexactly m
get:athen send
get:areceive "
get:aflushed. 
get:a"connecti
get:aTCB, and 
get:aNote this c
get:aa segment f
get:adifferent s
get:acurrent con
get:afourth, check
get:aSYN-RECEIVE
get:aESTABLISHED
get:aFIN-WAIT ST
get:aFIN-WAIT ST
get:aCLOSE-WAIT 
get:aCLOSING STA
get:aLAST-ACK ST
get:aTIME-WAIT S
get:aIf the SY
get:aoutstandi
get:aall segme
get:areceive a
get:athe CLOSE
get:aIf the SY
get:aand an ac
get:anumber ch
get:aTransmission Cont
get:aFunctional Specif
get:afifth check t
get:aif the ACK 
get:aif the ACK 
get:aSYN-RECEI
get:aIf SND.
get:aand con
get:aIf th
get:areset
get:a<SE
get:aand s
get:aESTABLISH
get:aIf SND.
get:aAny seg
get:aentirel
get:apositiv
get:afully a
get:a"ok" re
get:a(SEG.AC
get:asomethi
get:adrop th
get:aIf SND.
get:aupdated
get:aSND.WL2
get:aSND.WL1
get:aNote th
get:arecords
get:aSND.WND
get:athe las
get:aprevent
get:a[Page 72]        
get:aSeptember 1981   
get:aFIN-WAIT-
get:aIn addi
get:aour FIN
get:aprocess
get:aFIN-WAIT-
get:aIn addi
get:athe ret
get:aacknowl
get:aCLOSE-WAI
get:aDo the 
get:aCLOSING S
get:aIn addi
get:athe ACK
get:aotherwi
get:aLAST-ACK 
get:aThe onl
get:aacknowl
get:adelete 
get:aTIME-WAIT
get:aThe onl
get:aretrans
get:athe 2 M
get:asixth, check 
get:aESTABLISHED
get:aFIN-WAIT-1 
get:aFIN-WAIT-2 
get:aIf the UR
get:athe user 
get:apointer (
get:auser has 
get:amode") fo
get:asignal th
get:aTransmission Cont
get:aFunctional Specif
get:aCLOSE-WAIT 
get:aCLOSING STA
get:aLAST-ACK ST
get:aThis shou
get:aremote si
get:aseventh, proc
get:aESTABLISHED
get:aFIN-WAIT-1 
get:aFIN-WAIT-2 
get:aOnce in t
get:atext to u
get:ainto buff
get:aempty.  I
get:athe user 
get:ahas been 
get:aWhen the 
get:auser it m
get:aOnce the 
get:aRCV.NXT o
get:aapporopri
get:aRCV.NXT a
get:aPlease no
get:aSend an a:cknowledgment of the form
get:a<SEQ=SN
get:aThis ackn
get:atransmitt
get:a[Page 74]        
get:aSeptember 1981   
get:aCLOSE-WAIT 
get:aCLOSING STA
get:aLAST-ACK ST
get:aTIME-WAIT S
get:aThis shou
get:aremote si
get:aeighth, check
get:aDo not proc
get:asince the S
get:aIf the FIN 
get:areturn any 
get:aover the FI
get:aFIN implies
get:aSYN-RECEI
get:aESTABLISH
get:aEnter t
get:aFIN-WAIT-
get:aIf our 
get:aenter T
get:atimers;
get:aFIN-WAIT-
get:aEnter t
get:aoff the
get:aCLOSE-WAI
get:aRemain 
get:aCLOSING S
get:aRemain 
get:aLAST-ACK 
get:aRemain 
get:aTransmission Cont
get:aFunctional Specif
get:aTIME-WAIT
get:aRemain 
get:atimeout
get:a[Page 76]        
get:aSeptember 1981   
get:aFor any state
get:athe user "err:or
get:aand for any o
get:astate and ret
get:aRETRANSMISSION 
get:aFor any state
get:athe retransmi
get:aretransmissio
get:aTIME-WAIT TIMEO
get:aIf the time-w
get:aenter the CLO
get:aTransmission Cont
get:a[Page 78]        
get:aSeptember 1981   
get:aBBN Rep
get:aa Host 
get:ahost an
get:aA contr
get:aindicat
get:aspecifi
get:ais expe
get:apreviou
get:aThe uni
get:aARPANET
get:aA unit 
get:aIMPs.  
get:aA logic
get:aA messa
get:anetwork
get:aDestination Addre
get:aThe des
get:aidentif
get:aA contr
get:aindicat
get:aoccupyi
get:aA porti
get:afragmen
get:aA file 
get:aTransmission Cont
get:aControl
get:afragmen
get:aA compu
get:afrom th
get:aAn Inte
get:aby the 
get:aThe Int
get:aARPANET
get:aA sourc
get:ainternet datagram
get:aThe uni
get:ahigher 
get:ainternet fragment
get:aA porti
get:aheader.
get:aInterne
get:aThe Ini
get:anumber 
get:aThe Ini
get:aon a co
get:abased p
get:aThe Ini
get:aused by
get:aControl
get:adata.  
get:aon an A
get:a[Page 80]        
get:aSeptember 1981   
get:aThis is
get:adata re
get:asequenc
get:aof the 
get:aThe uni
get:aAn impl
get:aprocedu
get:aMaximum
get:athe int
get:aAn eigh
get:aAn Opti
get:amay be 
get:aprimari
get:atimesta
get:aoptions
get:aA packa
get:alogical
get:alogical
get:aThe por
get:aoutput 
get:aA progr
get:athe poi
get:aA contr
get:athis se
get:areceivi
get:areceive
get:aTransmission Cont
get:areceive
get:areceive
get:areceive next sequ
get:aThis is
get:areceive
get:aThis re
get:ais will
get:asegment
get:aRCV.NXT
get:aSegment
get:arange a
get:aA contr
get:athat th
get:ainterac
get:asequenc
get:asegment
get:ait.  In
get:arise to
get:aReal Ti:me Protocol
get:aof time
get:asegment
get:asegment
get:asegment
get:asegment
get:asegment
get:a[Page 82]        
get:aSeptember 1981   
get:asegment
get:aA logic
get:aunit of
get:asegment acknowled
get:aThe seq
get:aarrivin
get:aThe amo
get:aincludi
get:aThe num
get:aThis is
get:ause on 
get:ainitial
get:aeach oc
get:aThis re
get:a(receiv
get:awindow 
get:areceivi
get:abe emit
get:aSND.UNA
get:abetween
get:asend se
get:aleft se
get:asend ur
get:asegment
get:asegment
get:aTransmission Cont
get:asend wi
get:aAn addr
get:ais, the
get:aThe sou
get:aA contr
get:anumber,
get:awhere t
get:aTransmi
get:athe sta
get:aThe pre
get:aTransmi:ssion Control Protocol
get:areliabl
get:aType of
get:aAn Inte
get:afor thi
get:aA contr
get:aindicat
get:aurgent 
get:asequenc
get:apointer
get:aA contr
get:afield c
get:aindicat
get:aurgent 
get:a[Page 84]        
get:aSeptember 1981   
get:a[1]  Cerf, V., an
get:aIntercommuni
get:aVol. COM-22,
get:a[2]  Postel, J. (
get:aProtocol Spe
get:aInstitute, S
get:a[3]  Dalal, Y. an
get:aProtocols", 
get:aDecember 197
get:a[4]  Postel, J., 
get:aInstitute, S
get:bRFC
get:bDe
get:bI
get:bSeptember 1981   
get:bPREFACE .....
get:b1.  INTRODUCTION 
get:b1.1  Motivation
get:b1.2  Scope ....
get:b1.3  About This
get:b1.4  Interfaces
get:b1.5  Operation 
get:b2.  PHILOSOPHY ..
get:b2.1  Elements o
get:b2.2  Model of O
get:b2.3  The Host E
get:b2.4  Interfaces
get:b2.5  Relation t
get:b2.6  Reliable C
get:b2.7  Connection
get:b2.8  Data Commu
get:b2.9  Precedence
get:b2.10 Robustness
get:b3.  FUNCTIONAL SP
get:b3.1  Header For
get:b3.2  Terminolog
get:b3.3  Sequence N
get:b3.4  Establishi
get:b3.5  Closing a 
get:b3.6  Precedence
get:b3.7  Data Commu
get:b3.8  Interfaces
get:b3.9  Event Proc
get:bGLOSSARY ........
get:bREFERENCES ......
get:bTransmission Cont
get:b[Page ii]        
get:bSeptember 1981   
get:bThis document des
get:b(TCP).  There hav
get:bspecification on 
get:bdraws heavily fro
get:bboth in terms of 
get:bseveral details a
get:band redescribes t
get:bRFC
get:bReplaces: RFC 761
get:bIENs:  129, 124, 
get:b55, 44, 40, 27, 2
get:bThe Transmission 
get:breliable host-to-
get:bcommunication net
get:bThis document des
get:bTransmission Cont
get:binterface to prog
get:bComputer commun
get:brole in militar
get:bdocument focuse
get:bcommunication r
get:bcommunication u
get:bcongestion, but
get:bgovernment sect
get:bAs strategic an
get:bdeveloped and d
get:binterconnecting
get:bcommunication p
get:bapplications.  
get:bDeputy Undersec
get:bdeclared the Tr
get:bbe a basis for 
get:bstandardization
get:bTCP is a connec
get:bfit into a laye
get:bapplications.  
get:bcommunication b
get:bdistinct but in
get:bassumptions are
get:bprotocols below
get:bpotentially unr
get:bprotocols.  In 
get:bwide spectrum o
get:bconnections to 
get:bTransmission Cont
get:bTCP is based on
get:bTCP fits into a
get:bInternet Protoc
get:breceive variabl
get:bdatagram "envel
get:baddressing sour
get:binternet protoc
get:bthe TCP segment
get:bmultiple networ
get:balso carries in
get:band compartment
get:bcommunicated en
get:bMuch of this do
get:bwhich are co-re
get:bcomputer.  Some
get:bfront-end compu
get:bas well as netw
get:ban interface to
get:bimplementable e
get:bhost-to-front e
get:bThe TCP is inte
get:bcommunication s
get:bintended to be 
get:b1.3.  About this 
get:bThis document r
get:bany TCP impleme
get:bprotocols and i
get:b[Page 2]         
get:bSeptember 1981   
get:bsection offers 
get:boperation.  Sec
get:bdesign.  Sectio
get:brequired of TCP
get:buser calls, err
get:bThe TCP interfa
get:bthe other side 
get:bThe interface b
get:billustrated in 
get:bcalls much like
get:bapplication pro
get:bcalls to open a
get:bestablished con
get:basynchronously 
get:bconsiderable fr
get:binterfaces whic
get:benvironment, a 
get:binterface for a
get:bThe interface b
get:bunspecified exc
get:btwo levels can 
get:bTypically, one 
get:binterface.  TCP
get:binterconnected 
get:bthroughout this
get:bAs noted above,
get:bsecurable logic
get:bprocesses.  To 
get:bcommunication s:ystem requires facilities in the following areas
get:bBasic Data Tr
get:bPrecedence an
get:bThe basic opera
get:bthe following p
get:bTransmission Cont
get:bBasic Data Tran:sfer
get:bThe TCP is ab
get:bdirection bet
get:bsegments for 
get:bthe TCPs deci
get:bSometimes use
get:bsubmitted to 
get:bfunction is d
get:bactually tran
get:bpushed throug
get:bpromptly forw
get:bThe exact pus
get:bthe push func
get:bReliability
get:bThe TCP must 
get:bdelivered out
get:bis achieved b
get:btransmitted, 
get:breceiving TCP
get:binterval, the
get:bnumbers are u
get:bout of order 
get:badding a chec
get:breceiver, and
get:bAs long as th
get:bsystem does n
get:berrors will a
get:binternet comm
get:bFlow Control
get:bTCP provides 
get:bsent by the s
get:bevery ACK ind
get:bthe last segm
get:ballowed numbe
get:breceiving fur
get:b[Page 4]         
get:bSeptember 1981   
get:bMultiplexing
get:bTo allow for 
get:bcommunication
get:baddresses or 
get:band host addr
get:ba socket.  A 
get:bThat is, a so
get:bThe binding o
get:bHost.  Howeve
get:b(e.g., a "log
get:bmade known to
get:bthrough the k
get:baddresses of 
get:bConnections
get:bThe reliabili
get:bthat TCPs ini
get:beach data str
get:bsockets, sequ
get:bEach connecti
get:bidentifying i
get:bWhen two proc
get:bestablish a c
get:bside).  When 
get:bterminated or
get:bSince connect
get:bover the unre
get:bmechanism wit
get:berroneous ini
get:bPrecedence and :Security
get:bThe users of 
get:bcommunication
get:bthese feature
get:bTransmission Cont
get:b[Page 6]         
get:bSeptember 1981   
get:b2.1.  Elements of
get:bThe internetwor
get:bwhich are in tu
get:bthat the networ
get:blarge networks 
get:bpacket switchin
get:bconsume message
get:bnetworks, the g
get:bcommunication s
get:bconnections bet
get:bThe term packet
get:btransaction bet
get:bexchanged withi
get:bHosts are compu
get:bnetwork's point
get:bProcesses are v
get:baccordance with
get:bin execution). 
get:bviewed as commu
get:bThus, all commu
get:bSince a process
get:bstreams between
get:bthat each proce
get:bcommunicates wi
get:b2.2.  Model of Op
get:bProcesses trans
get:bdata as argumen
get:bsegments and ca
get:bthe destination
get:binto the receiv
get:bTCPs include co
get:bensure reliable
get:bThe model of in
get:bprotocol module
get:bto the local ne
get:binside internet
get:binternet module
get:bthrough the loc
get:bThe packet swit
get:bTransmission Cont
get:bother operation
get:bdestination int
get:bAt a gateway be
get:bfrom its local 
get:bthe internet da
get:bthen "wrapped" 
get:brouted to the n
get:bA gateway is pe
get:binternet datagr
get:bthrough the nex
get:binternet datagr
get:bfurther broken 
get:binternet datagr
get:binternet module
get:bA destination i
get:b(after reassemb
get:bdestination TCP
get:bThis simple mod
get:bimportant featu
get:bto the gateway 
get:bservice paramet
get:bIncluded in the
get:bdatagram.  Data
get:bhost and gatewa
get:bproperly segreg
get:b2.3.  The Host En
get:bThe TCP is assu
get:baccess the TCP 
get:bmay call on oth
get:bdata structures
get:bcontrolled by a
get:bnetwork device 
get:bdatagram protoc
get:bThe mechanisms 
get:bfront-end proce
get:bhost-to-front-e
get:bthe type of TCP
get:b[Page 8]         
get:bSeptember 1981   
get:bThe TCP/user in
get:bto OPEN or CLOS
get:bSTATUS about a 
get:bprograms on the
get:bfrom, and close
get:bThe TCP/interne
get:bdatagrams addre
get:bsystem.  These 
get:bservice, preced
get:b2.5.  Relation to
get:bThe following d
get:bhierarchy
get:b+------+ +
get:b|Telnet| |
get:b+------+ +
get:b|   
get:b+----
get:b| TCP
get:b+----
get:b| 
get:b+----
get:b|    
get:b+----
get:b+--
get:b|  
get:b+--
get:bIt is expected 
get:bprotocols effic
get:bprotocols like 
get:b2.6.  Reliable Co
get:bA stream of dat
get:border at the de
get:bTransmission Cont
get:bTransmission is
get:backnowledgments
get:bsequence number
get:bsegment is tran
get:bsequence number
get:bis the sequence
get:btransmissions i
get:bsegment contain
get:bstarts a timer;
get:bsegment is dele
get:breceived before
get:bAn acknowledgme
get:bdelivered to th
get:bthe responsibil
get:bTo govern the f
get:bemployed.  The 
get:bThis window spe
get:backnowledgment 
get:b2.7.  Connection 
get:bTo identify the
get:bprovides a port
get:bindependently b
get:bunique addresse
get:bidentifying the
get:bwill be unique 
get:bA connection is
get:blocal socket ma
get:bsockets.  A con
get:bthat is, it is 
get:bTCPs are free t
get:bHowever, severa
get:bThere must be w
get:bthe "appropriat
get:bmay "own" ports
get:bthe ports they 
get:bissue, but we e
get:buniquely alloca
get:bassociating the
get:bA connection is
get:bforeign socket 
get:b[Page 10]        
get:bSeptember 1981   
get:bconnection name
get:bsubsequent call
get:babout a connect
get:bis a data struc
get:bimplementation 
get:bpointer to the 
get:bwhether the con
get:bbe passively wa
get:bA passive OPEN 
get:bconnection requ
get:bOften the proce
get:brequest from an
get:bis used to deno
get:bare allowed onl
get:bA service proce
get:bprocesses would
get:bforeign socket.
get:brequested a con
get:blocal socket we
get:bWell-known sock
get:ba socket addres
get:b"Telnet-Server"
get:bsocket, and oth
get:bEntry, Text Gen
get:bbeing for test 
get:baccess to a "Lo
get:bat which a newl
get:bwell-known sock
get:bof sockets to s
get:bProcesses can i
get:bfrom other proc
get:bbeen establishe
get:bother at the sa
get:bis critical for
get:bcomponents act 
get:bThere are two p
get:bpassive OPENs a
get:blocal passive O
get:bcase, the match
get:bOPENs has left 
get:bforeign socket 
get:bOther possibili
get:bTransmission Cont
get:bIf there are se
get:bsame local sock
get:bwith the specif
get:bTCB exists, bef
get:bThe procedures 
get:bcontrol flag an
get:bexchange has be
get:bA connection is
get:bcontaining a SY
get:bcommand.  The m
get:bconnection has 
get:bwhen sequence n
get:bThe clearing of
get:bin this case ca
get:b2.8.  Data Commun
get:bThe data that f
get:boctets.  The se
get:bin that call (a
get:bthrough to the 
get:bA sending TCP i
get:bsend that data 
get:bfunction is sig
get:breceiving TCP s
get:bthe sending TCP
get:bThere is no nec
get:bboundaries.  Th
get:bsingle SEND cal
get:bThe purpose of 
get:bfrom the sendin
get:brecord service.
get:bThere is a coup
get:bof data that cr
get:bassociated with
get:bbuffer is retur
get:bnot filled.  If
get:bPUSH is seen, t
get:bTCP also provid
get:bat some point f
get:b[Page 12]        
get:bSeptember 1981   
get:bcurrently readi
get:bdefine what the
get:burgent data, bu
get:btake action to 
get:b2.9.  Precedence 
get:bThe TCP makes u
get:bsecurity option
get:bbasis to TCP us
get:ba multilevel se
get:buse only, and o
get:bcompartment.  C
get:busers may be li
get:bTCP modules whi
get:bproperly mark o
get:bprecedence.  Su
get:bhigher level pr
get:bthem to specify
get:bprecedence of c
get:b2.10.  Robustness
get:bTCP implementat:ions will follow a general principle of robustness
get:bconservative in
get:bTransmission Cont
get:b[Page 14]        
get:bSeptember 1981   
get:b3.1.  Header Form
get:bTCP segments ar
get:bheader carries 
get:bdestination hos
get:bheader, supplyi
get:bdivision allows
get:bTCP Header Form
get:b0            
get:b0 1 2 3 4 5 6
get:b+-+-+-+-+-+-+-
get:b|          Sou
get:b+-+-+-+-+-+-+-
get:b|             
get:b+-+-+-+-+-+-+-
get:b|             
get:b+-+-+-+-+-+-+-
get:b|  Data |     
get:b| Offset| Rese
get:b|       |     
get:b+-+-+-+-+-+-+-
get:b|           Ch
get:b+-+-+-+-+-+-+-
get:b|             
get:b+-+-+-+-+-+-+-
get:b|             
get:b+-+-+-+-+-+-+-
get:bNote th
get:bSource Port:  1
get:bThe source po
get:bDestination Por:t
get:bThe destinati
get:bTransmission Cont
get:bFunctional Specif
get:bSequence Number:
get:bThe sequence 
get:bwhen SYN is p
get:binitial seque
get:bAcknowledgment :Number
get:bIf the ACK co
get:bnext sequence
get:breceive.  Onc
get:bData Offset:  4
get:bThe number of
get:bthe data begi
get:bintegral numb
get:bReserved:  6 bi
get:bReserved for 
get:bControl Bits:  :6 bits (from left to right)
get:bURG:  Urgent 
get:bACK:  Acknowl
get:bPSH:  Push Fu
get:bRST:  Reset t
get:bSYN:  Synchro
get:bFIN:  No more
get:bWindow:  16 bit
get:bThe number of
get:backnowledgmen
get:bChecksum:  16 b
get:bThe checksum 
get:bcomplement su
get:bsegment conta
get:bchecksummed, 
get:bform a 16 bit
get:btransmitted a
get:bthe checksum 
get:bThe checksum 
get:b[Page 16]        
get:bSeptember 1981   
get:bprefixed to t
get:bAddress, the 
get:bThis gives th
get:binformation i
get:bacross the TC
get:bcalls by the 
get:bThe TCP Len
get:boctets (thi
get:bcomputed), 
get:bUrgent Pointer:
get:bThis field co
get:bpositive offs
get:burgent pointe
get:bthe urgent da
get:bthe URG contr
get:bOptions:  varia
get:bOptions may o
get:bmultiple of 8
get:bchecksum.  An
get:bcases for the: format of an option
get:bCase 1:  A 
get:bCase 2:  An
get:bth
get:bThe option-le
get:boption-length
get:bNote that the
get:bfield might i
get:bEnd-of-Option
get:bA TCP must im
get:bTransmission Cont
get:bFunctional Specif
get:bCurrently def:ined options include (kind indicated in octal)
get:bKind     Le
get:b----     --
get:b0         
get:b1         
get:b2         
get:bSpecific Opti
get:bEnd of Opti
get:b+--------
get:b|00000000
get:b+--------
get:bThis opti
get:bmight not
get:bthe Data 
get:bnot the e
get:bthe optio
get:bNo-Operatio
get:b+--------
get:b|00000001
get:b+--------
get:bThis opti
get:balign the
get:bThere is 
get:breceivers
get:bnot begin
get:bMaximum Seg
get:b+--------
get:b|00000010
get:b+--------
get:bKind=2  
get:b[Page 18]        
get:bSeptember 1981   
get:bMaximum S:egment Size Option Data
get:bIf this
get:breceive
get:bThis fi
get:b(i.e., 
get:boption 
get:bPadding:  varia
get:bThe TCP heade
get:band data begi
get:b3.2.  Terminology
get:bBefore we can d
get:bto introduce so
get:bconnection requ
get:bof these variab
get:bTransmission Co
get:bTCB are the loc
get:bprecedence of t
get:bbuffers, pointe
get:bIn addition sev
get:bsequence number
get:bSend Sequence
get:bSND.UNA - s
get:bSND.NXT - s
get:bSND.WND - s
get:bSND.UP  - s
get:bSND.WL1 - s
get:bSND.WL2 - s
get:bu
get:bISS     - i
get:bReceive Seque
get:bRCV.NXT - r
get:bRCV.WND - r
get:bRCV.UP  - r
get:bIRS     - i
get:bTransmission Cont
get:bFunctional Specif
get:bThe following d
get:bthe sequence sp
get:bSend Sequence S
get:b---
get:b1 - old s
get:b2 - seque
get:b3 - seque
get:b4 - futur
get:bThe send window
get:bReceive Sequenc
get:b1 - old s
get:b2 - seque
get:b3 - futur
get:bThe receive win
get:bThere are also 
get:btake their valu
get:b[Page 20]        
get:bSeptember 1981   
get:bCurrent Segme
get:bSEG.SEQ - s
get:bSEG.ACK - s
get:bSEG.LEN - s
get:bSEG.WND - s
get:bSEG.UP  - s
get:bSEG.PRC - s
get:bA connection pr
get:blifetime.  The :states are
get:bESTABLISHED, FI
get:bTIME-WAIT, and 
get:bbecause it repr
get:bno connection. : Briefly the meanings of the states are
get:bLISTEN - repr
get:bTCP and port.
get:bSYN-SENT - re
get:bafter having 
get:bSYN-RECEIVED 
get:brequest ackno
get:bconnection re
get:bESTABLISHED -
get:bdelivered to 
get:bof the connec
get:bFIN-WAIT-1 - 
get:bfrom the remo
get:btermination r
get:bFIN-WAIT-2 - 
get:bfrom the remo
get:bCLOSE-WAIT - 
get:bfrom the loca
get:bCLOSING - rep
get:backnowledgmen
get:bLAST-ACK - re
get:bconnection te
get:b(which includ
get:bTransmission Cont
get:bFunctional Specif
get:bTIME-WAIT - r
get:bthe remote TC
get:btermination r
get:bCLOSED - repr
get:bA TCP connectio
get:bevents.  The ev
get:bABORT, and STAT
get:bcontaining the 
get:bThe state diagr
get:bwith the causin
get:berror condition
get:bchanges.  In a 
get:bthe reaction of
get:bNOTE BENE:  thi
get:bthe total speci
get:b[Page 22]        
get:bSeptember 1981   
get:b+---------+     
get:b|         |<----
get:b|   SYN   |     
get:b|   RCVD  |<----
get:b|         |     
get:b|         |-----
get:b+---------+   rc
get:b|           --
get:b|             
get:b|             
get:b|  CLOSE      
get:b| -------     
get:b| snd FIN     
get:b|             
get:bV             
get:b+---------+     
get:b|  FIN    |<----
get:b| WAIT-1  |-----
get:b+---------+     
get:b| rcv ACK of F
get:b| ------------
get:bV        x    
get:b+---------+     
get:b|FINWAIT-2|     
get:b+---------+     
get:b|             
get:b|  rcv FIN    
get:b|  -------    
get:b\ snd ACK    
get:b------------
get:bTransmission Cont
get:bFunctional Specif
get:b3.3.  Sequence Nu
get:bA fundamental n
get:bover a TCP conn
get:bsequenced, each
get:bmechanism emplo
get:bnumber X indica
get:breceived.  This
get:bdetection in th
get:bwithin a segmen
get:bthe header is t
get:bnumbered consec
get:bIt is essential
get:bfinite, though 
get:bSince the space
get:bnumbers must be
get:bpreserves the r
get:b2**32 - 1 to 0 
get:barithmetic, so 
get:bcomparison of s
get:b(modulo 2**32).
get:bThe typical kin
get:bperform include:
get:b(a)  Determin
get:bnumber s
get:b(b)  Determin
get:bhave bee
get:bretransm
get:b(c)  Determin
get:bwhich ar
get:breceive 
get:b[Page 24]        
get:bSeptember 1981   
get:bIn response to 
get:bfollowing compa
get:bSND.UNA = old
get:bSND.NXT = nex
get:bSEG.ACK = ack
get:bnum
get:bSEG.SEQ = fir
get:bSEG.LEN = the
get:b(co
get:bSEG.SEQ+SEG.L
get:bA new acknowled
get:bthe inequality :below holds
get:bSND.UNA < SEG
get:bA segment on th
get:bof its sequence
get:backnowledgment 
get:bWhen data is re:ceived the following comparisons are needed
get:bRCV.NXT = nex
get:bis the le
get:bRCV.NXT+RCV.W
get:bsegment, 
get:bSEG.SEQ = fir
get:bSEG.SEQ+SEG.L
get:bA segment is ju
get:bRCV.NXT =< SE
get:bRCV.NXT =< SE
get:bTransmission Cont
get:bFunctional Specif
get:bThe first part 
get:bsegment falls i
get:bif the end of t
get:beither part of 
get:bActually, it is
get:bwindows and zer
get:bacceptability o:f an incoming segment
get:bSegment Recei
get:bLength  Windo
get:b------- -----
get:b0       0 
get:b0      >0 
get:b>0       0 
get:b>0      >0 
get:bNote that when 
get:bacceptable exce
get:bmaintain a zero
get:bACKs.  However,
get:bprocess the RST
get:bWe have taken a
get:bcontrol informa
get:bsome control fl
get:band acknowledge
get:bcontrol will be
get:bcarried in the 
get:bfor implicitly 
get:bare the only co
get:bare used only a
get:bpurposes, the S
get:boctet of the se
get:bto occur after 
get:boccurs.  The se
get:bspace occupying
get:bsequence number
get:b[Page 26]        
get:bSeptember 1981   
get:bInitial Sequenc
get:bThe protocol pl
get:bused over and o
get:bsockets.  New i
get:bincarnations of
get:b-- "how does th
get:bincarnations of
get:bconnection is b
get:bconnection brea
get:bTo avoid confus
get:bconnection from
get:bbe present in t
get:bassure this, ev
get:bsequence number
get:ban initial sequ
get:bnew 32 bit ISN.
get:bbit clock whose
get:bmicroseconds.  
get:bSince we assume
get:bthe Maximum Seg
get:bhours we can re
get:bFor each connec
get:bsequence number
get:bthe data sendin
get:blearned during 
get:bFor a connectio
get:bsynchronize on 
get:ban exchange of 
get:bcalled "SYN" (f
get:bshorthand, segm
get:bHence, the solu
get:binitial sequenc
get:bThe synchroniza
get:bsequence number
get:bfrom the other 
get:binitial sequenc
get:b1) A --> B  S
get:b2) A <-- B  A
get:b3) A <-- B  S
get:b4) A --> B  A
get:bTransmission Cont
get:bFunctional Specif
get:bBecause steps 2
get:bcalled the thre
get:bA three way han
get:btied to a globa
get:bmechanisms for 
get:bno way of knowi
get:bunless it remem
get:b(which is not a
get:bverify this SYN
get:bclock-driven sc
get:bKnowing When to
get:bTo be sure that
get:bsequence number
get:bthe network, th
get:b(MSL) before as
get:brecovering from
get:blost.  For this
get:bis an engineeri
get:bit is desirable
get:bsense, yet reta
get:bnot wait at all
get:bthan those rece
get:bThe TCP Quiet T
get:bThis specific
get:bretaining any
get:beach active (
get:bTCP segments 
get:bin the intern
get:bparagraphs be
get:bTCP implement
get:bat the risk o
get:bdata rejected
get:bTCPs consume 
get:bentered into 
get:bduplicate det
get:brelies on the
get:bthe extent th
get:bvalues before
get:bbeen delivere
get:bcopies of the
get:bsuch an assum
get:b[Page 28]        
get:bSeptember 1981   
get:bassigned the 
get:bat the receiv
get:bthat each seg
get:bas there are 
get:bUnder normal 
get:bto emit and t
get:bmistakenly us
get:bbeen acknowle
get:bdata is drain
get:bvery large to
get:bcause trouble
get:bto use up 2**
get:blifetime in t
get:bthis is deeme
get:brates escalat
get:bcycle time is
get:bwithin reason
get:bThe basic dup
get:bdefeated, how
get:bsequence numb
get:bthe TCP were 
get:bupon crashing
get:bconnection (p
get:bpackets with 
get:bpackets still
get:bincarnation o
get:babout the seq
get:bspecification
get:bbefore emitti
get:bsegments from
get:bEven hosts wh
get:binitial seque
get:b(i.e., even i
get:bnumber for ea
get:bSuppose, for 
get:bsequence numb
get:band that even
get:btakes on a va
get:bsegment sent 
get:bat this insta
get:bincarnation o
get:bS1 = ISN(t) -
get:bconnection!  
get:bTransmission Cont
get:bFunctional Specif
get:bduplicates in
get:bof S1 may arr
get:bthe new incar
get:bThe problem i
get:bcrashed nor d
get:bthe system fr
get:bOne way to de
get:bsegments for 
get:btime" specifi
get:bwilling to ri
get:bdestination m
get:bImplementors 
get:bconnection by
get:binformally im
get:bObviously, ev
get:bnecessary aft
get:bTo summarize:
get:bnumbers in th
get:b"busy" or "in
get:bblock of spac
get:bsegment, if a
get:bsequence numb
get:bthe previous 
get:bnumber overla
get:b3.4.  Establishin
get:bThe "three-way 
get:bconnection.  Th
get:bresponded to by
get:bsimultaneously 
get:boccurs, each TC
get:backnowledgment 
get:ban old duplicat
get:brecipient, that
get:bProper use of "
get:bSeveral example
get:bexamples do not
get:bsegments, this 
get:bdoesn't deliver
get:bvalid (i.e., th
get:bconnection reac
get:breduces the pos
get:b[Page 30]        
get:bSeptember 1981   
get:bimplementation 
get:binformation for
get:bThe simplest th
get:bfigures should 
get:bnumbered for re
get:bdeparture of a 
get:bsegment at B fr
get:bEllipsis (...) 
get:b(delayed).  An 
get:bComments appear
get:bthe departure o
get:bthe center of e
get:bform, with sequ
get:bfields such as 
get:bin the interest
get:bTCP A      
get:b1.  CLOSED     
get:b2.  SYN-SENT   
get:b3.  ESTABLISHED
get:b4.  ESTABLISHED
get:b5.  ESTABLISHED
get:bBasic 3
get:bIn line 2 of fi
get:bindicating that
get:bnumber 100.  In
get:breceived from T
get:bB is now expect
get:boccupied sequen
get:bAt line 4, TCP 
get:bTCP B's SYN; an
get:bsequence number
get:bbecause the ACK
get:bwould wind up A
get:bTransmission Cont
get:bFunctional Specif
get:bSimultaneous in
get:bfigure 8.  Each
get:bTCP A      
get:b1.  CLOSED     
get:b2.  SYN-SENT   
get:b3.  SYN-RECEIVE
get:b4.             
get:b5.  SYN-RECEIVE
get:b6.  ESTABLISHED
get:b7.             
get:bS
get:bThe principle r
get:bduplicate conne
get:bthis, a special
get:breceiving TCP i
get:bSYN-RECEIVED), 
get:bIf the TCP is i
get:bFIN-WAIT-1, FIN
get:baborts the conn
get:bcase under "hal
get:b[Page 32]        
get:bSeptember 1981   
get:bTCP A      
get:b1.  CLOSED     
get:b2.  SYN-SENT   
get:b3.  (duplicate)
get:b4.  SYN-SENT   
get:b5.  SYN-SENT   
get:b6.             
get:b7.  SYN-SENT   
get:b8.  ESTABLISHED
get:bAs a simple exa
get:bfigure 9.  At l
get:bcannot tell tha
get:b(line 4).  TCP 
get:bRST (reset) wit
get:bbelievable.  TC
get:bWhen the origin
get:bsynchronization
get:bbefore the RST,
get:bsent in both di
get:bHalf-Open Conne
get:bAn established 
get:bTCPs has closed
get:bknowledge of th
get:bbecome desynchr
get:bmemory.  Such c
get:battempt is made
get:bconnections are
get:bmildly involved
get:bIf at site A th
get:bTransmission Cont
get:bFunctional Specif
get:buser at site B 
get:breceiving a res
get:bsite B TCP that
get:bAssume that two
get:banother when a 
get:bDepending on th
get:bthat some error
get:bA is likely to 
get:bpoint.  As a re
get:bor try to SEND 
get:bcase, it receiv
get:blocal (A's) TCP
get:bwill send a seg
get:bexample shown i
get:bre-open the con
get:bTCP A      
get:b1.  (CRASH)    
get:b2.  CLOSED     
get:b3.  SYN-SENT --
get:b4.  (!!)     <-
get:b5.  SYN-SENT --
get:b6.  SYN-SENT   
get:b7.  SYN-SENT --
get:bWhen the SYN ar
get:band the incomin
get:backnowledgment 
get:b100).  TCP A se
get:bsent and, being
get:bdetected a half
get:b[Page 34]        
get:bSeptember 1981   
get:bcontinue to try
get:breduced to the 
get:bAn interesting 
get:btries to send d
get:bThis is illustr
get:bTCP A from TCP 
get:bexists, so TCP 
get:bprocesses it an
get:bTCP A    
get:b1.  (CRASH)    
get:b2.  (??)    <--
get:b3.          -->
get:bActive
get:bIn figure 12, w
get:bwaiting for SYN
get:binto action.  A
get:bgenerate a RST 
get:bthe reset and r
get:bTCP A      
get:b1.  LISTEN     
get:b2.       ... <S
get:b3.  (??) <-- <S
get:b4.       --> <S
get:b5.  LISTEN     
get:bOld Duplic
get:bTransmission Cont
get:bFunctional Specif
get:bA variety of ot
get:bby the followin
get:bReset Generatio
get:bAs a general ru
get:bwhich apparentl
get:bmust not be sen
get:bThere are three: groups of states
get:b1.  If the co
get:bin response t
get:bparticular, S
get:bby this means
get:bIf the incomi
get:bsequence numb
get:breset has seq
get:bof the sequen
get:bThe connectio
get:b2.  If the co
get:bSYN-SENT, SYN
get:bsomething not
get:bif an incomin
get:bdoes not exac
get:bconnection, a
get:bIf our SYN ha
get:bincoming segm
get:beither raise 
get:bthe system) o
get:bincoming segm
get:bcontinue as i
get:bcannot raise 
get:bdetected in t
get:bterminated th
get:bincoming segm
get:bmatch the loc
get:bmust be sent.
get:bIf the incomi
get:bsequence numb
get:breset has seq
get:bof the sequen
get:bThe connectio
get:b[Page 36]        
get:bSeptember 1981   
get:b3.  If the co
get:bFIN-WAIT-1, F
get:bany unaccepta
get:bunacceptible 
get:backnowledgmen
get:band an acknow
get:bto be receive
get:bIf an incomin
get:bprecedence wh
get:band precedenc
get:bconnection go
get:bnumber from t
get:bReset Processin
get:bIn all states e
get:bby checking the
get:bis in the windo
get:bto an initial S
get:backnowledges th
get:bThe receiver of
get:breceiver was in
get:bin SYN-RECEIVED
get:bthen the receiv
get:baborts the conn
get:bwas in any othe
get:band goes to the
get:b3.5.  Closing a C
get:bCLOSE is an ope
get:bnotion of closi
get:binterpretation,
get:bthe receiving s
get:bin a simplex fa
get:buntil he is tol
get:bcould initiate 
get:bRECEIVE until s
get:bhas CLOSED.  We
get:bRECEIVEs are ou
get:bcan terminate h
get:bbuffers SENT be
get:bdata in return 
get:bsuccessfully to
get:bTCP.  Users mus
get:bthe TCP says no
get:bTransmission Cont
get:bFunctional Specif
get:bThere are essen:tially three cases
get:b1) The user i
get:b2) The remote
get:b3) Both users
get:bCase 1:  Local 
get:bIn this case,
get:boutgoing segm
get:baccepted by t
get:bare allowed i
get:bwill be retra
get:bboth acknowle
get:bcan ACK this 
get:bsend its own 
get:bCase 2:  TCP re
get:bIf an unsolic
get:bcan ACK it an
get:buser will res
get:bthe other TCP
get:buntil its own
get:bconnection.  
get:bthe connectio
get:bCase 3:  both u
get:bA simultaneou
get:bFIN segments 
get:bhave been pro
get:bhas received.
get:b[Page 38]        
get:bSeptember 1981   
get:bTCP A      
get:b1.  ESTABLISHED
get:bFIN-WAIT-1 
get:b3.  FIN-WAIT-2 
get:b4.             
get:bTIME-WAIT  
get:b5.  TIME-WAIT  
get:bCLOSED     
get:bTCP A      
get:b1.  ESTABLISHED
get:b2.  (Close)    
get:bFIN-WAIT-1 
get:b3.  CLOSING    
get:b4.  TIME-WAIT  
get:b(2 MSL)    
get:bCLOSED     
get:bTransmission Cont
get:bFunctional Specif
get:b3.6.  Precedence 
get:bThe intent is t
get:bwith exactly th
get:bhigher of the p
get:bThe precedence 
get:bdefined in the 
get:bspecification t
get:bthe security pa
get:buser group, and
get:bA connection at
get:blower precedenc
get:ba connection du
get:backnowledgment 
get:bNote that TCP m
get:bprecedence will
get:bsegments and po
get:bThe security pa
get:b(the values wou
get:bnon-secure envi
get:bparameters, tho
get:b3.7.  Data Commun
get:bOnce the connec
get:bexchange of seg
get:b(checksum test 
get:bretransmission 
get:bDuplicate segme
get:bAs discussed in
get:bcertain tests o
get:bsegments to ver
get:bThe sender of d
get:bthe variable SN
get:bsequence number
get:bkeeps track of 
get:bvariable SND.UN
get:bsent has been a
get:bWhen the sender
get:bSND.NXT.  When 
get:bsends an acknow
get:b[Page 40]        
get:bSeptember 1981   
get:backnowledgment 
get:bthese variables
get:bThe amount by w
get:bdata in the seg
get:bsegments must c
get:bThe CLOSE user 
get:bflag in an inco
get:bRetransmission 
get:bBecause of the 
get:binternetwork sy
get:bretransmission 
get:bfor determining
get:bAn Example Re
get:bMeasure the
get:bparticular 
get:bcovers that
get:bsegments re
get:bTime (RTT).:  Next compute a Smoothed Round Trip Time (SRTT) as
get:bSRTT = ( 
get:band based o:n this, compute the retransmission timeout (RTO) as
get:bRTO = min
get:bwhere UBOUN
get:bLBOUND is a
get:ba smoothing
get:bfactor (e.g
get:bThe Communicati
get:bThe objective o
get:bto stimulate th
get:bpermit the rece
get:bthe currently k
get:bThis mechanism 
get:bthe end of urge
get:bthe receive seq
get:bmust tell the u
get:bnumber catches 
get:bTransmission Cont
get:bFunctional Specif
get:binto "normal mo
get:bis in "urgent m
get:bThe method empl
get:btransmitted.  T
get:bmeaningful and 
get:bthe urgent poin
get:bno urgent data 
get:bTo send an urge
get:boctet.  If the 
get:bthe urgent info
get:bManaging the Wi
get:bThe window sent
get:bnumbers the sen
get:bprepared to acc
get:bthe currently a
get:bIndicating a la
get:barrives than ca
get:bin excessive re
get:bnetwork and the
get:btransmission of
get:bbetween each ne
get:bThe mechanisms 
get:bsubsequently ad
get:bthat much data.
get:bdiscouraged.  T
get:bshrink the wind
get:bon the part of 
get:bThe sending TCP
get:bleast one octet
get:bsending TCP mus
get:bthe window is z
get:binterval when t
get:bguarantee that 
get:bwindow will be 
get:bWhen the receiv
get:bstill send an a
get:band current win
get:bThe sending TCP
get:b[Page 42]        
get:bSeptember 1981   
get:bwhich fit the c
get:bretransmission 
get:bIn a connection
get:bbe carried in a
get:bnumber so there
get:border.  This is
get:binformation to 
get:bthe data receiv
get:bthe window info
get:backnowledgment 
get:bequal or greate
get:bThe window mana
get:bcommunication p
get:bWindow Manage
get:bAllocating 
get:bmany small 
get:bfewer large
get:bOne suggest
get:bdefer updat
get:bleast X per
get:bconnection 
get:bAnother sug
get:bsegments by
get:bsending dat
get:bdata must b
get:bNote that t
get:bretransmiss
get:backnowledgm
get:bwindow info
get:bnew window 
get:bThe segment
get:bof transmit
get:bsegment con
get:bis accepted
get:bIf the send
get:bwindow is n
get:balternating
get:bpauses in t
get:bTransmission Cont
get:bFunctional Specif
get:bresult in b
get:bbig pair. A
get:bmostly smal
get:bThe suggest
get:bactively at
get:bwindows, si
get:bto many sma
get:bThere are of co:urse two interfaces of concern
get:band the TCP/low
get:bof the user/TCP
get:bprotocol module
get:bin detail by th
get:bcase that the l
get:bthat TCPs might
get:bUser/TCP Interf
get:bThe following
get:bat best, fict
get:bfacilities.  
get:bimplementatio
get:bTCPs must pro
get:bthat all TCP 
get:bhierarchy.  T
get:brequired of a
get:bTCP User Comm
get:bThe followi
get:binterface. 
get:bfunction ca
get:bmeant to ru
get:bThe user co
get:bTCP must pe
get:bIndividual 
get:bmay provide
get:bsingle call
get:bautomatical
get:bissued by t
get:b[Page 44]        
get:bSeptember 1981   
get:bIn providin
get:bnot only ac
get:bprocesses i:t serves.  The latter consists of
get:b(a) gener
get:bremote cl
get:b(b) repli
get:bvarious t
get:bFormat:  
get:b[, timeou
get:b-> local 
get:bWe assume
get:bprocesses
get:bto use th
get:bimplement
get:bfor the s
get:blower lev
get:bresult of
get:bable to m
get:bprocess c
get:bIf the ac
get:bcall to L
get:bhave eith
get:bparticula
get:bfor any c
get:bby the su
get:bA transmi
get:bfilled in
get:bOn an act
get:bsynchroni
get:bThe timeo
get:bfor all d
get:bdelivered
get:bwill abor
get:bThe TCP o
get:bthe users
get:bTransmission Cont
get:bFunctional Specif
get:bprecedenc
get:bor securi
get:bthe defau
get:bTCP will 
get:bsecurity/
get:bthe prece
get:brequested
get:bThe prece
get:brequested
get:brequest, 
get:bconnectio
get:bthis prec
get:ballowed t
get:bor that a
get:bA local c
get:bThe local
get:bfor the c
get:bFormat:  
get:bcount, PU
get:bThis call
get:bto be sen
get:bnot been 
get:bimplement
get:bautomatic
get:bauthorize
get:bIf the PU
get:bto the re
get:bsegment c
get:bthe data 
get:btransmiss
get:bIf the UR
get:bwill have
get:bthe urgen
get:bpointer i
get:bbeen cons
get:bis to sti
get:bindicate 
get:b[Page 46]        
get:bSeptember 1981   
get:bdata has 
get:bTCP signa
get:bof times 
get:burgent da
get:bIf no for
get:bconnectio
get:bhas becom
get:blocal soc
get:bforeign s
get:bforeign s
get:bknowing t
get:bHowever, 
get:bbecomes s
get:bSTATUS ca
get:bimplement
get:bsocket is
get:bIf a time
get:bconnectio
get:bIn the si
get:bthe sendi
get:bor the ti
get:bis both s
get:bconnectio
get:boffers po
get:bsophistic
get:bthe proce
get:bfurthermo
get:bMultiple 
get:bthe TCP w
get:bWe have i
get:bwhich a S
get:bpseudo-in
get:breturn a 
get:bimmediate
get:bbeen ackn
get:bassume ev
get:bclose any
get:bkind (syn
get:bsignals, 
get:bwith spec
get:bIn order 
get:bindicatio
get:bTransmission Cont
get:bFunctional Specif
get:bbuffer ad
get:bthe SEND 
get:bindicatin
get:bcalling p
get:bFormat:  
get:bcount) ->
get:bThis comm
get:bspecified
get:bcalling p
get:berror is 
get:bIn the si
get:bcalling p
get:berror occ
get:bA more so
get:bRECEIVEs 
get:bsegments 
get:bthe cost 
get:bnotify th
get:bIf enough
get:bthe PUSH 
get:bThe buffe
get:ba PUSH is
get:breturned 
get:bIf there 
get:bas it arr
get:bshould th
get:badditiona
get:bcall to R
get:bmay now l
get:burgent po
get:bin the sa
get:bboundary 
get:bTo distin
get:bcare of t
get:breturn co
get:bcount ind
get:bAlternati
get:b[Page 48]        
get:bSeptember 1981   
get:ballocate 
get:bwith the 
get:bFormat:  
get:bThis comm
get:bthe conne
get:bauthorize
get:bClosing c
get:bthe sense
get:bretransmi
get:bserviced.
get:bcalls, fo
get:bto the de
get:bcontinue 
get:bmay be tr
get:bmeans "I 
get:breceive a
get:bnot well 
get:bof all it
get:binto ABOR
get:bThe user 
get:binitiativ
get:b(e.g., re
get:bdestinati
get:bBecause c
get:bforeign T
get:bshort tim
get:breplies t
get:bClose als
get:bFormat:  
get:bThis is a
get:bexcluded 
get:btypically
get:bThis comm
get:binformati:on
get:blocal s
get:bTransmission Cont
get:bFunctional Specif
get:bforeign
get:blocal c
get:breceive
get:bsend wi
get:bconnect
get:bnumber 
get:bnumber 
get:burgent 
get:bprecede
get:bsecurit
get:band tra
get:bDepending
get:bimplement
get:bavailable
get:bauthorize
get:bprevents 
get:bconnectio
get:bFormat:  
get:bThis comm
get:baborted, 
get:bbe sent t
get:bDepending
get:bindicatio
get:breceive a
get:bTCP-to-User M
get:bIt is assum
get:bmeans for t
get:bthe TCP doe
get:bto the user
get:ban error me
get:brelating to
get:bother user 
get:bThe followi:ng information is provided
get:bLocal Con
get:bResponse 
get:bBuffer Ad
get:bByte coun
get:bPush flag
get:bUrgent fl
get:b[Page 50]        
get:bSeptember 1981   
get:bTCP/Lower-Level
get:bThe TCP calls
get:breceive infor
get:binternetwork 
get:bProtocol (IP)
get:bIf the lower 
get:bof service an
get:bfor these par:ameters
get:bType of Ser:vice = Precedence: routine, Delay: normal, Throughput
get:bnormal, Rel:iability
get:bTime to Liv
get:bNote that
get:bHere we e
get:bbe delive
get:bIf the lower 
get:bfeature) and 
get:broute informa
get:bso that the s
get:bchecksum be t
get:balso importan
get:bAny lower lev
get:bdestination a
get:bthe "TCP leng
get:bof IP and to 
get:bTransmission Cont
get:bFunctional Specif
get:b3.9.  Event Proce
get:bThe processing 
get:bimplementation.
get:bprocessing sequ
get:bsection only in
get:bThe activity of
get:bThe events that: occur can be cast into three categories
get:barriving segmen
get:bprocessing the 
get:bcases the proce
get:bEvents that o:ccur
get:bArriving Se
get:bSEGMENT A
get:bUSER TIME
get:bRETRANSMI
get:bTIME-WAIT
get:bThe model of th
get:bimmediate retur
get:bpseudo interrup
get:bmeans cause a d
get:bError responses
get:bcommands refere:ncing connections that do not exist receive "error
get:bconnection not 
get:bPlease note in 
get:backnowledgment 
get:bof the sequence
get:bequal to (modul
get:b[Page 52]        
get:bSeptember 1981   
get:bA natural way t
get:bimagine that th
get:bthat their cont
get:bin the sequence
get:band processed i
get:bWhen a segment 
get:bthe segment to 
get:bto be consisten
get:bNote that if no
get:bTransmission Cont
get:bFunctional Specif
get:bCLOSED STATE 
get:bCreate a ne
get:bstate infor
get:bsocket, pre
get:binformation
get:bunspecified
get:bparameters 
get:bprecedence 
get:b"error:  pr:ecedence not allowed" or "error
get:bnot allowed
get:bactive and :the foreign socket is unspecified, return "error
get:bforeign soc
get:bspecified, 
get:b(ISS) is se
get:bis sent.  S
get:bstate, and 
get:bIf the call
get:breturn "err:or
get:bno room to :create a new connection, return "error
get:bresources".
get:bIf active a
get:bconnection 
get:bsegment, se
get:bstate.  Dat
get:bqueued for 
get:burgent bit 
get:bsegments se
get:bqueue the r:equest, respond with "error
get:bIf Foreign :socket was not specified, then return "error
get:bsocket unsp
get:b[Page 54]        
get:bSeptember 1981   
get:bSYN-SENT STAT
get:bSYN-RECEIVED 
get:bESTABLISHED S
get:bFIN-WAIT-1 ST
get:bFIN-WAIT-2 ST
get:bCLOSE-WAIT ST
get:bCLOSING STATE
get:bLAST-ACK STAT
get:bTIME-WAIT STA
get:bReturn "err:or
get:bTransmission Cont
get:bFunctional Specif
get:bCLOSED STATE 
get:bIf the user
get:b"error:  co
get:bOtherwise, :return "error
get:bIf the fore
get:bfrom passiv
get:bSND.UNA to 
get:bassociated 
get:btransmissio
get:brequested i
get:bas a result
get:brequest, re:spond with "error
get:bForeign soc:ket was not specified, then return "error
get:bsocket unsp
get:bSYN-SENT STAT
get:bSYN-RECEIVED 
get:bQueue the d
get:bIf no space: to queue, respond with "error
get:bresources".
get:bESTABLISHED S
get:bCLOSE-WAIT ST
get:bSegmentize 
get:backnowledgm
get:binsufficien:t space to remember this buffer, simply return "error
get:binsufficien
get:bIf the urge
get:burgent poin
get:b[Page 56]        
get:bSeptember 1981   
get:bFIN-WAIT-1 ST
get:bFIN-WAIT-2 ST
get:bCLOSING STATE
get:bLAST-ACK STAT
get:bTIME-WAIT STA
get:bReturn "err:or
get:bTransmission Cont
get:bFunctional Specif
get:bCLOSED STATE 
get:bIf the user
get:b"error:  co
get:bOtherwise r:eturn "error
get:bSYN-SENT STAT
get:bSYN-RECEIVED 
get:bQueue for p
get:bis no room :to queue this request, respond with "error
get:binsufficien
get:bESTABLISHED S
get:bFIN-WAIT-1 ST
get:bFIN-WAIT-2 ST
get:bIf insuffic
get:brequest, qu
get:bremember th:e RECEIVE, respond with "error
get:bresources".
get:bReassemble 
get:bto user.  M
get:bIf RCV.UP i
get:buser notify
get:bWhen the TC
get:bthat fact m
get:backnowledgm
get:bdescribed b
get:b[Page 58]        
get:bSeptember 1981   
get:bCLOSE-WAIT ST
get:bSince the r
get:bsatisfied b
get:buser.  If n
get:b"error:  co
get:btext can be
get:bCLOSING STATE
get:bLAST-ACK STAT
get:bTIME-WAIT STA
get:bReturn "err:or
get:bTransmission Cont
get:bFunctional Specif
get:bCLOSED STATE 
get:bIf the user
get:b"error:  co
get:bOtherwise, :return "error
get:bAny outstan:ding RECEIVEs are returned with "error
get:bresponses. 
get:bSYN-SENT STAT
get:bDelete the :TCB and return "error
get:bqueued SEND
get:bSYN-RECEIVED 
get:bIf no SENDs
get:bthen form a
get:botherwise q
get:bESTABLISHED S
get:bQueue this 
get:bform a FIN 
get:bFIN-WAIT-1 ST
get:bFIN-WAIT-2 ST
get:bStrictly sp:eaking, this is an error and should receive a "error
get:bconnection 
get:bacceptable,
get:bFIN may be 
get:b[Page 60]        
get:bSeptember 1981   
get:bCLOSE-WAIT ST
get:bQueue this 
get:bsegmentized
get:bCLOSING STATE
get:bLAST-ACK STAT
get:bTIME-WAIT STA
get:bRespond wit:h "error
get:bTransmission Cont
get:bFunctional Specif
get:bCLOSED STATE 
get:bIf the user
get:b"error:  co
get:bOtherwise r:eturn "error
get:bAny outstan:ding RECEIVEs should be returned with "error
get:bconnection 
get:bSYN-SENT STAT
get:bAll queued 
get:bnotificatio
get:bSYN-RECEIVED 
get:bESTABLISHED S
get:bFIN-WAIT-1 ST
get:bFIN-WAIT-2 ST
get:bCLOSE-WAIT ST
get:bSend a rese:t segment
get:b<SEQ=SND.
get:bAll queued 
get:bnotificatio
get:bRST formed 
get:bTCB, enter 
get:bCLOSING STATE
get:bLAST-ACK STAT
get:bTIME-WAIT STA
get:bRespond wit
get:b[Page 62]        
get:bSeptember 1981   
get:bCLOSED STATE 
get:bIf the user
get:b"error:  co
get:bOtherwise r:eturn "error
get:bReturn "sta
get:bSYN-SENT STAT
get:bReturn "sta
get:bSYN-RECEIVED 
get:bReturn "sta
get:bESTABLISHED S
get:bReturn "sta
get:bFIN-WAIT-1 ST
get:bReturn "sta
get:bFIN-WAIT-2 ST
get:bReturn "sta
get:bCLOSE-WAIT ST
get:bReturn "sta
get:bCLOSING STATE
get:bReturn "sta
get:bLAST-ACK STAT
get:bReturn "sta
get:bTransmission Cont
get:bFunctional Specif
get:bTIME-WAIT STA
get:bReturn "sta
get:b[Page 64]        
get:bSeptember 1981   
get:bSEGMENT ARRIVES
get:bIf the state 
get:ball data in
get:bsegment con
get:bcontaining 
get:backnowledgm
get:breset seque
get:bIf the ACK 
get:b<SEQ=0><A
get:bIf the ACK 
get:b<SEQ=SEG.
get:bIf the state 
get:bfirst check
get:bAn incomi
get:bsecond chec
get:bAny ackno
get:bthe LISTE
get:bfor any a
get:bformatted: as follows
get:b<SEQ=SE
get:bthird check
get:bIf the SY
get:bsecurity/
get:bmatch the
get:b<SEQ=SE
get:bTransmission Cont
get:bFunctional Specif
get:bIf the SE
get:bthe user 
get:bsend a re
get:b<SEQ=SE
get:bIf the SE
get:bSet RCV.N
get:bcontrol o
get:bshould be: selected and a SYN segment sent of the form
get:b<SEQ=IS
get:bSND.NXT i
get:bstate sho
get:bincoming 
get:bin the SY
get:bnot be re
get:bthe forei
get:bunspecifi
get:bfourth othe
get:bAny other
get:bmust have
get:bprocessin
get:bit could 
get:bincarnati
get:bbut if yo
get:bIf the state 
get:bfirst check
get:bIf the AC
get:bIf SEG.
get:bthe RST
get:b<SEQ=
get:band dis
get:bIf SND.
get:bsecond chec
get:b[Page 66]        
get:bSeptember 1981   
get:bIf the RS
get:bIf the :ACK was acceptable then signal the user "error
get:bconnect
get:bdelete 
get:band ret
get:bthird check
get:bIf the se
get:bmatch the
get:bIf ther
get:b<SEQ=
get:bOtherwi
get:b<SEQ=
get:bIf there 
get:bThe pre
get:bTCB, if
get:b<SEQ=
get:bIf there 
get:bIf the 
get:bin the 
get:bthe pre
get:ballowed
get:b<SEQ=
get:bIf the 
get:bin the 
get:bIf a rese
get:bfourth chec
get:bThis step
get:bno ACK, a
get:bIf the SY
get:bTransmission Cont
get:bFunctional Specif
get:bare accep
get:bSEG.SEQ. 
get:bis an ACK
get:bare there
get:bIf SND.UN
get:bstate to 
get:b<SEQ=SN
get:band send 
get:btransmiss
get:btext in t
get:bbelow whe
get:bOtherwise
get:b<SEQ=IS
get:band send 
get:bsegment, 
get:bhas been 
get:bfifth, if n
get:bsegment and
get:b[Page 68]        
get:bSeptember 1981   
get:bfirst check s
get:bSYN-RECEIVE
get:bESTABLISHED
get:bFIN-WAIT-1 
get:bFIN-WAIT-2 
get:bCLOSE-WAIT 
get:bCLOSING STA
get:bLAST-ACK ST
get:bTIME-WAIT S
get:bSegments 
get:bare used 
get:bdone in S
get:bboundary 
get:bprocessed
get:bThere are
get:bsegment
get:bSegment R
get:bLength  W
get:b------- -
get:b0     
get:b0     
get:b>0     
get:b>0     
get:bIf the RC
get:bspecial a
get:bIf an inc
get:bshould be
get:bthe segme:nt and return)
get:b<SEQ=SN
get:bAfter sen
get:band retur
get:bTransmission Cont
get:bFunctional Specif
get:bIn the fo
get:bsegment t
get:bOne could
get:btrimming 
get:bSYN and F
get:bbegins at
get:bnumbers m
get:bsecond check 
get:bSYN-RECEIVE
get:bIf the RS
get:bIf this
get:bcame fr
get:bLISTEN 
get:bthis co
get:bfrom SY
get:bthe use
get:bon the 
get:bactive 
get:band ret
get:bESTABLISHED
get:bIf the RS
get:bshould re
get:bflushed. 
get:b"connecti
get:bTCB, and 
get:bCLOSING STA
get:bLAST-ACK ST
get:bIf the RS
get:bTCB, and 
get:b[Page 70]        
get:bSeptember 1981   
get:bthird check s
get:bSYN-RECEIVE
get:bIf the se
get:bexactly m
get:bthen send
get:bESTABLISHED
get:bIf the se
get:bexactly m
get:bthen send
get:breceive "
get:bflushed. 
get:b"connecti
get:bTCB, and 
get:bNote this c
get:ba segment f
get:bdifferent s
get:bcurrent con
get:bfourth, check
get:bSYN-RECEIVE
get:bESTABLISHED
get:bFIN-WAIT ST
get:bFIN-WAIT ST
get:bCLOSE-WAIT 
get:bCLOSING STA
get:bLAST-ACK ST
get:bTIME-WAIT S
get:bIf the SY
get:boutstandi
get:ball segme
get:breceive a
get:bthe CLOSE
get:bIf the SY
get:band an ac
get:bnumber ch
get:bTransmission Cont
get:bFunctional Specif
get:bfifth check t
get:bif the ACK 
get:bif the ACK 
get:bSYN-RECEI
get:bIf SND.
get:band con
get:bIf th
get:breset
get:b<SE
get:band s
get:bESTABLISH
get:bIf SND.
get:bAny seg
get:bentirel
get:bpositiv
get:bfully a
get:b"ok" re
get:b(SEG.AC
get:bsomethi
get:bdrop th
get:bIf SND.
get:bupdated
get:bSND.WL2
get:bSND.WL1
get:bNote th
get:brecords
get:bSND.WND
get:bthe las
get:bprevent
get:b[Page 72]        
get:bSeptember 1981   
get:bFIN-WAIT-
get:bIn addi
get:bour FIN
get:bprocess
get:bFIN-WAIT-
get:bIn addi
get:bthe ret
get:backnowl
get:bCLOSE-WAI
get:bDo the 
get:bCLOSING S
get:bIn addi
get:bthe ACK
get:botherwi
get:bLAST-ACK 
get:bThe onl
get:backnowl
get:bdelete 
get:bTIME-WAIT
get:bThe onl
get:bretrans
get:bthe 2 M
get:bsixth, check 
get:bESTABLISHED
get:bFIN-WAIT-1 
get:bFIN-WAIT-2 
get:bIf the UR
get:bthe user 
get:bpointer (
get:buser has 
get:bmode") fo
get:bsignal th
get:bTransmission Cont
get:bFunctional Specif
get:bCLOSE-WAIT 
get:bCLOSING STA
get:bLAST-ACK ST
get:bThis shou
get:bremote si
get:bseventh, proc
get:bESTABLISHED
get:bFIN-WAIT-1 
get:bFIN-WAIT-2 
get:bOnce in t
get:btext to u
get:binto buff
get:bempty.  I
get:bthe user 
get:bhas been 
get:bWhen the 
get:buser it m
get:bOnce the 
get:bRCV.NXT o
get:bapporopri
get:bRCV.NXT a
get:bPlease no
get:bSend an a:cknowledgment of the form
get:b<SEQ=SN
get:bThis ackn
get:btransmitt
get:b[Page 74]        
get:bSeptember 1981   
get:bCLOSE-WAIT 
get:bCLOSING STA
get:bLAST-ACK ST
get:bTIME-WAIT S
get:bThis shou
get:bremote si
get:beighth, check
get:bDo not proc
get:bsince the S
get:bIf the FIN 
get:breturn any 
get:bover the FI
get:bFIN implies
get:bSYN-RECEI
get:bESTABLISH
get:bEnter t
get:bFIN-WAIT-
get:bIf our 
get:benter T
get:btimers;
get:bFIN-WAIT-
get:bEnter t
get:boff the
get:bCLOSE-WAI
get:bRemain 
get:bCLOSING S
get:bRemain 
get:bLAST-ACK 
get:bRemain 
get:bTransmission Cont
get:bFunctional Specif
get:bTIME-WAIT
get:bRemain 
get:btimeout
get:b[Page 76]        
get:bSeptember 1981   
get:bFor any state
get:bthe user "err:or
get:band for any o
get:bstate and ret
get:bRETRANSMISSION 
get:bFor any state
get:bthe retransmi
get:bretransmissio
get:bTIME-WAIT TIMEO
get:bIf the time-w
get:benter the CLO
get:bTransmission Cont
get:b[Page 78]        
get:bSeptember 1981   
get:bBBN Rep
get:ba Host 
get:bhost an
get:bA contr
get:bindicat
get:bspecifi
get:bis expe
get:bpreviou
get:bThe uni
get:bARPANET
get:bA unit 
get:bIMPs.  
get:bA logic
get:bA messa
get:bnetwork
get:bDestination Addre
get:bThe des
get:bidentif
get:bA contr
get:bindicat
get:boccupyi
get:bA porti
get:bfragmen
get:bA file 
get:bTransmission Cont
get:bControl
get:bfragmen
get:bA compu
get:bfrom th
get:bAn Inte
get:bby the 
get:bThe Int
get:bARPANET
get:bA sourc
get:binternet datagram
get:bThe uni
get:bhigher 
get:binternet fragment
get:bA porti
get:bheader.
get:bInterne
get:bThe Ini
get:bnumber 
get:bThe Ini
get:bon a co
get:bbased p
get:bThe Ini
get:bused by
get:bControl
get:bdata.  
get:bon an A
get:b[Page 80]        
get:bSeptember 1981   
get:bThis is
get:bdata re
get:bsequenc
get:bof the 
get:bThe uni
get:bAn impl
get:bprocedu
get:bMaximum
get:bthe int
get:bAn eigh
get:bAn Opti
get:bmay be 
get:bprimari
get:btimesta
get:boptions
get:bA packa
get:blogical
get:blogical
get:bThe por
get:boutput 
get:bA progr
get:bthe poi
get:bA contr
get:bthis se
get:breceivi
get:breceive
get:bTransmission Cont
get:breceive
get:breceive
get:breceive next sequ
get:bThis is
get:breceive
get:bThis re
get:bis will
get:bsegment
get:bRCV.NXT
get:bSegment
get:brange a
get:bA contr
get:bthat th
get:binterac
get:bsequenc
get:bsegment
get:bit.  In
get:brise to
get:bReal Ti:me Protocol
get:bof time
get:bsegment
get:bsegment
get:bsegment
get:bsegment
get:bsegment
get:b[Page 82]        
get:bSeptember 1981   
get:bsegment
get:bA logic
get:bunit of
get:bsegment acknowled
get:bThe seq
get:barrivin
get:bThe amo
get:bincludi
get:bThe num
get:bThis is
get:buse on 
get:binitial
get:beach oc
get:bThis re
get:b(receiv
get:bwindow 
get:breceivi
get:bbe emit
get:bSND.UNA
get:bbetween
get:bsend se
get:bleft se
get:bsend ur
get:bsegment
get:bsegment
get:bTransmission Cont
get:bsend wi
get:bAn addr
get:bis, the
get:bThe sou
get:bA contr
get:bnumber,
get:bwhere t
get:bTransmi
get:bthe sta
get:bThe pre
get:bTransmi:ssion Control Protocol
get:breliabl
get:bType of
get:bAn Inte
get:bfor thi
get:bA contr
get:bindicat
get:burgent 
get:bsequenc
get:bpointer
get:bA contr
get:bfield c
get:bindicat
get:burgent 
get:b[Page 84]        
get:bSeptember 1981   
get:b[1]  Cerf, V., an
get:bIntercommuni
get:bVol. COM-22,
get:b[2]  Postel, J. (
get:bProtocol Spe
get:bInstitute, S
get:b[3]  Dalal, Y. an
get:bProtocols", 
get:bDecember 197
get:b[4]  Postel, J., 
get:bInstitute, S
get:baRFC
get:baDe
get:baI
get:baSeptember 1981   
get:baPREFACE .....
get:ba1.  INTRODUCTION 
get:ba1.1  Motivation
get:ba1.2  Scope ....
get:ba1.3  About This
get:ba1.4  Interfaces
get:ba1.5  Operation 
get:ba2.  PHILOSOPHY ..
get:ba2.1  Elements o
get:ba2.2  Model of O
get:ba2.3  The Host E
get:ba2.4  Interfaces
get:ba2.5  Relation t
get:ba2.6  Reliable C
get:ba2.7  Connection
get:ba2.8  Data Commu
get:ba2.9  Precedence
get:ba2.10 Robustness
get:ba3.  FUNCTIONAL SP
get:ba3.1  Header For
get:ba3.2  Terminolog
get:ba3.3  Sequence N
get:ba3.4  Establishi
get:ba3.5  Closing a 
get:ba3.6  Precedence
get:ba3.7  Data Commu
get:ba3.8  Interfaces
get:ba3.9  Event Proc
get:baGLOSSARY ........
get:baREFERENCES ......
get:baTransmission Cont
get:ba[Page ii]        
get:baSeptember 1981   
get:baThis document des
get:ba(TCP).  There hav
get:baspecification on 
get:badraws heavily fro
get:baboth in terms of 
get:baseveral details a
get:baand redescribes t
get:baRFC
get:baReplaces: RFC 761
get:baIENs:  129, 124, 
get:ba55, 44, 40, 27, 2
get:baThe Transmission 
get:bareliable host-to-
get:bacommunication net
get:baThis document des
get:baTransmission Cont
get:bainterface to prog
get:baComputer commun
get:barole in militar
get:badocument focuse
get:bacommunication r
get:bacommunication u
get:bacongestion, but
get:bagovernment sect
get:baAs strategic an
get:badeveloped and d
get:bainterconnecting
get:bacommunication p
get:baapplications.  
get:baDeputy Undersec
get:badeclared the Tr
get:babe a basis for 
get:bastandardization
get:baTCP is a connec
get:bafit into a laye
get:baapplications.  
get:bacommunication b
get:badistinct but in
get:baassumptions are
get:baprotocols below
get:bapotentially unr
get:baprotocols.  In 
get:bawide spectrum o
get:baconnections to 
get:baTransmission Cont
get:baTCP is based on
get:baTCP fits into a
get:baInternet Protoc
get:bareceive variabl
get:badatagram "envel
get:baaddressing sour
get:bainternet protoc
get:bathe TCP segment
get:bamultiple networ
get:baalso carries in
get:baand compartment
get:bacommunicated en
get:baMuch of this do
get:bawhich are co-re
get:bacomputer.  Some
get:bafront-end compu
get:baas well as netw
get:baan interface to
get:baimplementable e
get:bahost-to-front e
get:baThe TCP is inte
get:bacommunication s
get:baintended to be 
get:ba1.3.  About this 
get:baThis document r
get:baany TCP impleme
get:baprotocols and i
get:ba[Page 2]         
get:baSeptember 1981   
get:basection offers 
get:baoperation.  Sec
get:badesign.  Sectio
get:barequired of TCP
get:bauser calls, err
get:baThe TCP interfa
get:bathe other side 
get:baThe interface b
get:baillustrated in 
get:bacalls much like
get:baapplication pro
get:bacalls to open a
get:baestablished con
get:baasynchronously 
get:baconsiderable fr
get:bainterfaces whic
get:baenvironment, a 
get:bainterface for a
get:baThe interface b
get:baunspecified exc
get:batwo levels can 
get:baTypically, one 
get:bainterface.  TCP
get:bainterconnected 
get:bathroughout this
get:baAs noted above,
get:basecurable logic
get:baprocesses.  To 
get:bacommunication s:ystem requires facilities in the following areas
get:baBasic Data Tr
get:baPrecedence an
get:baThe basic opera
get:bathe following p
get:baTransmission Cont
get:baBasic Data Tran:sfer
get:baThe TCP is ab
get:badirection bet
get:basegments for 
get:bathe TCPs deci
get:baSometimes use
get:basubmitted to 
get:bafunction is d
get:baactually tran
get:bapushed throug
get:bapromptly forw
get:baThe exact pus
get:bathe push func
get:baReliability
get:baThe TCP must 
get:badelivered out
get:bais achieved b
get:batransmitted, 
get:bareceiving TCP
get:bainterval, the
get:banumbers are u
get:baout of order 
get:baadding a chec
get:bareceiver, and
get:baAs long as th
get:basystem does n
get:baerrors will a
get:bainternet comm
get:baFlow Control
get:baTCP provides 
get:basent by the s
get:baevery ACK ind
get:bathe last segm
get:baallowed numbe
get:bareceiving fur
get:ba[Page 4]         
get:baSeptember 1981   
get:baMultiplexing
get:baTo allow for 
get:bacommunication
get:baaddresses or 
get:baand host addr
get:baa socket.  A 
get:baThat is, a so
get:baThe binding o
get:baHost.  Howeve
get:ba(e.g., a "log
get:bamade known to
get:bathrough the k
get:baaddresses of 
get:baConnections
get:baThe reliabili
get:bathat TCPs ini
get:baeach data str
get:basockets, sequ
get:baEach connecti
get:baidentifying i
get:baWhen two proc
get:baestablish a c
get:baside).  When 
get:baterminated or
get:baSince connect
get:baover the unre
get:bamechanism wit
get:baerroneous ini
get:baPrecedence and :Security
get:baThe users of 
get:bacommunication
get:bathese feature
get:baTransmission Cont
get:ba[Page 6]         
get:baSeptember 1981   
get:ba2.1.  Elements of
get:baThe internetwor
get:bawhich are in tu
get:bathat the networ
get:balarge networks 
get:bapacket switchin
get:baconsume message
get:banetworks, the g
get:bacommunication s
get:baconnections bet
get:baThe term packet
get:batransaction bet
get:baexchanged withi
get:baHosts are compu
get:banetwork's point
get:baProcesses are v
get:baaccordance with
get:bain execution). 
get:baviewed as commu
get:baThus, all commu
get:baSince a process
get:bastreams between
get:bathat each proce
get:bacommunicates wi
get:ba2.2.  Model of Op
get:baProcesses trans
get:badata as argumen
get:basegments and ca
get:bathe destination
get:bainto the receiv
get:baTCPs include co
get:baensure reliable
get:baThe model of in
get:baprotocol module
get:bato the local ne
get:bainside internet
get:bainternet module
get:bathrough the loc
get:baThe packet swit
get:baTransmission Cont
get:baother operation
get:badestination int
get:baAt a gateway be
get:bafrom its local 
get:bathe internet da
get:bathen "wrapped" 
get:barouted to the n
get:baA gateway is pe
get:bainternet datagr
get:bathrough the nex
get:bainternet datagr
get:bafurther broken 
get:bainternet datagr
get:bainternet module
get:baA destination i
get:ba(after reassemb
get:badestination TCP
get:baThis simple mod
get:baimportant featu
get:bato the gateway 
get:baservice paramet
get:baIncluded in the
get:badatagram.  Data
get:bahost and gatewa
get:baproperly segreg
get:ba2.3.  The Host En
get:baThe TCP is assu
get:baaccess the TCP 
get:bamay call on oth
get:badata structures
get:bacontrolled by a
get:banetwork device 
get:badatagram protoc
get:baThe mechanisms 
get:bafront-end proce
get:bahost-to-front-e
get:bathe type of TCP
get:ba[Page 8]         
get:baSeptember 1981   
get:baThe TCP/user in
get:bato OPEN or CLOS
get:baSTATUS about a 
get:baprograms on the
get:bafrom, and close
get:baThe TCP/interne
get:badatagrams addre
get:basystem.  These 
get:baservice, preced
get:ba2.5.  Relation to
get:baThe following d
get:bahierarchy
get:ba+------+ +
get:ba|Telnet| |
get:ba+------+ +
get:ba|   
get:ba+----
get:ba| TCP
get:ba+----
get:ba| 
get:ba+----
get:ba|    
get:ba+----
get:ba+--
get:ba|  
get:ba+--
get:baIt is expected 
get:baprotocols effic
get:baprotocols like 
get:ba2.6.  Reliable Co
get:baA stream of dat
get:baorder at the de
get:baTransmission Cont
get:baTransmission is
get:baacknowledgments
get:basequence number
get:basegment is tran
get:basequence number
get:bais the sequence
get:batransmissions i
get:basegment contain
get:bastarts a timer;
get:basegment is dele
get:bareceived before
get:baAn acknowledgme
get:badelivered to th
get:bathe responsibil
get:baTo govern the f
get:baemployed.  The 
get:baThis window spe
get:baacknowledgment 
get:ba2.7.  Connection 
get:baTo identify the
get:baprovides a port
get:baindependently b
get:baunique addresse
get:baidentifying the
get:bawill be unique 
get:baA connection is
get:balocal socket ma
get:basockets.  A con
get:bathat is, it is 
get:baTCPs are free t
get:baHowever, severa
get:baThere must be w
get:bathe "appropriat
get:bamay "own" ports
get:bathe ports they 
get:baissue, but we e
get:bauniquely alloca
get:baassociating the
get:baA connection is
get:baforeign socket 
get:ba[Page 10]        
get:baSeptember 1981   
get:baconnection name
get:basubsequent call
get:baabout a connect
get:bais a data struc
get:baimplementation 
get:bapointer to the 
get:bawhether the con
get:babe passively wa
get:baA passive OPEN 
get:baconnection requ
get:baOften the proce
get:barequest from an
get:bais used to deno
get:baare allowed onl
get:baA service proce
get:baprocesses would
get:baforeign socket.
get:barequested a con
get:balocal socket we
get:baWell-known sock
get:baa socket addres
get:ba"Telnet-Server"
get:basocket, and oth
get:baEntry, Text Gen
get:babeing for test 
get:baaccess to a "Lo
get:baat which a newl
get:bawell-known sock
get:baof sockets to s
get:baProcesses can i
get:bafrom other proc
get:babeen establishe
get:baother at the sa
get:bais critical for
get:bacomponents act 
get:baThere are two p
get:bapassive OPENs a
get:balocal passive O
get:bacase, the match
get:baOPENs has left 
get:baforeign socket 
get:baOther possibili
get:baTransmission Cont
get:baIf there are se
get:basame local sock
get:bawith the specif
get:baTCB exists, bef
get:baThe procedures 
get:bacontrol flag an
get:baexchange has be
get:baA connection is
get:bacontaining a SY
get:bacommand.  The m
get:baconnection has 
get:bawhen sequence n
get:baThe clearing of
get:bain this case ca
get:ba2.8.  Data Commun
get:baThe data that f
get:baoctets.  The se
get:bain that call (a
get:bathrough to the 
get:baA sending TCP i
get:basend that data 
get:bafunction is sig
get:bareceiving TCP s
get:bathe sending TCP
get:baThere is no nec
get:baboundaries.  Th
get:basingle SEND cal
get:baThe purpose of 
get:bafrom the sendin
get:barecord service.
get:baThere is a coup
get:baof data that cr
get:baassociated with
get:babuffer is retur
get:banot filled.  If
get:baPUSH is seen, t
get:baTCP also provid
get:baat some point f
get:ba[Page 12]        
get:baSeptember 1981   
get:bacurrently readi
get:badefine what the
get:baurgent data, bu
get:batake action to 
get:ba2.9.  Precedence 
get:baThe TCP makes u
get:basecurity option
get:babasis to TCP us
get:baa multilevel se
get:bause only, and o
get:bacompartment.  C
get:bausers may be li
get:baTCP modules whi
get:baproperly mark o
get:baprecedence.  Su
get:bahigher level pr
get:bathem to specify
get:baprecedence of c
get:ba2.10.  Robustness
get:baTCP implementat:ions will follow a general principle of robustness
get:baconservative in
get:baTransmission Cont
get:ba[Page 14]        
get:baSeptember 1981   
get:ba3.1.  Header Form
get:baTCP segments ar
get:baheader carries 
get:badestination hos
get:baheader, supplyi
get:badivision allows
get:baTCP Header Form
get:ba0            
get:ba0 1 2 3 4 5 6
get:ba+-+-+-+-+-+-+-
get:ba|          Sou
get:ba+-+-+-+-+-+-+-
get:ba|             
get:ba+-+-+-+-+-+-+-
get:ba|             
get:ba+-+-+-+-+-+-+-
get:ba|  Data |     
get:ba| Offset| Rese
get:ba|       |     
get:ba+-+-+-+-+-+-+-
get:ba|           Ch
get:ba+-+-+-+-+-+-+-
get:ba|             
get:ba+-+-+-+-+-+-+-
get:ba|             
get:ba+-+-+-+-+-+-+-
get:baNote th
get:baSource Port:  1
get:baThe source po
get:baDestination Por:t
get:baThe destinati
get:baTransmission Cont
get:baFunctional Specif
get:baSequence Number:
get:baThe sequence 
get:bawhen SYN is p
get:bainitial seque
get:baAcknowledgment :Number
get:baIf the ACK co
get:banext sequence
get:bareceive.  Onc
get:baData Offset:  4
get:baThe number of
get:bathe data begi
get:baintegral numb
get:baReserved:  6 bi
get:baReserved for 
get:baControl Bits:  :6 bits (from left to right)
get:baURG:  Urgent 
get:baACK:  Acknowl
get:baPSH:  Push Fu
get:baRST:  Reset t
get:baSYN:  Synchro
get:baFIN:  No more
get:baWindow:  16 bit
get:baThe number of
get:baacknowledgmen
get:baChecksum:  16 b
get:baThe checksum 
get:bacomplement su
get:basegment conta
get:bachecksummed, 
get:baform a 16 bit
get:batransmitted a
get:bathe checksum 
get:baThe checksum 
get:ba[Page 16]        
get:baSeptember 1981   
get:baprefixed to t
get:baAddress, the 
get:baThis gives th
get:bainformation i
get:baacross the TC
get:bacalls by the 
get:baThe TCP Len
get:baoctets (thi
get:bacomputed), 
get:baUrgent Pointer:
get:baThis field co
get:bapositive offs
get:baurgent pointe
get:bathe urgent da
get:bathe URG contr
get:baOptions:  varia
get:baOptions may o
get:bamultiple of 8
get:bachecksum.  An
get:bacases for the: format of an option
get:baCase 1:  A 
get:baCase 2:  An
get:bath
get:baThe option-le
get:baoption-length
get:baNote that the
get:bafield might i
get:baEnd-of-Option
get:baA TCP must im
get:baTransmission Cont
get:baFunctional Specif
get:baCurrently def:ined options include (kind indicated in octal)
get:baKind     Le
get:ba----     --
get:ba0         
get:ba1         
get:ba2         
get:baSpecific Opti
get:baEnd of Opti
get:ba+--------
get:ba|00000000
get:ba+--------
get:baThis opti
get:bamight not
get:bathe Data 
get:banot the e
get:bathe optio
get:baNo-Operatio
get:ba+--------
get:ba|00000001
get:ba+--------
get:baThis opti
get:baalign the
get:baThere is 
get:bareceivers
get:banot begin
get:baMaximum Seg
get:ba+--------
get:ba|00000010
get:ba+--------
get:baKind=2  
get:ba[Page 18]        
get:baSeptember 1981   
get:baMaximum S:egment Size Option Data
get:baIf this
get:bareceive
get:baThis fi
get:ba(i.e., 
get:baoption 
get:baPadding:  varia
get:baThe TCP heade
get:baand data begi
get:ba3.2.  Terminology
get:baBefore we can d
get:bato introduce so
get:baconnection requ
get:baof these variab
get:baTransmission Co
get:baTCB are the loc
get:baprecedence of t
get:babuffers, pointe
get:baIn addition sev
get:basequence number
get:baSend Sequence
get:baSND.UNA - s
get:baSND.NXT - s
get:baSND.WND - s
get:baSND.UP  - s
get:baSND.WL1 - s
get:baSND.WL2 - s
get:bau
get:baISS     - i
get:baReceive Seque
get:baRCV.NXT - r
get:baRCV.WND - r
get:baRCV.UP  - r
get:baIRS     - i
get:baTransmission Cont
get:baFunctional Specif
get:baThe following d
get:bathe sequence sp
get:baSend Sequence S
get:ba---
get:ba1 - old s
get:ba2 - seque
get:ba3 - seque
get:ba4 - futur
get:baThe send window
get:baReceive Sequenc
get:ba1 - old s
get:ba2 - seque
get:ba3 - futur
get:baThe receive win
get:baThere are also 
get:batake their valu
get:ba[Page 20]        
get:baSeptember 1981   
get:baCurrent Segme
get:baSEG.SEQ - s
get:baSEG.ACK - s
get:baSEG.LEN - s
get:baSEG.WND - s
get:baSEG.UP  - s
get:baSEG.PRC - s
get:baA connection pr
get:balifetime.  The :states are
get:baESTABLISHED, FI
get:baTIME-WAIT, and 
get:babecause it repr
get:bano connection. : Briefly the meanings of the states are
get:baLISTEN - repr
get:baTCP and port.
get:baSYN-SENT - re
get:baafter having 
get:baSYN-RECEIVED 
get:barequest ackno
get:baconnection re
get:baESTABLISHED -
get:badelivered to 
get:baof the connec
get:baFIN-WAIT-1 - 
get:bafrom the remo
get:batermination r
get:baFIN-WAIT-2 - 
get:bafrom the remo
get:baCLOSE-WAIT - 
get:bafrom the loca
get:baCLOSING - rep
get:baacknowledgmen
get:baLAST-ACK - re
get:baconnection te
get:ba(which includ
get:baTransmission Cont
get:baFunctional Specif
get:baTIME-WAIT - r
get:bathe remote TC
get:batermination r
get:baCLOSED - repr
get:baA TCP connectio
get:baevents.  The ev
get:baABORT, and STAT
get:bacontaining the 
get:baThe state diagr
get:bawith the causin
get:baerror condition
get:bachanges.  In a 
get:bathe reaction of
get:baNOTE BENE:  thi
get:bathe total speci
get:ba[Page 22]        
get:baSeptember 1981   
get:ba+---------+     
get:ba|         |<----
get:ba|   SYN   |     
get:ba|   RCVD  |<----
get:ba|         |     
get:ba|         |-----
get:ba+---------+   rc
get:ba|           --
get:ba|             
get:ba|             
get:ba|  CLOSE      
get:ba| -------     
get:ba| snd FIN     
get:ba|             
get:baV             
get:ba+---------+     
get:ba|  FIN    |<----
get:ba| WAIT-1  |-----
get:ba+---------+     
get:ba| rcv ACK of F
get:ba| ------------
get:baV        x    
get:ba+---------+     
get:ba|FINWAIT-2|     
get:ba+---------+     
get:ba|             
get:ba|  rcv FIN    
get:ba|  -------    
get:ba\ snd ACK    
get:ba------------
get:baTransmission Cont
get:baFunctional Specif
get:ba3.3.  Sequence Nu
get:baA fundamental n
get:baover a TCP conn
get:basequenced, each
get:bamechanism emplo
get:banumber X indica
get:bareceived.  This
get:badetection in th
get:bawithin a segmen
get:bathe header is t
get:banumbered consec
get:baIt is essential
get:bafinite, though 
get:baSince the space
get:banumbers must be
get:bapreserves the r
get:ba2**32 - 1 to 0 
get:baarithmetic, so 
get:bacomparison of s
get:ba(modulo 2**32).
get:baThe typical kin
get:baperform include:
get:ba(a)  Determin
get:banumber s
get:ba(b)  Determin
get:bahave bee
get:baretransm
get:ba(c)  Determin
get:bawhich ar
get:bareceive 
get:ba[Page 24]        
get:baSeptember 1981   
get:baIn response to 
get:bafollowing compa
get:baSND.UNA = old
get:baSND.NXT = nex
get:baSEG.ACK = ack
get:banum
get:baSEG.SEQ = fir
get:baSEG.LEN = the
get:ba(co
get:baSEG.SEQ+SEG.L
get:baA new acknowled
get:bathe inequality :below holds
get:baSND.UNA < SEG
get:baA segment on th
get:baof its sequence
get:baacknowledgment 
get:baWhen data is re:ceived the following comparisons are needed
get:baRCV.NXT = nex
get:bais the le
get:baRCV.NXT+RCV.W
get:basegment, 
get:baSEG.SEQ = fir
get:baSEG.SEQ+SEG.L
get:baA segment is ju
get:baRCV.NXT =< SE
get:baRCV.NXT =< SE
get:baTransmission Cont
get:baFunctional Specif
get:baThe first part 
get:basegment falls i
get:baif the end of t
get:baeither part of 
get:baActually, it is
get:bawindows and zer
get:baacceptability o:f an incoming segment
get:baSegment Recei
get:baLength  Windo
get:ba------- -----
get:ba0       0 
get:ba0      >0 
get:ba>0       0 
get:ba>0      >0 
get:baNote that when 
get:baacceptable exce
get:bamaintain a zero
get:baACKs.  However,
get:baprocess the RST
get:baWe have taken a
get:bacontrol informa
get:basome control fl
get:baand acknowledge
get:bacontrol will be
get:bacarried in the 
get:bafor implicitly 
get:baare the only co
get:baare used only a
get:bapurposes, the S
get:baoctet of the se
get:bato occur after 
get:baoccurs.  The se
get:baspace occupying
get:basequence number
get:ba[Page 26]        
get:baSeptember 1981   
get:baInitial Sequenc
get:baThe protocol pl
get:baused over and o
get:basockets.  New i
get:baincarnations of
get:ba-- "how does th
get:baincarnations of
get:baconnection is b
get:baconnection brea
get:baTo avoid confus
get:baconnection from
get:babe present in t
get:baassure this, ev
get:basequence number
get:baan initial sequ
get:banew 32 bit ISN.
get:babit clock whose
get:bamicroseconds.  
get:baSince we assume
get:bathe Maximum Seg
get:bahours we can re
get:baFor each connec
get:basequence number
get:bathe data sendin
get:balearned during 
get:baFor a connectio
get:basynchronize on 
get:baan exchange of 
get:bacalled "SYN" (f
get:bashorthand, segm
get:baHence, the solu
get:bainitial sequenc
get:baThe synchroniza
get:basequence number
get:bafrom the other 
get:bainitial sequenc
get:ba1) A --> B  S
get:ba2) A <-- B  A
get:ba3) A <-- B  S
get:ba4) A --> B  A
get:baTransmission Cont
get:baFunctional Specif
get:baBecause steps 2
get:bacalled the thre
get:baA three way han
get:batied to a globa
get:bamechanisms for 
get:bano way of knowi
get:baunless it remem
get:ba(which is not a
get:baverify this SYN
get:baclock-driven sc
get:baKnowing When to
get:baTo be sure that
get:basequence number
get:bathe network, th
get:ba(MSL) before as
get:barecovering from
get:balost.  For this
get:bais an engineeri
get:bait is desirable
get:basense, yet reta
get:banot wait at all
get:bathan those rece
get:baThe TCP Quiet T
get:baThis specific
get:baretaining any
get:baeach active (
get:baTCP segments 
get:bain the intern
get:baparagraphs be
get:baTCP implement
get:baat the risk o
get:badata rejected
get:baTCPs consume 
get:baentered into 
get:baduplicate det
get:barelies on the
get:bathe extent th
get:bavalues before
get:babeen delivere
get:bacopies of the
get:basuch an assum
get:ba[Page 28]        
get:baSeptember 1981   
get:baassigned the 
get:baat the receiv
get:bathat each seg
get:baas there are 
get:baUnder normal 
get:bato emit and t
get:bamistakenly us
get:babeen acknowle
get:badata is drain
get:bavery large to
get:bacause trouble
get:bato use up 2**
get:balifetime in t
get:bathis is deeme
get:barates escalat
get:bacycle time is
get:bawithin reason
get:baThe basic dup
get:badefeated, how
get:basequence numb
get:bathe TCP were 
get:baupon crashing
get:baconnection (p
get:bapackets with 
get:bapackets still
get:baincarnation o
get:baabout the seq
get:baspecification
get:babefore emitti
get:basegments from
get:baEven hosts wh
get:bainitial seque
get:ba(i.e., even i
get:banumber for ea
get:baSuppose, for 
get:basequence numb
get:baand that even
get:batakes on a va
get:basegment sent 
get:baat this insta
get:baincarnation o
get:baS1 = ISN(t) -
get:baconnection!  
get:baTransmission Cont
get:baFunctional Specif
get:baduplicates in
get:baof S1 may arr
get:bathe new incar
get:baThe problem i
get:bacrashed nor d
get:bathe system fr
get:baOne way to de
get:basegments for 
get:batime" specifi
get:bawilling to ri
get:badestination m
get:baImplementors 
get:baconnection by
get:bainformally im
get:baObviously, ev
get:banecessary aft
get:baTo summarize:
get:banumbers in th
get:ba"busy" or "in
get:bablock of spac
get:basegment, if a
get:basequence numb
get:bathe previous 
get:banumber overla
get:ba3.4.  Establishin
get:baThe "three-way 
get:baconnection.  Th
get:baresponded to by
get:basimultaneously 
get:baoccurs, each TC
get:baacknowledgment 
get:baan old duplicat
get:barecipient, that
get:baProper use of "
get:baSeveral example
get:baexamples do not
get:basegments, this 
get:badoesn't deliver
get:bavalid (i.e., th
get:baconnection reac
get:bareduces the pos
get:ba[Page 30]        
get:baSeptember 1981   
get:baimplementation 
get:bainformation for
get:baThe simplest th
get:bafigures should 
get:banumbered for re
get:badeparture of a 
get:basegment at B fr
get:baEllipsis (...) 
get:ba(delayed).  An 
get:baComments appear
get:bathe departure o
get:bathe center of e
get:baform, with sequ
get:bafields such as 
get:bain the interest
get:baTCP A      
get:ba1.  CLOSED     
get:ba2.  SYN-SENT   
get:ba3.  ESTABLISHED
get:ba4.  ESTABLISHED
get:ba5.  ESTABLISHED
get:baBasic 3
get:baIn line 2 of fi
get:baindicating that
get:banumber 100.  In
get:bareceived from T
get:baB is now expect
get:baoccupied sequen
get:baAt line 4, TCP 
get:baTCP B's SYN; an
get:basequence number
get:babecause the ACK
get:bawould wind up A
get:baTransmission Cont
get:baFunctional Specif
get:baSimultaneous in
get:bafigure 8.  Each
get:baTCP A      
get:ba1.  CLOSED     
get:ba2.  SYN-SENT   
get:ba3.  SYN-RECEIVE
get:ba4.             
get:ba5.  SYN-RECEIVE
get:ba6.  ESTABLISHED
get:ba7.             
get:baS
get:baThe principle r
get:baduplicate conne
get:bathis, a special
get:bareceiving TCP i
get:baSYN-RECEIVED), 
get:baIf the TCP is i
get:baFIN-WAIT-1, FIN
get:baaborts the conn
get:bacase under "hal
get:ba[Page 32]        
get:baSeptember 1981   
get:baTCP A      
get:ba1.  CLOSED     
get:ba2.  SYN-SENT   
get:ba3.  (duplicate)
get:ba4.  SYN-SENT   
get:ba5.  SYN-SENT   
get:ba6.             
get:ba7.  SYN-SENT   
get:ba8.  ESTABLISHED
get:baAs a simple exa
get:bafigure 9.  At l
get:bacannot tell tha
get:ba(line 4).  TCP 
get:baRST (reset) wit
get:babelievable.  TC
get:baWhen the origin
get:basynchronization
get:babefore the RST,
get:basent in both di
get:baHalf-Open Conne
get:baAn established 
get:baTCPs has closed
get:baknowledge of th
get:babecome desynchr
get:bamemory.  Such c
get:baattempt is made
get:baconnections are
get:bamildly involved
get:baIf at site A th
get:baTransmission Cont
get:baFunctional Specif
get:bauser at site B 
get:bareceiving a res
get:basite B TCP that
get:baAssume that two
get:baanother when a 
get:baDepending on th
get:bathat some error
get:baA is likely to 
get:bapoint.  As a re
get:baor try to SEND 
get:bacase, it receiv
get:balocal (A's) TCP
get:bawill send a seg
get:baexample shown i
get:bare-open the con
get:baTCP A      
get:ba1.  (CRASH)    
get:ba2.  CLOSED     
get:ba3.  SYN-SENT --
get:ba4.  (!!)     <-
get:ba5.  SYN-SENT --
get:ba6.  SYN-SENT   
get:ba7.  SYN-SENT --
get:baWhen the SYN ar
get:baand the incomin
get:baacknowledgment 
get:ba100).  TCP A se
get:basent and, being
get:badetected a half
get:ba[Page 34]        
get:baSeptember 1981   
get:bacontinue to try
get:bareduced to the 
get:baAn interesting 
get:batries to send d
get:baThis is illustr
get:baTCP A from TCP 
get:baexists, so TCP 
get:baprocesses it an
get:baTCP A    
get:ba1.  (CRASH)    
get:ba2.  (??)    <--
get:ba3.          -->
get:baActive
get:baIn figure 12, w
get:bawaiting for SYN
get:bainto action.  A
get:bagenerate a RST 
get:bathe reset and r
get:baTCP A      
get:ba1.  LISTEN     
get:ba2.       ... <S
get:ba3.  (??) <-- <S
get:ba4.       --> <S
get:ba5.  LISTEN     
get:baOld Duplic
get:baTransmission Cont
get:baFunctional Specif
get:baA variety of ot
get:baby the followin
get:baReset Generatio
get:baAs a general ru
get:bawhich apparentl
get:bamust not be sen
get:baThere are three: groups of states
get:ba1.  If the co
get:bain response t
get:baparticular, S
get:baby this means
get:baIf the incomi
get:basequence numb
get:bareset has seq
get:baof the sequen
get:baThe connectio
get:ba2.  If the co
get:baSYN-SENT, SYN
get:basomething not
get:baif an incomin
get:badoes not exac
get:baconnection, a
get:baIf our SYN ha
get:baincoming segm
get:baeither raise 
get:bathe system) o
get:baincoming segm
get:bacontinue as i
get:bacannot raise 
get:badetected in t
get:baterminated th
get:baincoming segm
get:bamatch the loc
get:bamust be sent.
get:baIf the incomi
get:basequence numb
get:bareset has seq
get:baof the sequen
get:baThe connectio
get:ba[Page 36]        
get:baSeptember 1981   
get:ba3.  If the co
get:baFIN-WAIT-1, F
get:baany unaccepta
get:baunacceptible 
get:baacknowledgmen
get:baand an acknow
get:bato be receive
get:baIf an incomin
get:baprecedence wh
get:baand precedenc
get:baconnection go
get:banumber from t
get:baReset Processin
get:baIn all states e
get:baby checking the
get:bais in the windo
get:bato an initial S
get:baacknowledges th
get:baThe receiver of
get:bareceiver was in
get:bain SYN-RECEIVED
get:bathen the receiv
get:baaborts the conn
get:bawas in any othe
get:baand goes to the
get:ba3.5.  Closing a C
get:baCLOSE is an ope
get:banotion of closi
get:bainterpretation,
get:bathe receiving s
get:bain a simplex fa
get:bauntil he is tol
get:bacould initiate 
get:baRECEIVE until s
get:bahas CLOSED.  We
get:baRECEIVEs are ou
get:bacan terminate h
get:babuffers SENT be
get:badata in return 
get:basuccessfully to
get:baTCP.  Users mus
get:bathe TCP says no
get:baTransmission Cont
get:baFunctional Specif
get:baThere are essen:tially three cases
get:ba1) The user i
get:ba2) The remote
get:ba3) Both users
get:baCase 1:  Local 
get:baIn this case,
get:baoutgoing segm
get:baaccepted by t
get:baare allowed i
get:bawill be retra
get:baboth acknowle
get:bacan ACK this 
get:basend its own 
get:baCase 2:  TCP re
get:baIf an unsolic
get:bacan ACK it an
get:bauser will res
get:bathe other TCP
get:bauntil its own
get:baconnection.  
get:bathe connectio
get:baCase 3:  both u
get:baA simultaneou
get:baFIN segments 
get:bahave been pro
get:bahas received.
get:ba[Page 38]        
get:baSeptember 1981   
get:baTCP A      
get:ba1.  ESTABLISHED
get:baFIN-WAIT-1 
get:ba3.  FIN-WAIT-2 
get:ba4.             
get:baTIME-WAIT  
get:ba5.  TIME-WAIT  
get:baCLOSED     
get:baTCP A      
get:ba1.  ESTABLISHED
get:ba2.  (Close)    
get:baFIN-WAIT-1 
get:ba3.  CLOSING    
get:ba4.  TIME-WAIT  
get:ba(2 MSL)    
get:baCLOSED     
get:baTransmission Cont
get:baFunctional Specif
get:ba3.6.  Precedence 
get:baThe intent is t
get:bawith exactly th
get:bahigher of the p
get:baThe precedence 
get:badefined in the 
get:baspecification t
get:bathe security pa
get:bauser group, and
get:baA connection at
get:balower precedenc
get:baa connection du
get:baacknowledgment 
get:baNote that TCP m
get:baprecedence will
get:basegments and po
get:baThe security pa
get:ba(the values wou
get:banon-secure envi
get:baparameters, tho
get:ba3.7.  Data Commun
get:baOnce the connec
get:baexchange of seg
get:ba(checksum test 
get:baretransmission 
get:baDuplicate segme
get:baAs discussed in
get:bacertain tests o
get:basegments to ver
get:baThe sender of d
get:bathe variable SN
get:basequence number
get:bakeeps track of 
get:bavariable SND.UN
get:basent has been a
get:baWhen the sender
get:baSND.NXT.  When 
get:basends an acknow
get:ba[Page 40]        
get:baSeptember 1981   
get:baacknowledgment 
get:bathese variables
get:baThe amount by w
get:badata in the seg
get:basegments must c
get:baThe CLOSE user 
get:baflag in an inco
get:baRetransmission 
get:baBecause of the 
get:bainternetwork sy
get:baretransmission 
get:bafor determining
get:baAn Example Re
get:baMeasure the
get:baparticular 
get:bacovers that
get:basegments re
get:baTime (RTT).:  Next compute a Smoothed Round Trip Time (SRTT) as
get:baSRTT = ( 
get:baand based o:n this, compute the retransmission timeout (RTO) as
get:baRTO = min
get:bawhere UBOUN
get:baLBOUND is a
get:baa smoothing
get:bafactor (e.g
get:baThe Communicati
get:baThe objective o
get:bato stimulate th
get:bapermit the rece
get:bathe currently k
get:baThis mechanism 
get:bathe end of urge
get:bathe receive seq
get:bamust tell the u
get:banumber catches 
get:baTransmission Cont
get:baFunctional Specif
get:bainto "normal mo
get:bais in "urgent m
get:baThe method empl
get:batransmitted.  T
get:bameaningful and 
get:bathe urgent poin
get:bano urgent data 
get:baTo send an urge
get:baoctet.  If the 
get:bathe urgent info
get:baManaging the Wi
get:baThe window sent
get:banumbers the sen
get:baprepared to acc
get:bathe currently a
get:baIndicating a la
get:baarrives than ca
get:bain excessive re
get:banetwork and the
get:batransmission of
get:babetween each ne
get:baThe mechanisms 
get:basubsequently ad
get:bathat much data.
get:badiscouraged.  T
get:bashrink the wind
get:baon the part of 
get:baThe sending TCP
get:baleast one octet
get:basending TCP mus
get:bathe window is z
get:bainterval when t
get:baguarantee that 
get:bawindow will be 
get:baWhen the receiv
get:bastill send an a
get:baand current win
get:baThe sending TCP
get:ba[Page 42]        
get:baSeptember 1981   
get:bawhich fit the c
get:baretransmission 
get:baIn a connection
get:babe carried in a
get:banumber so there
get:baorder.  This is
get:bainformation to 
get:bathe data receiv
get:bathe window info
get:baacknowledgment 
get:baequal or greate
get:baThe window mana
get:bacommunication p
get:baWindow Manage
get:baAllocating 
get:bamany small 
get:bafewer large
get:baOne suggest
get:badefer updat
get:baleast X per
get:baconnection 
get:baAnother sug
get:basegments by
get:basending dat
get:badata must b
get:baNote that t
get:baretransmiss
get:baacknowledgm
get:bawindow info
get:banew window 
get:baThe segment
get:baof transmit
get:basegment con
get:bais accepted
get:baIf the send
get:bawindow is n
get:baalternating
get:bapauses in t
get:baTransmission Cont
get:baFunctional Specif
get:baresult in b
get:babig pair. A
get:bamostly smal
get:baThe suggest
get:baactively at
get:bawindows, si
get:bato many sma
get:baThere are of co:urse two interfaces of concern
get:baand the TCP/low
get:baof the user/TCP
get:baprotocol module
get:bain detail by th
get:bacase that the l
get:bathat TCPs might
get:baUser/TCP Interf
get:baThe following
get:baat best, fict
get:bafacilities.  
get:baimplementatio
get:baTCPs must pro
get:bathat all TCP 
get:bahierarchy.  T
get:barequired of a
get:baTCP User Comm
get:baThe followi
get:bainterface. 
get:bafunction ca
get:bameant to ru
get:baThe user co
get:baTCP must pe
get:baIndividual 
get:bamay provide
get:basingle call
get:baautomatical
get:baissued by t
get:ba[Page 44]        
get:baSeptember 1981   
get:baIn providin
get:banot only ac
get:baprocesses i:t serves.  The latter consists of
get:ba(a) gener
get:baremote cl
get:ba(b) repli
get:bavarious t
get:baFormat:  
get:ba[, timeou
get:ba-> local 
get:baWe assume
get:baprocesses
get:bato use th
get:baimplement
get:bafor the s
get:balower lev
get:baresult of
get:baable to m
get:baprocess c
get:baIf the ac
get:bacall to L
get:bahave eith
get:baparticula
get:bafor any c
get:baby the su
get:baA transmi
get:bafilled in
get:baOn an act
get:basynchroni
get:baThe timeo
get:bafor all d
get:badelivered
get:bawill abor
get:baThe TCP o
get:bathe users
get:baTransmission Cont
get:baFunctional Specif
get:baprecedenc
get:baor securi
get:bathe defau
get:baTCP will 
get:basecurity/
get:bathe prece
get:barequested
get:baThe prece
get:barequested
get:barequest, 
get:baconnectio
get:bathis prec
get:baallowed t
get:baor that a
get:baA local c
get:baThe local
get:bafor the c
get:baFormat:  
get:bacount, PU
get:baThis call
get:bato be sen
get:banot been 
get:baimplement
get:baautomatic
get:baauthorize
get:baIf the PU
get:bato the re
get:basegment c
get:bathe data 
get:batransmiss
get:baIf the UR
get:bawill have
get:bathe urgen
get:bapointer i
get:babeen cons
get:bais to sti
get:baindicate 
get:ba[Page 46]        
get:baSeptember 1981   
get:badata has 
get:baTCP signa
get:baof times 
get:baurgent da
get:baIf no for
get:baconnectio
get:bahas becom
get:balocal soc
get:baforeign s
get:baforeign s
get:baknowing t
get:baHowever, 
get:babecomes s
get:baSTATUS ca
get:baimplement
get:basocket is
get:baIf a time
get:baconnectio
get:baIn the si
get:bathe sendi
get:baor the ti
get:bais both s
get:baconnectio
get:baoffers po
get:basophistic
get:bathe proce
get:bafurthermo
get:baMultiple 
get:bathe TCP w
get:baWe have i
get:bawhich a S
get:bapseudo-in
get:bareturn a 
get:baimmediate
get:babeen ackn
get:baassume ev
get:baclose any
get:bakind (syn
get:basignals, 
get:bawith spec
get:baIn order 
get:baindicatio
get:baTransmission Cont
get:baFunctional Specif
get:babuffer ad
get:bathe SEND 
get:baindicatin
get:bacalling p
get:baFormat:  
get:bacount) ->
get:baThis comm
get:baspecified
get:bacalling p
get:baerror is 
get:baIn the si
get:bacalling p
get:baerror occ
get:baA more so
get:baRECEIVEs 
get:basegments 
get:bathe cost 
get:banotify th
get:baIf enough
get:bathe PUSH 
get:baThe buffe
get:baa PUSH is
get:bareturned 
get:baIf there 
get:baas it arr
get:bashould th
get:baadditiona
get:bacall to R
get:bamay now l
get:baurgent po
get:bain the sa
get:baboundary 
get:baTo distin
get:bacare of t
get:bareturn co
get:bacount ind
get:baAlternati
get:ba[Page 48]        
get:baSeptember 1981   
get:baallocate 
get:bawith the 
get:baFormat:  
get:baThis comm
get:bathe conne
get:baauthorize
get:baClosing c
get:bathe sense
get:baretransmi
get:baserviced.
get:bacalls, fo
get:bato the de
get:bacontinue 
get:bamay be tr
get:bameans "I 
get:bareceive a
get:banot well 
get:baof all it
get:bainto ABOR
get:baThe user 
get:bainitiativ
get:ba(e.g., re
get:badestinati
get:baBecause c
get:baforeign T
get:bashort tim
get:bareplies t
get:baClose als
get:baFormat:  
get:baThis is a
get:baexcluded 
get:batypically
get:baThis comm
get:bainformati:on
get:balocal s
get:baTransmission Cont
get:baFunctional Specif
get:baforeign
get:balocal c
get:bareceive
get:basend wi
get:baconnect
get:banumber 
get:banumber 
get:baurgent 
get:baprecede
get:basecurit
get:baand tra
get:baDepending
get:baimplement
get:baavailable
get:baauthorize
get:baprevents 
get:baconnectio
get:baFormat:  
get:baThis comm
get:baaborted, 
get:babe sent t
get:baDepending
get:baindicatio
get:bareceive a
get:baTCP-to-User M
get:baIt is assum
get:bameans for t
get:bathe TCP doe
get:bato the user
get:baan error me
get:barelating to
get:baother user 
get:baThe followi:ng information is provided
get:baLocal Con
get:baResponse 
get:baBuffer Ad
get:baByte coun
get:baPush flag
get:baUrgent fl
get:ba[Page 50]        
get:baSeptember 1981   
get:baTCP/Lower-Level
get:baThe TCP calls
get:bareceive infor
get:bainternetwork 
get:baProtocol (IP)
get:baIf the lower 
get:baof service an
get:bafor these par:ameters
get:baType of Ser:vice = Precedence: routine, Delay: normal, Throughput
get:banormal, Rel:iability
get:baTime to Liv
get:baNote that
get:baHere we e
get:babe delive
get:baIf the lower 
get:bafeature) and 
get:baroute informa
get:baso that the s
get:bachecksum be t
get:baalso importan
get:baAny lower lev
get:badestination a
get:bathe "TCP leng
get:baof IP and to 
get:baTransmission Cont
get:baFunctional Specif
get:ba3.9.  Event Proce
get:baThe processing 
get:baimplementation.
get:baprocessing sequ
get:basection only in
get:baThe activity of
get:baThe events that: occur can be cast into three categories
get:baarriving segmen
get:baprocessing the 
get:bacases the proce
get:baEvents that o:ccur
get:baArriving Se
get:baSEGMENT A
get:baUSER TIME
get:baRETRANSMI
get:baTIME-WAIT
get:baThe model of th
get:baimmediate retur
get:bapseudo interrup
get:bameans cause a d
get:baError responses
get:bacommands refere:ncing connections that do not exist receive "error
get:baconnection not 
get:baPlease note in 
get:baacknowledgment 
get:baof the sequence
get:baequal to (modul
get:ba[Page 52]        
get:baSeptember 1981   
get:baA natural way t
get:baimagine that th
get:bathat their cont
get:bain the sequence
get:baand processed i
get:baWhen a segment 
get:bathe segment to 
get:bato be consisten
get:baNote that if no
get:baTransmission Cont
get:baFunctional Specif
get:baCLOSED STATE 
get:baCreate a ne
get:bastate infor
get:basocket, pre
get:bainformation
get:baunspecified
get:baparameters 
get:baprecedence 
get:ba"error:  pr:ecedence not allowed" or "error
get:banot allowed
get:baactive and :the foreign socket is unspecified, return "error
get:baforeign soc
get:baspecified, 
get:ba(ISS) is se
get:bais sent.  S
get:bastate, and 
get:baIf the call
get:bareturn "err:or
get:bano room to :create a new connection, return "error
get:baresources".
get:baIf active a
get:baconnection 
get:basegment, se
get:bastate.  Dat
get:baqueued for 
get:baurgent bit 
get:basegments se
get:baqueue the r:equest, respond with "error
get:baIf Foreign :socket was not specified, then return "error
get:basocket unsp
get:ba[Page 54]        
get:baSeptember 1981   
get:baSYN-SENT STAT
get:baSYN-RECEIVED 
get:baESTABLISHED S
get:baFIN-WAIT-1 ST
get:baFIN-WAIT-2 ST
get:baCLOSE-WAIT ST
get:baCLOSING STATE
get:baLAST-ACK STAT
get:baTIME-WAIT STA
get:baReturn "err:or
get:baTransmission Cont
get:baFunctional Specif
get:baCLOSED STATE 
get:baIf the user
get:ba"error:  co
get:baOtherwise, :return "error
get:baIf the fore
get:bafrom passiv
get:baSND.UNA to 
get:baassociated 
get:batransmissio
get:barequested i
get:baas a result
get:barequest, re:spond with "error
get:baForeign soc:ket was not specified, then return "error
get:basocket unsp
get:baSYN-SENT STAT
get:baSYN-RECEIVED 
get:baQueue the d
get:baIf no space: to queue, respond with "error
get:baresources".
get:baESTABLISHED S
get:baCLOSE-WAIT ST
get:baSegmentize 
get:baacknowledgm
get:bainsufficien:t space to remember this buffer, simply return "error
get:bainsufficien
get:baIf the urge
get:baurgent poin
get:ba[Page 56]        
get:baSeptember 1981   
get:baFIN-WAIT-1 ST
get:baFIN-WAIT-2 ST
get:baCLOSING STATE
get:baLAST-ACK STAT
get:baTIME-WAIT STA
get:baReturn "err:or
get:baTransmission Cont
get:baFunctional Specif
get:baCLOSED STATE 
get:baIf the user
get:ba"error:  co
get:baOtherwise r:eturn "error
get:baSYN-SENT STAT
get:baSYN-RECEIVED 
get:baQueue for p
get:bais no room :to queue this request, respond with "error
get:bainsufficien
get:baESTABLISHED S
get:baFIN-WAIT-1 ST
get:baFIN-WAIT-2 ST
get:baIf insuffic
get:barequest, qu
get:baremember th:e RECEIVE, respond with "error
get:baresources".
get:baReassemble 
get:bato user.  M
get:baIf RCV.UP i
get:bauser notify
get:baWhen the TC
get:bathat fact m
get:baacknowledgm
get:badescribed b
get:ba[Page 58]        
get:baSeptember 1981   
get:baCLOSE-WAIT ST
get:baSince the r
get:basatisfied b
get:bauser.  If n
get:ba"error:  co
get:batext can be
get:baCLOSING STATE
get:baLAST-ACK STAT
get:baTIME-WAIT STA
get:baReturn "err:or
get:baTransmission Cont
get:baFunctional Specif
get:baCLOSED STATE 
get:baIf the user
get:ba"error:  co
get:baOtherwise, :return "error
get:baAny outstan:ding RECEIVEs are returned with "error
get:baresponses. 
get:baSYN-SENT STAT
get:baDelete the :TCB and return "error
get:baqueued SEND
get:baSYN-RECEIVED 
get:baIf no SENDs
get:bathen form a
get:baotherwise q
get:baESTABLISHED S
get:baQueue this 
get:baform a FIN 
get:baFIN-WAIT-1 ST
get:baFIN-WAIT-2 ST
get:baStrictly sp:eaking, this is an error and should receive a "error
get:baconnection 
get:baacceptable,
get:baFIN may be 
get:ba[Page 60]        
get:baSeptember 1981   
get:baCLOSE-WAIT ST
get:baQueue this 
get:basegmentized
get:baCLOSING STATE
get:baLAST-ACK STAT
get:baTIME-WAIT STA
get:baRespond wit:h "error
get:baTransmission Cont
get:baFunctional Specif
get:baCLOSED STATE 
get:baIf the user
get:ba"error:  co
get:baOtherwise r:eturn "error
get:baAny outstan:ding RECEIVEs should be returned with "error
get:baconnection 
get:baSYN-SENT STAT
get:baAll queued 
get:banotificatio
get:baSYN-RECEIVED 
get:baESTABLISHED S
get:baFIN-WAIT-1 ST
get:baFIN-WAIT-2 ST
get:baCLOSE-WAIT ST
get:baSend a rese:t segment
get:ba<SEQ=SND.
get:baAll queued 
get:banotificatio
get:baRST formed 
get:baTCB, enter 
get:baCLOSING STATE
get:baLAST-ACK STAT
get:baTIME-WAIT STA
get:baRespond wit
get:ba[Page 62]        
get:baSeptember 1981   
get:baCLOSED STATE 
get:baIf the user
get:ba"error:  co
get:baOtherwise r:eturn "error
get:baReturn "sta
get:baSYN-SENT STAT
get:baReturn "sta
get:baSYN-RECEIVED 
get:baReturn "sta
get:baESTABLISHED S
get:baReturn "sta
get:baFIN-WAIT-1 ST
get:baReturn "sta
get:baFIN-WAIT-2 ST
get:baReturn "sta
get:baCLOSE-WAIT ST
get:baReturn "sta
get:baCLOSING STATE
get:baReturn "sta
get:baLAST-ACK STAT
get:baReturn "sta
get:baTransmission Cont
get:baFunctional Specif
get:baTIME-WAIT STA
get:baReturn "sta
get:ba[Page 64]        
get:baSeptember 1981   
get:baSEGMENT ARRIVES
get:baIf the state 
get:baall data in
get:basegment con
get:bacontaining 
get:baacknowledgm
get:bareset seque
get:baIf the ACK 
get:ba<SEQ=0><A
get:baIf the ACK 
get:ba<SEQ=SEG.
get:baIf the state 
get:bafirst check
get:baAn incomi
get:basecond chec
get:baAny ackno
get:bathe LISTE
get:bafor any a
get:baformatted: as follows
get:ba<SEQ=SE
get:bathird check
get:baIf the SY
get:basecurity/
get:bamatch the
get:ba<SEQ=SE
get:baTransmission Cont
get:baFunctional Specif
get:baIf the SE
get:bathe user 
get:basend a re
get:ba<SEQ=SE
get:baIf the SE
get:baSet RCV.N
get:bacontrol o
get:bashould be: selected and a SYN segment sent of the form
get:ba<SEQ=IS
get:baSND.NXT i
get:bastate sho
get:baincoming 
get:bain the SY
get:banot be re
get:bathe forei
get:baunspecifi
get:bafourth othe
get:baAny other
get:bamust have
get:baprocessin
get:bait could 
get:baincarnati
get:babut if yo
get:baIf the state 
get:bafirst check
get:baIf the AC
get:baIf SEG.
get:bathe RST
get:ba<SEQ=
get:baand dis
get:baIf SND.
get:basecond chec
get:ba[Page 66]        
get:baSeptember 1981   
get:baIf the RS
get:baIf the :ACK was acceptable then signal the user "error
get:baconnect
get:badelete 
get:baand ret
get:bathird check
get:baIf the se
get:bamatch the
get:baIf ther
get:ba<SEQ=
get:baOtherwi
get:ba<SEQ=
get:baIf there 
get:baThe pre
get:baTCB, if
get:ba<SEQ=
get:baIf there 
get:baIf the 
get:bain the 
get:bathe pre
get:baallowed
get:ba<SEQ=
get:baIf the 
get:bain the 
get:baIf a rese
get:bafourth chec
get:baThis step
get:bano ACK, a
get:baIf the SY
get:baTransmission Cont
get:baFunctional Specif
get:baare accep
get:baSEG.SEQ. 
get:bais an ACK
get:baare there
get:baIf SND.UN
get:bastate to 
get:ba<SEQ=SN
get:baand send 
get:batransmiss
get:batext in t
get:babelow whe
get:baOtherwise
get:ba<SEQ=IS
get:baand send 
get:basegment, 
get:bahas been 
get:bafifth, if n
get:basegment and
get:ba[Page 68]        
get:baSeptember 1981   
get:bafirst check s
get:baSYN-RECEIVE
get:baESTABLISHED
get:baFIN-WAIT-1 
get:baFIN-WAIT-2 
get:baCLOSE-WAIT 
get:baCLOSING STA
get:baLAST-ACK ST
get:baTIME-WAIT S
get:baSegments 
get:baare used 
get:badone in S
get:baboundary 
get:baprocessed
get:baThere are
get:basegment
get:baSegment R
get:baLength  W
get:ba------- -
get:ba0     
get:ba0     
get:ba>0     
get:ba>0     
get:baIf the RC
get:baspecial a
get:baIf an inc
get:bashould be
get:bathe segme:nt and return)
get:ba<SEQ=SN
get:baAfter sen
get:baand retur
get:baTransmission Cont
get:baFunctional Specif
get:baIn the fo
get:basegment t
get:baOne could
get:batrimming 
get:baSYN and F
get:babegins at
get:banumbers m
get:basecond check 
get:baSYN-RECEIVE
get:baIf the RS
get:baIf this
get:bacame fr
get:baLISTEN 
get:bathis co
get:bafrom SY
get:bathe use
get:baon the 
get:baactive 
get:baand ret
get:baESTABLISHED
get:baIf the RS
get:bashould re
get:baflushed. 
get:ba"connecti
get:baTCB, and 
get:baCLOSING STA
get:baLAST-ACK ST
get:baIf the RS
get:baTCB, and 
get:ba[Page 70]        
get:baSeptember 1981   
get:bathird check s
get:baSYN-RECEIVE
get:baIf the se
get:baexactly m
get:bathen send
get:baESTABLISHED
get:baIf the se
get:baexactly m
get:bathen send
get:bareceive "
get:baflushed. 
get:ba"connecti
get:baTCB, and 
get:baNote this c
get:baa segment f
get:badifferent s
get:bacurrent con
get:bafourth, check
get:baSYN-RECEIVE
get:baESTABLISHED
get:baFIN-WAIT ST
get:baFIN-WAIT ST
get:baCLOSE-WAIT 
get:baCLOSING STA
get:baLAST-ACK ST
get:baTIME-WAIT S
get:baIf the SY
get:baoutstandi
get:baall segme
get:bareceive a
get:bathe CLOSE
get:baIf the SY
get:baand an ac
get:banumber ch
get:baTransmission Cont
get:baFunctional Specif
get:bafifth check t
get:baif the ACK 
get:baif the ACK 
get:baSYN-RECEI
get:baIf SND.
get:baand con
get:baIf th
get:bareset
get:ba<SE
get:baand s
get:baESTABLISH
get:baIf SND.
get:baAny seg
get:baentirel
get:bapositiv
get:bafully a
get:ba"ok" re
get:ba(SEG.AC
get:basomethi
get:badrop th
get:baIf SND.
get:baupdated
get:baSND.WL2
get:baSND.WL1
get:baNote th
get:barecords
get:baSND.WND
get:bathe las
get:baprevent
get:ba[Page 72]        
get:baSeptember 1981   
get:baFIN-WAIT-
get:baIn addi
get:baour FIN
get:baprocess
get:baFIN-WAIT-
get:baIn addi
get:bathe ret
get:baacknowl
get:baCLOSE-WAI
get:baDo the 
get:baCLOSING S
get:baIn addi
get:bathe ACK
get:baotherwi
get:baLAST-ACK 
get:baThe onl
get:baacknowl
get:badelete 
get:baTIME-WAIT
get:baThe onl
get:baretrans
get:bathe 2 M
get:basixth, check 
get:baESTABLISHED
get:baFIN-WAIT-1 
get:baFIN-WAIT-2 
get:baIf the UR
get:bathe user 
get:bapointer (
get:bauser has 
get:bamode") fo
get:basignal th
get:baTransmission Cont
get:baFunctional Specif
get:baCLOSE-WAIT 
get:baCLOSING STA
get:baLAST-ACK ST
get:baThis shou
get:baremote si
get:baseventh, proc
get:baESTABLISHED
get:baFIN-WAIT-1 
get:baFIN-WAIT-2 
get:baOnce in t
get:batext to u
get:bainto buff
get:baempty.  I
get:bathe user 
get:bahas been 
get:baWhen the 
get:bauser it m
get:baOnce the 
get:baRCV.NXT o
get:baapporopri
get:baRCV.NXT a
get:baPlease no
get:baSend an a:cknowledgment of the form
get:ba<SEQ=SN
get:baThis ackn
get:batransmitt
get:ba[Page 74]        
get:baSeptember 1981   
get:baCLOSE-WAIT 
get:baCLOSING STA
get:baLAST-ACK ST
get:baTIME-WAIT S
get:baThis shou
get:baremote si
get:baeighth, check
get:baDo not proc
get:basince the S
get:baIf the FIN 
get:bareturn any 
get:baover the FI
get:baFIN implies
get:baSYN-RECEI
get:baESTABLISH
get:baEnter t
get:baFIN-WAIT-
get:baIf our 
get:baenter T
get:batimers;
get:baFIN-WAIT-
get:baEnter t
get:baoff the
get:baCLOSE-WAI
get:baRemain 
get:baCLOSING S
get:baRemain 
get:baLAST-ACK 
get:baRemain 
get:baTransmission Cont
get:baFunctional Specif
get:baTIME-WAIT
get:baRemain 
get:batimeout
get:ba[Page 76]        
get:baSeptember 1981   
get:baFor any state
get:bathe user "err:or
get:baand for any o
get:bastate and ret
get:baRETRANSMISSION 
get:baFor any state
get:bathe retransmi
get:baretransmissio
get:baTIME-WAIT TIMEO
get:baIf the time-w
get:baenter the CLO
get:baTransmission Cont
get:ba[Page 78]        
get:baSeptember 1981   
get:baBBN Rep
get:baa Host 
get:bahost an
get:baA contr
get:baindicat
get:baspecifi
get:bais expe
get:bapreviou
get:baThe uni
get:baARPANET
get:baA unit 
get:baIMPs.  
get:baA logic
get:baA messa
get:banetwork
get:baDestination Addre
get:baThe des
get:baidentif
get:baA contr
get:baindicat
get:baoccupyi
get:baA porti
get:bafragmen
get:baA file 
get:baTransmission Cont
get:baControl
get:bafragmen
get:baA compu
get:bafrom th
get:baAn Inte
get:baby the 
get:baThe Int
get:baARPANET
get:baA sourc
get:bainternet datagram
get:baThe uni
get:bahigher 
get:bainternet fragment
get:baA porti
get:baheader.
get:baInterne
get:baThe Ini
get:banumber 
get:baThe Ini
get:baon a co
get:babased p
get:baThe Ini
get:baused by
get:baControl
get:badata.  
get:baon an A
get:ba[Page 80]        
get:baSeptember 1981   
get:baThis is
get:badata re
get:basequenc
get:baof the 
get:baThe uni
get:baAn impl
get:baprocedu
get:baMaximum
get:bathe int
get:baAn eigh
get:baAn Opti
get:bamay be 
get:baprimari
get:batimesta
get:baoptions
get:baA packa
get:balogical
get:balogical
get:baThe por
get:baoutput 
get:baA progr
get:bathe poi
get:baA contr
get:bathis se
get:bareceivi
get:bareceive
get:baTransmission Cont
get:bareceive
get:RFC
get:De
get:I
get:September 1981   
get:PREFACE .....
get:1.  INTRODUCTION 
get:1.1  Motivation
get:1.2  Scope ....
get:1.3  About This
get:1.4  Interfaces
get:1.5  Operation 
get:2.  PHILOSOPHY ..
get:2.1  Elements o
get:2.2  Model of O
get:2.3  The Host E
get:2.4  Interfaces
get:2.5  Relation t
get:2.6  Reliable C
get:2.7  Connection
get:2.8  Data Commu
get:2.9  Precedence
get:2.10 Robustness
get:3.  FUNCTIONAL SP
get:3.1  Header For
get:3.2  Terminolog
get:3.3  Sequence N
get:3.4  Establishi
get:3.5  Closing a 
get:3.6  Precedence
get:3.7  Data Commu
get:3.8  Interfaces
get:3.9  Event Proc
get:GLOSSARY ........
get:REFERENCES ......
get:Transmission Cont
get:[Page ii]        
get:September 1981   
get:This document des
get:(TCP).  There hav
get:specification on 
get:draws heavily fro
get:both in terms of 
get:several details a
get:and redescribes t
get:RFC
get:Replaces: RFC 761
get:IENs:  129, 124, 
get:55, 44, 40, 27, 2
get:The Transmission 
get:reliable host-to-
get:communication net
get:This document des
get:Transmission Cont
get:interface to prog
get:Computer commun
get:role in militar
get:document focuse
get:communication r
get:communication u
get:congestion, but
get:government sect
get:As strategic an
get:developed and d
get:interconnecting
get:communication p
get:applications.  
get:Deputy Undersec
get:declared the Tr
get:be a basis for 
get:standardization
get:TCP is a connec
get:fit into a laye
get:applications.  
get:communication b
get:distinct but in
get:assumptions are
get:protocols below
get:potentially unr
get:protocols.  In 
get:wide spectrum o
get:connections to 
get:Transmission Cont
get:TCP is based on
get:TCP fits into a
get:Internet Protoc
get:receive variabl
get:datagram "envel
get:addressing sour
get:internet protoc
get:the TCP segment
get:multiple networ
get:also carries in
get:and compartment
get:communicated en
get:Much of this do
get:which are co-re
get:computer.  Some
get:front-end compu
get:as well as netw
get:an interface to
get:implementable e
get:host-to-front e
get:The TCP is inte
get:communication s
get:intended to be 
get:1.3.  About this 
get:This document r
get:any TCP impleme
get:protocols and i
get:[Page 2]         
get:September 1981   
get:section offers 
get:operation.  Sec
get:design.  Sectio
get:required of TCP
get:user calls, err
get:The TCP interfa
get:the other side 
get:The interface b
get:illustrated in 
get:calls much like
get:application pro
get:calls to open a
get:established con
get:asynchronously 
get:considerable fr
get:interfaces whic
get:environment, a 
get:interface for a
get:The interface b
get:unspecified exc
get:two levels can 
get:Typically, one 
get:interface.  TCP
get:interconnected 
get:throughout this
get:As noted above,
get:securable logic
get:processes.  To 
get:communication s:ystem requires facilities in the following areas
get:Basic Data Tr
get:Precedence an
get:The basic opera
get:the following p
get:Transmission Cont
get:Basic Data Tran:sfer
get:The TCP is ab
get:direction bet
get:segments for 
get:the TCPs deci
get:Sometimes use
get:submitted to 
get:function is d
get:actually tran
get:pushed throug
get:promptly forw
get:The exact pus
get:the push func
get:Reliability
get:The TCP must 
get:delivered out
get:is achieved b
get:transmitted, 
get:receiving TCP
get:interval, the
get:numbers are u
get:out of order 
get:adding a chec
get:receiver, and
get:As long as th
get:system does n
get:errors will a
get:internet comm
get:Flow Control
get:TCP provides 
get:sent by the s
get:every ACK ind
get:the last segm
get:allowed numbe
get:receiving fur
get:[Page 4]         
get:September 1981   
get:Multiplexing
get:To allow for 
get:communication
get:addresses or 
get:and host addr
get:a socket.  A 
get:That is, a so
get:The binding o
get:Host.  Howeve
get:(e.g., a "log
get:made known to
get:through the k
get:addresses of 
get:Connections
get:The reliabili
get:that TCPs ini
get:each data str
get:sockets, sequ
get:Each connecti
get:identifying i
get:When two proc
get:establish a c
get:side).  When 
get:terminated or
get:Since connect
get:over the unre
get:mechanism wit
get:erroneous ini
get:Precedence and :Security
get:The users of 
get:communication
get:these feature
get:Transmission Cont
get:[Page 6]         
get:September 1981   
get:2.1.  Elements of
get:The internetwor
get:which are in tu
get:that the networ
get:large networks 
get:packet switchin
get:consume message
get:networks, the g
get:communication s
get:connections bet
get:The term packet
get:transaction bet
get:exchanged withi
get:Hosts are compu
get:network's point
get:Processes are v
get:accordance with
get:in execution). 
get:viewed as commu
get:Thus, all commu
get:Since a process
get:streams between
get:that each proce
get:communicates wi
get:2.2.  Model of Op
get:Processes trans
get:data as argumen
get:segments and ca
get:the destination
get:into the receiv
get:TCPs include co
get:ensure reliable
get:The model of in
get:protocol module
get:to the local ne
get:inside internet
get:internet module
get:through the loc
get:The packet swit
get:Transmission Cont
get:other operation
get:destination int
get:At a gateway be
get:from its local 
get:the internet da
get:then "wrapped" 
get:routed to the n
get:A gateway is pe
get:internet datagr
get:through the nex
get:internet datagr
get:further broken 
get:internet datagr
get:internet module
get:A destination i
get:(after reassemb
get:destination TCP
get:This simple mod
get:important featu
get:to the gateway 
get:service paramet
get:Included in the
get:datagram.  Data
get:host and gatewa
get:properly segreg
get:2.3.  The Host En
get:The TCP is assu
get:access the TCP 
get:may call on oth
get:data structures
get:controlled by a
get:network device 
get:datagram protoc
get:The mechanisms 
get:front-end proce
get:host-to-front-e
get:the type of TCP
get:[Page 8]         
get:September 1981   
get:The TCP/user in
get:to OPEN or CLOS
get:STATUS about a 
get:programs on the
get:from, and close
get:The TCP/interne
get:datagrams addre
get:system.  These 
get:service, preced
get:2.5.  Relation to
get:The following d
get:hierarchy
get:+------+ +
get:|Telnet| |
get:+------+ +
get:|   
get:+----
get:| TCP
get:+----
get:| 
get:+----
get:|    
get:+----
get:+--
get:|  
get:+--
get:It is expected 
get:protocols effic
get:protocols like 
get:2.6.  Reliable Co
get:A stream of dat
get:order at the de
get:Transmission Cont
get:Transmission is
get:acknowledgments
get:sequence number
get:segment is tran
get:sequence number
get:is the sequence
get:transmissions i
get:segment contain
get:starts a timer;
get:segment is dele
get:received before
get:An acknowledgme
get:delivered to th
get:the responsibil
get:To govern the f
get:employed.  The 
get:This window spe
get:acknowledgment 
get:2.7.  Connection 
get:To identify the
get:provides a port
get:independently b
get:unique addresse
get:identifying the
get:will be unique 
get:A connection is
get:local socket ma
get:sockets.  A con
get:that is, it is 
get:TCPs are free t
get:However, severa
get:There must be w
get:the "appropriat
get:may "own" ports
get:the ports they 
get:issue, but we e
get:uniquely alloca
get:associating the
get:A connection is
get:foreign socket 
get:[Page 10]        
get:September 1981   
get:connection name
get:subsequent call
get:about a connect
get:is a data struc
get:implementation 
get:pointer to the 
get:whether the con
get:be passively wa
get:A passive OPEN 
get:connection requ
get:Often the proce
get:request from an
get:is used to deno
get:are allowed onl
get:A service proce
get:processes would
get:foreign socket.
get:requested a con
get:local socket we
get:Well-known sock
get:a socket addres
get:"Telnet-Server"
get:socket, and oth
get:Entry, Text Gen
get:being for test 
get:access to a "Lo
get:at which a newl
get:well-known sock
get:of sockets to s
get:Processes can i
get:from other proc
get:been establishe
get:other at the sa
get:is critical for
get:components act 
get:There are two p
get:passive OPENs a
get:local passive O
get:case, the match
get:OPENs has left 
get:foreign socket 
get:Other possibili
get:Transmission Cont
get:If there are se
get:same local sock
get:with the specif
get:TCB exists, bef
get:The procedures 
get:control flag an
get:exchange has be
get:A connection is
get:containing a SY
get:command.  The m
get:connection has 
get:when sequence n
get:The clearing of
get:in this case ca
get:2.8.  Data Commun
get:The data that f
get:octets.  The se
get:in that call (a
get:through to the 
get:A sending TCP i
get:send that data 
get:function is sig
get:receiving TCP s
get:the sending TCP
get:There is no nec
get:boundaries.  Th
get:single SEND cal
get:The purpose of 
get:from the sendin
get:record service.
get:There is a coup
get:of data that cr
get:associated with
get:buffer is retur
get:not filled.  If
get:PUSH is seen, t
get:TCP also provid
get:at some point f
get:[Page 12]        
get:September 1981   
get:currently readi
get:define what the
get:urgent data, bu
get:take action to 
get:2.9.  Precedence 
get:The TCP makes u
get:security option
get:basis to TCP us
get:a multilevel se
get:use only, and o
get:compartment.  C
get:users may be li
get:TCP modules whi
get:properly mark o
get:precedence.  Su
get:higher level pr
get:them to specify
get:precedence of c
get:2.10.  Robustness
get:TCP implementat:ions will follow a general principle of robustness
get:conservative in
get:Transmission Cont
get:[Page 14]        
get:September 1981   
get:3.1.  Header Form
get:TCP segments ar
get:header carries 
get:destination hos
get:header, supplyi
get:division allows
get:TCP Header Form
get:0            
get:0 1 2 3 4 5 6
get:+-+-+-+-+-+-+-
get:|          Sou
get:+-+-+-+-+-+-+-
get:|             
get:+-+-+-+-+-+-+-
get:|             
get:+-+-+-+-+-+-+-
get:|  Data |     
get:| Offset| Rese
get:|       |     
get:+-+-+-+-+-+-+-
get:|           Ch
get:+-+-+-+-+-+-+-
get:|             
get:+-+-+-+-+-+-+-
get:|             
get:+-+-+-+-+-+-+-
get:Note th
get:Source Port:  1
get:The source po
get:Destination Por:t
get:The destinati
get:Transmission Cont
get:Functional Specif
get:Sequence Number:
get:The sequence 
get:when SYN is p
get:initial seque
get:Acknowledgment :Number
get:If the ACK co
get:next sequence
get:receive.  Onc
get:Data Offset:  4
get:The number of
get:the data begi
get:integral numb
get:Reserved:  6 bi
get:Reserved for 
get:Control Bits:  :6 bits (from left to right)
get:URG:  Urgent 
get:ACK:  Acknowl
get:PSH:  Push Fu
get:RST:  Reset t
get:SYN:  Synchro
get:FIN:  No more
get:Window:  16 bit
get:The number of
get:acknowledgmen
get:Checksum:  16 b
get:The checksum 
get:complement su
get:segment conta
get:checksummed, 
get:form a 16 bit
get:transmitted a
get:the checksum 
get:The checksum 
get:[Page 16]        
get:September 1981   
get:prefixed to t
get:Address, the 
get:This gives th
get:information i
get:across the TC
get:calls by the 
get:The TCP Len
get:octets (thi
get:computed), 
get:Urgent Pointer:
get:This field co
get:positive offs
get:urgent pointe
get:the urgent da
get:the URG contr
get:Options:  varia
get:Options may o
get:multiple of 8
get:checksum.  An
get:cases for the: format of an option
get:Case 1:  A 
get:Case 2:  An
get:th
get:The option-le
get:option-length
get:Note that the
get:field might i
get:End-of-Option
get:A TCP must im
get:Transmission Cont
get:Functional Specif
get:Currently def:ined options include (kind indicated in octal)
get:Kind     Le
get:----     --
get:0         
get:1         
get:2         
get:Specific Opti
get:End of Opti
get:+--------
get:|00000000
get:+--------
get:This opti
get:might not
get:the Data 
get:not the e
get:the optio
get:No-Operatio
get:+--------
get:|00000001
get:+--------
get:This opti
get:align the
get:There is 
get:receivers
get:not begin
get:Maximum Seg
get:+--------
get:|00000010
get:+--------
get:Kind=2  
get:[Page 18]        
get:September 1981   
get:Maximum S:egment Size Option Data
get:If this
get:receive
get:This fi
get:(i.e., 
get:option 
get:Padding:  varia
get:The TCP heade
get:and data begi
get:3.2.  Terminology
get:Before we can d
get:to introduce so
get:connection requ
get:of these variab
get:Transmission Co
get:TCB are the loc
get:precedence of t
get:buffers, pointe
get:In addition sev
get:sequence number
get:Send Sequence
get:SND.UNA - s
get:SND.NXT - s
get:SND.WND - s
get:SND.UP  - s
get:SND.WL1 - s
get:SND.WL2 - s
get:u
get:ISS     - i
get:Receive Seque
get:RCV.NXT - r
get:RCV.WND - r
get:RCV.UP  - r
get:IRS     - i
get:Transmission Cont
get:Functional Specif
get:The following d
get:the sequence sp
get:Send Sequence S
get:---
get:1 - old s
get:2 - seque
get:3 - seque
get:4 - futur
get:The send window
get:Receive Sequenc
get:1 - old s
get:2 - seque
get:3 - futur
get:The receive win
get:There are also 
get:take their valu
get:[Page 20]        
get:September 1981   
get:Current Segme
get:SEG.SEQ - s
get:SEG.ACK - s
get:SEG.LEN - s
get:SEG.WND - s
get:SEG.UP  - s
get:SEG.PRC - s
get:A connection pr
get:lifetime.  The :states are
get:ESTABLISHED, FI
get:TIME-WAIT, and 
get:because it repr
get:no connection. : Briefly the meanings of the states are
get:LISTEN - repr
get:TCP and port.
get:SYN-SENT - re
get:after having 
get:SYN-RECEIVED 
get:request ackno
get:connection re
get:ESTABLISHED -
get:delivered to 
get:of the connec
get:FIN-WAIT-1 - 
get:from the remo
get:termination r
get:FIN-WAIT-2 - 
get:from the remo
get:CLOSE-WAIT - 
get:from the loca
get:CLOSING - rep
get:acknowledgmen
get:LAST-ACK - re
get:connection te
get:(which includ
get:Transmission Cont
get:Functional Specif
get:TIME-WAIT - r
get:the remote TC
get:termination r
get:CLOSED - repr
get:A TCP connectio
get:events.  The ev
get:ABORT, and STAT
get:containing the 
get:The state diagr
get:with the causin
get:error condition
get:changes.  In a 
get:the reaction of
get:NOTE BENE:  thi
get:the total speci
get:[Page 22]        
get:September 1981   
get:+---------+     
get:|         |<----
get:|   SYN   |     
get:|   RCVD  |<----
get:|         |     
get:|         |-----
get:+---------+   rc
get:|           --
get:|             
get:|             
get:|  CLOSE      
get:| -------     
get:| snd FIN     
get:|             
get:V             
get:+---------+     
get:|  FIN    |<----
get:| WAIT-1  |-----
get:+---------+     
get:| rcv ACK of F
get:| ------------
get:V        x    
get:+---------+     
get:|FINWAIT-2|     
get:+---------+     
get:|             
get:|  rcv FIN    
get:|  -------    
get:\ snd ACK    
get:------------
get:Transmission Cont
get:Functional Specif
get:3.3.  Sequence Nu
get:A fundamental n
get:over a TCP conn
get:sequenced, each
get:mechanism emplo
get:number X indica
get:received.  This
get:detection in th
get:within a segmen
get:the header is t
get:numbered consec
get:It is essential
get:finite, though 
get:Since the space
get:numbers must be
get:preserves the r
get:2**32 - 1 to 0 
get:arithmetic, so 
get:comparison of s
get:(modulo 2**32).
get:The typical kin
get:perform include:
get:(a)  Determin
get:number s
get:(b)  Determin
get:have bee
get:retransm
get:(c)  Determin
get:which ar
get:receive 
get:[Page 24]        
get:September 1981   
get:In response to 
get:following compa
get:SND.UNA = old
get:SND.NXT = nex
get:SEG.ACK = ack
get:num
get:SEG.SEQ = fir
get:SEG.LEN = the
get:(co
get:SEG.SEQ+SEG.L
get:A new acknowled
get:the inequality :below holds
get:SND.UNA < SEG
get:A segment on th
get:of its sequence
get:acknowledgment 
get:When data is re:ceived the following comparisons are needed
get:RCV.NXT = nex
get:is the le
get:RCV.NXT+RCV.W
get:segment, 
get:SEG.SEQ = fir
get:SEG.SEQ+SEG.L
get:A segment is ju
get:RCV.NXT =< SE
get:RCV.NXT =< SE
get:Transmission Cont
get:Functional Specif
get:The first part 
get:segment falls i
get:if the end of t
get:either part of 
get:Actually, it is
get:windows and zer
get:acceptability o:f an incoming segment
get:Segment Recei
get:Length  Windo
get:------- -----
get:0       0 
get:0      >0 
get:>0       0 
get:>0      >0 
get:Note that when 
get:acceptable exce
get:maintain a zero
get:ACKs.  However,
get:process the RST
get:We have taken a
get:control informa
get:some control fl
get:and acknowledge
get:control will be
get:carried in the 
get:for implicitly 
get:are the only co
get:are used only a
get:purposes, the S
get:octet of the se
get:to occur after 
get:occurs.  The se
get:space occupying
get:sequence number
get:[Page 26]        
get:September 1981   
get:Initial Sequenc
get:The protocol pl
get:used over and o
get:sockets.  New i
get:incarnations of
get:-- "how does th
get:incarnations of
get:connection is b
get:connection brea
get:To avoid confus
get:connection from
get:be present in t
get:assure this, ev
get:sequence number
get:an initial sequ
get:new 32 bit ISN.
get:bit clock whose
get:microseconds.  
get:Since we assume
get:the Maximum Seg
get:hours we can re
get:For each connec
get:sequence number
get:the data sendin
get:learned during 
get:For a connectio
get:synchronize on 
get:an exchange of 
get:called "SYN" (f
get:shorthand, segm
get:Hence, the solu
get:initial sequenc
get:The synchroniza
get:sequence number
get:from the other 
get:initial sequenc
get:1) A --> B  S
get:2) A <-- B  A
get:3) A <-- B  S
get:4) A --> B  A
get:Transmission Cont
get:Functional Specif
get:Because steps 2
get:called the thre
get:A three way han
get:tied to a globa
get:mechanisms for 
get:no way of knowi
get:unless it remem
get:(which is not a
get:verify this SYN
get:clock-driven sc
get:Knowing When to
get:To be sure that
get:sequence number
get:the network, th
get:(MSL) before as
get:recovering from
get:lost.  For this
get:is an engineeri
get:it is desirable
get:sense, yet reta
get:not wait at all
get:than those rece
get:The TCP Quiet T
get:This specific
get:retaining any
get:each active (
get:TCP segments 
get:in the intern
get:paragraphs be
get:TCP implement
get:at the risk o
get:data rejected
get:TCPs consume 
get:entered into 
get:duplicate det
get:relies on the
get:the extent th
get:values before
get:been delivere
get:copies of the
get:such an assum
get:[Page 28]        
get:September 1981   
get:assigned the 
get:at the receiv
get:that each seg
get:as there are 
get:Under normal 
get:to emit and t
get:mistakenly us
get:been acknowle
get:data is drain
get:very large to
get:cause trouble
get:to use up 2**
get:lifetime in t
get:this is deeme
get:rates escalat
get:cycle time is
get:within reason
get:The basic dup
get:defeated, how
get:sequence numb
get:the TCP were 
get:upon crashing
get:connection (p
get:packets with 
get:packets still
get:incarnation o
get:about the seq
get:specification
get:before emitti
get:segments from
get:Even hosts wh
get:initial seque
get:(i.e., even i
get:number for ea
get:Suppose, for 
get:sequence numb
get:and that even
get:takes on a va
get:segment sent 
get:at this insta
get:incarnation o
get:S1 = ISN(t) -
get:connection!  
get:Transmission Cont
get:Functional Specif
get:duplicates in
get:of S1 may arr
get:the new incar
get:The problem i
get:crashed nor d
get:the system fr
get:One way to de
get:segments for 
get:time" specifi
get:willing to ri
get:destination m
get:Implementors 
get:connection by
get:informally im
get:Obviously, ev
get:necessary aft
get:To summarize:
get:numbers in th
get:"busy" or "in
get:block of spac
get:segment, if a
get:sequence numb
get:the previous 
get:number overla
get:3.4.  Establishin
get:The "three-way 
get:connection.  Th
get:responded to by
get:simultaneously 
get:occurs, each TC
get:acknowledgment 
get:an old duplicat
get:recipient, that
get:Proper use of "
get:Several example
get:examples do not
get:segments, this 
get:doesn't deliver
get:valid (i.e., th
get:connection reac
get:reduces the pos
get:[Page 30]        
get:September 1981   
get:implementation 
get:information for
get:The simplest th
get:figures should 
get:numbered for re
get:departure of a 
get:segment at B fr
get:Ellipsis (...) 
get:(delayed).  An 
get:Comments appear
get:the departure o
get:the center of e
get:form, with sequ
get:fields such as 
get:in the interest
get:TCP A      
get:1.  CLOSED     
get:2.  SYN-SENT   
get:3.  ESTABLISHED
get:4.  ESTABLISHED
get:5.  ESTABLISHED
get:Basic 3
get:In line 2 of fi
get:indicating that
get:number 100.  In
get:received from T
get:B is now expect
get:occupied sequen
get:At line 4, TCP 
get:TCP B's SYN; an
get:sequence number
get:because the ACK
get:would wind up A
get:Transmission Cont
get:Functional Specif
get:Simultaneous in
get:figure 8.  Each
get:TCP A      
get:1.  CLOSED     
get:2.  SYN-SENT   
get:3.  SYN-RECEIVE
get:4.             
get:5.  SYN-RECEIVE
get:6.  ESTABLISHED
get:7.             
get:S
get:The principle r
get:duplicate conne
get:this, a special
get:receiving TCP i
get:SYN-RECEIVED), 
get:If the TCP is i
get:FIN-WAIT-1, FIN
get:aborts the conn
get:case under "hal
get:[Page 32]        
get:September 1981   
get:TCP A      
get:1.  CLOSED     
get:2.  SYN-SENT   
get:3.  (duplicate)
get:4.  SYN-SENT   
get:5.  SYN-SENT   
get:6.             
get:7.  SYN-SENT   
get:8.  ESTABLISHED
get:As a simple exa
get:figure 9.  At l
get:cannot tell tha
get:(line 4).  TCP 
get:RST (reset) wit
get:believable.  TC
get:When the origin
get:synchronization
get:before the RST,
get:sent in both di
get:Half-Open Conne
get:An established 
get:TCPs has closed
get:knowledge of th
get:become desynchr
get:memory.  Such c
get:attempt is made
get:connections are
get:mildly involved
get:If at site A th
get:Transmission Cont
get:Functional Specif
get:user at site B 
get:receiving a res
get:site B TCP that
get:Assume that two
get:another when a 
get:Depending on th
get:that some error
get:A is likely to 
get:point.  As a re
get:or try to SEND 
get:case, it receiv
get:local (A's) TCP
get:will send a seg
get:example shown i
get:re-open the con
get:TCP A      
get:1.  (CRASH)    
get:2.  CLOSED     
get:3.  SYN-SENT --
get:4.  (!!)     <-
get:5.  SYN-SENT --
get:6.  SYN-SENT   
get:7.  SYN-SENT --
get:When the SYN ar
get:and the incomin
get:acknowledgment 
get:100).  TCP A se
get:sent and, being
get:detected a half
get:[Page 34]        
get:September 1981   
get:continue to try
get:reduced to the 
get:An interesting 
get:tries to send d
get:This is illustr
get:TCP A from TCP 
get:exists, so TCP 
get:processes it an
get:TCP A    
get:1.  (CRASH)    
get:2.  (??)    <--
get:3.          -->
get:Active
get:In figure 12, w
get:waiting for SYN
get:into action.  A
get:generate a RST 
get:the reset and r
get:TCP A      
get:1.  LISTEN     
get:2.       ... <S
get:3.  (??) <-- <S
get:4.       --> <S
get:5.  LISTEN     
get:Old Duplic
get:Transmission Cont
get:Functional Specif
get:A variety of ot
get:by the followin
get:Reset Generatio
get:As a general ru
get:which apparentl
get:must not be sen
get:There are three: groups of states
get:1.  If the co
get:in response t
get:particular, S
get:by this means
get:If the incomi
get:sequence numb
get:reset has seq
get:of the sequen
get:The connectio
get:2.  If the co
get:SYN-SENT, SYN
get:something not
get:if an incomin
get:does not exac
get:connection, a
get:If our SYN ha
get:incoming segm
get:either raise 
get:the system) o
get:incoming segm
get:continue as i
get:cannot raise 
get:detected in t
get:terminated th
get:incoming segm
get:match the loc
get:must be sent.
get:If the incomi
get:sequence numb
get:reset has seq
get:of the sequen
get:The connectio
get:[Page 36]        
get:September 1981   
get:3.  If the co
get:FIN-WAIT-1, F
get:any unaccepta
get:unacceptible 
get:acknowledgmen
get:and an acknow
get:to be receive
get:If an incomin
get:precedence wh
get:and precedenc
get:connection go
get:number from t
get:Reset Processin
get:In all states e
get:by checking the
get:is in the windo
get:to an initial S
get:acknowledges th
get:The receiver of
get:receiver was in
get:in SYN-RECEIVED
get:then the receiv
get:aborts the conn
get:was in any othe
get:and goes to the
get:3.5.  Closing a C
get:CLOSE is an ope
get:notion of closi
get:interpretation,
get:the receiving s
get:in a simplex fa
get:until he is tol
get:could initiate 
get:RECEIVE until s
get:has CLOSED.  We
get:RECEIVEs are ou
get:can terminate h
get:buffers SENT be
get:data in return 
get:successfully to
get:TCP.  Users mus
get:the TCP says no
get:Transmission Cont
get:Functional Specif
get:There are essen:tially three cases
get:1) The user i
get:2) The remote
get:3) Both users
get:Case 1:  Local 
get:In this case,
get:outgoing segm
get:accepted by t
get:are allowed i
get:will be retra
get:both acknowle
get:can ACK this 
get:send its own 
get:Case 2:  TCP re
get:If an unsolic
get:can ACK it an
get:user will res
get:the other TCP
get:until its own
get:connection.  
get:the connectio
get:Case 3:  both u
get:A simultaneou
get:FIN segments 
get:have been pro
get:has received.
get:[Page 38]        
get:September 1981   
get:TCP A      
get:1.  ESTABLISHED
get:FIN-WAIT-1 
get:3.  FIN-WAIT-2 
get:4.             
get:TIME-WAIT  
get:5.  TIME-WAIT  
get:CLOSED     
get:TCP A      
get:1.  ESTABLISHED
get:2.  (Close)    
get:FIN-WAIT-1 
get:3.  CLOSING    
get:4.  TIME-WAIT  
get:(2 MSL)    
get:CLOSED     
get:Transmission Cont
get:Functional Specif
get:3.6.  Precedence 
get:The intent is t
get:with exactly th
get:higher of the p
get:The precedence 
get:defined in the 
get:specification t
get:the security pa
get:user group, and
get:A connection at
get:lower precedenc
get:a connection du
get:acknowledgment 
get:Note that TCP m
get:precedence will
get:segments and po
get:The security pa
get:(the values wou
get:non-secure envi
get:parameters, tho
get:3.7.  Data Commun
get:Once the connec
get:exchange of seg
get:(checksum test 
get:retransmission 
get:Duplicate segme
get:As discussed in
get:certain tests o
get:segments to ver
get:The sender of d
get:the variable SN
get:sequence number
get:keeps track of 
get:variable SND.UN
get:sent has been a
get:When the sender
get:SND.NXT.  When 
get:sends an acknow
get:[Page 40]        
get:September 1981   
get:acknowledgment 
get:these variables
get:The amount by w
get:data in the seg
get:segments must c
get:The CLOSE user 
get:flag in an inco
get:Retransmission 
get:Because of the 
get:internetwork sy
get:retransmission 
get:for determining
get:An Example Re
get:Measure the
get:particular 
get:covers that
get:segments re
get:Time (RTT).:  Next compute a Smoothed Round Trip Time (SRTT) as
get:SRTT = ( 
get:and based o:n this, compute the retransmission timeout (RTO) as
get:RTO = min
get:where UBOUN
get:LBOUND is a
get:a smoothing
get:factor (e.g
get:The Communicati
get:The objective o
get:to stimulate th
get:permit the rece
get:the currently k
get:This mechanism 
get:the end of urge
get:the receive seq
get:must tell the u
get:number catches 
get:Transmission Cont
get:Functional Specif
get:into "normal mo
get:is in "urgent m
get:The method empl
get:transmitted.  T
get:meaningful and 
get:the urgent poin
get:no urgent data 
get:To send an urge
get:octet.  If the 
get:the urgent info
get:Managing the Wi
get:The window sent
get:numbers the sen
get:prepared to acc
get:the currently a
get:Indicating a la
get:arrives than ca
get:in excessive re
get:network and the
get:transmission of
get:between each ne
get:The mechanisms 
get:subsequently ad
get:that much data.
get:discouraged.  T
get:shrink the wind
get:on the part of 
get:The sending TCP
get:least one octet
get:sending TCP mus
get:the window is z
get:interval when t
get:guarantee that 
get:window will be 
get:When the receiv
get:still send an a
get:and current win
get:The sending TCP
get:[Page 42]        
get:September 1981   
get:which fit the c
get:retransmission 
get:In a connection
get:be carried in a
get:number so there
get:order.  This is
get:information to 
get:the data receiv
get:the window info
get:acknowledgment 
get:equal or greate
get:The window mana
get:communication p
get:Window Manage
get:Allocating 
get:many small 
get:fewer large
get:One suggest
get:defer updat
get:least X per
get:connection 
get:Another sug
get:segments by
get:sending dat
get:data must b
get:Note that t
get:retransmiss
get:acknowledgm
get:window info
get:new window 
get:The segment
get:of transmit
get:segment con
get:is accepted
get:If the send
get:window is n
get:alternating
get:pauses in t
get:Transmission Cont
get:Functional Specif
get:result in b
get:big pair. A
get:mostly smal
get:The suggest
get:actively at
get:windows, si
get:to many sma
get:There are of co:urse two interfaces of concern
get:and the TCP/low
get:of the user/TCP
get:protocol module
get:in detail by th
get:case that the l
get:that TCPs might
get:User/TCP Interf
get:The following
get:at best, fict
get:facilities.  
get:implementatio
get:TCPs must pro
get:that all TCP 
get:hierarchy.  T
get:required of a
get:TCP User Comm
get:The followi
get:interface. 
get:function ca
get:meant to ru
get:The user co
get:TCP must pe
get:Individual 
get:may provide
get:single call
get:automatical
get:issued by t
get:[Page 44]        
get:September 1981   
get:In providin
get:not only ac
get:processes i:t serves.  The latter consists of
get:(a) gener
get:remote cl
get:(b) repli
get:various t
get:Format:  
get:[, timeou
get:-> local 
get:We assume
get:processes
get:to use th
get:implement
get:for the s
get:lower lev
get:result of
get:able to m
get:process c
get:If the ac
get:call to L
get:have eith
get:particula
get:for any c
get:by the su
get:A transmi
get:filled in
get:On an act
get:synchroni
get:The timeo
get:for all d
get:delivered
get:will abor
get:The TCP o
get:the users
get:Transmission Cont
get:Functional Specif
get:precedenc
get:or securi
get:the defau
get:TCP will 
get:security/
get:the prece
get:requested
get:The prece
get:requested
get:request, 
get:connectio
get:this prec
get:allowed t
get:or that a
get:A local c
get:The local
get:for the c
get:Format:  
get:count, PU
get:This call
get:to be sen
get:not been 
get:implement
get:automatic
get:authorize
get:If the PU
get:to the re
get:segment c
get:the data 
get:transmiss
get:If the UR
get:will have
get:the urgen
get:pointer i
get:been cons
get:is to sti
get:indicate 
get:[Page 46]        
get:September 1981   
get:data has 
get:TCP signa
get:of times 
get:urgent da
get:If no for
get:connectio
get:has becom
get:local soc
get:foreign s
get:foreign s
get:knowing t
get:However, 
get:becomes s
get:STATUS ca
get:implement
get:socket is
get:If a time
get:connectio
get:In the si
get:the sendi
get:or the ti
get:is both s
get:connectio
get:offers po
get:sophistic
get:the proce
get:furthermo
get:Multiple 
get:the TCP w
get:We have i
get:which a S
get:pseudo-in
get:return a 
get:immediate
get:been ackn
get:assume ev
get:close any
get:kind (syn
get:signals, 
get:with spec
get:In order 
get:indicatio
get:Transmission Cont
get:Functional Specif
get:buffer ad
get:the SEND 
get:indicatin
get:calling p
get:Format:  
get:count) ->
get:This comm
get:specified
get:calling p
get:error is 
get:In the si
get:calling p
get:error occ
get:A more so
get:RECEIVEs 
get:segments 
get:the cost 
get:notify th
get:If enough
get:the PUSH 
get:The buffe
get:a PUSH is
get:returned 
get:If there 
get:as it arr
get:should th
get:additiona
get:call to R
get:may now l
get:urgent po
get:in the sa
get:boundary 
get:To distin
get:care of t
get:return co
get:count ind
get:Alternati
get:[Page 48]        
get:September 1981   
get:allocate 
get:with the 
get:Format:  
get:This comm
get:the conne
get:authorize
get:Closing c
get:the sense
get:retransmi
get:serviced.
get:calls, fo
get:to the de
get:continue 
get:may be tr
get:means "I 
get:receive a
get:not well 
get:of all it
get:into ABOR
get:The user 
get:initiativ
get:(e.g., re
get:destinati
get:Because c
get:foreign T
get:short tim
get:replies t
get:Close als
get:Format:  
get:This is a
get:excluded 
get:typically
get:This comm
get:informati:on
get:local s
get:Transmission Cont
get:Functional Specif
get:foreign
get:local c
get:receive
get:send wi
get:connect
get:number 
get:number 
get:urgent 
get:precede
get:securit
get:and tra
get:Depending
get:implement
get:available
get:authorize
get:prevents 
get:connectio
get:Format:  
get:This comm
get:aborted, 
get:be sent t
get:Depending
get:indicatio
get:receive a
get:TCP-to-User M
get:It is assum
get:means for t
get:the TCP doe
get:to the user
get:an error me
get:relating to
get:other user 
get:The followi:ng information is provided
get:Local Con
get:Response 
get:Buffer Ad
get:Byte coun
get:Push flag
get:Urgent fl
get:[Page 50]        
get:September 1981   
get:TCP/Lower-Level
get:The TCP calls
get:receive infor
get:internetwork 
get:Protocol (IP)
get:If the lower 
get:of service an
get:for these par:ameters
get:Type of Ser:vice = Precedence: routine, Delay: normal, Throughput
get:normal, Rel:iability
get:Time to Liv
get:Note that
get:Here we e
get:be delive
get:If the lower 
get:feature) and 
get:route informa
get:so that the s
get:checksum be t
get:also importan
get:Any lower lev
get:destination a
get:the "TCP leng
get:of IP and to 
get:Transmission Cont
get:Functional Specif
get:3.9.  Event Proce
get:The processing 
get:implementation.
get:processing sequ
get:section only in
get:The activity of
get:The events that: occur can be cast into three categories
get:arriving segmen
get:processing the 
get:cases the proce
get:Events that o:ccur
get:Arriving Se
get:SEGMENT A
get:USER TIME
get:RETRANSMI
get:TIME-WAIT
get:The model of th
get:immediate retur
get:pseudo interrup
get:means cause a d
get:Error responses
get:commands refere:ncing connections that do not exist receive "error
get:connection not 
get:Please note in 
get:acknowledgment 
get:of the sequence
get:equal to (modul
get:[Page 52]        
get:September 1981   
get:A natural way t
get:imagine that th
get:that their cont
get:in the sequence
get:and processed i
get:When a segment 
get:the segment to 
get:to be consisten
get:Note that if no
get:Transmission Cont
get:Functional Specif
get:CLOSED STATE 
get:Create a ne
get:state infor
get:socket, pre
get:information
get:unspecified
get:parameters 
get:precedence 
get:"error:  pr:ecedence not allowed" or "error
get:not allowed
get:active and :the foreign socket is unspecified, return "error
get:foreign soc
get:specified, 
get:(ISS) is se
get:is sent.  S
get:state, and 
get:If the call
get:return "err:or
get:no room to :create a new connection, return "error
get:resources".
get:If active a
get:connection 
get:segment, se
get:state.  Dat
get:queued for 
get:urgent bit 
get:segments se
get:queue the r:equest, respond with "error
get:If Foreign :socket was not specified, then return "error
get:socket unsp
get:[Page 54]        
get:September 1981   
get:SYN-SENT STAT
get:SYN-RECEIVED 
get:ESTABLISHED S
get:FIN-WAIT-1 ST
get:FIN-WAIT-2 ST
get:CLOSE-WAIT ST
get:CLOSING STATE
get:LAST-ACK STAT
get:TIME-WAIT STA
get:Return "err:or
get:Transmission Cont
get:Functional Specif
get:CLOSED STATE 
get:If the user
get:"error:  co
get:Otherwise, :return "error
get:If the fore
get:from passiv
get:SND.UNA to 
get:associated 
get:transmissio
get:requested i
get:as a result
get:request, re:spond with "error
get:Foreign soc:ket was not specified, then return "error
get:socket unsp
get:SYN-SENT STAT
get:SYN-RECEIVED 
get:Queue the d
get:If no space: to queue, respond with "error
get:resources".
get:ESTABLISHED S
get:CLOSE-WAIT ST
get:Segmentize 
get:acknowledgm
get:insufficien:t space to remember this buffer, simply return "error
get:insufficien
get:If the urge
get:urgent poin
get:[Page 56]        
get:September 1981   
get:FIN-WAIT-1 ST
get:FIN-WAIT-2 ST
get:CLOSING STATE
get:LAST-ACK STAT
get:TIME-WAIT STA
get:Return "err:or
get:Transmission Cont
get:Functional Specif
get:CLOSED STATE 
get:If the user
get:"error:  co
get:Otherwise r:eturn "error
get:SYN-SENT STAT
get:SYN-RECEIVED 
get:Queue for p
get:is no room :to queue this request, respond with "error
get:insufficien
get:ESTABLISHED S
get:FIN-WAIT-1 ST
get:FIN-WAIT-2 ST
get:If insuffic
get:request, qu
get:remember th:e RECEIVE, respond with "error
get:resources".
get:Reassemble 
get:to user.  M
get:If RCV.UP i
get:user notify
get:When the TC
get:that fact m
get:acknowledgm
get:described b
get:[Page 58]        
get:September 1981   
get:CLOSE-WAIT ST
get:Since the r
get:satisfied b
get:user.  If n
get:"error:  co
get:text can be
get:CLOSING STATE
get:LAST-ACK STAT
get:TIME-WAIT STA
get:Return "err:or
get:Transmission Cont
get:Functional Specif
get:CLOSED STATE 
get:If the user
get:"error:  co
get:Otherwise, :return "error
get:Any outstan:ding RECEIVEs are returned with "error
get:responses. 
get:SYN-SENT STAT
get:Delete the :TCB and return "error
get:queued SEND
get:SYN-RECEIVED 
get:If no SENDs
get:then form a
get:otherwise q
get:ESTABLISHED S
get:Queue this 
get:form a FIN 
get:FIN-WAIT-1 ST
get:FIN-WAIT-2 ST
get:Strictly sp:eaking, this is an error and should receive a "error
get:connection 
get:acceptable,
get:FIN may be 
get:[Page 60]        
get:September 1981   
get:CLOSE-WAIT ST
get:Queue this 
get:segmentized
get:CLOSING STATE
get:LAST-ACK STAT
get:TIME-WAIT STA
get:Respond wit:h "error
get:Transmission Cont
get:Functional Specif
get:CLOSED STATE 
get:If the user
get:"error:  co
get:Otherwise r:eturn "error
get:Any outstan:ding RECEIVEs should be returned with "error
get:connection 
get:SYN-SENT STAT
get:All queued 
get:notificatio
get:SYN-RECEIVED 
get:ESTABLISHED S
get:FIN-WAIT-1 ST
get:FIN-WAIT-2 ST
get:CLOSE-WAIT ST
get:Send a rese:t segment
get:<SEQ=SND.
get:All queued 
get:notificatio
get:RST formed 
get:TCB, enter 
get:CLOSING STATE
get:LAST-ACK STAT
get:TIME-WAIT STA
get:Respond wit
get:[Page 62]        
get:September 1981   
get:CLOSED STATE 
get:If the user
get:"error:  co
get:Otherwise r:eturn "error
get:Return "sta
get:SYN-SENT STAT
get:Return "sta
get:SYN-RECEIVED 
get:Return "sta
get:ESTABLISHED S
get:Return "sta
get:FIN-WAIT-1 ST
get:Return "sta
get:FIN-WAIT-2 ST
get:Return "sta
get:CLOSE-WAIT ST
get:Return "sta
get:CLOSING STATE
get:Return "sta
get:LAST-ACK STAT
get:Return "sta
get:Transmission Cont
get:Functional Specif
get:TIME-WAIT STA
get:Return "sta
get:[Page 64]        
get:September 1981   
get:SEGMENT ARRIVES
get:If the state 
get:all data in
get:segment con
get:containing 
get:acknowledgm
get:reset seque
get:If the ACK 
get:<SEQ=0><A
get:If the ACK 
get:<SEQ=SEG.
get:If the state 
get:first check
get:An incomi
get:second chec
get:Any ackno
get:the LISTE
get:for any a
get:formatted: as follows
get:<SEQ=SE
get:third check
get:If the SY
get:security/
get:match the
get:<SEQ=SE
get:Transmission Cont
get:Functional Specif
get:If the SE
get:the user 
get:send a re
get:<SEQ=SE
get:If the SE
get:Set RCV.N
get:control o
get:should be: selected and a SYN segment sent of the form
get:<SEQ=IS
get:SND.NXT i
get:state sho
get:incoming 
get:in the SY
get:not be re
get:the forei
get:unspecifi
get:fourth othe
get:Any other
get:must have
get:processin
get:it could 
get:incarnati
get:but if yo
get:If the state 
get:first check
get:If the AC
get:If SEG.
get:the RST
get:<SEQ=
get:and dis
get:If SND.
get:second chec
get:[Page 66]        
get:September 1981   
get:If the RS
get:If the :ACK was acceptable then signal the user "error
get:connect
get:delete 
get:and ret
get:third check
get:If the se
get:match the
get:If ther
get:<SEQ=
get:Otherwi
get:<SEQ=
get:If there 
get:The pre
get:TCB, if
get:<SEQ=
get:If there 
get:If the 
get:in the 
get:the pre
get:allowed
get:<SEQ=
get:If the 
get:in the 
get:If a rese
get:fourth chec
get:This step
get:no ACK, a
get:If the SY
get:Transmission Cont
get:Functional Specif
get:are accep
get:SEG.SEQ. 
get:is an ACK
get:are there
get:If SND.UN
get:state to 
get:<SEQ=SN
get:and send 
get:transmiss
get:text in t
get:below whe
get:Otherwise
get:<SEQ=IS
get:and send 
get:segment, 
get:has been 
get:fifth, if n
get:segment and
get:[Page 68]        
get:September 1981   
get:first check s
get:SYN-RECEIVE
get:ESTABLISHED
get:FIN-WAIT-1 
get:FIN-WAIT-2 
get:CLOSE-WAIT 
get:CLOSING STA
get:LAST-ACK ST
get:TIME-WAIT S
get:Segments 
get:are used 
get:done in S
get:boundary 
get:processed
get:There are
get:segment
get:Segment R
get:Length  W
get:------- -
get:0     
get:0     
get:>0     
get:>0     
get:If the RC
get:special a
get:If an inc
get:should be
get:the segme:nt and return)
get:<SEQ=SN
get:After sen
get:and retur
get:Transmission Cont
get:Functional Specif
get:In the fo
get:segment t
get:One could
get:trimming 
get:SYN and F
get:begins at
get:numbers m
get:second check 
get:SYN-RECEIVE
get:If the RS
get:If this
get:came fr
get:LISTEN 
get:this co
get:from SY
get:the use
get:on the 
get:active 
get:and ret
get:ESTABLISHED
get:If the RS
get:should re
get:flushed. 
get:"connecti
get:TCB, and 
get:CLOSING STA
get:LAST-ACK ST
get:If the RS
get:TCB, and 
get:[Page 70]        
get:September 1981   
get:third check s
get:SYN-RECEIVE
get:If the se
get:exactly m
get:then send
get:ESTABLISHED
get:If the se
get:exactly m
get:then send
get:receive "
get:flushed. 
get:"connecti
get:TCB, and 
get:Note this c
get:a segment f
get:different s
get:current con
get:fourth, check
get:SYN-RECEIVE
get:ESTABLISHED
get:FIN-WAIT ST
get:FIN-WAIT ST
get:CLOSE-WAIT 
get:CLOSING STA
get:LAST-ACK ST
get:TIME-WAIT S
get:If the SY
get:outstandi
get:all segme
get:receive a
get:the CLOSE
get:If the SY
get:and an ac
get:number ch
get:Transmission Cont
get:Functional Specif
get:fifth check t
get:if the ACK 
get:if the ACK 
get:SYN-RECEI
get:If SND.
get:and con
get:If th
get:reset
get:<SE
get:and s
get:ESTABLISH
get:If SND.
get:Any seg
get:entirel
get:positiv
get:fully a
get:"ok" re
get:(SEG.AC
get:somethi
get:drop th
get:If SND.
get:updated
get:SND.WL2
get:SND.WL1
get:Note th
get:records
get:SND.WND
get:the las
get:prevent
get:[Page 72]        
get:September 1981   
get:FIN-WAIT-
get:In addi
get:our FIN
get:process
get:FIN-WAIT-
get:In addi
get:the ret
get:acknowl
get:CLOSE-WAI
get:Do the 
get:CLOSING S
get:In addi
get:the ACK
get:otherwi
get:LAST-ACK 
get:The onl
get:acknowl
get:delete 
get:TIME-WAIT
get:The onl
get:retrans
get:the 2 M
get:sixth, check 
get:ESTABLISHED
get:FIN-WAIT-1 
get:FIN-WAIT-2 
get:If the UR
get:the user 
get:pointer (
get:user has 
get:mode") fo
get:signal th
get:Transmission Cont
get:Functional Specif
get:CLOSE-WAIT 
get:CLOSING STA
get:LAST-ACK ST
get:This shou
get:remote si
get:seventh, proc
get:ESTABLISHED
get:FIN-WAIT-1 
get:FIN-WAIT-2 
get:Once in t
get:text to u
get:into buff
get:empty.  I
get:the user 
get:has been 
get:When the 
get:user it m
get:Once the 
get:RCV.NXT o
get:apporopri
get:RCV.NXT a
get:Please no
get:Send an a:cknowledgment of the form
get:<SEQ=SN
get:This ackn
get:transmitt
get:[Page 74]        
get:September 1981   
get:CLOSE-WAIT 
get:CLOSING STA
get:LAST-ACK ST
get:TIME-WAIT S
get:This shou
get:remote si
get:eighth, check
get:Do not proc
get:since the S
get:If the FIN 
get:return any 
get:over the FI
get:FIN implies
get:SYN-RECEI
get:ESTABLISH
get:Enter t
get:FIN-WAIT-
get:If our 
get:enter T
get:timers;
get:FIN-WAIT-
get:Enter t
get:off the
get:CLOSE-WAI
get:Remain 
get:CLOSING S
get:Remain 
get:LAST-ACK 
get:Remain 
get:Transmission Cont
get:Functional Specif
get:TIME-WAIT
get:Remain 
get:timeout
get:[Page 76]        
get:September 1981   
get:For any state
get:the user "err:or
get:and for any o
get:state and ret
get:RETRANSMISSION 
get:For any state
get:the retransmi
get:retransmissio
get:TIME-WAIT TIMEO
get:If the time-w
get:enter the CLO
get:Transmission Cont
get:[Page 78]        
get:September 1981   
get:BBN Rep
get:a Host 
get:host an
get:A contr
get:indicat
get:specifi
get:is expe
get:previou
get:The uni
get:ARPANET
get:A unit 
get:IMPs.  
get:A logic
get:A messa
get:network
get:Destination Addre
get:The des
get:identif
get:A contr
get:indicat
get:occupyi
get:A porti
get:fragmen
get:A file 
get:Transmission Cont
get:Control
get:fragmen
get:A compu
get:from th
get:An Inte
get:by the 
get:The Int
get:ARPANET
get:A sourc
get:internet datagram
get:The uni
get:higher 
get:internet fragment
get:A porti
get:header.
get:Interne
get:The Ini
get:number 
get:The Ini
get:on a co
get:based p
get:The Ini
get:used by
get:Control
get:data.  
get:on an A
get:[Page 80]        
get:September 1981   
get:This is
get:data re
get:sequenc
get:of the 
get:The uni
get:An impl
get:procedu
get:Maximum
get:the int
get:An eigh
get:An Opti
get:may be 
get:primari
get:timesta
get:options
get:A packa
get:logical
get:logical
get:The por
get:output 
get:A progr
get:the poi
get:A contr
get:this se
get:receivi
get:receive
get:Transmission Cont
get:receive
get:receive
get:receive next sequ
get:This is
get:receive
get:This re
get:is will
get:segment
get:RCV.NXT
get:Segment
get:range a
get:A contr
get:that th
get:interac
get:sequenc
get:segment
get:it.  In
get:rise to
get:Real Ti:me Protocol
get:of time
get:segment
get:segment
get:segment
get:segment
get:segment
get:[Page 82]        
get:September 1981   
get:segment
get:A logic
get:unit of
get:segment acknowled
get:The seq
get:arrivin
get:The amo
get:includi
get:The num
get:This is
get:use on 
get:initial
get:each oc
get:This re
get:(receiv
get:window 
get:receivi
get:be emit
get:SND.UNA
get:between
get:send se
get:left se
get:send ur
get:segment
get:segment
get:Transmission Cont
get:send wi
get:An addr
get:is, the
get:The sou
get:A contr
get:number,
get:where t
get:Transmi
get:the sta
get:The pre
get:Transmi:ssion Control Protocol
get:reliabl
get:Type of
get:An Inte
get:for thi
get:A contr
get:indicat
get:urgent 
get:sequenc
get:pointer
get:A contr
get:field c
get:indicat
get:urgent 
get:[Page 84]        
get:September 1981   
get:[1]  Cerf, V., an
get:Intercommuni
get:Vol. COM-22,
get:[2]  Postel, J. (
get:Protocol Spe
get:Institute, S
get:[3]  Dalal, Y. an
get:Protocols", 
get:December 197
get:[4]  Postel, J., 
get:Institute, S
get:aRFC
get:aDe
get:aI
get:aSeptember 1981   
get:aPREFACE .....
get:a1.  INTRODUCTION 
get:a1.1  Motivation
get:a1.2  Scope ....
get:a1.3  About This
get:a1.4  Interfaces
get:a1.5  Operation 
get:a2.  PHILOSOPHY ..
get:a2.1  Elements o
get:a2.2  Model of O
get:a2.3  The Host E
get:a2.4  Interfaces
get:a2.5  Relation t
get:a2.6  Reliable C
get:a2.7  Connection
get:a2.8  Data Commu
get:a2.9  Precedence
get:a2.10 Robustness
get:a3.  FUNCTIONAL SP
get:a3.1  Header For
get:a3.2  Terminolog
get:a3.3  Sequence N
get:a3.4  Establishi
get:a3.5  Closing a 
get:a3.6  Precedence
get:a3.7  Data Commu
get:a3.8  Interfaces
get:a3.9  Event Proc
get:aGLOSSARY ........
get:aREFERENCES ......
get:aTransmission Cont
get:a[Page ii]        
get:aSeptember 1981   
get:aThis document des
get:a(TCP).  There hav
get:aspecification on 
get:adraws heavily fro
get:aboth in terms of 
get:aseveral details a
get:aand redescribes t
get:aRFC
get:aReplaces: RFC 761
get:aIENs:  129, 124, 
get:a55, 44, 40, 27, 2
get:aThe Transmission 
get:areliable host-to-
get:acommunication net
get:aThis document des
get:aTransmission Cont
get:ainterface to prog
get:aComputer commun
get:arole in militar
get:adocument focuse
get:acommunication r
get:acommunication u
get:acongestion, but
get:agovernment sect
get:aAs strategic an
get:adeveloped and d
get:ainterconnecting
get:acommunication p
get:aapplications.  
get:aDeputy Undersec
get:adeclared the Tr
get:abe a basis for 
get:astandardization
get:aTCP is a connec
get:afit into a laye
get:aapplications.  
get:acommunication b
get:adistinct but in
get:aassumptions are
get:aprotocols below
get:apotentially unr
get:aprotocols.  In 
get:awide spectrum o
get:aconnections to 
get:aTransmission Cont
get:aTCP is based on
get:aTCP fits into a
get:aInternet Protoc
get:areceive variabl
get:adatagram "envel
get:aaddressing sour
get:ainternet protoc
get:athe TCP segment
get:amultiple networ
get:aalso carries in
get:aand compartment
get:acommunicated en
get:aMuch of this do
get:awhich are co-re
get:acomputer.  Some
get:afront-end compu
get:aas well as netw
get:aan interface to
get:aimplementable e
get:ahost-to-front e
get:aThe TCP is inte
get:acommunication s
get:aintended to be 
get:a1.3.  About this 
get:aThis document r
get:aany TCP impleme
get:aprotocols and i
get:a[Page 2]         
get:aSeptember 1981   
get:asection offers 
get:aoperation.  Sec
get:adesign.  Sectio
get:arequired of TCP
get:auser calls, err
get:aThe TCP interfa
get:athe other side 
get:aThe interface b
get:aillustrated in 
get:acalls much like
get:aapplication pro
get:acalls to open a
get:aestablished con
get:aasynchronously 
get:aconsiderable fr
get:ainterfaces whic
get:aenvironment, a 
get:ainterface for a
get:aThe interface b
get:aunspecified exc
get:atwo levels can 
get:aTypically, one 
get:ainterface.  TCP
get:ainterconnected 
get:athroughout this
get:aAs noted above,
get:asecurable logic
get:aprocesses.  To 
get:acommunication s:ystem requires facilities in the following areas
get:aBasic Data Tr
get:aPrecedence an
get:aThe basic opera
get:athe following p
get:aTransmission Cont
get:aBasic Data Tran:sfer
get:aThe TCP is ab
get:adirection bet
get:asegments for 
get:athe TCPs deci
get:aSometimes use
get:asubmitted to 
get:afunction is d
get:aactually tran
get:apushed throug
get:apromptly forw
get:aThe exact pus
get:athe push func
get:aReliability
get:aThe TCP must 
get:adelivered out
get:ais achieved b
get:atransmitted, 
get:areceiving TCP
get:ainterval, the
get:anumbers are u
get:aout of order 
get:aadding a chec
get:areceiver, and
get:aAs long as th
get:asystem does n
get:aerrors will a
get:ainternet comm
get:aFlow Control
get:aTCP provides 
get:asent by the s
get:aevery ACK ind
get:athe last segm
get:aallowed numbe
get:areceiving fur
get:a[Page 4]         
get:aSeptember 1981   
get:aMultiplexing
get:aTo allow for 
get:acommunication
get:aaddresses or 
get:aand host addr
get:aa socket.  A 
get:aThat is, a so
get:aThe binding o
get:aHost.  Howeve
get:a(e.g., a "log
get:amade known to
get:athrough the k
get:aaddresses of 
get:aConnections
get:aThe reliabili
get:athat TCPs ini
get:aeach data str
get:asockets, sequ
get:aEach connecti
get:aidentifying i
get:aWhen two proc
get:aestablish a c
get:aside).  When 
get:aterminated or
get:aSince connect
get:aover the unre
get:amechanism wit
get:aerroneous ini
get:aPrecedence and :Security
get:aThe users of 
get:acommunication
get:athese feature
get:aTransmission Cont
get:a[Page 6]         
get:aSeptember 1981   
get:a2.1.  Elements of
get:aThe internetwor
get:awhich are in tu
get:athat the networ
get:alarge networks 
get:apacket switchin
get:aconsume message
get:anetworks, the g
get:acommunication s
get:aconnections bet
get:aThe term packet
get:atransaction bet
get:aexchanged withi
get:aHosts are compu
get:anetwork's point
get:aProcesses are v
get:aaccordance with
get:ain execution). 
get:aviewed as commu
get:aThus, all commu
get:aSince a process
get:astreams between
get:athat each proce
get:acommunicates wi
get:a2.2.  Model of Op
get:aProcesses trans
get:adata as argumen
get:asegments and ca
get:athe destination
get:ainto the receiv
get:aTCPs include co
get:aensure reliable
get:aThe model of in
get:aprotocol module
get:ato the local ne
get:ainside internet
get:ainternet module
get:athrough the loc
get:aThe packet swit
get:aTransmission Cont
get:aother operation
get:adestination int
get:aAt a gateway be
get:afrom its local 
get:athe internet da
get:athen "wrapped" 
get:arouted to the n
get:aA gateway is pe
get:ainternet datagr
get:athrough the nex
get:ainternet datagr
get:afurther broken 
get:ainternet datagr
get:ainternet module
get:aA destination i
get:a(after reassemb
get:adestination TCP
get:aThis simple mod
get:aimportant featu
get:ato the gateway 
get:aservice paramet
get:aIncluded in the
get:adatagram.  Data
get:ahost and gatewa
get:aproperly segreg
get:a2.3.  The Host En
get:aThe TCP is assu
get:aaccess the TCP 
get:amay call on oth
get:adata structures
get:acontrolled by a
get:anetwork device 
get:adatagram protoc
get:aThe mechanisms 
get:afront-end proce
get:ahost-to-front-e
get:athe type of TCP
get:a[Page 8]         
get:aSeptember 1981   
get:aThe TCP/user in
get:ato OPEN or CLOS
get:aSTATUS about a 
get:aprograms on the
get:afrom, and close
get:aThe TCP/interne
get:adatagrams addre
get:asystem.  These 
get:aservice, preced
get:a2.5.  Relation to
get:aThe following d
get:ahierarchy
get:a+------+ +
get:a|Telnet| |
get:a+------+ +
get:a|   
get:a+----
get:a| TCP
get:a+----
get:a| 
get:a+----
get:a|    
get:a+----
get:a+--
get:a|  
get:a+--
get:aIt is expected 
get:aprotocols effic
get:aprotocols like 
get:a2.6.  Reliable Co
get:aA stream of dat
get:aorder at the de
get:aTransmission Cont
get:aTransmission is
get:aacknowledgments
get:asequence number
get:asegment is tran
get:asequence number
get:ais the sequence
get:atransmissions i
get:asegment contain
get:astarts a timer;
get:asegment is dele
get:areceived before
get:aAn acknowledgme
get:adelivered to th
get:athe responsibil
get:aTo govern the f
get:aemployed.  The 
get:aThis window spe
get:aacknowledgment 
get:a2.7.  Connection 
get:aTo identify the
get:aprovides a port
get:aindependently b
get:aunique addresse
get:aidentifying the
get:awill be unique 
get:aA connection is
get:alocal socket ma
get:asockets.  A con
get:athat is, it is 
get:aTCPs are free t
get:aHowever, severa
get:aThere must be w
get:athe "appropriat
get:amay "own" ports
get:athe ports they 
get:aissue, but we e
get:auniquely alloca
get:aassociating the
get:aA connection is
get:aforeign socket 
get:a[Page 10]        
get:aSeptember 1981   
get:aconnection name
get:asubsequent call
get:aabout a connect
get:ais a data struc
get:aimplementation 
get:apointer to the 
get:awhether the con
get:abe passively wa
get:aA passive OPEN 
get:aconnection requ
get:aOften the proce
get:arequest from an
get:ais used to deno
get:aare allowed onl
get:aA service proce
get:aprocesses would
get:aforeign socket.
get:arequested a con
get:alocal socket we
get:aWell-known sock
get:aa socket addres
get:a"Telnet-Server"
get:asocket, and oth
get:aEntry, Text Gen
get:abeing for test 
get:aaccess to a "Lo
get:aat which a newl
get:awell-known sock
get:aof sockets to s
get:aProcesses can i
get:afrom other proc
get:abeen establishe
get:aother at the sa
get:ais critical for
get:acomponents act 
get:aThere are two p
get:apassive OPENs a
get:alocal passive O
get:acase, the match
get:aOPENs has left 
get:aforeign socket 
get:aOther possibili
get:aTransmission Cont
get:aIf there are se
get:asame local sock
get:awith the specif
get:aTCB exists, bef
get:aThe procedures 
get:acontrol flag an
get:aexchange has be
get:aA connection is
get:acontaining a SY
get:acommand.  The m
get:aconnection has 
get:awhen sequence n
get:aThe clearing of
get:ain this case ca
get:a2.8.  Data Commun
get:aThe data that f
get:aoctets.  The se
get:ain that call (a
get:athrough to the 
get:aA sending TCP i
get:asend that data 
get:afunction is sig
get:areceiving TCP s
get:athe sending TCP
get:aThere is no nec
get:aboundaries.  Th
get:asingle SEND cal
get:aThe purpose of 
get:afrom the sendin
get:arecord service.
get:aThere is a coup
get:aof data that cr
get:aassociated with
get:abuffer is retur
get:anot filled.  If
get:aPUSH is seen, t
get:aTCP also provid
get:aat some point f
get:a[Page 12]        
get:aSeptember 1981   
get:acurrently readi
get:adefine what the
get:aurgent data, bu
get:atake action to 
get:a2.9.  Precedence 
get:aThe TCP makes u
get:asecurity option
get:abasis to TCP us
get:aa multilevel se
get:ause only, and o
get:acompartment.  C
get:ausers may be li
get:aTCP modules whi
get:aproperly mark o
get:aprecedence.  Su
get:ahigher level pr
get:athem to specify
get:aprecedence of c
get:a2.10.  Robustness
get:aTCP implementat:ions will follow a general principle of robustness
get:aconservative in
get:aTransmission Cont
get:a[Page 14]        
get:aSeptember 1981   
get:a3.1.  Header Form
get:aTCP segments ar
get:aheader carries 
get:adestination hos
get:aheader, supplyi
get:adivision allows
get:aTCP Header Form
get:a0            
get:a0 1 2 3 4 5 6
get:a+-+-+-+-+-+-+-
get:a|          Sou
get:a+-+-+-+-+-+-+-
get:a|             
get:a+-+-+-+-+-+-+-
get:a|             
get:a+-+-+-+-+-+-+-
get:a|  Data |     
get:a| Offset| Rese
get:a|       |     
get:a+-+-+-+-+-+-+-
get:a|           Ch
get:a+-+-+-+-+-+-+-
get:a|             
get:a+-+-+-+-+-+-+-
get:a|             
get:a+-+-+-+-+-+-+-
get:aNote th
get:aSource Port:  1
get:aThe source po
get:aDestination Por:t
get:aThe destinati
get:aTransmission Cont
get:aFunctional Specif
get:aSequence Number:
get:aThe sequence 
get:awhen SYN is p
get:ainitial seque
get:aAcknowledgment :Number
get:aIf the ACK co
get:anext sequence
get:areceive.  Onc
get:aData Offset:  4
get:aThe number of
get:athe data begi
get:aintegral numb
get:aReserved:  6 bi
get:aReserved for 
get:aControl Bits:  :6 bits (from left to right)
get:aURG:  Urgent 
get:aACK:  Acknowl
get:aPSH:  Push Fu
get:aRST:  Reset t
get:aSYN:  Synchro
get:aFIN:  No more
get:aWindow:  16 bit
get:aThe number of
get:aacknowledgmen
get:aChecksum:  16 b
get:aThe checksum 
get:acomplement su
get:asegment conta
get:achecksummed, 
get:aform a 16 bit
get:atransmitted a
get:athe checksum 
get:aThe checksum 
get:a[Page 16]        
get:aSeptember 1981   
get:aprefixed to t
get:aAddress, the 
get:aThis gives th
get:ainformation i
get:aacross the TC
get:acalls by the 
get:aThe TCP Len
get:aoctets (thi
get:acomputed), 
get:aUrgent Pointer:
get:aThis field co
get:apositive offs
get:aurgent pointe
get:athe urgent da
get:athe URG contr
get:aOptions:  varia
get:aOptions may o
get:amultiple of 8
get:achecksum.  An
get:acases for the: format of an option
get:aCase 1:  A 
get:aCase 2:  An
get:ath
get:aThe option-le
get:aoption-length
get:aNote that the
get:afield might i
get:aEnd-of-Option
get:aA TCP must im
get:aTransmission Cont
get:aFunctional Specif
get:aCurrently def:ined options include (kind indicated in octal)
get:aKind     Le
get:a----     --
get:a0         
get:a1         
get:a2         
get:aSpecific Opti
get:aEnd of Opti
get:a+--------
get:a|00000000
get:a+--------
get:aThis opti
get:amight not
get:athe Data 
get:anot the e
get:athe optio
get:aNo-Operatio
get:a+--------
get:a|00000001
get:a+--------
get:aThis opti
get:aalign the
get:aThere is 
get:areceivers
get:anot begin
get:aMaximum Seg
get:a+--------
get:a|00000010
get:a+--------
get:aKind=2  
get:a[Page 18]        
get:aSeptember 1981   
get:aMaximum S:egment Size Option Data
get:aIf this
get:areceive
get:aThis fi
get:a(i.e., 
get:aoption 
get:aPadding:  varia
get:aThe TCP heade
get:aand data begi
get:a3.2.  Terminology
get:aBefore we can d
get:ato introduce so
get:aconnection requ
get:aof these variab
get:aTransmission Co
get:aTCB are the loc
get:aprecedence of t
get:abuffers, pointe
get:aIn addition sev
get:asequence number
get:aSend Sequence
get:aSND.UNA - s
get:aSND.NXT - s
get:aSND.WND - s
get:aSND.UP  - s
get:aSND.WL1 - s
get:aSND.WL2 - s
get:au
get:aISS     - i
get:aReceive Seque
get:aRCV.NXT - r
get:aRCV.WND - r
get:aRCV.UP  - r
get:aIRS     - i
get:aTransmission Cont
get:aFunctional Specif
get:aThe following d
get:athe sequence sp
get:aSend Sequence S
get:a---
get:a1 - old s
get:a2 - seque
get:a3 - seque
get:a4 - futur
get:aThe send window
get:aReceive Sequenc
get:a1 - old s
get:a2 - seque
get:a3 - futur
get:aThe receive win
get:aThere are also 
get:atake their valu
get:a[Page 20]        
get:aSeptember 1981   
get:aCurrent Segme
get:aSEG.SEQ - s
get:aSEG.ACK - s
get:aSEG.LEN - s
get:aSEG.WND - s
get:aSEG.UP  - s
get:aSEG.PRC - s
get:aA connection pr
get:alifetime.  The :states are
get:aESTABLISHED, FI
get:aTIME-WAIT, and 
get:abecause it repr
get:ano connection. : Briefly the meanings of the states are
get:aLISTEN - repr
get:aTCP and port.
get:aSYN-SENT - re
get:aafter having 
get:aSYN-RECEIVED 
get:arequest ackno
get:aconnection re
get:aESTABLISHED -
get:adelivered to 
get:aof the connec
get:aFIN-WAIT-1 - 
get:afrom the remo
get:atermination r
get:aFIN-WAIT-2 - 
get:afrom the remo
get:aCLOSE-WAIT - 
get:afrom the loca
get:aCLOSING - rep
get:aacknowledgmen
get:aLAST-ACK - re
get:aconnection te
get:a(which includ
get:aTransmission Cont
get:aFunctional Specif
get:aTIME-WAIT - r
get:athe remote TC
get:atermination r
get:aCLOSED - repr
get:aA TCP connectio
get:aevents.  The ev
get:aABORT, and STAT
get:acontaining the 
get:aThe state diagr
get:awith the causin
get:aerror condition
get:achanges.  In a 
get:athe reaction of
get:aNOTE BENE:  thi
get:athe total speci
get:a[Page 22]        
get:aSeptember 1981   
get:a+---------+     
get:a|         |<----
get:a|   SYN   |     
get:a|   RCVD  |<----
get:a|         |     
get:a|         |-----
get:a+---------+   rc
get:a|           --
get:a|             
get:a|             
get:a|  CLOSE      
get:a| -------     
get:a| snd FIN     
get:a|             
get:aV             
get:a+---------+     
get:a|  FIN    |<----
get:a| WAIT-1  |-----
get:a+---------+     
get:a| rcv ACK of F
get:a| ------------
get:aV        x    
get:a+---------+     
get:a|FINWAIT-2|     
get:a+---------+     
get:a|             
get:a|  rcv FIN    
get:a|  -------    
get:a\ snd ACK    
get:a------------
get:aTransmission Cont
get:aFunctional Specif
get:a3.3.  Sequence Nu
get:aA fundamental n
get:aover a TCP conn
get:asequenced, each
get:amechanism emplo
get:anumber X indica
get:areceived.  This
get:adetection in th
get:awithin a segmen
get:athe header is t
get:anumbered consec
get:aIt is essential
get:afinite, though 
get:aSince the space
get:anumbers must be
get:apreserves the r
get:a2**32 - 1 to 0 
get:aarithmetic, so 
get:acomparison of s
get:a(modulo 2**32).
get:aThe typical kin
get:aperform include:
get:a(a)  Determin
get:anumber s
get:a(b)  Determin
get:ahave bee
get:aretransm
get:a(c)  Determin
get:awhich ar
get:areceive 
get:a[Page 24]        
get:aSeptember 1981   
get:aIn response to 
get:afollowing compa
get:aSND.UNA = old
get:aSND.NXT = nex
get:aSEG.ACK = ack
get:anum
get:aSEG.SEQ = fir
get:aSEG.LEN = the
get:a(co
get:aSEG.SEQ+SEG.L
get:aA new acknowled
get:athe inequality :below holds
get:aSND.UNA < SEG
get:aA segment on th
get:aof its sequence
get:aacknowledgment 
get:aWhen data is re:ceived the following comparisons are needed
get:aRCV.NXT = nex
get:ais the le
get:aRCV.NXT+RCV.W
get:asegment, 
get:aSEG.SEQ = fir
get:aSEG.SEQ+SEG.L
get:aA segment is ju
get:aRCV.NXT =< SE
get:aRCV.NXT =< SE
get:aTransmission Cont
get:aFunctional Specif
get:aThe first part 
get:asegment falls i
get:aif the end of t
get:aeither part of 
get:aActually, it is
get:awindows and zer
get:aacceptability o:f an incoming segment
get:aSegment Recei
get:aLength  Windo
get:a------- -----
get:a0       0 
get:a0      >0 
get:a>0       0 
get:a>0      >0 
get:aNote that when 
get:aacceptable exce
get:amaintain a zero
get:aACKs.  However,
get:aprocess the RST
get:aWe have taken a
get:acontrol informa
get:asome control fl
get:aand acknowledge
get:acontrol will be
get:acarried in the 
get:afor implicitly 
get:aare the only co
get:aare used only a
get:apurposes, the S
get:aoctet of the se
get:ato occur after 
get:aoccurs.  The se
get:aspace occupying
get:asequence number
get:a[Page 26]        
get:aSeptember 1981   
get:aInitial Sequenc
get:aThe protocol pl
get:aused over and o
get:asockets.  New i
get:aincarnations of
get:a-- "how does th
get:aincarnations of
get:aconnection is b
get:aconnection brea
get:aTo avoid confus
get:aconnection from
get:abe present in t
get:aassure this, ev
get:asequence number
get:aan initial sequ
get:anew 32 bit ISN.
get:abit clock whose
get:amicroseconds.  
get:aSince we assume
get:athe Maximum Seg
get:ahours we can re
get:aFor each connec
get:asequence number
get:athe data sendin
get:alearned during 
get:aFor a connectio
get:asynchronize on 
get:aan exchange of 
get:acalled "SYN" (f
get:ashorthand, segm
get:aHence, the solu
get:ainitial sequenc
get:aThe synchroniza
get:asequence number
get:afrom the other 
get:ainitial sequenc
get:a1) A --> B  S
get:a2) A <-- B  A
get:a3) A <-- B  S
get:a4) A --> B  A
get:aTransmission Cont
get:aFunctional Specif
get:aBecause steps 2
get:acalled the thre
get:aA three way han
get:atied to a globa
get:amechanisms for 
get:ano way of knowi
get:aunless it remem
get:a(which is not a
get:averify this SYN
get:aclock-driven sc
get:aKnowing When to
get:aTo be sure that
get:asequence number
get:athe network, th
get:a(MSL) before as
get:arecovering from
get:alost.  For this
get:ais an engineeri
get:ait is desirable
get:asense, yet reta
get:anot wait at all
get:athan those rece
get:aThe TCP Quiet T
get:aThis specific
get:aretaining any
get:aeach active (
get:aTCP segments 
get:ain the intern
get:aparagraphs be
get:aTCP implement
get:aat the risk o
get:adata rejected
get:aTCPs consume 
get:aentered into 
get:aduplicate det
get:arelies on the
get:athe extent th
get:avalues before
get:abeen delivere
get:acopies of the
get:asuch an assum
get:a[Page 28]        
get:aSeptember 1981   
get:aassigned the 
get:aat the receiv
get:athat each seg
get:aas there are 
get:aUnder normal 
get:ato emit and t
get:amistakenly us
get:abeen acknowle
get:adata is drain
get:avery large to
get:acause trouble
get:ato use up 2**
get:alifetime in t
get:athis is deeme
get:arates escalat
get:acycle time is
get:awithin reason
get:aThe basic dup
get:adefeated, how
get:asequence numb
get:athe TCP were 
get:aupon crashing
get:aconnection (p
get:apackets with 
get:apackets still
get:aincarnation o
get:aabout the seq
get:aspecification
get:abefore emitti
get:asegments from
get:aEven hosts wh
get:ainitial seque
get:a(i.e., even i
get:anumber for ea
get:aSuppose, for 
get:asequence numb
get:aand that even
get:atakes on a va
get:asegment sent 
get:aat this insta
get:aincarnation o
get:aS1 = ISN(t) -
get:aconnection!  
get:aTransmission Cont
get:aFunctional Specif
get:aduplicates in
get:aof S1 may arr
get:athe new incar
get:aThe problem i
get:acrashed nor d
get:athe system fr
get:aOne way to de
get:asegments for 
get:atime" specifi
get:awilling to ri
get:adestination m
get:aImplementors 
get:aconnection by
get:ainformally im
get:aObviously, ev
get:anecessary aft
get:aTo summarize:
get:anumbers in th
get:a"busy" or "in
get:ablock of spac
get:asegment, if a
get:asequence numb
get:athe previous 
get:anumber overla
get:a3.4.  Establishin
get:aThe "three-way 
get:aconnection.  Th
get:aresponded to by
get:asimultaneously 
get:aoccurs, each TC
get:aacknowledgment 
get:aan old duplicat
get:arecipient, that
get:aProper use of "
get:aSeveral example
get:aexamples do not
get:asegments, this 
get:adoesn't deliver
get:avalid (i.e., th
get:aconnection reac
get:areduces the pos
get:a[Page 30]        
get:aSeptember 1981   
get:aimplementation 
get:ainformation for
get:aThe simplest th
get:afigures should 
get:anumbered for re
get:adeparture of a 
get:asegment at B fr
get:aEllipsis (...) 
get:a(delayed).  An 
get:aComments appear
get:athe departure o
get:athe center of e
get:aform, with sequ
get:afields such as 
get:ain the interest
get:aTCP A      
get:a1.  CLOSED     
get:a2.  SYN-SENT   
get:a3.  ESTABLISHED
get:a4.  ESTABLISHED
get:a5.  ESTABLISHED
get:aBasic 3
get:aIn line 2 of fi
get:aindicating that
get:anumber 100.  In
get:areceived from T
get:aB is now expect
get:aoccupied sequen
get:aAt line 4, TCP 
get:aTCP B's SYN; an
get:asequence number
get:abecause the ACK
get:awould wind up A
get:aTransmission Cont
get:aFunctional Specif
get:aSimultaneous in
get:afigure 8.  Each
get:aTCP A      
get:a1.  CLOSED     
get:a2.  SYN-SENT   
get:a3.  SYN-RECEIVE
get:a4.             
get:a5.  SYN-RECEIVE
get:a6.  ESTABLISHED
get:a7.             
get:aS
get:aThe principle r
get:aduplicate conne
get:athis, a special
get:areceiving TCP i
get:aSYN-RECEIVED), 
get:aIf the TCP is i
get:aFIN-WAIT-1, FIN
get:aaborts the conn
get:acase under "hal
get:a[Page 32]        
get:aSeptember 1981   
get:aTCP A      
get:a1.  CLOSED     
get:a2.  SYN-SENT   
get:a3.  (duplicate)
get:a4.  SYN-SENT   
get:a5.  SYN-SENT   
get:a6.             
get:a7.  SYN-SENT   
get:a8.  ESTABLISHED
get:aAs a simple exa
get:afigure 9.  At l
get:acannot tell tha
get:a(line 4).  TCP 
get:aRST (reset) wit
get:abelievable.  TC
get:aWhen the origin
get:asynchronization
get:abefore the RST,
get:asent in both di
get:aHalf-Open Conne
get:aAn established 
get:aTCPs has closed
get:aknowledge of th
get:abecome desynchr
get:amemory.  Such c
get:aattempt is made
get:aconnections are
get:amildly involved
get:aIf at site A th
get:aTransmission Cont
get:aFunctional Specif
get:auser at site B 
get:areceiving a res
get:asite B TCP that
get:aAssume that two
get:aanother when a 
get:aDepending on th
get:athat some error
get:aA is likely to 
get:apoint.  As a re
get:aor try to SEND 
get:acase, it receiv
get:alocal (A's) TCP
get:awill send a seg
get:aexample shown i
get:are-open the con
get:aTCP A      
get:a1.  (CRASH)    
get:a2.  CLOSED     
get:a3.  SYN-SENT --
get:a4.  (!!)     <-
get:a5.  SYN-SENT --
get:a6.  SYN-SENT   
get:a7.  SYN-SENT --
get:aWhen the SYN ar
get:aand the incomin
get:aacknowledgment 
get:a100).  TCP A se
get:asent and, being
get:adetected a half
get:a[Page 34]        
get:aSeptember 1981   
get:acontinue to try
get:areduced to the 
get:aAn interesting 
get:atries to send d
get:aThis is illustr
get:aTCP A from TCP 
get:aexists, so TCP 
get:aprocesses it an
get:aTCP A    
get:a1.  (CRASH)    
get:a2.  (??)    <--
get:a3.          -->
get:aActive
get:aIn figure 12, w
get:awaiting for SYN
get:ainto action.  A
get:agenerate a RST 
get:athe reset and r
get:aTCP A      
get:a1.  LISTEN     
get:a2.       ... <S
get:a3.  (??) <-- <S
get:a4.       --> <S
get:a5.  LISTEN     
get:aOld Duplic
get:aTransmission Cont
get:aFunctional Specif
get:aA variety of ot
get:aby the followin
get:aReset Generatio
get:aAs a general ru
get:awhich apparentl
get:amust not be sen
get:aThere are three: groups of states
get:a1.  If the co
get:ain response t
get:aparticular, S
get:aby this means
get:aIf the incomi
get:asequence numb
get:areset has seq
get:aof the sequen
get:aThe connectio
get:a2.  If the co
get:aSYN-SENT, SYN
get:asomething not
get:aif an incomin
get:adoes not exac
get:aconnection, a
get:aIf our SYN ha
get:aincoming segm
get:aeither raise 
get:athe system) o
get:aincoming segm
get:acontinue as i
get:acannot raise 
get:adetected in t
get:aterminated th
get:aincoming segm
get:amatch the loc
get:amust be sent.
get:aIf the incomi
get:asequence numb
get:areset has seq
get:aof the sequen
get:aThe connectio
get:a[Page 36]        
get:aSeptember 1981   
get:a3.  If the co
get:aFIN-WAIT-1, F
get:aany unaccepta
get:aunacceptible 
get:aacknowledgmen
get:aand an acknow
get:ato be receive
get:aIf an incomin
get:aprecedence wh
get:aand precedenc
get:aconnection go
get:anumber from t
get:aReset Processin
get:aIn all states e
get:aby checking the
get:ais in the windo
get:ato an initial S
get:aacknowledges th
get:aThe receiver of
get:areceiver was in
get:ain SYN-RECEIVED
get:athen the receiv
get:aaborts the conn
get:awas in any othe
get:aand goes to the
get:a3.5.  Closing a C
get:aCLOSE is an ope
get:anotion of closi
get:ainterpretation,
get:athe receiving s
get:ain a simplex fa
get:auntil he is tol
get:acould initiate 
get:aRECEIVE until s
get:ahas CLOSED.  We
get:aRECEIVEs are ou
get:acan terminate h
get:abuffers SENT be
get:adata in return 
get:asuccessfully to
get:aTCP.  Users mus
get:athe TCP says no
get:aTransmission Cont
get:aFunctional Specif
get:aThere are essen:tially three cases
get:a1) The user i
get:a2) The remote
get:a3) Both users
get:aCase 1:  Local 
get:aIn this case,
get:aoutgoing segm
get:aaccepted by t
get:aare allowed i
get:awill be retra
get:aboth acknowle
get:acan ACK this 
get:asend its own 
get:aCase 2:  TCP re
get:aIf an unsolic
get:acan ACK it an
get:auser will res
get:athe other TCP
get:auntil its own
get:aconnection.  
get:athe connectio
get:aCase 3:  both u
get:aA simultaneou
get:aFIN segments 
get:ahave been pro
get:ahas received.
get:a[Page 38]        
get:aSeptember 1981   
get:aTCP A      
get:a1.  ESTABLISHED
get:aFIN-WAIT-1 
get:a3.  FIN-WAIT-2 
get:a4.             
get:aTIME-WAIT  
get:a5.  TIME-WAIT  
get:aCLOSED     
get:aTCP A      
get:a1.  ESTABLISHED
get:a2.  (Close)    
get:aFIN-WAIT-1 
get:a3.  CLOSING    
get:a4.  TIME-WAIT  
get:a(2 MSL)    
get:aCLOSED     
get:aTransmission Cont
get:aFunctional Specif
get:a3.6.  Precedence 
get:aThe intent is t
get:awith exactly th
get:ahigher of the p
get:aThe precedence 
get:adefined in the 
get:aspecification t
get:athe security pa
get:auser group, and
get:aA connection at
get:alower precedenc
get:aa connection du
get:aacknowledgment 
get:aNote that TCP m
get:aprecedence will
get:asegments and po
get:aThe security pa
get:a(the values wou
get:anon-secure envi
get:aparameters, tho
get:a3.7.  Data Commun
get:aOnce the connec
get:aexchange of seg
get:a(checksum test 
get:aretransmission 
get:aDuplicate segme
get:aAs discussed in
get:acertain tests o
get:asegments to ver
get:aThe sender of d
get:athe variable SN
get:asequence number
get:akeeps track of 
get:avariable SND.UN
get:asent has been a
get:aWhen the sender
get:aSND.NXT.  When 
get:asends an acknow
get:a[Page 40]        
get:aSeptember 1981   
get:aacknowledgment 
get:athese variables
get:aThe amount by w
get:adata in the seg
get:asegments must c
get:aThe CLOSE user 
get:aflag in an inco
get:aRetransmission 
get:aBecause of the 
get:ainternetwork sy
get:aretransmission 
get:afor determining
get:aAn Example Re
get:aMeasure the
get:aparticular 
get:acovers that
get:asegments re
get:aTime (RTT).:  Next compute a Smoothed Round Trip Time (SRTT) as
get:aSRTT = ( 
get:aand based o:n this, compute the retransmission timeout (RTO) as
get:aRTO = min
get:awhere UBOUN
get:aLBOUND is a
get:aa smoothing
get:afactor (e.g
get:aThe Communicati
get:aThe objective o
get:ato stimulate th
get:apermit the rece
get:athe currently k
get:aThis mechanism 
get:athe end of urge
get:athe receive seq
get:amust tell the u
get:anumber catches 
get:aTransmission Cont
get:aFunctional Specif
get:ainto "normal mo
get:ais in "urgent m
get:aThe method empl
get:atransmitted.  T
get:ameaningful and 
get:athe urgent poin
get:ano urgent data 
get:aTo send an urge
get:aoctet.  If the 
get:athe urgent info
get:aManaging the Wi
get:aThe window sent
get:anumbers the sen
get:aprepared to acc
get:athe currently a
get:aIndicating a la
get:aarrives than ca
get:ain excessive re
get:anetwork and the
get:atransmission of
get:abetween each ne
get:aThe mechanisms 
get:asubsequently ad
get:athat much data.
get:adiscouraged.  T
get:ashrink the wind
get:aon the part of 
get:aThe sending TCP
get:aleast one octet
get:asending TCP mus
get:athe window is z
get:ainterval when t
get:aguarantee that 
get:awindow will be 
get:aWhen the receiv
get:astill send an a
get:aand current win
get:aThe sending TCP
get:a[Page 42]        
get:aSeptember 1981   
get:awhich fit the c
get:aretransmission 
get:aIn a connection
get:abe carried in a
get:anumber so there
get:aorder.  This is
get:ainformation to 
get:athe data receiv
get:athe window info
get:aacknowledgment 
get:aequal or greate
get:aThe window mana
get:acommunication p
get:aWindow Manage
get:aAllocating 
get:amany small 
get:afewer large
get:aOne suggest
get:adefer updat
get:aleast X per
get:aconnection 
get:aAnother sug
get:asegments by
get:asending dat
get:adata must b
get:aNote that t
get:aretransmiss
get:aacknowledgm
get:awindow info
get:anew window 
get:aThe segment
get:aof transmit
get:asegment con
get:ais accepted
get:aIf the send
get:awindow is n
get:aalternating
get:apauses in t
get:aTransmission Cont
get:aFunctional Specif
get:aresult in b
get:abig pair. A
get:amostly smal
get:aThe suggest
get:aactively at
get:awindows, si
get:ato many sma
get:aThere are of co:urse two interfaces of concern
get:aand the TCP/low
get:aof the user/TCP
get:aprotocol module
get:ain detail by th
get:acase that the l
get:athat TCPs might
get:aUser/TCP Interf
get:aThe following
get:aat best, fict
get:afacilities.  
get:aimplementatio
get:aTCPs must pro
get:athat all TCP 
get:ahierarchy.  T
get:arequired of a
get:aTCP User Comm
get:aThe followi
get:ainterface. 
get:afunction ca
get:ameant to ru
get:aThe user co
get:aTCP must pe
get:aIndividual 
get:amay provide
get:asingle call
get:aautomatical
get:aissued by t
get:a[Page 44]        
get:aSeptember 1981   
get:aIn providin
get:anot only ac
get:aprocesses i:t serves.  The latter consists of
get:a(a) gener
get:aremote cl
get:a(b) repli
get:avarious t
get:aFormat:  
get:a[, timeou
get:a-> local 
get:aWe assume
get:aprocesses
get:ato use th
get:aimplement
get:afor the s
get:alower lev
get:aresult of
get:aable to m
get:aprocess c
get:aIf the ac
get:acall to L
get:ahave eith
get:aparticula
get:afor any c
get:aby the su
get:aA transmi
get:afilled in
get:aOn an act
get:asynchroni
get:aThe timeo
get:afor all d
get:adelivered
get:awill abor
get:aThe TCP o
get:athe users
get:aTransmission Cont
get:aFunctional Specif
get:aprecedenc
get:aor securi
get:athe defau
get:aTCP will 
get:asecurity/
get:athe prece
get:arequested
get:aThe prece
get:arequested
get:arequest, 
get:aconnectio
get:athis prec
get:aallowed t
get:aor that a
get:aA local c
get:aThe local
get:afor the c
get:aFormat:  
get:acount, PU
get:aThis call
get:ato be sen
get:anot been 
get:aimplement
get:aautomatic
get:aauthorize
get:aIf the PU
get:ato the re
get:asegment c
get:athe data 
get:atransmiss
get:aIf the UR
get:awill have
get:athe urgen
get:apointer i
get:abeen cons
get:ais to sti
get:aindicate 
get:a[Page 46]        
get:aSeptember 1981   
get:adata has 
get:aTCP signa
get:aof times 
get:aurgent da
get:aIf no for
get:aconnectio
get:ahas becom
get:alocal soc
get:aforeign s
get:aforeign s
get:aknowing t
get:aHowever, 
get:abecomes s
get:aSTATUS ca
get:aimplement
get:asocket is
get:aIf a time
get:aconnectio
get:aIn the si
get:athe sendi
get:aor the ti
get:ais both s
get:aconnectio
get:aoffers po
get:asophistic
get:athe proce
get:afurthermo
get:aMultiple 
get:athe TCP w
get:aWe have i
get:awhich a S
get:apseudo-in
get:areturn a 
get:aimmediate
get:abeen ackn
get:aassume ev
get:aclose any
get:akind (syn
get:asignals, 
get:awith spec
get:aIn order 
get:aindicatio
get:aTransmission Cont
get:aFunctional Specif
get:abuffer ad
get:athe SEND 
get:aindicatin
get:acalling p
get:aFormat:  
get:acount) ->
get:aThis comm
get:aspecified
get:acalling p
get:aerror is 
get:aIn the si
get:acalling p
get:aerror occ
get:aA more so
get:aRECEIVEs 
get:asegments 
get:athe cost 
get:anotify th
get:aIf enough
get:athe PUSH 
get:aThe buffe
get:aa PUSH is
get:areturned 
get:aIf there 
get:aas it arr
get:ashould th
get:aadditiona
get:acall to R
get:amay now l
get:aurgent po
get:ain the sa
get:aboundary 
get:aTo distin
get:acare of t
get:areturn co
get:acount ind
get:aAlternati
get:a[Page 48]        
get:aSeptember 1981   
get:aallocate 
get:awith the 
get:aFormat:  
get:aThis comm
get:athe conne
get:aauthorize
get:aClosing c
get:athe sense
get:aretransmi
get:aserviced.
get:acalls, fo
get:ato the de
get:acontinue 
get:amay be tr
get:ameans "I 
get:areceive a
get:anot well 
get:aof all it
get:ainto ABOR
get:aThe user 
get:ainitiativ
get:a(e.g., re
get:adestinati
get:aBecause c
get:aforeign T
get:ashort tim
get:areplies t
get:aClose als
get:aFormat:  
get:aThis is a
get:aexcluded 
get:atypically
get:aThis comm
get:ainformati:on
get:alocal s
get:aTransmission Cont
get:aFunctional Specif
get:aforeign
get:alocal c
get:areceive
get:asend wi
get:aconnect
get:anumber 
get:anumber 
get:aurgent 
get:aprecede
get:asecurit
get:aand tra
get:aDepending
get:aimplement
get:aavailable
get:aauthorize
get:aprevents 
get:aconnectio
get:aFormat:  
get:aThis comm
get:aaborted, 
get:abe sent t
get:aDepending
get:aindicatio
get:areceive a
get:aTCP-to-User M
get:aIt is assum
get:ameans for t
get:athe TCP doe
get:ato the user
get:aan error me
get:arelating to
get:aother user 
get:aThe followi:ng information is provided
get:aLocal Con
get:aResponse 
get:aBuffer Ad
get:aByte coun
get:aPush flag
get:aUrgent fl
get:a[Page 50]        
get:aSeptember 1981   
get:aTCP/Lower-Level
get:aThe TCP calls
get:areceive infor
get:ainternetwork 
get:aProtocol (IP)
get:aIf the lower 
get:aof service an
get:afor these par:ameters
get:aType of Ser:vice = Precedence: routine, Delay: normal, Throughput
get:anormal, Rel:iability
get:aTime to Liv
get:aNote that
get:aHere we e
get:abe delive
get:aIf the lower 
get:afeature) and 
get:aroute informa
get:aso that the s
get:achecksum be t
get:aalso importan
get:aAny lower lev
get:adestination a
get:athe "TCP leng
get:aof IP and to 
get:aTransmission Cont
get:aFunctional Specif
get:a3.9.  Event Proce
get:aThe processing 
get:aimplementation.
get:aprocessing sequ
get:asection only in
get:aThe activity of
get:aThe events that: occur can be cast into three categories
get:aarriving segmen
get:aprocessing the 
get:acases the proce
get:aEvents that o:ccur
get:aArriving Se
get:aSEGMENT A
get:aUSER TIME
get:aRETRANSMI
get:aTIME-WAIT
get:aThe model of th
get:aimmediate retur
get:apseudo interrup
get:ameans cause a d
get:aError responses
get:acommands refere:ncing connections that do not exist receive "error
get:aconnection not 
get:aPlease note in 
get:aacknowledgment 
get:aof the sequence
get:aequal to (modul
get:a[Page 52]        
get:aSeptember 1981   
get:aA natural way t
get:aimagine that th
get:athat their cont
get:ain the sequence
get:aand processed i
get:aWhen a segment 
get:athe segment to 
get:ato be consisten
get:aNote that if no
get:aTransmission Cont
get:aFunctional Specif
get:aCLOSED STATE 
get:aCreate a ne
get:astate infor
get:asocket, pre
get:ainformation
get:aunspecified
get:aparameters 
get:aprecedence 
get:a"error:  pr:ecedence not allowed" or "error
get:anot allowed
get:aactive and :the foreign socket is unspecified, return "error
get:aforeign soc
get:aspecified, 
get:a(ISS) is se
get:ais sent.  S
get:astate, and 
get:aIf the call
get:areturn "err:or
get:ano room to :create a new connection, return "error
get:aresources".
get:aIf active a
get:aconnection 
get:asegment, se
get:astate.  Dat
get:aqueued for 
get:aurgent bit 
get:asegments se
get:aqueue the r:equest, respond with "error
get:aIf Foreign :socket was not specified, then return "error
get:asocket unsp
get:a[Page 54]        
get:aSeptember 1981   
get:aSYN-SENT STAT
get:aSYN-RECEIVED 
get:aESTABLISHED S
get:aFIN-WAIT-1 ST
get:aFIN-WAIT-2 ST
get:aCLOSE-WAIT ST
get:aCLOSING STATE
get:aLAST-ACK STAT
get:aTIME-WAIT STA
get:aReturn "err:or
get:aTransmission Cont
get:aFunctional Specif
get:aCLOSED STATE 
get:aIf the user
get:a"error:  co
get:aOtherwise, :return "error
get:aIf the fore
get:afrom passiv
get:aSND.UNA to 
get:aassociated 
get:atransmissio
get:arequested i
get:aas a result
get:arequest, re:spond with "error
get:aForeign soc:ket was not specified, then return "error
get:asocket unsp
get:aSYN-SENT STAT
get:aSYN-RECEIVED 
get:aQueue the d
get:aIf no space: to queue, respond with "error
get:aresources".
get:aESTABLISHED S
get:aCLOSE-WAIT ST
get:aSegmentize 
get:aacknowledgm
get:ainsufficien:t space to remember this buffer, simply return "error
get:ainsufficien
get:aIf the urge
get:aurgent poin
get:a[Page 56]        
get:aSeptember 1981   
get:aFIN-WAIT-1 ST
get:aFIN-WAIT-2 ST
get:aCLOSING STATE
get:aLAST-ACK STAT
get:aTIME-WAIT STA
get:aReturn "err:or
get:aTransmission Cont
get:aFunctional Specif
get:aCLOSED STATE 
get:aIf the user
get:a"error:  co
get:aOtherwise r:eturn "error
get:aSYN-SENT STAT
get:aSYN-RECEIVED 
get:aQueue for p
get:ais no room :to queue this request, respond with "error
get:ainsufficien
get:aESTABLISHED S
get:aFIN-WAIT-1 ST
get:aFIN-WAIT-2 ST
get:aIf insuffic
get:arequest, qu
get:aremember th:e RECEIVE, respond with "error
get:aresources".
get:aReassemble 
get:ato user.  M
get:aIf RCV.UP i
get:auser notify
get:aWhen the TC
get:athat fact m
get:aacknowledgm
get:adescribed b
get:a[Page 58]        
get:aSeptember 1981   
get:aCLOSE-WAIT ST
get:aSince the r
get:asatisfied b
get:auser.  If n
get:a"error:  co
get:atext can be
get:aCLOSING STATE
get:aLAST-ACK STAT
get:aTIME-WAIT STA
get:aReturn "err:or
get:aTransmission Cont
get:aFunctional Specif
get:aCLOSED STATE 
get:aIf the user
get:a"error:  co
get:aOtherwise, :return "error
get:aAny outstan:ding RECEIVEs are returned with "error
get:aresponses. 
get:aSYN-SENT STAT
get:aDelete the :TCB and return "error
get:aqueued SEND
get:aSYN-RECEIVED 
get:aIf no SENDs
get:athen form a
get:aotherwise q
get:aESTABLISHED S
get:aQueue this 
get:aform a FIN 
get:aFIN-WAIT-1 ST
get:aFIN-WAIT-2 ST
get:aStrictly sp:eaking, this is an error and should receive a "error
get:aconnection 
get:aacceptable,
get:aFIN may be 
get:a[Page 60]        
get:aSeptember 1981   
get:aCLOSE-WAIT ST
get:aQueue this 
get:asegmentized
get:aCLOSING STATE
get:aLAST-ACK STAT
get:aTIME-WAIT STA
get:aRespond wit:h "error
get:aTransmission Cont
get:aFunctional Specif
get:aCLOSED STATE 
get:aIf the user
get:a"error:  co
get:aOtherwise r:eturn "error
get:aAny outstan:ding RECEIVEs should be returned with "error
get:aconnection 
get:aSYN-SENT STAT
get:aAll queued 
get:anotificatio
get:aSYN-RECEIVED 
get:aESTABLISHED S
get:aFIN-WAIT-1 ST
get:aFIN-WAIT-2 ST
get:aCLOSE-WAIT ST
get:aSend a rese:t segment
get:a<SEQ=SND.
get:aAll queued 
get:anotificatio
get:aRST formed 
get:aTCB, enter 
get:aCLOSING STATE
get:aLAST-ACK STAT
get:aTIME-WAIT STA
get:aRespond wit
get:a[Page 62]        
get:aSeptember 1981   
get:aCLOSED STATE 
get:aIf the user
get:a"error:  co
get:aOtherwise r:eturn "error
get:aReturn "sta
get:aSYN-SENT STAT
get:aReturn "sta
get:aSYN-RECEIVED 
get:aReturn "sta
get:aESTABLISHED S
get:aReturn "sta
get:aFIN-WAIT-1 ST
get:aReturn "sta
get:aFIN-WAIT-2 ST
get:aReturn "sta
get:aCLOSE-WAIT ST
get:aReturn "sta
get:aCLOSING STATE
get:aReturn "sta
get:aLAST-ACK STAT
get:aReturn "sta
get:aTransmission Cont
get:aFunctional Specif
get:aTIME-WAIT STA
get:aReturn "sta
get:a[Page 64]        
get:aSeptember 1981   
get:aSEGMENT ARRIVES
get:aIf the state 
get:aall data in
get:asegment con
get:acontaining 
get:aacknowledgm
get:areset seque
get:aIf the ACK 
get:a<SEQ=0><A
get:aIf the ACK 
get:a<SEQ=SEG.
get:aIf the state 
get:afirst check
get:aAn incomi
get:asecond chec
get:aAny ackno
get:athe LISTE
get:afor any a
get:aformatted: as follows
get:a<SEQ=SE
get:athird check
get:aIf the SY
get:asecurity/
get:amatch the
get:a<SEQ=SE
get:aTransmission Cont
get:aFunctional Specif
get:aIf the SE
get:athe user 
get:asend a re
get:a<SEQ=SE
get:aIf the SE
get:aSet RCV.N
get:acontrol o
get:ashould be: selected and a SYN segment sent of the form
get:a<SEQ=IS
get:aSND.NXT i
get:astate sho
get:aincoming 
get:ain the SY
get:anot be re
get:athe forei
get:aunspecifi
get:afourth othe
get:aAny other
get:amust have
get:aprocessin
get:ait could 
get:aincarnati
get:abut if yo
get:aIf the state 
get:afirst check
get:aIf the AC
get:aIf SEG.
get:athe RST
get:a<SEQ=
get:aand dis
get:aIf SND.
get:asecond chec
get:a[Page 66]        
get:aSeptember 1981   
get:aIf the RS
get:aIf the :ACK was acceptable then signal the user "error
get:aconnect
get:adelete 
get:aand ret
get:athird check
get:aIf the se
get:amatch the
get:aIf ther
get:a<SEQ=
get:aOtherwi
get:a<SEQ=
get:aIf there 
get:aThe pre
get:aTCB, if
get:a<SEQ=
get:aIf there 
get:aIf the 
get:ain the 
get:athe pre
get:aallowed
get:a<SEQ=
get:aIf the 
get:ain the 
get:aIf a rese
get:afourth chec
get:aThis step
get:ano ACK, a
get:aIf the SY
get:aTransmission Cont
get:aFunctional Specif
get:aare accep
get:aSEG.SEQ. 
get:ais an ACK
get:aare there
get:aIf SND.UN
get:astate to 
get:a<SEQ=SN
get:aand send 
get:atransmiss
get:atext in t
get:abelow whe
get:aOtherwise
get:a<SEQ=IS
get:aand send 
get:asegment, 
get:ahas been 
get:afifth, if n
get:asegment and
get:a[Page 68]        
get:aSeptember 1981   
get:afirst check s
get:aSYN-RECEIVE
get:aESTABLISHED
get:aFIN-WAIT-1 
get:aFIN-WAIT-2 
get:aCLOSE-WAIT 
get:aCLOSING STA
get:aLAST-ACK ST
get:aTIME-WAIT S
get:aSegments 
get:aare used 
get:adone in S
get:aboundary 
get:aprocessed
get:aThere are
get:asegment
get:aSegment R
get:aLength  W
get:a------- -
get:a0     
get:a0     
get:a>0     
get:a>0     
get:aIf the RC
get:aspecial a
get:aIf an inc
get:ashould be
get:athe segme:nt and return)
get:a<SEQ=SN
get:aAfter sen
get:aand retur
get:aTransmission Cont
get:aFunctional Specif
get:aIn the fo
get:asegment t
get:aOne could
get:atrimming 
get:aSYN and F
get:abegins at
get:anumbers m
get:asecond check 
get:aSYN-RECEIVE
get:aIf the RS
get:aIf this
get:acame fr
get:aLISTEN 
get:athis co
get:afrom SY
get:athe use
get:aon the 
get:aactive 
get:aand ret
get:aESTABLISHED
get:aIf the RS
get:ashould re
get:aflushed. 
get:a"connecti
get:aTCB, and 
get:aCLOSING STA
get:aLAST-ACK ST
get:aIf the RS
get:aTCB, and 
get:a[Page 70]        
get:aSeptember 1981   
get:athird check s
get:aSYN-RECEIVE
get:aIf the se
get:aexactly m
get:athen send
get:aESTABLISHED
get:aIf the se
get:aexactly m
get:athen send
get:areceive "
get:aflushed. 
get:a"connecti
get:aTCB, and 
get:aNote this c
get:aa segment f
get:adifferent s
get:acurrent con
get:afourth, check
get:aSYN-RECEIVE
get:aESTABLISHED
get:aFIN-WAIT ST
get:aFIN-WAIT ST
get:aCLOSE-WAIT 
get:aCLOSING STA
get:aLAST-ACK ST
get:aTIME-WAIT S
get:aIf the SY
get:aoutstandi
get:aall segme
get:areceive a
get:athe CLOSE
get:aIf the SY
get:aand an ac
get:anumber ch
get:aTransmission Cont
get:aFunctional Specif
get:afifth check t
get:aif the ACK 
get:aif the ACK 
get:aSYN-RECEI
get:aIf SND.
get:aand con
get:aIf th
get:areset
get:a<SE
get:aand s
get:aESTABLISH
get:aIf SND.
get:aAny seg
get:aentirel
get:apositiv
get:afully a
get:a"ok" re
get:a(SEG.AC
get:asomethi
get:adrop th
get:aIf SND.
get:aupdated
get:aSND.WL2
get:aSND.WL1
get:aNote th
get:arecords
get:aSND.WND
get:athe las
get:aprevent
get:a[Page 72]        
get:aSeptember 1981   
get:aFIN-WAIT-
get:aIn addi
get:aour FIN
get:aprocess
get:aFIN-WAIT-
get:aIn addi
get:athe ret
get:aacknowl
get:aCLOSE-WAI
get:aDo the 
get:aCLOSING S
get:aIn addi
get:athe ACK
get:aotherwi
get:aLAST-ACK 
get:aThe onl
get:aacknowl
get:adelete 
get:aTIME-WAIT
get:aThe onl
get:aretrans
get:athe 2 M
get:asixth, check 
get:aESTABLISHED
get:aFIN-WAIT-1 
get:aFIN-WAIT-2 
get:aIf the UR
get:athe user 
get:apointer (
get:auser has 
get:amode") fo
get:asignal th
get:aTransmission Cont
get:aFunctional Specif
get:aCLOSE-WAIT 
get:aCLOSING STA
get:aLAST-ACK ST
get:aThis shou
get:aremote si
get:aseventh, proc
get:aESTABLISHED
get:aFIN-WAIT-1 
get:aFIN-WAIT-2 
get:aOnce in t
get:atext to u
get:ainto buff
get:aempty.  I
get:athe user 
get:ahas been 
get:aWhen the 
get:auser it m
get:aOnce the 
get:aRCV.NXT o
get:aapporopri
get:aRCV.NXT a
get:aPlease no
get:aSend an a:cknowledgment of the form
get:a<SEQ=SN
get:aThis ackn
get:atransmitt
get:a[Page 74]        
get:aSeptember 1981   
get:aCLOSE-WAIT 
get:aCLOSING STA
get:aLAST-ACK ST
get:aTIME-WAIT S
get:aThis shou
get:aremote si
get:aeighth, check
get:aDo not proc
get:asince the S
get:aIf the FIN 
get:areturn any 
get:aover the FI
get:aFIN implies
get:aSYN-RECEI
get:aESTABLISH
get:aEnter t
get:aFIN-WAIT-
get:aIf our 
get:aenter T
get:atimers;
get:aFIN-WAIT-
get:aEnter t
get:aoff the
get:aCLOSE-WAI
get:aRemain 
get:aCLOSING S
get:aRemain 
get:aLAST-ACK 
get:aRemain 
get:aTransmission Cont
get:aFunctional Specif
get:aTIME-WAIT
get:aRemain 
get:atimeout
get:a[Page 76]        
get:aSeptember 1981   
get:aFor any state
get:athe user "err:or
get:aand for any o
get:astate and ret
get:aRETRANSMISSION 
get:aFor any state
get:athe retransmi
get:aretransmissio
get:aTIME-WAIT TIMEO
get:aIf the time-w
get:aenter the CLO
get:aTransmission Cont
get:a[Page 78]        
get:aSeptember 1981   
get:aBBN Rep
get:aa Host 
get:ahost an
get:aA contr
get:aindicat
get:aspecifi
get:ais expe
get:apreviou
get:aThe uni
get:aARPANET
get:aA unit 
get:aIMPs.  
get:aA logic
get:aA messa
get:anetwork
get:aDestination Addre
get:aThe des
get:aidentif
get:aA contr
get:aindicat
get:aoccupyi
get:aA porti
get:afragmen
get:aA file 
get:aTransmission Cont
get:aControl
get:afragmen
get:aA compu
get:afrom th
get:aAn Inte
get:aby the 
get:aThe Int
get:aARPANET
get:aA sourc
get:ainternet datagram
get:aThe uni
get:ahigher 
get:ainternet fragment
get:aA porti
get:aheader.
get:aInterne
get:aThe Ini
get:anumber 
get:aThe Ini
get:aon a co
get:abased p
get:aThe Ini
get:aused by
get:aControl
get:adata.  
get:aon an A
get:a[Page 80]        
get:aSeptember 1981   
get:aThis is
get:adata re
get:asequenc
get:aof the 
get:aThe uni
get:aAn impl
get:aprocedu
get:aMaximum
get:athe int
get:aAn eigh
get:aAn Opti
get:amay be 
get:aprimari
get:atimesta
get:aoptions
get:aA packa
get:alogical
get:alogical
get:aThe por
get:aoutput 
get:aA progr
get:athe poi
get:aA contr
get:athis se
get:areceivi
get:areceive
get:aTransmission Cont
get:areceive
get:areceive
get:areceive next sequ
get:aThis is
get:areceive
get:aThis re
get:ais will
get:asegment
get:aRCV.NXT
get:aSegment
get:arange a
get:aA contr
get:athat th
get:ainterac
get:asequenc
get:asegment
get:ait.  In
get:arise to
get:aReal Ti:me Protocol
get:aof time
get:asegment
get:asegment
get:asegment
get:asegment
get:asegment
get:a[Page 82]        
get:aSeptember 1981   
get:asegment
get:aA logic
get:aunit of
get:asegment acknowled
get:aThe seq
get:aarrivin
get:aThe amo
get:aincludi
get:aThe num
get:aThis is
get:ause on 
get:ainitial
get:aeach oc
get:aThis re
get:a(receiv
get:awindow 
get:areceivi
get:abe emit
get:aSND.UNA
get:abetween
get:asend se
get:aleft se
get:asend ur
get:asegment
get:asegment
get:aTransmission Cont
get:asend wi
get:aAn addr
get:ais, the
get:aThe sou
get:aA contr
get:anumber,
get:awhere t
get:aTransmi
get:athe sta
get:aThe pre
get:aTransmi:ssion Control Protocol
get:areliabl
get:aType of
get:aAn Inte
get:afor thi
get:aA contr
get:aindicat
get:aurgent 
get:asequenc
get:apointer
get:aA contr
get:afield c
get:aindicat
get:aurgent 
get:a[Page 84]        
get:aSeptember 1981   
get:a[1]  Cerf, V., an
get:aIntercommuni
get:aVol. COM-22,
get:a[2]  Postel, J. (
get:aProtocol Spe
get:aInstitute, S
get:a[3]  Dalal, Y. an
get:aProtocols", 
get:aDecember 197
get:a[4]  Postel, J., 
get:aInstitute, S
get:bRFC
get:bDe
get:bI
get:bSeptember 1981   
get:bPREFACE .....
get:b1.  INTRODUCTION 
get:b1.1  Motivation
get:b1.2  Scope ....
get:b1.3  About This
get:b1.4  Interfaces
get:b1.5  Operation 
get:b2.  PHILOSOPHY ..
get:b2.1  Elements o
get:b2.2  Model of O
get:b2.3  The Host E
get:b2.4  Interfaces
get:b2.5  Relation t
get:b2.6  Reliable C
get:b2.7  Connection
get:b2.8  Data Commu
get:b2.9  Precedence
get:b2.10 Robustness
get:b3.  FUNCTIONAL SP
get:b3.1  Header For
get:b3.2  Terminolog
get:b3.3  Sequence N
get:b3.4  Establishi
get:b3.5  Closing a 
get:b3.6  Precedence
get:b3.7  Data Commu
get:b3.8  Interfaces
get:b3.9  Event Proc
get:bGLOSSARY ........
get:bREFERENCES ......
get:bTransmission Cont
get:b[Page ii]        
get:bSeptember 1981   
get:bThis document des
get:b(TCP).  There hav
get:bspecification on 
get:bdraws heavily fro
get:bboth in terms of 
get:bseveral details a
get:band redescribes t
get:bRFC
get:bReplaces: RFC 761
get:bIENs:  129, 124, 
get:b55, 44, 40, 27, 2
get:bThe Transmission 
get:breliable host-to-
get:bcommunication net
get:bThis document des
get:bTransmission Cont
get:binterface to prog
get:bComputer commun
get:brole in militar
get:bdocument focuse
get:bcommunication r
get:bcommunication u
get:bcongestion, but
get:bgovernment sect
get:bAs strategic an
get:bdeveloped and d
get:binterconnecting
get:bcommunication p
get:bapplications.  
get:bDeputy Undersec
get:bdeclared the Tr
get:bbe a basis for 
get:bstandardization
get:bTCP is a connec
get:bfit into a laye
get:bapplications.  
get:bcommunication b
get:bdistinct but in
get:bassumptions are
get:bprotocols below
get:bpotentially unr
get:bprotocols.  In 
get:bwide spectrum o
get:bconnections to 
get:bTransmission Cont
get:bTCP is based on
get:bTCP fits into a
get:bInternet Protoc
get:breceive variabl
get:bdatagram "envel
get:baddressing sour
get:binternet protoc
get:bthe TCP segment
get:bmultiple networ
get:balso carries in
get:band compartment
get:bcommunicated en
get:bMuch of this do
get:bwhich are co-re
get:bcomputer.  Some
get:bfront-end compu
get:bas well as netw
get:ban interface to
get:bimplementable e
get:bhost-to-front e
get:bThe TCP is inte
get:bcommunication s
get:bintended to be 
get:b1.3.  About this 
get:bThis document r
get:bany TCP impleme
get:bprotocols and i
get:b[Page 2]         
get:bSeptember 1981   
get:bsection offers 
get:boperation.  Sec
get:bdesign.  Sectio
get:brequired of TCP
get:buser calls, err
get:bThe TCP interfa
get:bthe other side 
get:bThe interface b
get:billustrated in 
get:bcalls much like
get:bapplication pro
get:bcalls to open a
get:bestablished con
get:basynchronously 
get:bconsiderable fr
get:binterfaces whic
get:benvironment, a 
get:binterface for a
get:bThe interface b
get:bunspecified exc
get:btwo levels can 
get:bTypically, one 
get:binterface.  TCP
get:binterconnected 
get:bthroughout this
get:bAs noted above,
get:bsecurable logic
get:bprocesses.  To 
get:bcommunication s:ystem requires facilities in the following areas
get:bBasic Data Tr
get:bPrecedence an
get:bThe basic opera
get:bthe following p
get:bTransmission Cont
get:bBasic Data Tran:sfer
get:bThe TCP is ab
get:bdirection bet
get:bsegments for 
get:bthe TCPs deci
get:bSometimes use
get:bsubmitted to 
get:bfunction is d
get:bactually tran
get:bpushed throug
get:bpromptly forw
get:bThe exact pus
get:bthe push func
get:bReliability
get:bThe TCP must 
get:bdelivered out
get:bis achieved b
get:btransmitted, 
get:breceiving TCP
get:binterval, the
get:bnumbers are u
get:bout of order 
get:badding a chec
get:breceiver, and
get:bAs long as th
get:bsystem does n
get:berrors will a
get:binternet comm
get:bFlow Control
get:bTCP provides 
get:bsent by the s
get:bevery ACK ind
get:bthe last segm
get:ballowed numbe
get:breceiving fur
get:b[Page 4]         
get:bSeptember 1981   
get:bMultiplexing
get:bTo allow for 
get:bcommunication
get:baddresses or 
get:band host addr
get:ba socket.  A 
get:bThat is, a so
get:bThe binding o
get:bHost.  Howeve
get:b(e.g., a "log
get:bmade known to
get:bthrough the k
get:baddresses of 
get:bConnections
get:bThe reliabili
get:bthat TCPs ini
get:beach data str
get:bsockets, sequ
get:bEach connecti
get:bidentifying i
get:bWhen two proc
get:bestablish a c
get:bside).  When 
get:bterminated or
get:bSince connect
get:bover the unre
get:bmechanism wit
get:berroneous ini
get:bPrecedence and :Security
get:bThe users of 
get:bcommunication
get:bthese feature
get:bTransmission Cont
get:b[Page 6]         
get:bSeptember 1981   
get:b2.1.  Elements of
get:bThe internetwor
get:bwhich are in tu
get:bthat the networ
get:blarge networks 
get:bpacket switchin
get:bconsume message
get:bnetworks, the g
get:bcommunication s
get:bconnections bet
get:bThe term packet
get:btransaction bet
get:bexchanged withi
get:bHosts are compu
get:bnetwork's point
get:bProcesses are v
get:baccordance with
get:bin execution). 
get:bviewed as commu
get:bThus, all commu
get:bSince a process
get:bstreams between
get:bthat each proce
get:bcommunicates wi
get:b2.2.  Model of Op
get:bProcesses trans
get:bdata as argumen
get:bsegments and ca
get:bthe destination
get:binto the receiv
get:bTCPs include co
get:bensure reliable
get:bThe model of in
get:bprotocol module
get:bto the local ne
get:binside internet
get:binternet module
get:bthrough the loc
get:bThe packet swit
get:bTransmission Cont
get:bother operation
get:bdestination int
get:bAt a gateway be
get:bfrom its local 
get:bthe internet da
get:bthen "wrapped" 
get:brouted to the n
get:bA gateway is pe
get:binternet datagr
get:bthrough the nex
get:binternet datagr
get:bfurther broken 
get:binternet datagr
get:binternet module
get:bA destination i
get:b(after reassemb
get:bdestination TCP
get:bThis simple mod
get:bimportant featu
get:bto the gateway 
get:bservice paramet
get:bIncluded in the
get:bdatagram.  Data
get:bhost and gatewa
get:bproperly segreg
get:b2.3.  The Host En
get:bThe TCP is assu
get:baccess the TCP 
get:bmay call on oth
get:bdata structures
get:bcontrolled by a
get:bnetwork device 
get:bdatagram protoc
get:bThe mechanisms 
get:bfront-end proce
get:bhost-to-front-e
get:bthe type of TCP
get:b[Page 8]         
get:bSeptember 1981   
get:bThe TCP/user in
get:bto OPEN or CLOS
get:bSTATUS about a 
get:bprograms on the
get:bfrom, and close
get:bThe TCP/interne
get:bdatagrams addre
get:bsystem.  These 
get:bservice, preced
get:b2.5.  Relation to
get:bThe following d
get:bhierarchy
get:b+------+ +
get:b|Telnet| |
get:b+------+ +
get:b|   
get:b+----
get:b| TCP
get:b+----
get:b| 
get:b+----
get:b|    
get:b+----
get:b+--
get:b|  
get:b+--
get:bIt is expected 
get:bprotocols effic
get:bprotocols like 
get:b2.6.  Reliable Co
get:bA stream of dat
get:border at the de
get:bTransmission Cont
get:bTransmission is
get:backnowledgments
get:bsequence number
get:bsegment is tran
get:bsequence number
get:bis the sequence
get:btransmissions i
get:bsegment contain
get:bstarts a timer;
get:bsegment is dele
get:breceived before
get:bAn acknowledgme
get:bdelivered to th
get:bthe responsibil
get:bTo govern the f
get:bemployed.  The 
get:bThis window spe
get:backnowledgment 
get:b2.7.  Connection 
get:bTo identify the
get:bprovides a port
get:bindependently b
get:bunique addresse
get:bidentifying the
get:bwill be unique 
get:bA connection is
get:blocal socket ma
get:bsockets.  A con
get:bthat is, it is 
get:bTCPs are free t
get:bHowever, severa
get:bThere must be w
get:bthe "appropriat
get:bmay "own" ports
get:bthe ports they 
get:bissue, but we e
get:buniquely alloca
get:bassociating the
get:bA connection is
get:bforeign socket 
get:b[Page 10]        
get:bSeptember 1981   
get:bconnection name
get:bsubsequent call
get:babout a connect
get:bis a data struc
get:bimplementation 
get:bpointer to the 
get:bwhether the con
get:bbe passively wa
get:bA passive OPEN 
get:bconnection requ
get:bOften the proce
get:brequest from an
get:bis used to deno
get:bare allowed onl
get:bA service proce
get:bprocesses would
get:bforeign socket.
get:brequested a con
get:blocal socket we
get:bWell-known sock
get:ba socket addres
get:b"Telnet-Server"
get:bsocket, and oth
get:bEntry, Text Gen
get:bbeing for test 
get:baccess to a "Lo
get:bat which a newl
get:bwell-known sock
get:bof sockets to s
get:bProcesses can i
get:bfrom other proc
get:bbeen establishe
get:bother at the sa
get:bis critical for
get:bcomponents act 
get:bThere are two p
get:bpassive OPENs a
get:blocal passive O
get:bcase, the match
get:bOPENs has left 
get:bforeign socket 
get:bOther possibili
get:bTransmission Cont
get:bIf there are se
get:bsame local sock
get:bwith the specif
get:bTCB exists, bef
get:bThe procedures 
get:bcontrol flag an
get:bexchange has be
get:bA connection is
get:bcontaining a SY
get:bcommand.  The m
get:bconnection has 
get:bwhen sequence n
get:bThe clearing of
get:bin this case ca
get:b2.8.  Data Commun
get:bThe data that f
get:boctets.  The se
get:bin that call (a
get:bthrough to the 
get:bA sending TCP i
get:bsend that data 
get:bfunction is sig
get:breceiving TCP s
get:bthe sending TCP
get:bThere is no nec
get:bboundaries.  Th
get:bsingle SEND cal
get:bThe purpose of 
get:bfrom the sendin
get:brecord service.
get:bThere is a coup
get:bof data that cr
get:bassociated with
get:bbuffer is retur
get:bnot filled.  If
get:bPUSH is seen, t
get:bTCP also provid
get:bat some point f
get:b[Page 12]        
get:bSeptember 1981   
get:bcurrently readi
get:bdefine what the
get:burgent data, bu
get:btake action to 
get:b2.9.  Precedence 
get:bThe TCP makes u
get:bsecurity option
get:bbasis to TCP us
get:ba multilevel se
get:buse only, and o
get:bcompartment.  C
get:busers may be li
get:bTCP modules whi
get:bproperly mark o
get:bprecedence.  Su
get:bhigher level pr
get:bthem to specify
get:bprecedence of c
get:b2.10.  Robustness
get:bTCP implementat:ions will follow a general principle of robustness
get:bconservative in
get:bTransmission Cont
get:b[Page 14]        
get:bSeptember 1981   
get:b3.1.  Header Form
get:bTCP segments ar
get:bheader carries 
get:bdestination hos
get:bheader, supplyi
get:bdivision allows
get:bTCP Header Form
get:b0            
get:b0 1 2 3 4 5 6
get:b+-+-+-+-+-+-+-
get:b|          Sou
get:b+-+-+-+-+-+-+-
get:b|             
get:b+-+-+-+-+-+-+-
get:b|             
get:b+-+-+-+-+-+-+-
get:b|  Data |     
get:b| Offset| Rese
get:b|       |     
get:b+-+-+-+-+-+-+-
get:b|           Ch
get:b+-+-+-+-+-+-+-
get:b|             
get:b+-+-+-+-+-+-+-
get:b|             
get:b+-+-+-+-+-+-+-
get:bNote th
get:bSource Port:  1
get:bThe source po
get:bDestination Por:t
get:bThe destinati
get:bTransmission Cont
get:bFunctional Specif
get:bSequence Number:
get:bThe sequence 
get:bwhen SYN is p
get:binitial seque
get:bAcknowledgment :Number
get:bIf the ACK co
get:bnext sequence
get:breceive.  Onc
get:bData Offset:  4
get:bThe number of
get:bthe data begi
get:bintegral numb
get:bReserved:  6 bi
get:bReserved for 
get:bControl Bits:  :6 bits (from left to right)
get:bURG:  Urgent 
get:bACK:  Acknowl
get:bPSH:  Push Fu
get:bRST:  Reset t
get:bSYN:  Synchro
get:bFIN:  No more
get:bWindow:  16 bit
get:bThe number of
get:backnowledgmen
get:bChecksum:  16 b
get:bThe checksum 
get:bcomplement su
get:bsegment conta
get:bchecksummed, 
get:bform a 16 bit
get:btransmitted a
get:bthe checksum 
get:bThe checksum 
get:b[Page 16]        
get:bSeptember 1981   
get:bprefixed to t
get:bAddress, the 
get:bThis gives th
get:binformation i
get:bacross the TC
get:bcalls by the 
get:bThe TCP Len
get:boctets (thi
get:bcomputed), 
get:bUrgent Pointer:
get:bThis field co
get:bpositive offs
get:burgent pointe
get:bthe urgent da
get:bthe URG contr
get:bOptions:  varia
get:bOptions may o
get:bmultiple of 8
get:bchecksum.  An
get:bcases for the: format of an option
get:bCase 1:  A 
get:bCase 2:  An
get:bth
get:bThe option-le
get:boption-length
get:bNote that the
get:bfield might i
get:bEnd-of-Option
get:bA TCP must im
get:bTransmission Cont
get:bFunctional Specif
get:bCurrently def:ined options include (kind indicated in octal)
get:bKind     Le
get:b----     --
get:b0         
get:b1         
get:b2         
get:bSpecific Opti
get:bEnd of Opti
get:b+--------
get:b|00000000
get:b+--------
get:bThis opti
get:bmight not
get:bthe Data 
get:bnot the e
get:bthe optio
get:bNo-Operatio
get:b+--------
get:b|00000001
get:b+--------
get:bThis opti
get:balign the
get:bThere is 
get:breceivers
get:bnot begin
get:bMaximum Seg
get:b+--------
get:b|00000010
get:b+--------
get:bKind=2  
get:b[Page 18]        
get:bSeptember 1981   
get:bMaximum S:egment Size Option Data
get:bIf this
get:breceive
get:bThis fi
get:b(i.e., 
get:boption 
get:bPadding:  varia
get:bThe TCP heade
get:band data begi
get:b3.2.  Terminology
get:bBefore we can d
get:bto introduce so
get:bconnection requ
get:bof these variab
get:bTransmission Co
get:bTCB are the loc
get:bprecedence of t
get:bbuffers, pointe
get:bIn addition sev
get:bsequence number
get:bSend Sequence
get:bSND.UNA - s
get:bSND.NXT - s
get:bSND.WND - s
get:bSND.UP  - s
get:bSND.WL1 - s
get:bSND.WL2 - s
get:bu
get:bISS     - i
get:bReceive Seque
get:bRCV.NXT - r
get:bRCV.WND - r
get:bRCV.UP  - r
get:bIRS     - i
get:bTransmission Cont
get:bFunctional Specif
get:bThe following d
get:bthe sequence sp
get:bSend Sequence S
get:b---
get:b1 - old s
get:b2 - seque
get:b3 - seque
get:b4 - futur
get:bThe send window
get:bReceive Sequenc
get:b1 - old s
get:b2 - seque
get:b3 - futur
get:bThe receive win
get:bThere are also 
get:btake their valu
get:b[Page 20]        
get:bSeptember 1981   
get:bCurrent Segme
get:bSEG.SEQ - s
get:bSEG.ACK - s
get:bSEG.LEN - s
get:bSEG.WND - s
get:bSEG.UP  - s
get:bSEG.PRC - s
get:bA connection pr
get:blifetime.  The :states are
get:bESTABLISHED, FI
get:bTIME-WAIT, and 
get:bbecause it repr
get:bno connection. : Briefly the meanings of the states are
get:bLISTEN - repr
get:bTCP and port.
get:bSYN-SENT - re
get:bafter having 
get:bSYN-RECEIVED 
get:brequest ackno
get:bconnection re
get:bESTABLISHED -
get:bdelivered to 
get:bof the connec
get:bFIN-WAIT-1 - 
get:bfrom the remo
get:btermination r
get:bFIN-WAIT-2 - 
get:bfrom the remo
get:bCLOSE-WAIT - 
get:bfrom the loca
get:bCLOSING - rep
get:backnowledgmen
get:bLAST-ACK - re
get:bconnection te
get:b(which includ
get:bTransmission Cont
get:bFunctional Specif
get:bTIME-WAIT - r
get:bthe remote TC
get:btermination r
get:bCLOSED - repr
get:bA TCP connectio
get:bevents.  The ev
get:bABORT, and STAT
get:bcontaining the 
get:bThe state diagr
get:bwith the causin
get:berror condition
get:bchanges.  In a 
get:bthe reaction of
get:bNOTE BENE:  thi
get:bthe total speci
get:b[Page 22]        
get:bSeptember 1981   
get:b+---------+     
get:b|         |<----
get:b|   SYN   |     
get:b|   RCVD  |<----
get:b|         |     
get:b|         |-----
get:b+---------+   rc
get:b|           --
get:b|             
get:b|             
get:b|  CLOSE      
get:b| -------     
get:b| snd FIN     
get:b|             
get:bV             
get:b+---------+     
get:b|  FIN    |<----
get:b| WAIT-1  |-----
get:b+---------+     
get:b| rcv ACK of F
get:b| ------------
get:bV        x    
get:b+---------+     
get:b|FINWAIT-2|     
get:b+---------+     
get:b|             
get:b|  rcv FIN    
get:b|  -------    
get:b\ snd ACK    
get:b------------
get:bTransmission Cont
get:bFunctional Specif
get:b3.3.  Sequence Nu
get:bA fundamental n
get:bover a TCP conn
get:bsequenced, each
get:bmechanism emplo
get:bnumber X indica
get:breceived.  This
get:bdetection in th
get:bwithin a segmen
get:bthe header is t
get:bnumbered consec
get:bIt is essential
get:bfinite, though 
get:bSince the space
get:bnumbers must be
get:bpreserves the r
get:b2**32 - 1 to 0 
get:barithmetic, so 
get:bcomparison of s
get:b(modulo 2**32).
get:bThe typical kin
get:bperform include:
get:b(a)  Determin
get:bnumber s
get:b(b)  Determin
get:bhave bee
get:bretransm
get:b(c)  Determin
get:bwhich ar
get:breceive 
get:b[Page 24]        
get:bSeptember 1981   
get:bIn response to 
get:bfollowing compa
get:bSND.UNA = old
get:bSND.NXT = nex
get:bSEG.ACK = ack
get:bnum
get:bSEG.SEQ = fir
get:bSEG.LEN = the
get:b(co
get:bSEG.SEQ+SEG.L
get:bA new acknowled
get:bthe inequality :below holds
get:bSND.UNA < SEG
get:bA segment on th
get:bof its sequence
get:backnowledgment 
get:bWhen data is re:ceived the following comparisons are needed
get:bRCV.NXT = nex
get:bis the le
get:bRCV.NXT+RCV.W
get:bsegment, 
get:bSEG.SEQ = fir
get:bSEG.SEQ+SEG.L
get:bA segment is ju
get:bRCV.NXT =< SE
get:bRCV.NXT =< SE
get:bTransmission Cont
get:bFunctional Specif
get:bThe first part 
get:bsegment falls i
get:bif the end of t
get:beither part of 
get:bActually, it is
get:bwindows and zer
get:bacceptability o:f an incoming segment
get:bSegment Recei
get:bLength  Windo
get:b------- -----
get:b0       0 
get:b0      >0 
get:b>0       0 
get:b>0      >0 
get:bNote that when 
get:bacceptable exce
get:bmaintain a zero
get:bACKs.  However,
get:bprocess the RST
get:bWe have taken a
get:bcontrol informa
get:bsome control fl
get:band acknowledge
get:bcontrol will be
get:bcarried in the 
get:bfor implicitly 
get:bare the only co
get:bare used only a
get:bpurposes, the S
get:boctet of the se
get:bto occur after 
get:boccurs.  The se
get:bspace occupying
get:bsequence number
get:b[Page 26]        
get:bSeptember 1981   
get:bInitial Sequenc
get:bThe protocol pl
get:bused over and o
get:bsockets.  New i
get:bincarnations of
get:b-- "how does th
get:bincarnations of
get:bconnection is b
get:bconnection brea
get:bTo avoid confus
get:bconnection from
get:bbe present in t
get:bassure this, ev
get:bsequence number
get:ban initial sequ
get:bnew 32 bit ISN.
get:bbit clock whose
get:bmicroseconds.  
get:bSince we assume
get:bthe Maximum Seg
get:bhours we can re
get:bFor each connec
get:bsequence number
get:bthe data sendin
get:blearned during 
get:bFor a connectio
get:bsynchronize on 
get:ban exchange of 
get:bcalled "SYN" (f
get:bshorthand, segm
get:bHence, the solu
get:binitial sequenc
get:bThe synchroniza
get:bsequence number
get:bfrom the other 
get:binitial sequenc
get:b1) A --> B  S
get:b2) A <-- B  A
get:b3) A <-- B  S
get:b4) A --> B  A
get:bTransmission Cont
get:bFunctional Specif
get:bBecause steps 2
get:bcalled the thre
get:bA three way han
get:btied to a globa
get:bmechanisms for 
get:bno way of knowi
get:bunless it remem
get:b(which is not a
get:bverify this SYN
get:bclock-driven sc
get:bKnowing When to
get:bTo be sure that
get:bsequence number
get:bthe network, th
get:b(MSL) before as
get:brecovering from
get:blost.  For this
get:bis an engineeri
get:bit is desirable
get:bsense, yet reta
get:bnot wait at all
get:bthan those rece
get:bThe TCP Quiet T
get:bThis specific
get:bretaining any
get:beach active (
get:bTCP segments 
get:bin the intern
get:bparagraphs be
get:bTCP implement
get:bat the risk o
get:bdata rejected
get:bTCPs consume 
get:bentered into 
get:bduplicate det
get:brelies on the
get:bthe extent th
get:bvalues before
get:bbeen delivere
get:bcopies of the
get:bsuch an assum
get:b[Page 28]        
get:bSeptember 1981   
get:bassigned the 
get:bat the receiv
get:bthat each seg
get:bas there are 
get:bUnder normal 
get:bto emit and t
get:bmistakenly us
get:bbeen acknowle
get:bdata is drain
get:bvery large to
get:bcause trouble
get:bto use up 2**
get:blifetime in t
get:bthis is deeme
get:brates escalat
get:bcycle time is
get:bwithin reason
get:bThe basic dup
get:bdefeated, how
get:bsequence numb
get:bthe TCP were 
get:bupon crashing
get:bconnection (p
get:bpackets with 
get:bpackets still
get:bincarnation o
get:babout the seq
get:bspecification
get:bbefore emitti
get:bsegments from
get:bEven hosts wh
get:binitial seque
get:b(i.e., even i
get:bnumber for ea
get:bSuppose, for 
get:bsequence numb
get:band that even
get:btakes on a va
get:bsegment sent 
get:bat this insta
get:bincarnation o
get:bS1 = ISN(t) -
get:bconnection!  
get:bTransmission Cont
get:bFunctional Specif
get:bduplicates in
get:bof S1 may arr
get:bthe new incar
get:bThe problem i
get:bcrashed nor d
get:bthe system fr
get:bOne way to de
get:bsegments for 
get:btime" specifi
get:bwilling to ri
get:bdestination m
get:bImplementors 
get:bconnection by
get:binformally im
get:bObviously, ev
get:bnecessary aft
get:bTo summarize:
get:bnumbers in th
get:b"busy" or "in
get:bblock of spac
get:bsegment, if a
get:bsequence numb
get:bthe previous 
get:bnumber overla
get:b3.4.  Establishin
get:bThe "three-way 
get:bconnection.  Th
get:bresponded to by
get:bsimultaneously 
get:boccurs, each TC
get:backnowledgment 
get:ban old duplicat
get:brecipient, that
get:bProper use of "
get:bSeveral example
get:bexamples do not
get:bsegments, this 
get:bdoesn't deliver
get:bvalid (i.e., th
get:bconnection reac
get:breduces the pos
get:b[Page 30]        
get:bSeptember 1981   
get:bimplementation 
get:binformation for
get:bThe simplest th
get:bfigures should 
get:bnumbered for re
get:bdeparture of a 
get:bsegment at B fr
get:bEllipsis (...) 
get:b(delayed).  An 
get:bComments appear
get:bthe departure o
get:bthe center of e
get:bform, with sequ
get:bfields such as 
get:bin the interest
get:bTCP A      
get:b1.  CLOSED     
get:b2.  SYN-SENT   
get:b3.  ESTABLISHED
get:b4.  ESTABLISHED
get:b5.  ESTABLISHED
get:bBasic 3
get:bIn line 2 of fi
get:bindicating that
get:bnumber 100.  In
get:breceived from T
get:bB is now expect
get:boccupied sequen
get:bAt line 4, TCP 
get:bTCP B's SYN; an
get:bsequence number
get:bbecause the ACK
get:bwould wind up A
get:bTransmission Cont
get:bFunctional Specif
get:bSimultaneous in
get:bfigure 8.  Each
get:bTCP A      
get:b1.  CLOSED     
get:b2.  SYN-SENT   
get:b3.  SYN-RECEIVE
get:b4.             
get:b5.  SYN-RECEIVE
get:b6.  ESTABLISHED
get:b7.             
get:bS
get:bThe principle r
get:bduplicate conne
get:bthis, a special
get:breceiving TCP i
get:bSYN-RECEIVED), 
get:bIf the TCP is i
get:bFIN-WAIT-1, FIN
get:baborts the conn
get:bcase under "hal
get:b[Page 32]        
get:bSeptember 1981   
get:bTCP A      
get:b1.  CLOSED     
get:b2.  SYN-SENT   
get:b3.  (duplicate)
get:b4.  SYN-SENT   
get:b5.  SYN-SENT   
get:b6.             
get:b7.  SYN-SENT   
get:b8.  ESTABLISHED
get:bAs a simple exa
get:bfigure 9.  At l
get:bcannot tell tha
get:b(line 4).  TCP 
get:bRST (reset) wit
get:bbelievable.  TC
get:bWhen the origin
get:bsynchronization
get:bbefore the RST,
get:bsent in both di
get:bHalf-Open Conne
get:bAn established 
get:bTCPs has closed
get:bknowledge of th
get:bbecome desynchr
get:bmemory.  Such c
get:battempt is made
get:bconnections are
get:bmildly involved
get:bIf at site A th
get:bTransmission Cont
get:bFunctional Specif
get:buser at site B 
get:breceiving a res
get:bsite B TCP that
get:bAssume that two
get:banother when a 
get:bDepending on th
get:bthat some error
get:bA is likely to 
get:bpoint.  As a re
get:bor try to SEND 
get:bcase, it receiv
get:blocal (A's) TCP
get:bwill send a seg
get:bexample shown i
get:bre-open the con
get:bTCP A      
get:b1.  (CRASH)    
get:b2.  CLOSED     
get:b3.  SYN-SENT --
get:b4.  (!!)     <-
get:b5.  SYN-SENT --
get:b6.  SYN-SENT   
get:b7.  SYN-SENT --
get:bWhen the SYN ar
get:band the incomin
get:backnowledgment 
get:b100).  TCP A se
get:bsent and, being
get:bdetected a half
get:b[Page 34]        
get:bSeptember 1981   
get:bcontinue to try
get:breduced to the 
get:bAn interesting 
get:btries to send d
get:bThis is illustr
get:bTCP A from TCP 
get:bexists, so TCP 
get:bprocesses it an
get:bTCP A    
get:b1.  (CRASH)    
get:b2.  (??)    <--
get:b3.          -->
get:bActive
get:bIn figure 12, w
get:bwaiting for SYN
get:binto action.  A
get:bgenerate a RST 
get:bthe reset and r
get:bTCP A      
get:b1.  LISTEN     
get:b2.       ... <S
get:b3.  (??) <-- <S
get:b4.       --> <S
get:b5.  LISTEN     
get:bOld Duplic
get:bTransmission Cont
get:bFunctional Specif
get:bA variety of ot
get:bby the followin
get:bReset Generatio
get:bAs a general ru
get:bwhich apparentl
get:bmust not be sen
get:bThere are three: groups of states
get:b1.  If the co
get:bin response t
get:bparticular, S
get:bby this means
get:bIf the incomi
get:bsequence numb
get:breset has seq
get:bof the sequen
get:bThe connectio
get:b2.  If the co
get:bSYN-SENT, SYN
get:bsomething not
get:bif an incomin
get:bdoes not exac
get:bconnection, a
get:bIf our SYN ha
get:bincoming segm
get:beither raise 
get:bthe system) o
get:bincoming segm
get:bcontinue as i
get:bcannot raise 
get:bdetected in t
get:bterminated th
get:bincoming segm
get:bmatch the loc
get:bmust be sent.
get:bIf the incomi
get:bsequence numb
get:breset has seq
get:bof the sequen
get:bThe connectio
get:b[Page 36]        
get:bSeptember 1981   
get:b3.  If the co
get:bFIN-WAIT-1, F
get:bany unaccepta
get:bunacceptible 
get:backnowledgmen
get:band an acknow
get:bto be receive
get:bIf an incomin
get:bprecedence wh
get:band precedenc
get:bconnection go
get:bnumber from t
get:bReset Processin
get:bIn all states e
get:bby checking the
get:bis in the windo
get:bto an initial S
get:backnowledges th
get:bThe receiver of
get:breceiver was in
get:bin SYN-RECEIVED
get:bthen the receiv
get:baborts the conn
get:bwas in any othe
get:band goes to the
get:b3.5.  Closing a C
get:bCLOSE is an ope
get:bnotion of closi
get:binterpretation,
get:bthe receiving s
get:bin a simplex fa
get:buntil he is tol
get:bcould initiate 
get:bRECEIVE until s
get:bhas CLOSED.  We
get:bRECEIVEs are ou
get:bcan terminate h
get:bbuffers SENT be
get:bdata in return 
get:bsuccessfully to
get:bTCP.  Users mus
get:bthe TCP says no
get:bTransmission Cont
get:bFunctional Specif
get:bThere are essen:tially three cases
get:b1) The user i
get:b2) The remote
get:b3) Both users
get:bCase 1:  Local 
get:bIn this case,
get:boutgoing segm
get:baccepted by t
get:bare allowed i
get:bwill be retra
get:bboth acknowle
get:bcan ACK this 
get:bsend its own 
get:bCase 2:  TCP re
get:bIf an unsolic
get:bcan ACK it an
get:buser will res
get:bthe other TCP
get:buntil its own
get:bconnection.  
get:bthe connectio
get:bCase 3:  both u
get:bA simultaneou
get:bFIN segments 
get:bhave been pro
get:bhas received.
get:b[Page 38]        
get:bSeptember 1981   
get:bTCP A      
get:b1.  ESTABLISHED
get:bFIN-WAIT-1 
get:b3.  FIN-WAIT-2 
get:b4.             
get:bTIME-WAIT  
get:b5.  TIME-WAIT  
get:bCLOSED     
get:bTCP A      
get:b1.  ESTABLISHED
get:b2.  (Close)    
get:bFIN-WAIT-1 
get:b3.  CLOSING    
get:b4.  TIME-WAIT  
get:b(2 MSL)    
get:bCLOSED     
get:bTransmission Cont
get:bFunctional Specif
get:b3.6.  Precedence 
get:bThe intent is t
get:bwith exactly th
get:bhigher of the p
get:bThe precedence 
get:bdefined in the 
get:bspecification t
get:bthe security pa
get:buser group, and
get:bA connection at
get:blower precedenc
get:ba connection du
get:backnowledgment 
get:bNote that TCP m
get:bprecedence will
get:bsegments and po
get:bThe security pa
get:b(the values wou
get:bnon-secure envi
get:bparameters, tho
get:b3.7.  Data Commun
get:bOnce the connec
get:bexchange of seg
get:b(checksum test 
get:bretransmission 
get:bDuplicate segme
get:bAs discussed in
get:bcertain tests o
get:bsegments to ver
get:bThe sender of d
get:bthe variable SN
get:bsequence number
get:bkeeps track of 
get:bvariable SND.UN
get:bsent has been a
get:bWhen the sender
get:bSND.NXT.  When 
get:bsends an acknow
get:b[Page 40]        
get:bSeptember 1981   
get:backnowledgment 
get:bthese variables
get:bThe amount by w
get:bdata in the seg
get:bsegments must c
get:bThe CLOSE user 
get:bflag in an inco
get:bRetransmission 
get:bBecause of the 
get:binternetwork sy
get:bretransmission 
get:bfor determining
get:bAn Example Re
get:bMeasure the
get:bparticular 
get:bcovers that
get:bsegments re
get:bTime (RTT).:  Next compute a Smoothed Round Trip Time (SRTT) as
get:bSRTT = ( 
get:band based o:n this, compute the retransmission timeout (RTO) as
get:bRTO = min
get:bwhere UBOUN
get:bLBOUND is a
get:ba smoothing
get:bfactor (e.g
get:bThe Communicati
get:bThe objective o
get:bto stimulate th
get:bpermit the rece
get:bthe currently k
get:bThis mechanism 
get:bthe end of urge
get:bthe receive seq
get:bmust tell the u
get:bnumber catches 
get:bTransmission Cont
get:bFunctional Specif
get:binto "normal mo
get:bis in "urgent m
get:bThe method empl
get:btransmitted.  T
get:bmeaningful and 
get:bthe urgent poin
get:bno urgent data 
get:bTo send an urge
get:boctet.  If the 
get:bthe urgent info
get:bManaging the Wi
get:bThe window sent
get:bnumbers the sen
get:bprepared to acc
get:bthe currently a
get:bIndicating a la
get:barrives than ca
get:bin excessive re
get:bnetwork and the
get:btransmission of
get:bbetween each ne
get:bThe mechanisms 
get:bsubsequently ad
get:bthat much data.
get:bdiscouraged.  T
get:bshrink the wind
get:bon the part of 
get:bThe sending TCP
get:bleast one octet
get:bsending TCP mus
get:bthe window is z
get:binterval when t
get:bguarantee that 
get:bwindow will be 
get:bWhen the receiv
get:bstill send an a
get:band current win
get:bThe sending TCP
get:b[Page 42]        
get:bSeptember 1981   
get:bwhich fit the c
get:bretransmission 
get:bIn a connection
get:bbe carried in a
get:bnumber so there
get:border.  This is
get:binformation to 
get:bthe data receiv
get:bthe window info
get:backnowledgment 
get:bequal or greate
get:bThe window mana
get:bcommunication p
get:bWindow Manage
get:bAllocating 
get:bmany small 
get:bfewer large
get:bOne suggest
get:bdefer updat
get:bleast X per
get:bconnection 
get:bAnother sug
get:bsegments by
get:bsending dat
get:bdata must b
get:bNote that t
get:bretransmiss
get:backnowledgm
get:bwindow info
get:bnew window 
get:bThe segment
get:bof transmit
get:bsegment con
get:bis accepted
get:bIf the send
get:bwindow is n
get:balternating
get:bpauses in t
get:bTransmission Cont
get:bFunctional Specif
get:bresult in b
get:bbig pair. A
get:bmostly smal
get:bThe suggest
get:bactively at
get:bwindows, si
get:bto many sma
get:bThere are of co:urse two interfaces of concern
get:band the TCP/low
get:bof the user/TCP
get:bprotocol module
get:bin detail by th
get:bcase that the l
get:bthat TCPs might
get:bUser/TCP Interf
get:bThe following
get:bat best, fict
get:bfacilities.  
get:bimplementatio
get:bTCPs must pro
get:bthat all TCP 
get:bhierarchy.  T
get:brequired of a
get:bTCP User Comm
get:bThe followi
get:binterface. 
get:bfunction ca
get:bmeant to ru
get:bThe user co
get:bTCP must pe
get:bIndividual 
get:bmay provide
get:bsingle call
get:bautomatical
get:bissued by t
get:b[Page 44]        
get:bSeptember 1981   
get:bIn providin
get:bnot only ac
get:bprocesses i:t serves.  The latter consists of
get:b(a) gener
get:bremote cl
get:b(b) repli
get:bvarious t
get:bFormat:  
get:b[, timeou
get:b-> local 
get:bWe assume
get:bprocesses
get:bto use th
get:bimplement
get:bfor the s
get:blower lev
get:bresult of
get:bable to m
get:bprocess c
get:bIf the ac
get:bcall to L
get:bhave eith
get:bparticula
get:bfor any c
get:bby the su
get:bA transmi
get:bfilled in
get:bOn an act
get:bsynchroni
get:bThe timeo
get:bfor all d
get:bdelivered
get:bwill abor
get:bThe TCP o
get:bthe users
get:bTransmission Cont
get:bFunctional Specif
get:bprecedenc
get:bor securi
get:bthe defau
get:bTCP will 
get:bsecurity/
get:bthe prece
get:brequested
get:bThe prece
get:brequested
get:brequest, 
get:bconnectio
get:bthis prec
get:ballowed t
get:bor that a
get:bA local c
get:bThe local
get:bfor the c
get:bFormat:  
get:bcount, PU
get:bThis call
get:bto be sen
get:bnot been 
get:bimplement
get:bautomatic
get:bauthorize
get:bIf the PU
get:bto the re
get:bsegment c
get:bthe data 
get:btransmiss
get:bIf the UR
get:bwill have
get:bthe urgen
get:bpointer i
get:bbeen cons
get:bis to sti
get:bindicate 
get:b[Page 46]        
get:bSeptember 1981   
get:bdata has 
get:bTCP signa
get:bof times 
get:burgent da
get:bIf no for
get:bconnectio
get:bhas becom
get:blocal soc
get:bforeign s
get:bforeign s
get:bknowing t
get:bHowever, 
get:bbecomes s
get:bSTATUS ca
get:bimplement
get:bsocket is
get:bIf a time
get:bconnectio
get:bIn the si
get:bthe sendi
get:bor the ti
get:bis both s
get:bconnectio
get:boffers po
get:bsophistic
get:bthe proce
get:bfurthermo
get:bMultiple 
get:bthe TCP w
get:bWe have i
get:bwhich a S
get:bpseudo-in
get:breturn a 
get:bimmediate
get:bbeen ackn
get:bassume ev
get:bclose any
get:bkind (syn
get:bsignals, 
get:bwith spec
get:bIn order 
get:bindicatio
get:bTransmission Cont
get:bFunctional Specif
get:bbuffer ad
get:bthe SEND 
get:bindicatin
get:bcalling p
get:bFormat:  
get:bcount) ->
get:bThis comm
get:bspecified
get:bcalling p
get:berror is 
get:bIn the si
get:bcalling p
get:berror occ
get:bA more so
get:bRECEIVEs 
get:bsegments 
get:bthe cost 
get:bnotify th
get:bIf enough
get:bthe PUSH 
get:bThe buffe
get:ba PUSH is
get:breturned 
get:bIf there 
get:bas it arr
get:bshould th
get:badditiona
get:bcall to R
get:bmay now l
get:burgent po
get:bin the sa
get:bboundary 
get:bTo distin
get:bcare of t
get:breturn co
get:bcount ind
get:bAlternati
get:b[Page 48]        
get:bSeptember 1981   
get:ballocate 
get:bwith the 
get:bFormat:  
get:bThis comm
get:bthe conne
get:bauthorize
get:bClosing c
get:bthe sense
get:bretransmi
get:bserviced.
get:bcalls, fo
get:bto the de
get:bcontinue 
get:bmay be tr
get:bmeans "I 
get:breceive a
get:bnot well 
get:bof all it
get:binto ABOR
get:bThe user 
get:binitiativ
get:b(e.g., re
get:bdestinati
get:bBecause c
get:bforeign T
get:bshort tim
get:breplies t
get:bClose als
get:bFormat:  
get:bThis is a
get:bexcluded 
get:btypically
get:bThis comm
get:binformati:on
get:blocal s
get:bTransmission Cont
get:bFunctional Specif
get:bforeign
get:blocal c
get:breceive
get:bsend wi
get:bconnect
get:bnumber 
get:bnumber 
get:burgent 
get:bprecede
get:bsecurit
get:band tra
get:bDepending
get:bimplement
get:bavailable
get:bauthorize
get:bprevents 
get:bconnectio
get:bFormat:  
get:bThis comm
get:baborted, 
get:bbe sent t
get:bDepending
get:bindicatio
get:breceive a
get:bTCP-to-User M
get:bIt is assum
get:bmeans for t
get:bthe TCP doe
get:bto the user
get:ban error me
get:brelating to
get:bother user 
get:bThe followi:ng information is provided
get:bLocal Con
get:bResponse 
get:bBuffer Ad
get:bByte coun
get:bPush flag
get:bUrgent fl
get:b[Page 50]        
get:bSeptember 1981   
get:bTCP/Lower-Level
get:bThe TCP calls
get:breceive infor
get:binternetwork 
get:bProtocol (IP)
get:bIf the lower 
get:bof service an
get:bfor these par:ameters
get:bType of Ser:vice = Precedence: routine, Delay: normal, Throughput
get:bnormal, Rel:iability
get:bTime to Liv
get:bNote that
get:bHere we e
get:bbe delive
get:bIf the lower 
get:bfeature) and 
get:broute informa
get:bso that the s
get:bchecksum be t
get:balso importan
get:bAny lower lev
get:bdestination a
get:bthe "TCP leng
get:bof IP and to 
get:bTransmission Cont
get:bFunctional Specif
get:b3.9.  Event Proce
get:bThe processing 
get:bimplementation.
get:bprocessing sequ
get:bsection only in
get:bThe activity of
get:bThe events that: occur can be cast into three categories
get:barriving segmen
get:bprocessing the 
get:bcases the proce
get:bEvents that o:ccur
get:bArriving Se
get:bSEGMENT A
get:bUSER TIME
get:bRETRANSMI
get:bTIME-WAIT
get:bThe model of th
get:bimmediate retur
get:bpseudo interrup
get:bmeans cause a d
get:bError responses
get:bcommands refere:ncing connections that do not exist receive "error
get:bconnection not 
get:bPlease note in 
get:backnowledgment 
get:bof the sequence
get:bequal to (modul
get:b[Page 52]        
get:bSeptember 1981   
get:bA natural way t
get:bimagine that th
get:bthat their cont
get:bin the sequence
get:band processed i
get:bWhen a segment 
get:bthe segment to 
get:bto be consisten
get:bNote that if no
get:bTransmission Cont
get:bFunctional Specif
get:bCLOSED STATE 
get:bCreate a ne
get:bstate infor
get:bsocket, pre
get:binformation
get:bunspecified
get:bparameters 
get:bprecedence 
get:b"error:  pr:ecedence not allowed" or "error
get:bnot allowed
get:bactive and :the foreign socket is unspecified, return "error
get:bforeign soc
get:bspecified, 
get:b(ISS) is se
get:bis sent.  S
get:bstate, and 
get:bIf the call
get:breturn "err:or
get:bno room to :create a new connection, return "error
get:bresources".
get:bIf active a
get:bconnection 
get:bsegment, se
get:bstate.  Dat
get:bqueued for 
get:burgent bit 
get:bsegments se
get:bqueue the r:equest, respond with "error
get:bIf Foreign :socket was not specified, then return "error
get:bsocket unsp
get:b[Page 54]        
get:bSeptember 1981   
get:bSYN-SENT STAT
get:bSYN-RECEIVED 
get:bESTABLISHED S
get:bFIN-WAIT-1 ST
get:bFIN-WAIT-2 ST
get:bCLOSE-WAIT ST
get:bCLOSING STATE
get:bLAST-ACK STAT
get:bTIME-WAIT STA
get:bReturn "err:or
get:bTransmission Cont
get:bFunctional Specif
get:bCLOSED STATE 
get:bIf the user
get:b"error:  co
get:bOtherwise, :return "error
get:bIf the fore
get:bfrom passiv
get:bSND.UNA to 
get:bassociated 
get:btransmissio
get:brequested i
get:bas a result
get:brequest, re:spond with "error
get:bForeign soc:ket was not specified, then return "error
get:bsocket unsp
get:bSYN-SENT STAT
get:bSYN-RECEIVED 
get:bQueue the d
get:bIf no space: to queue, respond with "error
get:bresources".
get:bESTABLISHED S
get:bCLOSE-WAIT ST
get:bSegmentize 
get:backnowledgm
get:binsufficien:t space to remember this buffer, simply return "error
get:binsufficien
get:bIf the urge
get:burgent poin
get:b[Page 56]        
get:bSeptember 1981   
get:bFIN-WAIT-1 ST
get:bFIN-WAIT-2 ST
get:bCLOSING STATE
get:bLAST-ACK STAT
get:bTIME-WAIT STA
get:bReturn "err:or
get:bTransmission Cont
get:bFunctional Specif
get:bCLOSED STATE 
get:bIf the user
get:b"error:  co
get:bOtherwise r:eturn "error
get:bSYN-SENT STAT
get:bSYN-RECEIVED 
get:bQueue for p
get:bis no room :to queue this request, respond with "error
get:binsufficien
get:bESTABLISHED S
get:bFIN-WAIT-1 ST
get:bFIN-WAIT-2 ST
get:bIf insuffic
get:brequest, qu
get:bremember th:e RECEIVE, respond with "error
get:bresources".
get:bReassemble 
get:bto user.  M
get:bIf RCV.UP i
get:buser notify
get:bWhen the TC
get:bthat fact m
get:backnowledgm
get:bdescribed b
get:b[Page 58]        
get:bSeptember 1981   
get:bCLOSE-WAIT ST
get:bSince the r
get:bsatisfied b
get:buser.  If n
get:b"error:  co
get:btext can be
get:bCLOSING STATE
get:bLAST-ACK STAT
get:bTIME-WAIT STA
get:bReturn "err:or
get:bTransmission Cont
get:bFunctional Specif
get:bCLOSED STATE 
get:bIf the user
get:b"error:  co
get:bOtherwise, :return "error
get:bAny outstan:ding RECEIVEs are returned with "error
get:bresponses. 
get:bSYN-SENT STAT
get:bDelete the :TCB and return "error
get:bqueued SEND
get:bSYN-RECEIVED 
get:bIf no SENDs
get:bthen form a
get:botherwise q
get:bESTABLISHED S
get:bQueue this 
get:bform a FIN 
get:bFIN-WAIT-1 ST
get:bFIN-WAIT-2 ST
get:bStrictly sp:eaking, this is an error and should receive a "error
get:bconnection 
get:bacceptable,
get:bFIN may be 
get:b[Page 60]        
get:bSeptember 1981   
get:bCLOSE-WAIT ST
get:bQueue this 
get:bsegmentized
get:bCLOSING STATE
get:bLAST-ACK STAT
get:bTIME-WAIT STA
get:bRespond wit:h "error
get:bTransmission Cont
get:bFunctional Specif
get:bCLOSED STATE 
get:bIf the user
get:b"error:  co
get:bOtherwise r:eturn "error
get:bAny outstan:ding RECEIVEs should be returned with "error
get:bconnection 
get:bSYN-SENT STAT
get:bAll queued 
get:bnotificatio
get:bSYN-RECEIVED 
get:bESTABLISHED S
get:bFIN-WAIT-1 ST
get:bFIN-WAIT-2 ST
get:bCLOSE-WAIT ST
get:bSend a rese:t segment
get:b<SEQ=SND.
get:bAll queued 
get:bnotificatio
get:bRST formed 
get:bTCB, enter 
get:bCLOSING STATE
get:bLAST-ACK STAT
get:bTIME-WAIT STA
get:bRespond wit
get:b[Page 62]        
get:bSeptember 1981   
get:bCLOSED STATE 
get:bIf the user
get:b"error:  co
get:bOtherwise r:eturn "error
get:bReturn "sta
get:bSYN-SENT STAT
get:bReturn "sta
get:bSYN-RECEIVED 
get:bReturn "sta
get:bESTABLISHED S
get:bReturn "sta
get:bFIN-WAIT-1 ST
get:bReturn "sta
get:bFIN-WAIT-2 ST
get:bReturn "sta
get:bCLOSE-WAIT ST
get:bReturn "sta
get:bCLOSING STATE
get:bReturn "sta
get:bLAST-ACK STAT
get:bReturn "sta
get:bTransmission Cont
get:bFunctional Specif
get:bTIME-WAIT STA
get:bReturn "sta
get:b[Page 64]        
get:bSeptember 1981   
get:bSEGMENT ARRIVES
get:bIf the state 
get:ball data in
get:bsegment con
get:bcontaining 
get:backnowledgm
get:breset seque
get:bIf the ACK 
get:b<SEQ=0><A
get:bIf the ACK 
get:b<SEQ=SEG.
get:bIf the state 
get:bfirst check
get:bAn incomi
get:bsecond chec
get:bAny ackno
get:bthe LISTE
get:bfor any a
get:bformatted: as follows
get:b<SEQ=SE
get:bthird check
get:bIf the SY
get:bsecurity/
get:bmatch the
get:b<SEQ=SE
get:bTransmission Cont
get:bFunctional Specif
get:bIf the SE
get:bthe user 
get:bsend a re
get:b<SEQ=SE
get:bIf the SE
get:bSet RCV.N
get:bcontrol o
get:bshould be: selected and a SYN segment sent of the form
get:b<SEQ=IS
get:bSND.NXT i
get:bstate sho
get:bincoming 
get:bin the SY
get:bnot be re
get:bthe forei
get:bunspecifi
get:bfourth othe
get:bAny other
get:bmust have
get:bprocessin
get:bit could 
get:bincarnati
get:bbut if yo
get:bIf the state 
get:bfirst check
get:bIf the AC
get:bIf SEG.
get:bthe RST
get:b<SEQ=
get:band dis
get:bIf SND.
get:bsecond chec
get:b[Page 66]        
get:bSeptember 1981   
get:bIf the RS
get:bIf the :ACK was acceptable then signal the user "error
get:bconnect
get:bdelete 
get:band ret
get:bthird check
get:bIf the se
get:bmatch the
get:bIf ther
get:b<SEQ=
get:bOtherwi
get:b<SEQ=
get:bIf there 
get:bThe pre
get:bTCB, if
get:b<SEQ=
get:bIf there 
get:bIf the 
get:bin the 
get:bthe pre
get:ballowed
get:b<SEQ=
get:bIf the 
get:bin the 
get:bIf a rese
get:bfourth chec
get:bThis step
get:bno ACK, a
get:bIf the SY
get:bTransmission Cont
get:bFunctional Specif
get:bare accep
get:bSEG.SEQ. 
get:bis an ACK
get:bare there
get:bIf SND.UN
get:bstate to 
get:b<SEQ=SN
get:band send 
get:btransmiss
get:btext in t
get:bbelow whe
get:bOtherwise
get:b<SEQ=IS
get:band send 
get:bsegment, 
get:bhas been 
get:bfifth, if n
get:bsegment and
get:b[Page 68]        
get:bSeptember 1981   
get:bfirst check s
get:bSYN-RECEIVE
get:bESTABLISHED
get:bFIN-WAIT-1 
get:bFIN-WAIT-2 
get:bCLOSE-WAIT 
get:bCLOSING STA
get:bLAST-ACK ST
get:bTIME-WAIT S
get:bSegments 
get:bare used 
get:bdone in S
get:bboundary 
get:bprocessed
get:bThere are
get:bsegment
get:bSegment R
get:bLength  W
get:b------- -
get:b0     
get:b0     
get:b>0     
get:b>0     
get:bIf the RC
get:bspecial a
get:bIf an inc
get:bshould be
get:bthe segme:nt and return)
get:b<SEQ=SN
get:bAfter sen
get:band retur
get:bTransmission Cont
get:bFunctional Specif
get:bIn the fo
get:bsegment t
get:bOne could
get:btrimming 
get:bSYN and F
get:bbegins at
get:bnumbers m
get:bsecond check 
get:bSYN-RECEIVE
get:bIf the RS
get:bIf this
get:bcame fr
get:bLISTEN 
get:bthis co
get:bfrom SY
get:bthe use
get:bon the 
get:bactive 
get:band ret
get:bESTABLISHED
get:bIf the RS
get:bshould re
get:bflushed. 
get:b"connecti
get:bTCB, and 
get:bCLOSING STA
get:bLAST-ACK ST
get:bIf the RS
get:bTCB, and 
get:b[Page 70]        
get:bSeptember 1981   
get:bthird check s
get:bSYN-RECEIVE
get:bIf the se
get:bexactly m
get:bthen send
get:bESTABLISHED
get:bIf the se
get:bexactly m
get:bthen send
get:breceive "
get:bflushed. 
get:b"connecti
get:bTCB, and 
get:bNote this c
get:ba segment f
get:bdifferent s
get:bcurrent con
get:bfourth, check
get:bSYN-RECEIVE
get:bESTABLISHED
get:bFIN-WAIT ST
get:bFIN-WAIT ST
get:bCLOSE-WAIT 
get:bCLOSING STA
get:bLAST-ACK ST
get:bTIME-WAIT S
get:bIf the SY
get:boutstandi
get:ball segme
get:breceive a
get:bthe CLOSE
get:bIf the SY
get:band an ac
get:bnumber ch
get:bTransmission Cont
get:bFunctional Specif
get:bfifth check t
get:bif the ACK 
get:bif the ACK 
get:bSYN-RECEI
get:bIf SND.
get:band con
get:bIf th
get:breset
get:b<SE
get:band s
get:bESTABLISH
get:bIf SND.
get:bAny seg
get:bentirel
get:bpositiv
get:bfully a
get:b"ok" re
get:b(SEG.AC
get:bsomethi
get:bdrop th
get:bIf SND.
get:bupdated
get:bSND.WL2
get:bSND.WL1
get:bNote th
get:brecords
get:bSND.WND
get:bthe las
get:bprevent
get:b[Page 72]        
get:bSeptember 1981   
get:bFIN-WAIT-
get:bIn addi
get:bour FIN
get:bprocess
get:bFIN-WAIT-
get:bIn addi
get:bthe ret
get:backnowl
get:bCLOSE-WAI
get:bDo the 
get:bCLOSING S
get:bIn addi
get:bthe ACK
get:botherwi
get:bLAST-ACK 
get:bThe onl
get:backnowl
get:bdelete 
get:bTIME-WAIT
get:bThe onl
get:bretrans
get:bthe 2 M
get:bsixth, check 
get:bESTABLISHED
get:bFIN-WAIT-1 
get:bFIN-WAIT-2 
get:bIf the UR
get:bthe user 
get:bpointer (
get:buser has 
get:bmode") fo
get:bsignal th
get:bTransmission Cont
get:bFunctional Specif
get:bCLOSE-WAIT 
get:bCLOSING STA
get:bLAST-ACK ST
get:bThis shou
get:bremote si
get:bseventh, proc
get:bESTABLISHED
get:bFIN-WAIT-1 
get:bFIN-WAIT-2 
get:bOnce in t
get:btext to u
get:binto buff
get:bempty.  I
get:bthe user 
get:bhas been 
get:bWhen the 
get:buser it m
get:bOnce the 
get:bRCV.NXT o
get:bapporopri
get:bRCV.NXT a
get:bPlease no
get:bSend an a:cknowledgment of the form
get:b<SEQ=SN
get:bThis ackn
get:btransmitt
get:b[Page 74]        
get:bSeptember 1981   
get:bCLOSE-WAIT 
get:bCLOSING STA
get:bLAST-ACK ST
get:bTIME-WAIT S
get:bThis shou
get:bremote si
get:beighth, check
get:bDo not proc
get:bsince the S
get:bIf the FIN 
get:breturn any 
get:bover the FI
get:bFIN implies
get:bSYN-RECEI
get:bESTABLISH
get:bEnter t
get:bFIN-WAIT-
get:bIf our 
get:benter T
get:btimers;
get:bFIN-WAIT-
get:bEnter t
get:boff the
get:bCLOSE-WAI
get:bRemain 
get:bCLOSING S
get:bRemain 
get:bLAST-ACK 
get:bRemain 
get:bTransmission Cont
get:bFunctional Specif
get:bTIME-WAIT
get:bRemain 
get:btimeout
get:b[Page 76]        
get:bSeptember 1981   
get:bFor any state
get:bthe user "err:or
get:band for any o
get:bstate and ret
get:bRETRANSMISSION 
get:bFor any state
get:bthe retransmi
get:bretransmissio
get:bTIME-WAIT TIMEO
get:bIf the time-w
get:benter the CLO
get:bTransmission Cont
get:b[Page 78]        
get:bSeptember 1981   
get:bBBN Rep
get:ba Host 
get:bhost an
get:bA contr
get:bindicat
get:bspecifi
get:bis expe
get:bpreviou
get:bThe uni
get:bARPANET
get:bA unit 
get:bIMPs.  
get:bA logic
get:bA messa
get:bnetwork
get:bDestination Addre
get:bThe des
get:bidentif
get:bA contr
get:bindicat
get:boccupyi
get:bA porti
get:bfragmen
get:bA file 
get:bTransmission Cont
get:bControl
get:bfragmen
get:bA compu
get:bfrom th
get:bAn Inte
get:bby the 
get:bThe Int
get:bARPANET
get:bA sourc
get:binternet datagram
get:bThe uni
get:bhigher 
get:binternet fragment
get:bA porti
get:bheader.
get:bInterne
get:bThe Ini
get:bnumber 
get:bThe Ini
get:bon a co
get:bbased p
get:bThe Ini
get:bused by
get:bControl
get:bdata.  
get:bon an A
get:b[Page 80]        
get:bSeptember 1981   
get:bThis is
get:bdata re
get:bsequenc
get:bof the 
get:bThe uni
get:bAn impl
get:bprocedu
get:bMaximum
get:bthe int
get:bAn eigh
get:bAn Opti
get:bmay be 
get:bprimari
get:btimesta
get:boptions
get:bA packa
get:blogical
get:blogical
get:bThe por
get:boutput 
get:bA progr
get:bthe poi
get:bA contr
get:bthis se
get:breceivi
get:breceive
get:bTransmission Cont
get:breceive
get:breceive
get:breceive next sequ
get:bThis is
get:breceive
get:bThis re
get:bis will
get:bsegment
get:bRCV.NXT
get:bSegment
get:brange a
get:bA contr
get:bthat th
get:binterac
get:bsequenc
get:bsegment
get:bit.  In
get:brise to
get:bReal Ti:me Protocol
get:bof time
get:bsegment
get:bsegment
get:bsegment
get:bsegment
get:bsegment
get:b[Page 82]        
get:bSeptember 1981   
get:bsegment
get:bA logic
get:bunit of
get:bsegment acknowled
get:bThe seq
get:barrivin
get:bThe amo
get:bincludi
get:bThe num
get:bThis is
get:buse on 
get:binitial
get:beach oc
get:bThis re
get:b(receiv
get:bwindow 
get:breceivi
get:bbe emit
get:bSND.UNA
get:bbetween
get:bsend se
get:bleft se
get:bsend ur
get:bsegment
get:bsegment
get:bTransmission Cont
get:bsend wi
get:bAn addr
get:bis, the
get:bThe sou
get:bA contr
get:bnumber,
get:bwhere t
get:bTransmi
get:bthe sta
get:bThe pre
get:bTransmi:ssion Control Protocol
get:breliabl
get:bType of
get:bAn Inte
get:bfor thi
get:bA contr
get:bindicat
get:burgent 
get:bsequenc
get:bpointer
get:bA contr
get:bfield c
get:bindicat
get:burgent 
get:b[Page 84]        
get:bSeptember 1981   
get:b[1]  Cerf, V., an
get:bIntercommuni
get:bVol. COM-22,
get:b[2]  Postel, J. (
get:bProtocol Spe
get:bInstitute, S
get:b[3]  Dalal, Y. an
get:bProtocols", 
get:bDecember 197
get:b[4]  Postel, J., 
get:bInstitute, S
get:baRFC
get:baDe
get:baI
get:baSeptember 1981   
get:baPREFACE .....
get:ba1.  INTRODUCTION 
get:ba1.1  Motivation
get:ba1.2  Scope ....
get:ba1.3  About This
get:ba1.4  Interfaces
get:ba1.5  Operation 
get:ba2.  PHILOSOPHY ..
get:ba2.1  Elements o
get:ba2.2  Model of O
get:ba2.3  The Host E
get:ba2.4  Interfaces
get:ba2.5  Relation t
get:ba2.6  Reliable C
get:ba2.7  Connection
get:ba2.8  Data Commu
get:ba2.9  Precedence
get:ba2.10 Robustness
get:ba3.  FUNCTIONAL SP
get:ba3.1  Header For
get:ba3.2  Terminolog
get:ba3.3  Sequence N
get:ba3.4  Establishi
get:ba3.5  Closing a 
get:ba3.6  Precedence
get:ba3.7  Data Commu
get:ba3.8  Interfaces
get:ba3.9  Event Proc
get:baGLOSSARY ........
get:baREFERENCES ......
get:baTransmission Cont
get:ba[Page ii]        
get:baSeptember 1981   
get:baThis document des
get:ba(TCP).  There hav
get:baspecification on 
get:badraws heavily fro
get:baboth in terms of 
get:baseveral details a
get:baand redescribes t
get:baRFC
get:baReplaces: RFC 761
get:baIENs:  129, 124, 
get:ba55, 44, 40, 27, 2
get:baThe Transmission 
get:bareliable host-to-
get:bacommunication net
get:baThis document des
get:baTransmission Cont
get:bainterface to prog
get:baComputer commun
get:barole in militar
get:badocument focuse
get:bacommunication r
get:bacommunication u
get:bacongestion, but
get:bagovernment sect
get:baAs strategic an
get:badeveloped and d
get:bainterconnecting
get:bacommunication p
get:baapplications.  
get:baDeputy Undersec
get:badeclared the Tr
get:babe a basis for 
get:bastandardization
get:baTCP is a connec
get:bafit into a laye
get:baapplications.  
get:bacommunication b
get:badistinct but in
get:baassumptions are
get:baprotocols below
get:bapotentially unr
get:baprotocols.  In 
get:bawide spectrum o
get:baconnections to 
get:baTransmission Cont
get:baTCP is based on
get:baTCP fits into a
get:baInternet Protoc
get:bareceive variabl
get:badatagram "envel
get:baaddressing sour
get:bainternet protoc
get:bathe TCP segment
get:bamultiple networ
get:baalso carries in
get:baand compartment
get:bacommunicated en
get:baMuch of this do
get:bawhich are co-re
get:bacomputer.  Some
get:bafront-end compu
get:baas well as netw
get:baan interface to
get:baimplementable e
get:bahost-to-front e
get:baThe TCP is inte
get:bacommunication s
get:baintended to be 
get:ba1.3.  About this 
get:baThis document r
get:baany TCP impleme
get:baprotocols and i
get:ba[Page 2]         
get:baSeptember 1981   
get:basection offers 
get:baoperation.  Sec
get:badesign.  Sectio
get:barequired of TCP
get:bauser calls, err
get:baThe TCP interfa
get:bathe other side 
get:baThe interface b
get:baillustrated in 
get:bacalls much like
get:baapplication pro
get:bacalls to open a
get:baestablished con
get:baasynchronously 
get:baconsiderable fr
get:bainterfaces whic
get:baenvironment, a 
get:bainterface for a
get:baThe interface b
get:baunspecified exc
get:batwo levels can 
get:baTypically, one 
get:bainterface.  TCP
get:bainterconnected 
get:bathroughout this
get:baAs noted above,
get:basecurable logic
get:baprocesses.  To 
get:bacommunication s:ystem requires facilities in the following areas
get:baBasic Data Tr
get:baPrecedence an
get:baThe basic opera
get:bathe following p
get:baTransmission Cont
get:baBasic Data Tran:sfer
get:baThe TCP is ab
get:badirection bet
get:basegments for 
get:bathe TCPs deci
get:baSometimes use
get:basubmitted to 
get:bafunction is d
get:baactually tran
get:bapushed throug
get:bapromptly forw
get:baThe exact pus
get:bathe push func
get:baReliability
get:baThe TCP must 
get:badelivered out
get:bais achieved b
get:batransmitted, 
get:bareceiving TCP
get:bainterval, the
get:banumbers are u
get:baout of order 
get:baadding a chec
get:bareceiver, and
get:baAs long as th
get:basystem does n
get:baerrors will a
get:bainternet comm
get:baFlow Control
get:baTCP provides 
get:basent by the s
get:baevery ACK ind
get:bathe last segm
get:baallowed numbe
get:bareceiving fur
get:ba[Page 4]         
get:baSeptember 1981   
get:baMultiplexing
get:baTo allow for 
get:bacommunication
get:baaddresses or 
get:baand host addr
get:baa socket.  A 
get:baThat is, a so
get:baThe binding o
get:baHost.  Howeve
get:ba(e.g., a "log
get:bamade known to
get:bathrough the k
get:baaddresses of 
get:baConnections
get:baThe reliabili
get:bathat TCPs ini
get:baeach data str
get:basockets, sequ
get:baEach connecti
get:baidentifying i
get:baWhen two proc
get:baestablish a c
get:baside).  When 
get:baterminated or
get:baSince connect
get:baover the unre
get:bamechanism wit
get:baerroneous ini
get:baPrecedence and :Security
get:baThe users of 
get:bacommunication
get:bathese feature
get:baTransmission Cont
get:ba[Page 6]         
get:baSeptember 1981   
get:ba2.1.  Elements of
get:baThe internetwor
get:bawhich are in tu
get:bathat the networ
get:balarge networks 
get:bapacket switchin
get:baconsume message
get:banetworks, the g
get:bacommunication s
get:baconnections bet
get:baThe term packet
get:batransaction bet
get:baexchanged withi
get:baHosts are compu
get:banetwork's point
get:baProcesses are v
get:baaccordance with
get:bain execution). 
get:baviewed as commu
get:baThus, all commu
get:baSince a process
get:bastreams between
get:bathat each proce
get:bacommunicates wi
get:ba2.2.  Model of Op
get:baProcesses trans
get:badata as argumen
get:basegments and ca
get:bathe destination
get:bainto the receiv
get:baTCPs include co
get:baensure reliable
get:baThe model of in
get:baprotocol module
get:bato the local ne
get:bainside internet
get:bainternet module
get:bathrough the loc
get:baThe packet swit
get:baTransmission Cont
get:baother operation
get:badestination int
get:baAt a gateway be
get:bafrom its local 
get:bathe internet da
get:bathen "wrapped" 
get:barouted to the n
get:baA gateway is pe
get:bainternet datagr
get:bathrough the nex
get:bainternet datagr
get:bafurther broken 
get:bainternet datagr
get:bainternet module
get:baA destination i
get:ba(after reassemb
get:badestination TCP
get:baThis simple mod
get:baimportant featu
get:bato the gateway 
get:baservice paramet
get:baIncluded in the
get:badatagram.  Data
get:bahost and gatewa
get:baproperly segreg
get:ba2.3.  The Host En
get:baThe TCP is assu
get:baaccess the TCP 
get:bamay call on oth
get:badata structures
get:bacontrolled by a
get:banetwork device 
get:badatagram protoc
get:baThe mechanisms 
get:bafront-end proce
get:bahost-to-front-e
get:bathe type of TCP
get:ba[Page 8]         
get:baSeptember 1981   
get:baThe TCP/user in
get:bato OPEN or CLOS
get:baSTATUS about a 
get:baprograms on the
get:bafrom, and close
get:baThe TCP/interne
get:badatagrams addre
get:basystem.  These 
get:baservice, preced
get:ba2.5.  Relation to
get:baThe following d
get:bahierarchy
get:ba+------+ +
get:ba|Telnet| |
get:ba+------+ +
get:ba|   
get:ba+----
get:ba| TCP
get:ba+----
get:ba| 
get:ba+----
get:ba|    
get:ba+----
get:ba+--
get:ba|  
get:ba+--
get:baIt is expected 
get:baprotocols effic
get:baprotocols like 
get:ba2.6.  Reliable Co
get:baA stream of dat
get:baorder at the de
get:baTransmission Cont
get:baTransmission is
get:baacknowledgments
get:basequence number
get:basegment is tran
get:basequence number
get:bais the sequence
get:batransmissions i
get:basegment contain
get:bastarts a timer;
get:basegment is dele
get:bareceived before
get:baAn acknowledgme
get:badelivered to th
get:bathe responsibil
get:baTo govern the f
get:baemployed.  The 
get:baThis window spe
get:baacknowledgment 
get:ba2.7.  Connection 
get:baTo identify the
get:baprovides a port
get:baindependently b
get:baunique addresse
get:baidentifying the
get:bawill be unique 
get:baA connection is
get:balocal socket ma
get:basockets.  A con
get:bathat is, it is 
get:baTCPs are free t
get:baHowever, severa
get:baThere must be w
get:bathe "appropriat
get:bamay "own" ports
get:bathe ports they 
get:baissue, but we e
get:bauniquely alloca
get:baassociating the
get:baA connection is
get:baforeign socket 
get:ba[Page 10]        
get:baSeptember 1981   
get:baconnection name
get:basubsequent call
get:baabout a connect
get:bais a data struc
get:baimplementation 
get:bapointer to the 
get:bawhether the con
get:babe passively wa
get:baA passive OPEN 
get:baconnection requ
get:baOften the proce
get:barequest from an
get:bais used to deno
get:baare allowed onl
get:baA service proce
get:baprocesses would
get:baforeign socket.
get:barequested a con
get:balocal socket we
get:baWell-known sock
get:baa socket addres
get:ba"Telnet-Server"
get:basocket, and oth
get:baEntry, Text Gen
get:babeing for test 
get:baaccess to a "Lo
get:baat which a newl
get:bawell-known sock
get:baof sockets to s
get:baProcesses can i
get:bafrom other proc
get:babeen establishe
get:baother at the sa
get:bais critical for
get:bacomponents act 
get:baThere are two p
get:bapassive OPENs a
get:balocal passive O
get:bacase, the match
get:baOPENs has left 
get:baforeign socket 
get:baOther possibili
get:baTransmission Cont
get:baIf there are se
get:basame local sock
get:bawith the specif
get:baTCB exists, bef
get:baThe procedures 
get:bacontrol flag an
get:baexchange has be
get:baA connection is
get:bacontaining a SY
get:bacommand.  The m
get:baconnection has 
get:bawhen sequence n
get:baThe clearing of
get:bain this case ca
get:ba2.8.  Data Commun
get:baThe data that f
get:baoctets.  The se
get:bain that call (a
get:bathrough to the 
get:baA sending TCP i
get:basend that data 
get:bafunction is sig
get:bareceiving TCP s
get:bathe sending TCP
get:baThere is no nec
get:baboundaries.  Th
get:basingle SEND cal
get:baThe purpose of 
get:bafrom the sendin
get:barecord service.
get:baThere is a coup
get:baof data that cr
get:baassociated with
get:babuffer is retur
get:banot filled.  If
get:baPUSH is seen, t
get:baTCP also provid
get:baat some point f
get:ba[Page 12]        
get:baSeptember 1981   
get:bacurrently readi
get:badefine what the
get:baurgent data, bu
get:batake action to 
get:ba2.9.  Precedence 
get:baThe TCP makes u
get:basecurity option
get:babasis to TCP us
get:baa multilevel se
get:bause only, and o
get:bacompartment.  C
get:bausers may be li
get:baTCP modules whi
get:baproperly mark o
get:baprecedence.  Su
get:bahigher level pr
get:bathem to specify
get:baprecedence of c
get:ba2.10.  Robustness
get:baTCP implementat:ions will follow a general principle of robustness
get:baconservative in
get:baTransmission Cont
get:ba[Page 14]        
get:baSeptember 1981   
get:ba3.1.  Header Form
get:baTCP segments ar
get:baheader carries 
get:badestination hos
get:baheader, supplyi
get:badivision allows
get:baTCP Header Form
get:ba0            
get:ba0 1 2 3 4 5 6
get:ba+-+-+-+-+-+-+-
get:ba|          Sou
get:ba+-+-+-+-+-+-+-
get:ba|             
get:ba+-+-+-+-+-+-+-
get:ba|             
get:ba+-+-+-+-+-+-+-
get:ba|  Data |     
get:ba| Offset| Rese
get:ba|       |     
get:ba+-+-+-+-+-+-+-
get:ba|           Ch
get:ba+-+-+-+-+-+-+-
get:ba|             
get:ba+-+-+-+-+-+-+-
get:ba|             
get:ba+-+-+-+-+-+-+-
get:baNote th
get:baSource Port:  1
get:baThe source po
get:baDestination Por:t
get:baThe destinati
get:baTransmission Cont
get:baFunctional Specif
get:baSequence Number:
get:baThe sequence 
get:bawhen SYN is p
get:bainitial seque
get:baAcknowledgment :Number
get:baIf the ACK co
get:banext sequence
get:bareceive.  Onc
get:baData Offset:  4
get:baThe number of
get:bathe data begi
get:baintegral numb
get:baReserved:  6 bi
get:baReserved for 
get:baControl Bits:  :6 bits (from left to right)
get:baURG:  Urgent 
get:baACK:  Acknowl
get:baPSH:  Push Fu
get:baRST:  Reset t
get:baSYN:  Synchro
get:baFIN:  No more
get:baWindow:  16 bit
get:baThe number of
get:baacknowledgmen
get:baChecksum:  16 b
get:baThe checksum 
get:bacomplement su
get:basegment conta
get:bachecksummed, 
get:baform a 16 bit
get:batransmitted a
get:bathe checksum 
get:baThe checksum 
get:ba[Page 16]        
get:baSeptember 1981   
get:baprefixed to t
get:baAddress, the 
get:baThis gives th
get:bainformation i
get:baacross the TC
get:bacalls by the 
get:baThe TCP Len
get:baoctets (thi
get:bacomputed), 
get:baUrgent Pointer:
get:baThis field co
get:bapositive offs
get:baurgent pointe
get:bathe urgent da
get:bathe URG contr
get:baOptions:  varia
get:baOptions may o
get:bamultiple of 8
get:bachecksum.  An
get:bacases for the: format of an option
get:baCase 1:  A 
get:baCase 2:  An
get:bath
get:baThe option-le
get:baoption-length
get:baNote that the
get:bafield might i
get:baEnd-of-Option
get:baA TCP must im
get:baTransmission Cont
get:baFunctional Specif
get:baCurrently def:ined options include (kind indicated in octal)
get:baKind     Le
get:ba----     --
get:ba0         
get:ba1         
get:ba2         
get:baSpecific Opti
get:baEnd of Opti
get:ba+--------
get:ba|00000000
get:ba+--------
get:baThis opti
get:bamight not
get:bathe Data 
get:banot the e
get:bathe optio
get:baNo-Operatio
get:ba+--------
get:ba|00000001
get:ba+--------
get:baThis opti
get:baalign the
get:baThere is 
get:bareceivers
get:banot begin
get:baMaximum Seg
get:ba+--------
get:ba|00000010
get:ba+--------
get:baKind=2  
get:ba[Page 18]        
get:baSeptember 1981   
get:baMaximum S:egment Size Option Data
get:baIf this
get:bareceive
get:baThis fi
get:ba(i.e., 
get:baoption 
get:baPadding:  varia
get:baThe TCP heade
get:baand data begi
get:ba3.2.  Terminology
get:baBefore we can d
get:bato introduce so
get:baconnection requ
get:baof these variab
get:baTransmission Co
get:baTCB are the loc
get:baprecedence of t
get:babuffers, pointe
get:baIn addition sev
get:basequence number
get:baSend Sequence
get:baSND.UNA - s
get:baSND.NXT - s
get:baSND.WND - s
get:baSND.UP  - s
get:baSND.WL1 - s
get:baSND.WL2 - s
get:bau
get:baISS     - i
get:baReceive Seque
get:baRCV.NXT - r
get:baRCV.WND - r
get:baRCV.UP  - r
get:baIRS     - i
get:baTransmission Cont
get:baFunctional Specif
get:baThe following d
get:bathe sequence sp
get:baSend Sequence S
get:ba---
get:ba1 - old s
get:ba2 - seque
get:ba3 - seque
get:ba4 - futur
get:baThe send window
get:baReceive Sequenc
get:ba1 - old s
get:ba2 - seque
get:ba3 - futur
get:baThe receive win
get:baThere are also 
get:batake their valu
get:ba[Page 20]        
get:baSeptember 1981   
get:baCurrent Segme
get:baSEG.SEQ - s
get:baSEG.ACK - s
get:baSEG.LEN - s
get:baSEG.WND - s
get:baSEG.UP  - s
get:baSEG.PRC - s
get:baA connection pr
get:balifetime.  The :states are
get:baESTABLISHED, FI
get:baTIME-WAIT, and 
get:babecause it repr
get:bano connection. : Briefly the meanings of the states are
get:baLISTEN - repr
get:baTCP and port.
get:baSYN-SENT - re
get:baafter having 
get:baSYN-RECEIVED 
get:barequest ackno
get:baconnection re
get:baESTABLISHED -
get:badelivered to 
get:baof the connec
get:baFIN-WAIT-1 - 
get:bafrom the remo
get:batermination r
get:baFIN-WAIT-2 - 
get:bafrom the remo
get:baCLOSE-WAIT - 
get:bafrom the loca
get:baCLOSING - rep
get:baacknowledgmen
get:baLAST-ACK - re
get:baconnection te
get:ba(which includ
get:baTransmission Cont
get:baFunctional Specif
get:baTIME-WAIT - r
get:bathe remote TC
get:batermination r
get:baCLOSED - repr
get:baA TCP connectio
get:baevents.  The ev
get:baABORT, and STAT
get:bacontaining the 
get:baThe state diagr
get:bawith the causin
get:baerror condition
get:bachanges.  In a 
get:bathe reaction of
get:baNOTE BENE:  thi
get:bathe total speci
get:ba[Page 22]        
get:baSeptember 1981   
get:ba+---------+     
get:ba|         |<----
get:ba|   SYN   |     
get:ba|   RCVD  |<----
get:ba|         |     
get:ba|         |-----
get:ba+---------+   rc
get:ba|           --
get:ba|             
get:ba|             
get:ba|  CLOSE      
get:ba| -------     
get:ba| snd FIN     
get:ba|             
get:baV             
get:ba+---------+     
get:ba|  FIN    |<----
get:ba| WAIT-1  |-----
get:ba+---------+     
get:ba| rcv ACK of F
get:ba| ------------
get:baV        x    
get:ba+---------+     
get:ba|FINWAIT-2|     
get:ba+---------+     
get:ba|             
get:ba|  rcv FIN    
get:ba|  -------    
get:ba\ snd ACK    
get:ba------------
get:baTransmission Cont
get:baFunctional Specif
get:ba3.3.  Sequence Nu
get:baA fundamental n
get:baover a TCP conn
get:basequenced, each
get:bamechanism emplo
get:banumber X indica
get:bareceived.  This
get:badetection in th
get:bawithin a segmen
get:bathe header is t
get:banumbered consec
get:baIt is essential
get:bafinite, though 
get:baSince the space
get:banumbers must be
get:bapreserves the r
get:ba2**32 - 1 to 0 
get:baarithmetic, so 
get:bacomparison of s
get:ba(modulo 2**32).
get:baThe typical kin
get:baperform include:
get:ba(a)  Determin
get:banumber s
get:ba(b)  Determin
get:bahave bee
get:baretransm
get:ba(c)  Determin
get:bawhich ar
get:bareceive 
get:ba[Page 24]        
get:baSeptember 1981   
get:baIn response to 
get:bafollowing compa
get:baSND.UNA = old
get:baSND.NXT = nex
get:baSEG.ACK = ack
get:banum
get:baSEG.SEQ = fir
get:baSEG.LEN = the
get:ba(co
get:baSEG.SEQ+SEG.L
get:baA new acknowled
get:bathe inequality :below holds
get:baSND.UNA < SEG
get:baA segment on th
get:baof its sequence
get:baacknowledgment 
get:baWhen data is re:ceived the following comparisons are needed
get:baRCV.NXT = nex
get:bais the le
get:baRCV.NXT+RCV.W
get:basegment, 
get:baSEG.SEQ = fir
get:baSEG.SEQ+SEG.L
get:baA segment is ju
get:baRCV.NXT =< SE
get:baRCV.NXT =< SE
get:baTransmission Cont
get:baFunctional Specif
get:baThe first part 
get:basegment falls i
get:baif the end of t
get:baeither part of 
get:baActually, it is
get:bawindows and zer
get:baacceptability o:f an incoming segment
get:baSegment Recei
get:baLength  Windo
get:ba------- -----
get:ba0       0 
get:ba0      >0 
get:ba>0       0 
get:ba>0      >0 
get:baNote that when 
get:baacceptable exce
get:bamaintain a zero
get:baACKs.  However,
get:baprocess the RST
get:baWe have taken a
get:bacontrol informa
get:basome control fl
get:baand acknowledge
get:bacontrol will be
get:bacarried in the 
get:bafor implicitly 
get:baare the only co
get:baare used only a
get:bapurposes, the S
get:baoctet of the se
get:bato occur after 
get:baoccurs.  The se
get:baspace occupying
get:basequence number
get:ba[Page 26]        
get:baSeptember 1981   
get:baInitial Sequenc
get:baThe protocol pl
get:baused over and o
get:basockets.  New i
get:baincarnations of
get:ba-- "how does th
get:baincarnations of
get:baconnection is b
get:baconnection brea
get:baTo avoid confus
get:baconnection from
get:babe present in t
get:baassure this, ev
get:basequence number
get:baan initial sequ
get:banew 32 bit ISN.
get:babit clock whose
get:bamicroseconds.  
get:baSince we assume
get:bathe Maximum Seg
get:bahours we can re
get:baFor each connec
get:basequence number
get:bathe data sendin
get:balearned during 
get:baFor a connectio
get:basynchronize on 
get:baan exchange of 
get:bacalled "SYN" (f
get:bashorthand, segm
get:baHence, the solu
get:bainitial sequenc
get:baThe synchroniza
get:basequence number
get:bafrom the other 
get:bainitial sequenc
get:ba1) A --> B  S
get:ba2) A <-- B  A
get:ba3) A <-- B  S
get:ba4) A --> B  A
get:baTransmission Cont
get:baFunctional Specif
get:baBecause steps 2
get:bacalled the thre
get:baA three way han
get:batied to a globa
get:bamechanisms for 
get:bano way of knowi
get:baunless it remem
get:ba(which is not a
get:baverify this SYN
get:baclock-driven sc
get:baKnowing When to
get:baTo be sure that
get:basequence number
get:bathe network, th
get:ba(MSL) before as
get:barecovering from
get:balost.  For this
get:bais an engineeri
get:bait is desirable
get:basense, yet reta
get:banot wait at all
get:bathan those rece
get:baThe TCP Quiet T
get:baThis specific
get:baretaining any
get:baeach active (
get:baTCP segments 
get:bain the intern
get:baparagraphs be
get:baTCP implement
get:baat the risk o
get:badata rejected
get:baTCPs consume 
get:baentered into 
get:baduplicate det
get:barelies on the
get:bathe extent th
get:bavalues before
get:babeen delivere
get:bacopies of the
get:basuch an assum
get:ba[Page 28]        
get:baSeptember 1981   
get:baassigned the 
get:baat the receiv
get:bathat each seg
get:baas there are 
get:baUnder normal 
get:bato emit and t
get:bamistakenly us
get:babeen acknowle
get:badata is drain
get:bavery large to
get:bacause trouble
get:bato use up 2**
get:balifetime in t
get:bathis is deeme
get:barates escalat
get:bacycle time is
get:bawithin reason
get:baThe basic dup
get:badefeated, how
get:basequence numb
get:bathe TCP were 
get:baupon crashing
get:baconnection (p
get:bapackets with 
get:bapackets still
get:baincarnation o
get:baabout the seq
get:baspecification
get:babefore emitti
get:basegments from
get:baEven hosts wh
get:bainitial seque
get:ba(i.e., even i
get:banumber for ea
get:baSuppose, for 
get:basequence numb
get:baand that even
get:batakes on a va
get:basegment sent 
get:baat this insta
get:baincarnation o
get:baS1 = ISN(t) -
get:baconnection!  
get:baTransmission Cont
get:baFunctional Specif
get:baduplicates in
get:baof S1 may arr
get:bathe new incar
get:baThe problem i
get:bacrashed nor d
get:bathe system fr
get:baOne way to de
get:basegments for 
get:batime" specifi
get:bawilling to ri
get:badestination m
get:baImplementors 
get:baconnection by
get:bainformally im
get:baObviously, ev
get:banecessary aft
get:baTo summarize:
get:banumbers in th
get:ba"busy" or "in
get:bablock of spac
get:basegment, if a
get:basequence numb
get:bathe previous 
get:banumber overla
get:ba3.4.  Establishin
get:baThe "three-way 
get:baconnection.  Th
get:baresponded to by
get:basimultaneously 
get:baoccurs, each TC
get:baacknowledgment 
get:baan old duplicat
get:barecipient, that
get:baProper use of "
get:baSeveral example
get:baexamples do not
get:basegments, this 
get:badoesn't deliver
get:bavalid (i.e., th
get:baconnection reac
get:bareduces the pos
get:ba[Page 30]        
get:baSeptember 1981   
get:baimplementation 
get:bainformation for
get:baThe simplest th
get:bafigures should 
get:banumbered for re
get:badeparture of a 
get:basegment at B fr
get:baEllipsis (...) 
get:ba(delayed).  An 
get:baComments appear
get:bathe departure o
get:bathe center of e
get:baform, with sequ
get:bafields such as 
get:bain the interest
get:baTCP A      
get:ba1.  CLOSED     
get:ba2.  SYN-SENT   
get:ba3.  ESTABLISHED
get:ba4.  ESTABLISHED
get:ba5.  ESTABLISHED
get:baBasic 3
get:baIn line 2 of fi
get:baindicating that
get:banumber 100.  In
get:bareceived from T
get:baB is now expect
get:baoccupied sequen
get:baAt line 4, TCP 
get:baTCP B's SYN; an
get:basequence number
get:babecause the ACK
get:bawould wind up A
get:baTransmission Cont
get:baFunctional Specif
get:baSimultaneous in
get:bafigure 8.  Each
get:baTCP A      
get:ba1.  CLOSED     
get:ba2.  SYN-SENT   
get:ba3.  SYN-RECEIVE
get:ba4.             
get:ba5.  SYN-RECEIVE
get:ba6.  ESTABLISHED
get:ba7.             
get:baS
get:baThe principle r
get:baduplicate conne
get:bathis, a special
get:bareceiving TCP i
get:baSYN-RECEIVED), 
get:baIf the TCP is i
get:baFIN-WAIT-1, FIN
get:baaborts the conn
get:bacase under "hal
get:ba[Page 32]        
get:baSeptember 1981   
get:baTCP A      
get:ba1.  CLOSED     
get:ba2.  SYN-SENT   
get:ba3.  (duplicate)
get:ba4.  SYN-SENT   
get:ba5.  SYN-SENT   
get:ba6.             
get:ba7.  SYN-SENT   
get:ba8.  ESTABLISHED
get:baAs a simple exa
get:bafigure 9.  At l
get:bacannot tell tha
get:ba(line 4).  TCP 
get:baRST (reset) wit
get:babelievable.  TC
get:baWhen the origin
get:basynchronization
get:babefore the RST,
get:basent in both di
get:baHalf-Open Conne
get:baAn established 
get:baTCPs has closed
get:baknowledge of th
get:babecome desynchr
get:bamemory.  Such c
get:baattempt is made
get:baconnections are
get:bamildly involved
get:baIf at site A th
get:baTransmission Cont
get:baFunctional Specif
get:bauser at site B 
get:bareceiving a res
get:basite B TCP that
get:baAssume that two
get:baanother when a 
get:baDepending on th
get:bathat some error
get:baA is likely to 
get:bapoint.  As a re
get:baor try to SEND 
get:bacase, it receiv
get:balocal (A's) TCP
get:bawill send a seg
get:baexample shown i
get:bare-open the con
get:baTCP A      
get:ba1.  (CRASH)    
get:ba2.  CLOSED     
get:ba3.  SYN-SENT --
get:ba4.  (!!)     <-
get:ba5.  SYN-SENT --
get:ba6.  SYN-SENT   
get:ba7.  SYN-SENT --
get:baWhen the SYN ar
get:baand the incomin
get:baacknowledgment 
get:ba100).  TCP A se
get:basent and, being
get:badetected a half
get:ba[Page 34]        
get:baSeptember 1981   
get:bacontinue to try
get:bareduced to the 
get:baAn interesting 
get:batries to send d
get:baThis is illustr
get:baTCP A from TCP 
get:baexists, so TCP 
get:baprocesses it an
get:baTCP A    
get:ba1.  (CRASH)    
get:ba2.  (??)    <--
get:ba3.          -->
get:baActive
get:baIn figure 12, w
get:bawaiting for SYN
get:bainto action.  A
get:bagenerate a RST 
get:bathe reset and r
get:baTCP A      
get:ba1.  LISTEN     
get:ba2.       ... <S
get:ba3.  (??) <-- <S
get:ba4.       --> <S
get:ba5.  LISTEN     
get:baOld Duplic
get:baTransmission Cont
get:baFunctional Specif
get:baA variety of ot
get:baby the followin
get:baReset Generatio
get:baAs a general ru
get:bawhich apparentl
get:bamust not be sen
get:baThere are three: groups of states
get:ba1.  If the co
get:bain response t
get:baparticular, S
get:baby this means
get:baIf the incomi
get:basequence numb
get:bareset has seq
get:baof the sequen
get:baThe connectio
get:ba2.  If the co
get:baSYN-SENT, SYN
get:basomething not
get:baif an incomin
get:badoes not exac
get:baconnection, a
get:baIf our SYN ha
get:baincoming segm
get:baeither raise 
get:bathe system) o
get:baincoming segm
get:bacontinue as i
get:bacannot raise 
get:badetected in t
get:baterminated th
get:baincoming segm
get:bamatch the loc
get:bamust be sent.
get:baIf the incomi
get:basequence numb
get:bareset has seq
get:baof the sequen
get:baThe connectio
get:ba[Page 36]        
get:baSeptember 1981   
get:ba3.  If the co
get:baFIN-WAIT-1, F
get:baany unaccepta
get:baunacceptible 
get:baacknowledgmen
get:baand an acknow
get:bato be receive
get:baIf an incomin
get:baprecedence wh
get:baand precedenc
get:baconnection go
get:banumber from t
get:baReset Processin
get:baIn all states e
get:baby checking the
get:bais in the windo
get:bato an initial S
get:baacknowledges th
get:baThe receiver of
get:bareceiver was in
get:bain SYN-RECEIVED
get:bathen the receiv
get:baaborts the conn
get:bawas in any othe
get:baand goes to the
get:ba3.5.  Closing a C
get:baCLOSE is an ope
get:banotion of closi
get:bainterpretation,
get:bathe receiving s
get:bain a simplex fa
get:bauntil he is tol
get:bacould initiate 
get:baRECEIVE until s
get:bahas CLOSED.  We
get:baRECEIVEs are ou
get:bacan terminate h
get:babuffers SENT be
get:badata in return 
get:basuccessfully to
get:baTCP.  Users mus
get:bathe TCP says no
get:baTransmission Cont
get:baFunctional Specif
get:baThere are essen:tially three cases
get:ba1) The user i
get:ba2) The remote
get:ba3) Both users
get:baCase 1:  Local 
get:baIn this case,
get:baoutgoing segm
get:baaccepted by t
get:baare allowed i
get:bawill be retra
get:baboth acknowle
get:bacan ACK this 
get:basend its own 
get:baCase 2:  TCP re
get:baIf an unsolic
get:bacan ACK it an
get:bauser will res
get:bathe other TCP
get:bauntil its own
get:baconnection.  
get:bathe connectio
get:baCase 3:  both u
get:baA simultaneou
get:baFIN segments 
get:bahave been pro
get:bahas received.
get:ba[Page 38]        
get:baSeptember 1981   
get:baTCP A      
get:ba1.  ESTABLISHED
get:baFIN-WAIT-1 
get:ba3.  FIN-WAIT-2 
get:ba4.             
get:baTIME-WAIT  
get:ba5.  TIME-WAIT  
get:baCLOSED     
get:baTCP A      
get:ba1.  ESTABLISHED
get:ba2.  (Close)    
get:baFIN-WAIT-1 
get:ba3.  CLOSING    
get:ba4.  TIME-WAIT  
get:ba(2 MSL)    
get:baCLOSED     
get:baTransmission Cont
get:baFunctional Specif
get:ba3.6.  Precedence 
get:baThe intent is t
get:bawith exactly th
get:bahigher of the p
get:baThe precedence 
get:badefined in the 
get:baspecification t
get:bathe security pa
get:bauser group, and
get:baA connection at
get:balower precedenc
get:baa connection du
get:baacknowledgment 
get:baNote that TCP m
get:baprecedence will
get:basegments and po
get:baThe security pa
get:ba(the values wou
get:banon-secure envi
get:baparameters, tho
get:ba3.7.  Data Commun
get:baOnce the connec
get:baexchange of seg
get:ba(checksum test 
get:baretransmission 
get:baDuplicate segme
get:baAs discussed in
get:bacertain tests o
get:basegments to ver
get:baThe sender of d
get:bathe variable SN
get:basequence number
get:bakeeps track of 
get:bavariable SND.UN
get:basent has been a
get:baWhen the sender
get:baSND.NXT.  When 
get:basends an acknow
get:ba[Page 40]        
get:baSeptember 1981   
get:baacknowledgment 
get:bathese variables
get:baThe amount by w
get:badata in the seg
get:basegments must c
get:baThe CLOSE user 
get:baflag in an inco
get:baRetransmission 
get:baBecause of the 
get:bainternetwork sy
get:baretransmission 
get:bafor determining
get:baAn Example Re
get:baMeasure the
get:baparticular 
get:bacovers that
get:basegments re
get:baTime (RTT).:  Next compute a Smoothed Round Trip Time (SRTT) as
get:baSRTT = ( 
get:baand based o:n this, compute the retransmission timeout (RTO) as
get:baRTO = min
get:bawhere UBOUN
get:baLBOUND is a
get:baa smoothing
get:bafactor (e.g
get:baThe Communicati
get:baThe objective o
get:bato stimulate th
get:bapermit the rece
get:bathe currently k
get:baThis mechanism 
get:bathe end of urge
get:bathe receive seq
get:bamust tell the u
get:banumber catches 
get:baTransmission Cont
get:baFunctional Specif
get:bainto "normal mo
get:bais in "urgent m
get:baThe method empl
get:batransmitted.  T
get:bameaningful and 
get:bathe urgent poin
get:bano urgent data 
get:baTo send an urge
get:baoctet.  If the 
get:bathe urgent info
get:baManaging the Wi
get:baThe window sent
get:banumbers the sen
get:baprepared to acc
get:bathe currently a
get:baIndicating a la
get:baarrives than ca
get:bain excessive re
get:banetwork and the
get:batransmission of
get:babetween each ne
get:baThe mechanisms 
get:basubsequently ad
get:bathat much data.
get:badiscouraged.  T
get:bashrink the wind
get:baon the part of 
get:baThe sending TCP
get:baleast one octet
get:basending TCP mus
get:bathe window is z
get:bainterval when t
get:baguarantee that 
get:bawindow will be 
get:baWhen the receiv
get:bastill send an a
get:baand current win
get:baThe sending TCP
get:ba[Page 42]        
get:baSeptember 1981   
get:bawhich fit the c
get:baretransmission 
get:baIn a connection
get:babe carried in a
get:banumber so there
get:baorder.  This is
get:bainformation to 
get:bathe data receiv
get:bathe window info
get:baacknowledgment 
get:baequal or greate
get:baThe window mana
get:bacommunication p
get:baWindow Manage
get:baAllocating 
get:bamany small 
get:bafewer large
get:baOne suggest
get:badefer updat
get:baleast X per
get:baconnection 
get:baAnother sug
get:basegments by
get:basending dat
get:badata must b
get:baNote that t
get:baretransmiss
get:baacknowledgm
get:bawindow info
get:banew window 
get:baThe segment
get:baof transmit
get:basegment con
get:bais accepted
get:baIf the send
get:bawindow is n
get:baalternating
get:bapauses in t
get:baTransmission Cont
get:baFunctional Specif
get:baresult in b
get:babig pair. A
get:bamostly smal
get:baThe suggest
get:baactively at
get:bawindows, si
get:bato many sma
get:baThere are of co:urse two interfaces of concern
get:baand the TCP/low
get:baof the user/TCP
get:baprotocol module
get:bain detail by th
get:bacase that the l
get:bathat TCPs might
get:baUser/TCP Interf
get:baThe following
get:baat best, fict
get:bafacilities.  
get:baimplementatio
get:baTCPs must pro
get:bathat all TCP 
get:bahierarchy.  T
get:barequired of a
get:baTCP User Comm
get:baThe followi
get:bainterface. 
get:bafunction ca
get:bameant to ru
get:baThe user co
get:baTCP must pe
get:baIndividual 
get:bamay provide
get:basingle call
get:baautomatical
get:baissued by t
get:ba[Page 44]        
get:baSeptember 1981   
get:baIn providin
get:banot only ac
get:baprocesses i:t serves.  The latter consists of
get:ba(a) gener
get:baremote cl
get:ba(b) repli
get:bavarious t
get:baFormat:  
get:ba[, timeou
get:ba-> local 
get:baWe assume
get:baprocesses
get:bato use th
get:baimplement
get:bafor the s
get:balower lev
get:baresult of
get:baable to m
get:baprocess c
get:baIf the ac
get:bacall to L
get:bahave eith
get:baparticula
get:bafor any c
get:baby the su
get:baA transmi
get:bafilled in
get:baOn an act
get:basynchroni
get:baThe timeo
get:bafor all d
get:badelivered
get:bawill abor
get:baThe TCP o
get:bathe users
get:baTransmission Cont
get:baFunctional Specif
get:baprecedenc
get:baor securi
get:bathe defau
get:baTCP will 
get:basecurity/
get:bathe prece
get:barequested
get:baThe prece
get:barequested
get:barequest, 
get:baconnectio
get:bathis prec
get:baallowed t
get:baor that a
get:baA local c
get:baThe local
get:bafor the c
get:baFormat:  
get:bacount, PU
get:baThis call
get:bato be sen
get:banot been 
get:baimplement
get:baautomatic
get:baauthorize
get:baIf the PU
get:bato the re
get:basegment c
get:bathe data 
get:batransmiss
get:baIf the UR
get:bawill have
get:bathe urgen
get:bapointer i
get:babeen cons
get:bais to sti
get:baindicate 
get:ba[Page 46]        
get:baSeptember 1981   
get:badata has 
get:baTCP signa
get:baof times 
get:baurgent da
get:baIf no for
get:baconnectio
get:bahas becom
get:balocal soc
get:baforeign s
get:baforeign s
get:baknowing t
get:baHowever, 
get:babecomes s
get:baSTATUS ca
get:baimplement
get:basocket is
get:baIf a time
get:baconnectio
get:baIn the si
get:bathe sendi
get:baor the ti
get:bais both s
get:baconnectio
get:baoffers po
get:basophistic
get:bathe proce
get:bafurthermo
get:baMultiple 
get:bathe TCP w
get:baWe have i
get:bawhich a S
get:bapseudo-in
get:bareturn a 
get:baimmediate
get:babeen ackn
get:baassume ev
get:baclose any
get:bakind (syn
get:basignals, 
get:bawith spec
get:baIn order 
get:baindicatio
get:baTransmission Cont
get:baFunctional Specif
get:babuffer ad
get:bathe SEND 
get:baindicatin
get:bacalling p
get:baFormat:  
get:bacount) ->
get:baThis comm
get:baspecified
get:bacalling p
get:baerror is 
get:baIn the si
get:bacalling p
get:baerror occ
get:baA more so
get:baRECEIVEs 
get:basegments 
get:bathe cost 
get:banotify th
get:baIf enough
get:bathe PUSH 
get:baThe buffe
get:baa PUSH is
get:bareturned 
get:baIf there 
get:baas it arr
get:bashould th
get:baadditiona
get:bacall to R
get:bamay now l
get:baurgent po
get:bain the sa
get:baboundary 
get:baTo distin
get:bacare of t
get:bareturn co
get:bacount ind
get:baAlternati
get:ba[Page 48]        
get:baSeptember 1981   
get:baallocate 
get:bawith the 
get:baFormat:  
get:baThis comm
get:bathe conne
get:baauthorize
get:baClosing c
get:bathe sense
get:baretransmi
get:baserviced.
get:bacalls, fo
get:bato the de
get:bacontinue 
get:bamay be tr
get:bameans "I 
get:bareceive a
get:banot well 
get:baof all it
get:bainto ABOR
get:baThe user 
get:bainitiativ
get:ba(e.g., re
get:badestinati
get:baBecause c
get:baforeign T
get:bashort tim
get:bareplies t
get:baClose als
get:baFormat:  
get:baThis is a
get:baexcluded 
get:batypically
get:baThis comm
get:bainformati:on
get:balocal s
get:baTransmission Cont
get:baFunctional Specif
get:baforeign
get:balocal c
get:bareceive
get:basend wi
get:baconnect
get:banumber 
get:banumber 
get:baurgent 
get:baprecede
get:basecurit
get:baand tra
get:baDepending
get:baimplement
get:baavailable
get:baauthorize
get:baprevents 
get:baconnectio
get:baFormat:  
get:baThis comm
get:baaborted, 
get:babe sent t
get:baDepending
get:baindicatio
get:bareceive a
get:baTCP-to-User M
get:baIt is assum
get:bameans for t
get:bathe TCP doe
get:bato the user
get:baan error me
get:barelating to
get:baother user 
get:baThe followi:ng information is provided
get:baLocal Con
get:baResponse 
get:baBuffer Ad
get:baByte coun
get:baPush flag
get:baUrgent fl
get:ba[Page 50]        
get:baSeptember 1981   
get:baTCP/Lower-Level
get:baThe TCP calls
get:bareceive infor
get:bainternetwork 
get:baProtocol (IP)
get:baIf the lower 
get:baof service an
get:bafor these par:ameters
get:baType of Ser:vice = Precedence: routine, Delay: normal, Throughput
get:banormal, Rel:iability
get:baTime to Liv
get:baNote that
get:baHere we e
get:babe delive
get:baIf the lower 
get:bafeature) and 
get:baroute informa
get:baso that the s
get:bachecksum be t
get:baalso importan
get:baAny lower lev
get:badestination a
get:bathe "TCP leng
get:baof IP and to 
get:baTransmission Cont
get:baFunctional Specif
get:ba3.9.  Event Proce
get:baThe processing 
get:baimplementation.
get:baprocessing sequ
get:basection only in
get:baThe activity of
get:baThe events that: occur can be cast into three categories
get:baarriving segmen
get:baprocessing the 
get:bacases the proce
get:baEvents that o:ccur
get:baArriving Se
get:baSEGMENT A
get:baUSER TIME
get:baRETRANSMI
get:baTIME-WAIT
get:baThe model of th
get:baimmediate retur
get:bapseudo interrup
get:bameans cause a d
get:baError responses
get:bacommands refere:ncing connections that do not exist receive "error
get:baconnection not 
get:baPlease note in 
get:baacknowledgment 
get:baof the sequence
get:baequal to (modul
get:ba[Page 52]        
get:baSeptember 1981   
get:baA natural way t
get:baimagine that th
get:bathat their cont
get:bain the sequence
get:baand processed i
get:baWhen a segment 
get:bathe segment to 
get:bato be consisten
get:baNote that if no
get:baTransmission Cont
get:baFunctional Specif
get:baCLOSED STATE 
get:baCreate a ne
get:bastate infor
get:basocket, pre
get:bainformation
get:baunspecified
get:baparameters 
get:baprecedence 
get:ba"error:  pr:ecedence not allowed" or "error
get:banot allowed
get:baactive and :the foreign socket is unspecified, return "error
get:baforeign soc
get:baspecified, 
get:ba(ISS) is se
get:bais sent.  S
get:bastate, and 
get:baIf the call
get:bareturn "err:or
get:bano room to :create a new connection, return "error
get:baresources".
get:baIf active a
get:baconnection 
get:basegment, se
get:bastate.  Dat
get:baqueued for 
get:baurgent bit 
get:basegments se
get:baqueue the r:equest, respond with "error
get:baIf Foreign :socket was not specified, then return "error
get:basocket unsp
get:ba[Page 54]        
get:baSeptember 1981   
get:baSYN-SENT STAT
get:baSYN-RECEIVED 
get:baESTABLISHED S
get:baFIN-WAIT-1 ST
get:baFIN-WAIT-2 ST
get:baCLOSE-WAIT ST
get:baCLOSING STATE
get:baLAST-ACK STAT
get:baTIME-WAIT STA
get:baReturn "err:or
get:baTransmission Cont
get:baFunctional Specif
get:baCLOSED STATE 
get:baIf the user
get:ba"error:  co
get:baOtherwise, :return "error
get:baIf the fore
get:bafrom passiv
get:baSND.UNA to 
get:baassociated 
get:batransmissio
get:barequested i
get:baas a result
get:barequest, re:spond with "error
get:baForeign soc:ket was not specified, then return "error
get:basocket unsp
get:baSYN-SENT STAT
get:baSYN-RECEIVED 
get:baQueue the d
get:baIf no space: to queue, respond with "error
get:baresources".
get:baESTABLISHED S
get:baCLOSE-WAIT ST
get:baSegmentize 
get:baacknowledgm
get:bainsufficien:t space to remember this buffer, simply return "error
get:bainsufficien
get:baIf the urge
get:baurgent poin
get:ba[Page 56]        
get:baSeptember 1981   
get:baFIN-WAIT-1 ST
get:baFIN-WAIT-2 ST
get:baCLOSING STATE
get:baLAST-ACK STAT
get:baTIME-WAIT STA
get:baReturn "err:or
get:baTransmission Cont
get:baFunctional Specif
get:baCLOSED STATE 
get:baIf the user
get:ba"error:  co
get:baOtherwise r:eturn "error
get:baSYN-SENT STAT
get:baSYN-RECEIVED 
get:baQueue for p
get:bais no room :to queue this request, respond with "error
get:bainsufficien
get:baESTABLISHED S
get:baFIN-WAIT-1 ST
get:baFIN-WAIT-2 ST
get:baIf insuffic
get:barequest, qu
get:baremember th:e RECEIVE, respond with "error
get:baresources".
get:baReassemble 
get:bato user.  M
get:baIf RCV.UP i
get:bauser notify
get:baWhen the TC
get:bathat fact m
get:baacknowledgm
get:badescribed b
get:ba[Page 58]        
get:baSeptember 1981   
get:baCLOSE-WAIT ST
get:baSince the r
get:basatisfied b
get:bauser.  If n
get:ba"error:  co
get:batext can be
get:baCLOSING STATE
get:baLAST-ACK STAT
get:baTIME-WAIT STA
get:baReturn "err:or
get:baTransmission Cont
get:baFunctional Specif
get:baCLOSED STATE 
get:baIf the user
get:ba"error:  co
get:baOtherwise, :return "error
get:baAny outstan:ding RECEIVEs are returned with "error
get:baresponses. 
get:baSYN-SENT STAT
get:baDelete the :TCB and return "error
get:baqueued SEND
get:baSYN-RECEIVED 
get:baIf no SENDs
get:bathen form a
get:baotherwise q
get:baESTABLISHED S
get:baQueue this 
get:baform a FIN 
get:baFIN-WAIT-1 ST
get:baFIN-WAIT-2 ST
get:baStrictly sp:eaking, this is an error and should receive a "error
get:baconnection 
get:baacceptable,
get:baFIN may be 
get:ba[Page 60]        
get:baSeptember 1981   
get:baCLOSE-WAIT ST
get:baQueue this 
get:basegmentized
get:baCLOSING STATE
get:baLAST-ACK STAT
get:baTIME-WAIT STA
get:baRespond wit:h "error
get:baTransmission Cont
get:baFunctional Specif
get:baCLOSED STATE 
get:baIf the user
get:ba"error:  co
get:baOtherwise r:eturn "error
get:baAny outstan:ding RECEIVEs should be returned with "error
get:baconnection 
get:baSYN-SENT STAT
get:baAll queued 
get:banotificatio
get:baSYN-RECEIVED 
get:baESTABLISHED S
get:baFIN-WAIT-1 ST
get:baFIN-WAIT-2 ST
get:baCLOSE-WAIT ST
get:baSend a rese:t segment
get:ba<SEQ=SND.
get:baAll queued 
get:banotificatio
get:baRST formed 
get:baTCB, enter 
get:baCLOSING STATE
get:baLAST-ACK STAT
get:baTIME-WAIT STA
get:baRespond wit
get:ba[Page 62]        
get:baSeptember 1981   
get:baCLOSED STATE 
get:baIf the user
get:ba"error:  co
get:baOtherwise r:eturn "error
get:baReturn "sta
get:baSYN-SENT STAT
get:baReturn "sta
get:baSYN-RECEIVED 
get:baReturn "sta
get:baESTABLISHED S
get:baReturn "sta
get:baFIN-WAIT-1 ST
get:baReturn "sta
get:baFIN-WAIT-2 ST
get:baReturn "sta
get:baCLOSE-WAIT ST
get:baReturn "sta
get:baCLOSING STATE
get:baReturn "sta
get:baLAST-ACK STAT
get:baReturn "sta
get:baTransmission Cont
get:baFunctional Specif
get:baTIME-WAIT STA
get:baReturn "sta
get:ba[Page 64]        
get:baSeptember 1981   
get:baSEGMENT ARRIVES
get:baIf the state 
get:baall data in
get:basegment con
get:bacontaining 
get:baacknowledgm
get:bareset seque
get:baIf the ACK 
get:ba<SEQ=0><A
get:baIf the ACK 
get:ba<SEQ=SEG.
get:baIf the state 
get:bafirst check
get:baAn incomi
get:basecond chec
get:baAny ackno
get:bathe LISTE
get:bafor any a
get:baformatted: as follows
get:ba<SEQ=SE
get:bathird check
get:baIf the SY
get:basecurity/
get:bamatch the
get:ba<SEQ=SE
get:baTransmission Cont
get:baFunctional Specif
get:baIf the SE
get:bathe user 
get:basend a re
get:ba<SEQ=SE
get:baIf the SE
get:baSet RCV.N
get:bacontrol o
get:bashould be: selected and a SYN segment sent of the form
get:ba<SEQ=IS
get:baSND.NXT i
get:bastate sho
get:baincoming 
get:bain the SY
get:banot be re
get:bathe forei
get:baunspecifi
get:bafourth othe
get:baAny other
get:bamust have
get:baprocessin
get:bait could 
get:baincarnati
get:babut if yo
get:baIf the state 
get:bafirst check
get:baIf the AC
get:baIf SEG.
get:bathe RST
get:ba<SEQ=
get:baand dis
get:baIf SND.
get:basecond chec
get:ba[Page 66]        
get:baSeptember 1981   
get:baIf the RS
get:baIf the :ACK was acceptable then signal the user "error
get:baconnect
get:badelete 
get:baand ret
get:bathird check
get:baIf the se
get:bamatch the
get:baIf ther
get:ba<SEQ=
get:baOtherwi
get:ba<SEQ=
get:baIf there 
get:baThe pre
get:baTCB, if
get:ba<SEQ=
get:baIf there 
get:baIf the 
get:bain the 
get:bathe pre
get:baallowed
get:ba<SEQ=
get:baIf the 
get:bain the 
get:baIf a rese
get:bafourth chec
get:baThis step
get:bano ACK, a
get:baIf the SY
get:baTransmission Cont
get:baFunctional Specif
get:baare accep
get:baSEG.SEQ. 
get:bais an ACK
get:baare there
get:baIf SND.UN
get:bastate to 
get:ba<SEQ=SN
get:baand send 
get:batransmiss
get:batext in t
get:babelow whe
get:baOtherwise
get:ba<SEQ=IS
get:baand send 
get:basegment, 
get:bahas been 
get:bafifth, if n
get:basegment and
get:ba[Page 68]        
get:baSeptember 1981   
get:bafirst check s
get:baSYN-RECEIVE
get:baESTABLISHED
get:baFIN-WAIT-1 
get:baFIN-WAIT-2 
get:baCLOSE-WAIT 
get:baCLOSING STA
get:baLAST-ACK ST
get:baTIME-WAIT S
get:baSegments 
get:baare used 
get:badone in S
get:baboundary 
get:baprocessed
get:baThere are
get:basegment
get:baSegment R
get:baLength  W
get:ba------- -
get:ba0     
get:ba0     
get:ba>0     
get:ba>0     
get:baIf the RC
get:baspecial a
get:baIf an inc
get:bashould be
get:bathe segme:nt and return)
get:ba<SEQ=SN
get:baAfter sen
get:baand retur
get:baTransmission Cont
get:baFunctional Specif
get:baIn the fo
get:basegment t
get:baOne could
get:batrimming 
get:baSYN and F
get:babegins at
get:banumbers m
get:basecond check 
get:baSYN-RECEIVE
get:baIf the RS
get:baIf this
get:bacame fr
get:baLISTEN 
get:bathis co
get:bafrom SY
get:bathe use
get:baon the 
get:baactive 
get:baand ret
get:baESTABLISHED
get:baIf the RS
get:bashould re
get:baflushed. 
get:ba"connecti
get:baTCB, and 
get:baCLOSING STA
get:baLAST-ACK ST
get:baIf the RS
get:baTCB, and 
get:ba[Page 70]        
get:baSeptember 1981   
get:bathird check s
get:baSYN-RECEIVE
get:baIf the se
get:baexactly m
get:bathen send
get:baESTABLISHED
get:baIf the se
get:baexactly m
get:bathen send
get:bareceive "
get:baflushed. 
get:ba"connecti
get:baTCB, and 
get:baNote this c
get:baa segment f
get:badifferent s
get:bacurrent con
get:bafourth, check
get:baSYN-RECEIVE
get:baESTABLISHED
get:baFIN-WAIT ST
get:baFIN-WAIT ST
get:baCLOSE-WAIT 
get:baCLOSING STA
get:baLAST-ACK ST
get:baTIME-WAIT S
get:baIf the SY
get:baoutstandi
get:baall segme
get:bareceive a
get:bathe CLOSE
get:baIf the SY
get:baand an ac
get:banumber ch
get:baTransmission Cont
get:baFunctional Specif
get:bafifth check t
get:baif the ACK 
get:baif the ACK 
get:baSYN-RECEI
get:baIf SND.
get:baand con
get:baIf th
get:bareset
get:ba<SE
get:baand s
get:baESTABLISH
get:baIf SND.
get:baAny seg
get:baentirel
get:bapositiv
get:bafully a
get:ba"ok" re
get:ba(SEG.AC
get:basomethi
get:badrop th
get:baIf SND.
get:baupdated
get:baSND.WL2
get:baSND.WL1
get:baNote th
get:barecords
get:baSND.WND
get:bathe las
get:baprevent
get:ba[Page 72]        
get:baSeptember 1981   
get:baFIN-WAIT-
get:baIn addi
get:baour FIN
get:baprocess
get:baFIN-WAIT-
get:baIn addi
get:bathe ret
get:baacknowl
get:baCLOSE-WAI
get:baDo the 
get:baCLOSING S
get:baIn addi
get:bathe ACK
get:baotherwi
get:baLAST-ACK 
get:baThe onl
get:baacknowl
get:badelete 
get:baTIME-WAIT
get:baThe onl
get:baretrans
get:bathe 2 M
get:basixth, check 
get:baESTABLISHED
get:baFIN-WAIT-1 
get:baFIN-WAIT-2 
get:baIf the UR
get:bathe user 
get:bapointer (
get:bauser has 
get:bamode") fo
get:basignal th
get:baTransmission Cont
get:baFunctional Specif
get:baCLOSE-WAIT 
get:baCLOSING STA
get:baLAST-ACK ST
get:baThis shou
get:baremote si
get:baseventh, proc
get:baESTABLISHED
get:baFIN-WAIT-1 
get:baFIN-WAIT-2 
get:baOnce in t
get:batext to u
get:bainto buff
get:baempty.  I
get:bathe user 
get:bahas been 
get:baWhen the 
get:bauser it m
get:baOnce the 
get:baRCV.NXT o
get:baapporopri
get:baRCV.NXT a
get:baPlease no
get:baSend an a:cknowledgment of the form
get:ba<SEQ=SN
get:baThis ackn
get:batransmitt
get:ba[Page 74]        
get:baSeptember 1981   
get:baCLOSE-WAIT 
get:baCLOSING STA
get:baLAST-ACK ST
get:baTIME-WAIT S
get:baThis shou
get:baremote si
get:baeighth, check
get:baDo not proc
get:basince the S
get:baIf the FIN 
get:bareturn any 
get:baover the FI
get:baFIN implies
get:baSYN-RECEI
get:baESTABLISH
get:baEnter t
get:baFIN-WAIT-
get:baIf our 
get:baenter T
get:batimers;
get:baFIN-WAIT-
get:baEnter t
get:baoff the
get:baCLOSE-WAI
get:baRemain 
get:baCLOSING S
get:baRemain 
get:baLAST-ACK 
get:baRemain 
get:baTransmission Cont
get:baFunctional Specif
get:baTIME-WAIT
get:baRemain 
get:batimeout
get:ba[Page 76]        
get:baSeptember 1981   
get:baFor any state
get:bathe user "err:or
get:baand for any o
get:bastate and ret
get:baRETRANSMISSION 
get:baFor any state
get:bathe retransmi
get:baretransmissio
get:baTIME-WAIT TIMEO
get:baIf the time-w
get:baenter the CLO
get:baTransmission Cont
get:ba[Page 78]        
get:baSeptember 1981   
get:baBBN Rep
get:baa Host 
get:bahost an
get:baA contr
get:baindicat
get:baspecifi
get:bais expe
get:bapreviou
get:baThe uni
get:baARPANET
get:baA unit 
get:baIMPs.  
get:baA logic
get:baA messa
get:banetwork
get:baDestination Addre
get:baThe des
get:baidentif
get:baA contr
get:baindicat
get:baoccupyi
get:baA porti
get:bafragmen
get:baA file 
get:baTransmission Cont
get:baControl
get:bafragmen
get:baA compu
get:bafrom th
get:baAn Inte
get:baby the 
get:baThe Int
get:baARPANET
get:baA sourc
get:bainternet datagram
get:baThe uni
get:bahigher 
get:bainternet fragment
get:baA porti
get:baheader.
get:baInterne
get:baThe Ini
get:banumber 
get:baThe Ini
get:baon a co
get:babased p
get:baThe Ini
get:baused by
get:baControl
get:badata.  
get:baon an A
get:ba[Page 80]        
get:baSeptember 1981   
get:baThis is
get:badata re
get:basequenc
get:baof the 
get:baThe uni
get:baAn impl
get:baprocedu
get:baMaximum
get:bathe int
get:baAn eigh
get:baAn Opti
get:bamay be 
get:baprimari
get:batimesta
get:baoptions
get:baA packa
get:balogical
get:balogical
get:baThe por
get:baoutput 
get:baA progr
get:bathe poi
get:baA contr
get:bathis se
get:bareceivi
get:bareceive
get:baTransmission Cont
get:bareceive
get:RFC
get:De
get:I
get:September 1981   
get:PREFACE .....
get:1.  INTRODUCTION 
get:1.1  Motivation
get:1.2  Scope ....
get:1.3  About This
get:1.4  Interfaces
get:1.5  Operation 
get:2.  PHILOSOPHY ..
get:2.1  Elements o
get:2.2  Model of O
get:2.3  The Host E
get:2.4  Interfaces
get:2.5  Relation t
get:2.6  Reliable C
get:2.7  Connection
get:2.8  Data Commu
get:2.9  Precedence
get:2.10 Robustness
get:3.  FUNCTIONAL SP
get:3.1  Header For
get:3.2  Terminolog
get:3.3  Sequence N
get:3.4  Establishi
get:3.5  Closing a 
get:3.6  Precedence
get:3.7  Data Commu
get:3.8  Interfaces
get:3.9  Event Proc
get:GLOSSARY ........
get:REFERENCES ......
get:Transmission Cont
get:[Page ii]        
get:September 1981   
get:This document des
get:(TCP).  There hav
get:specification on 
get:draws heavily fro
get:both in terms of 
get:several details a
get:and redescribes t
get:RFC
get:Replaces: RFC 761
get:IENs:  129, 124, 
get:55, 44, 40, 27, 2
get:The Transmission 
get:reliable host-to-
get:communication net
get:This document des
get:Transmission Cont
get:interface to prog
get:Computer commun
get:role in militar
get:document focuse
get:communication r
get:communication u
get:congestion, but
get:government sect
get:As strategic an
get:developed and d
get:interconnecting
get:communication p
get:applications.  
get:Deputy Undersec
get:declared the Tr
get:be a basis for 
get:standardization
get:TCP is a connec
get:fit into a laye
get:applications.  
get:communication b
get:distinct but in
get:assumptions are
get:protocols below
get:potentially unr
get:protocols.  In 
get:wide spectrum o
get:connections to 
get:Transmission Cont
get:TCP is based on
get:TCP fits into a
get:Internet Protoc
get:receive variabl
get:datagram "envel
get:addressing sour
get:internet protoc
get:the TCP segment
get:multiple networ
get:also carries in
get:and compartment
get:communicated en
get:Much of this do
get:which are co-re
get:computer.  Some
get:front-end compu
get:as well as netw
get:an interface to
get:implementable e
get:host-to-front e
get:The TCP is inte
get:communication s
get:intended to be 
get:1.3.  About this 
get:This document r
get:any TCP impleme
get:protocols and i
get:[Page 2]         
get:September 1981   
get:section offers 
get:operation.  Sec
get:design.  Sectio
get:required of TCP
get:user calls, err
get:The TCP interfa
get:the other side 
get:The interface b
get:illustrated in 
get:calls much like
get:application pro
get:calls to open a
get:established con
get:asynchronously 
get:considerable fr
get:interfaces whic
get:environment, a 
get:interface for a
get:The interface b
get:unspecified exc
get:two levels can 
get:Typically, one 
get:interface.  TCP
get:interconnected 
get:throughout this
get:As noted above,
get:securable logic
get:processes.  To 
get:communication s:ystem requires facilities in the following areas
get:Basic Data Tr
get:Precedence an
get:The basic opera
get:the following p
get:Transmission Cont
get:Basic Data Tran:sfer
get:The TCP is ab
get:direction bet
get:segments for 
get:the TCPs deci
get:Sometimes use
get:submitted to 
get:function is d
get:actually tran
get:pushed throug
get:promptly forw
get:The exact pus
get:the push func
get:Reliability
get:The TCP must 
get:delivered out
get:is achieved b
get:transmitted, 
get:receiving TCP
get:interval, the
get:numbers are u
get:out of order 
get:adding a chec
get:receiver, and
get:As long as th
get:system does n
get:errors will a
get:internet comm
get:Flow Control
get:TCP provides 
get:sent by the s
get:every ACK ind
get:the last segm
get:allowed numbe
get:receiving fur
get:[Page 4]         
get:September 1981   
get:Multiplexing
get:To allow for 
get:communication
get:addresses or 
get:and host addr
get:a socket.  A 
get:That is, a so
get:The binding o
get:Host.  Howeve
get:(e.g., a "log
get:made known to
get:through the k
get:addresses of 
get:Connections
get:The reliabili
get:that TCPs ini
get:each data str
get:sockets, sequ
get:Each connecti
get:identifying i
get:When two proc
get:establish a c
get:side).  When 
get:terminated or
get:Since connect
get:over the unre
get:mechanism wit
get:erroneous ini
get:Precedence and :Security
get:The users of 
get:communication
get:these feature
get:Transmission Cont
get:[Page 6]         
get:September 1981   
get:2.1.  Elements of
get:The internetwor
get:which are in tu
get:that the networ
get:large networks 
get:packet switchin
get:consume message
get:networks, the g
get:communication s
get:connections bet
get:The term packet
get:transaction bet
get:exchanged withi
get:Hosts are compu
get:network's point
get:Processes are v
get:accordance with
get:in execution). 
get:viewed as commu
get:Thus, all commu
get:Since a process
get:streams between
get:that each proce
get:communicates wi
get:2.2.  Model of Op
get:Processes trans
get:data as argumen
get:segments and ca
get:the destination
get:into the receiv
get:TCPs include co
get:ensure reliable
get:The model of in
get:protocol module
get:to the local ne
get:inside internet
get:internet module
get:through the loc
get:The packet swit
get:Transmission Cont
get:other operation
get:destination int
get:At a gateway be
get:from its local 
get:the internet da
get:then "wrapped" 
get:routed to the n
get:A gateway is pe
get:internet datagr
get:through the nex
get:internet datagr
get:further broken 
get:internet datagr
get:internet module
get:A destination i
get:(after reassemb
get:destination TCP
get:This simple mod
get:important featu
get:to the gateway 
get:service paramet
get:Included in the
get:datagram.  Data
get:host and gatewa
get:properly segreg
get:2.3.  The Host En
get:The TCP is assu
get:access the TCP 
get:may call on oth
get:data structures
get:controlled by a
get:network device 
get:datagram protoc
get:The mechanisms 
get:front-end proce
get:host-to-front-e
get:the type of TCP
get:[Page 8]         
get:September 1981   
get:The TCP/user in
get:to OPEN or CLOS
get:STATUS about a 
get:programs on the
get:from, and close
get:The TCP/interne
get:datagrams addre
get:system.  These 
get:service, preced
get:2.5.  Relation to
get:The following d
get:hierarchy
get:+------+ +
get:|Telnet| |
get:+------+ +
get:|   
get:+----
get:| TCP
get:+----
get:| 
get:+----
get:|    
get:+----
get:+--
get:|  
get:+--
get:It is expected 
get:protocols effic
get:protocols like 
get:2.6.  Reliable Co
get:A stream of dat
get:order at the de
get:Transmission Cont
get:Transmission is
get:acknowledgments
get:sequence number
get:segment is tran
get:sequence number
get:is the sequence
get:transmissions i
get:segment contain
get:starts a timer;
get:segment is dele
get:received before
get:An acknowledgme
get:delivered to th
get:the responsibil
get:To govern the f
get:employed.  The 
get:This window spe
get:acknowledgment 
get:2.7.  Connection 
get:To identify the
get:provides a port
get:independently b
get:unique addresse
get:identifying the
get:will be unique 
get:A connection is
get:local socket ma
get:sockets.  A con
get:that is, it is 
get:TCPs are free t
get:However, severa
get:There must be w
get:the "appropriat
get:may "own" ports
get:the ports they 
get:issue, but we e
get:uniquely alloca
get:associating the
get:A connection is
get:foreign socket 
get:[Page 10]        
get:September 1981   
get:connection name
get:subsequent call
get:about a connect
get:is a data struc
get:implementation 
get:pointer to the 
get:whether the con
get:be passively wa
get:A passive OPEN 
get:connection requ
get:Often the proce
get:request from an
get:is used to deno
get:are allowed onl
get:A service proce
get:processes would
get:foreign socket.
get:requested a con
get:local socket we
get:Well-known sock
get:a socket addres
get:"Telnet-Server"
get:socket, and oth
get:Entry, Text Gen
get:being for test 
get:access to a "Lo
get:at which a newl
get:well-known sock
get:of sockets to s
get:Processes can i
get:from other proc
get:been establishe
get:other at the sa
get:is critical for
get:components act 
get:There are two p
get:passive OPENs a
get:local passive O
get:case, the match
get:OPENs has left 
get:foreign socket 
get:Other possibili
get:Transmission Cont
get:If there are se
get:same local sock
get:with the specif
get:TCB exists, bef
get:The procedures 
get:control flag an
get:exchange has be
get:A connection is
get:containing a SY
get:command.  The m
get:connection has 
get:when sequence n
get:The clearing of
get:in this case ca
get:2.8.  Data Commun
get:The data that f
get:octets.  The se
get:in that call (a
get:through to the 
get:A sending TCP i
get:send that data 
get:function is sig
get:receiving TCP s
get:the sending TCP
get:There is no nec
get:boundaries.  Th
get:single SEND cal
get:The purpose of 
get:from the sendin
get:record service.
get:There is a coup
get:of data that cr
get:associated with
get:buffer is retur
get:not filled.  If
get:PUSH is seen, t
get:TCP also provid
get:at some point f
get:[Page 12]        
get:September 1981   
get:currently readi
get:define what the
get:urgent data, bu
get:take action to 
get:2.9.  Precedence 
get:The TCP makes u
get:security option
get:basis to TCP us
get:a multilevel se
get:use only, and o
get:compartment.  C
get:users may be li
get:TCP modules whi
get:properly mark o
get:precedence.  Su
get:higher level pr
get:them to specify
get:precedence of c
get:2.10.  Robustness
get:TCP implementat:ions will follow a general principle of robustness
get:conservative in
get:Transmission Cont
get:[Page 14]        
get:September 1981   
get:3.1.  Header Form
get:TCP segments ar
get:header carries 
get:destination hos
get:header, supplyi
get:division allows
get:TCP Header Form
get:0            
get:0 1 2 3 4 5 6
get:+-+-+-+-+-+-+-
get:|          Sou
get:+-+-+-+-+-+-+-
get:|             
get:+-+-+-+-+-+-+-
get:|             
get:+-+-+-+-+-+-+-
get:|  Data |     
get:| Offset| Rese
get:|       |     
get:+-+-+-+-+-+-+-
get:|           Ch
get:+-+-+-+-+-+-+-
get:|             
get:+-+-+-+-+-+-+-
get:|             
get:+-+-+-+-+-+-+-
get:Note th
get:Source Port:  1
get:The source po
get:Destination Por:t
get:The destinati
get:Transmission Cont
get:Functional Specif
get:Sequence Number:
get:The sequence 
get:when SYN is p
get:initial seque
get:Acknowledgment :Number
get:If the ACK co
get:next sequence
get:receive.  Onc
get:Data Offset:  4
get:The number of
get:the data begi
get:integral numb
get:Reserved:  6 bi
get:Reserved for 
get:Control Bits:  :6 bits (from left to right)
get:URG:  Urgent 
get:ACK:  Acknowl
get:PSH:  Push Fu
get:RST:  Reset t
get:SYN:  Synchro
get:FIN:  No more
get:Window:  16 bit
get:The number of
get:acknowledgmen
get:Checksum:  16 b
get:The checksum 
get:complement su
get:segment conta
get:checksummed, 
get:form a 16 bit
get:transmitted a
get:the checksum 
get:The checksum 
get:[Page 16]        
get:September 1981   
get:prefixed to t
get:Address, the 
get:This gives th
get:information i
get:across the TC
get:calls by the 
get:The TCP Len
get:octets (thi
get:computed), 
get:Urgent Pointer:
get:This field co
get:positive offs
get:urgent pointe
get:the urgent da
get:the URG contr
get:Options:  varia
get:Options may o
get:multiple of 8
get:checksum.  An
get:cases for the: format of an option
get:Case 1:  A 
get:Case 2:  An
get:th
get:The option-le
get:option-length
get:Note that the
get:field might i
get:End-of-Option
get:A TCP must im
get:Transmission Cont
get:Functional Specif
get:Currently def:ined options include (kind indicated in octal)
get:Kind     Le
get:----     --
get:0         
get:1         
get:2         
get:Specific Opti
get:End of Opti
get:+--------
get:|00000000
get:+--------
get:This opti
get:might not
get:the Data 
get:not the e
get:the optio
get:No-Operatio
get:+--------
get:|00000001
get:+--------
get:This opti
get:align the
get:There is 
get:receivers
get:not begin
get:Maximum Seg
get:+--------
get:|00000010
get:+--------
get:Kind=2  
get:[Page 18]        
get:September 1981   
get:Maximum S:egment Size Option Data
get:If this
get:receive
get:This fi
get:(i.e., 
get:option 
get:Padding:  varia
get:The TCP heade
get:and data begi
get:3.2.  Terminology
get:Before we can d
get:to introduce so
get:connection requ
get:of these variab
get:Transmission Co
get:TCB are the loc
get:precedence of t
get:buffers, pointe
get:In addition sev
get:sequence number
get:Send Sequence
get:SND.UNA - s
get:SND.NXT - s
get:SND.WND - s
get:SND.UP  - s
get:SND.WL1 - s
get:SND.WL2 - s
get:u
get:ISS     - i
get:Receive Seque
get:RCV.NXT - r
get:RCV.WND - r
get:RCV.UP  - r
get:IRS     - i
get:Transmission Cont
get:Functional Specif
get:The following d
get:the sequence sp
get:Send Sequence S
get:---
get:1 - old s
get:2 - seque
get:3 - seque
get:4 - futur
get:The send window
get:Receive Sequenc
get:1 - old s
get:2 - seque
get:3 - futur
get:The receive win
get:There are also 
get:take their valu
get:[Page 20]        
get:September 1981   
get:Current Segme
get:SEG.SEQ - s
get:SEG.ACK - s
get:SEG.LEN - s
get:SEG.WND - s
get:SEG.UP  - s
get:SEG.PRC - s
get:A connection pr
get:lifetime.  The :states are
get:ESTABLISHED, FI
get:TIME-WAIT, and 
get:because it repr
get:no connection. : Briefly the meanings of the states are
get:LISTEN - repr
get:TCP and port.
get:SYN-SENT - re
get:after having 
get:SYN-RECEIVED 
get:request ackno
get:connection re
get:ESTABLISHED -
get:delivered to 
get:of the connec
get:FIN-WAIT-1 - 
get:from the remo
get:termination r
get:FIN-WAIT-2 - 
get:from the remo
get:CLOSE-WAIT - 
get:from the loca
get:CLOSING - rep
get:acknowledgmen
get:LAST-ACK - re
get:connection te
get:(which includ
get:Transmission Cont
get:Functional Specif
get:TIME-WAIT - r
get:the remote TC
get:termination r
get:CLOSED - repr
get:A TCP connectio
get:events.  The ev
get:ABORT, and STAT
get:containing the 
get:The state diagr
get:with the causin
get:error condition
get:changes.  In a 
get:the reaction of
get:NOTE BENE:  thi
get:the total speci
get:[Page 22]        
get:September 1981   
get:+---------+     
get:|         |<----
get:|   SYN   |     
get:|   RCVD  |<----
get:|         |     
get:|         |-----
get:+---------+   rc
get:|           --
get:|             
get:|             
get:|  CLOSE      
get:| -------     
get:| snd FIN     
get:|             
get:V             
get:+---------+     
get:|  FIN    |<----
get:| WAIT-1  |-----
get:+---------+     
get:| rcv ACK of F
get:| ------------
get:V        x    
get:+---------+     
get:|FINWAIT-2|     
get:+---------+     
get:|             
get:|  rcv FIN    
get:|  -------    
get:\ snd ACK    
get:------------
get:Transmission Cont
get:Functional Specif
get:3.3.  Sequence Nu
get:A fundamental n
get:over a TCP conn
get:sequenced, each
get:mechanism emplo
get:number X indica
get:received.  This
get:detection in th
get:within a segmen
get:the header is t
get:numbered consec
get:It is essential
get:finite, though 
get:Since the space
get:numbers must be
get:preserves the r
get:2**32 - 1 to 0 
get:arithmetic, so 
get:comparison of s
get:(modulo 2**32).
get:The typical kin
get:perform include:
get:(a)  Determin
get:number s
get:(b)  Determin
get:have bee
get:retransm
get:(c)  Determin
get:which ar
get:receive 
get:[Page 24]        
get:September 1981   
get:In response to 
get:following compa
get:SND.UNA = old
get:SND.NXT = nex
get:SEG.ACK = ack
get:num
get:SEG.SEQ = fir
get:SEG.LEN = the
get:(co
get:SEG.SEQ+SEG.L
get:A new acknowled
get:the inequality :below holds
get:SND.UNA < SEG
get:A segment on th
get:of its sequence
get:acknowledgment 
get:When data is re:ceived the following comparisons are needed
get:RCV.NXT = nex
get:is the le
get:RCV.NXT+RCV.W
get:segment, 
get:SEG.SEQ = fir
get:SEG.SEQ+SEG.L
get:A segment is ju
get:RCV.NXT =< SE
get:RCV.NXT =< SE
get:Transmission Cont
get:Functional Specif
get:The first part 
get:segment falls i
get:if the end of t
get:either part of 
get:Actually, it is
get:windows and zer
get:acceptability o:f an incoming segment
get:Segment Recei
get:Length  Windo
get:------- -----
get:0       0 
get:0      >0 
get:>0       0 
get:>0      >0 
get:Note that when 
get:acceptable exce
get:maintain a zero
get:ACKs.  However,
get:process the RST
get:We have taken a
get:control informa
get:some control fl
get:and acknowledge
get:control will be
get:carried in the 
get:for implicitly 
get:are the only co
get:are used only a
get:purposes, the S
get:octet of the se
get:to occur after 
get:occurs.  The se
get:space occupying
get:sequence number
get:[Page 26]        
get:September 1981   
get:Initial Sequenc
get:The protocol pl
get:used over and o
get:sockets.  New i
get:incarnations of
get:-- "how does th
get:incarnations of
get:connection is b
get:connection brea
get:To avoid confus
get:connection from
get:be present in t
get:assure this, ev
get:sequence number
get:an initial sequ
get:new 32 bit ISN.
get:bit clock whose
get:microseconds.  
get:Since we assume
get:the Maximum Seg
get:hours we can re
get:For each connec
get:sequence number
get:the data sendin
get:learned during 
get:For a connectio
get:synchronize on 
get:an exchange of 
get:called "SYN" (f
get:shorthand, segm
get:Hence, the solu
get:initial sequenc
get:The synchroniza
get:sequence number
get:from the other 
get:initial sequenc
get:1) A --> B  S
get:2) A <-- B  A
get:3) A <-- B  S
get:4) A --> B  A
get:Transmission Cont
get:Functional Specif
get:Because steps 2
get:called the thre
get:A three way han
get:tied to a globa
get:mechanisms for 
get:no way of knowi
get:unless it remem
get:(which is not a
get:verify this SYN
get:clock-driven sc
get:Knowing When to
get:To be sure that
get:sequence number
get:the network, th
get:(MSL) before as
get:recovering from
get:lost.  For this
get:is an engineeri
get:it is desirable
get:sense, yet reta
get:not wait at all
get:than those rece
get:The TCP Quiet T
get:This specific
get:retaining any
get:each active (
get:TCP segments 
get:in the intern
get:paragraphs be
get:TCP implement
get:at the risk o
get:data rejected
get:TCPs consume 
get:entered into 
get:duplicate det
get:relies on the
get:the extent th
get:values before
get:been delivere
get:copies of the
get:such an assum
get:[Page 28]        
get:September 1981   
get:assigned the 
get:at the receiv
get:that each seg
get:as there are 
get:Under normal 
get:to emit and t
get:mistakenly us
get:been acknowle
get:data is drain
get:very large to
get:cause trouble
get:to use up 2**
get:lifetime in t
get:this is deeme
get:rates escalat
get:cycle time is
get:within reason
get:The basic dup
get:defeated, how
get:sequence numb
get:the TCP were 
get:upon crashing
get:connection (p
get:packets with 
get:packets still
get:incarnation o
get:about the seq
get:specification
get:before emitti
get:segments from
get:Even hosts wh
get:initial seque
get:(i.e., even i
get:number for ea
get:Suppose, for 
get:sequence numb
get:and that even
get:takes on a va
get:segment sent 
get:at this insta
get:incarnation o
get:S1 = ISN(t) -
get:connection!  
get:Transmission Cont
get:Functional Specif
get:duplicates in
get:of S1 may arr
get:the new incar
get:The problem i
get:crashed nor d
get:the system fr
get:One way to de
get:segments for 
get:time" specifi
get:willing to ri
get:destination m
get:Implementors 
get:connection by
get:informally im
get:Obviously, ev
get:necessary aft
get:To summarize:
get:numbers in th
get:"busy" or "in
get:block of spac
get:segment, if a
get:sequence numb
get:the previous 
get:number overla
get:3.4.  Establishin
get:The "three-way 
get:connection.  Th
get:responded to by
get:simultaneously 
get:occurs, each TC
get:acknowledgment 
get:an old duplicat
get:recipient, that
get:Proper use of "
get:Several example
get:examples do not
get:segments, this 
get:doesn't deliver
get:valid (i.e., th
get:connection reac
get:reduces the pos
get:[Page 30]        
get:September 1981   
get:implementation 
get:information for
get:The simplest th
get:figures should 
get:numbered for re
get:departure of a 
get:segment at B fr
get:Ellipsis (...) 
get:(delayed).  An 
get:Comments appear
get:the departure o
get:the center of e
get:form, with sequ
get:fields such as 
get:in the interest
get:TCP A      
get:1.  CLOSED     
get:2.  SYN-SENT   
get:3.  ESTABLISHED
get:4.  ESTABLISHED
get:5.  ESTABLISHED
get:Basic 3
get:In line 2 of fi
get:indicating that
get:number 100.  In
get:received from T
get:B is now expect
get:occupied sequen
get:At line 4, TCP 
get:TCP B's SYN; an
get:sequence number
get:because the ACK
get:would wind up A
get:Transmission Cont
get:Functional Specif
get:Simultaneous in
get:figure 8.  Each
get:TCP A      
get:1.  CLOSED     
get:2.  SYN-SENT   
get:3.  SYN-RECEIVE
get:4.             
get:5.  SYN-RECEIVE
get:6.  ESTABLISHED
get:7.             
get:S
get:The principle r
get:duplicate conne
get:this, a special
get:receiving TCP i
get:SYN-RECEIVED), 
get:If the TCP is i
get:FIN-WAIT-1, FIN
get:aborts the conn
get:case under "hal
get:[Page 32]        
get:September 1981   
get:TCP A      
get:1.  CLOSED     
get:2.  SYN-SENT   
get:3.  (duplicate)
get:4.  SYN-SENT   
get:5.  SYN-SENT   
get:6.             
get:7.  SYN-SENT   
get:8.  ESTABLISHED
get:As a simple exa
get:figure 9.  At l
get:cannot tell tha
get:(line 4).  TCP 
get:RST (reset) wit
get:believable.  TC
get:When the origin
get:synchronization
get:before the RST,
get:sent in both di
get:Half-Open Conne
get:An established 
get:TCPs has closed
get:knowledge of th
get:become desynchr
get:memory.  Such c
get:attempt is made
get:connections are
get:mildly involved
get:If at site A th
get:Transmission Cont
get:Functional Specif
get:user at site B 
get:receiving a res
get:site B TCP that
get:Assume that two
get:another when a 
get:Depending on th
get:that some error
get:A is likely to 
get:point.  As a re
get:or try to SEND 
get:case, it receiv
get:local (A's) TCP
get:will send a seg
get:example shown i
get:re-open the con
get:TCP A      
get:1.  (CRASH)    
get:2.  CLOSED     
get:3.  SYN-SENT --
get:4.  (!!)     <-
get:5.  SYN-SENT --
get:6.  SYN-SENT   
get:7.  SYN-SENT --
get:When the SYN ar
get:and the incomin
get:acknowledgment 
get:100).  TCP A se
get:sent and, being
get:detected a half
get:[Page 34]        
get:September 1981   
get:continue to try
get:reduced to the 
get:An interesting 
get:tries to send d
get:This is illustr
get:TCP A from TCP 
get:exists, so TCP 
get:processes it an
get:TCP A    
get:1.  (CRASH)    
get:2.  (??)    <--
get:3.          -->
get:Active
get:In figure 12, w
get:waiting for SYN
get:into action.  A
get:generate a RST 
get:the reset and r
get:TCP A      
get:1.  LISTEN     
get:2.       ... <S
get:3.  (??) <-- <S
get:4.       --> <S
get:5.  LISTEN     
get:Old Duplic
get:Transmission Cont
get:Functional Specif
get:A variety of ot
get:by the followin
get:Reset Generatio
get:As a general ru
get:which apparentl
get:must not be sen
get:There are three: groups of states
get:1.  If the co
get:in response t
get:particular, S
get:by this means
get:If the incomi
get:sequence numb
get:reset has seq
get:of the sequen
get:The connectio
get:2.  If the co
get:SYN-SENT, SYN
get:something not
get:if an incomin
get:does not exac
get:connection, a
get:If our SYN ha
get:incoming segm
get:either raise 
get:the system) o
get:incoming segm
get:continue as i
get:cannot raise 
get:detected in t
get:terminated th
get:incoming segm
get:match the loc
get:must be sent.
get:If the incomi
get:sequence numb
get:reset has seq
get:of the sequen
get:The connectio
get:[Page 36]        
get:September 1981   
get:3.  If the co
get:FIN-WAIT-1, F
get:any unaccepta
get:unacceptible 
get:acknowledgmen
get:and an acknow
get:to be receive
get:If an incomin
get:precedence wh
get:and precedenc
get:connection go
get:number from t
get:Reset Processin
get:In all states e
get:by checking the
get:is in the windo
get:to an initial S
get:acknowledges th
get:The receiver of
get:receiver was in
get:in SYN-RECEIVED
get:then the receiv
get:aborts the conn
get:was in any othe
get:and goes to the
get:3.5.  Closing a C
get:CLOSE is an ope
get:notion of closi
get:interpretation,
get:the receiving s
get:in a simplex fa
get:until he is tol
get:could initiate 
get:RECEIVE until s
get:has CLOSED.  We
get:RECEIVEs are ou
get:can terminate h
get:buffers SENT be
get:data in return 
get:successfully to
get:TCP.  Users mus
get:the TCP says no
get:Transmission Cont
get:Functional Specif
get:There are essen:tially three cases
get:1) The user i
get:2) The remote
get:3) Both users
get:Case 1:  Local 
get:In this case,
get:outgoing segm
get:accepted by t
get:are allowed i
get:will be retra
get:both acknowle
get:can ACK this 
get:send its own 
get:Case 2:  TCP re
get:If an unsolic
get:can ACK it an
get:user will res
get:the other TCP
get:until its own
get:connection.  
get:the connectio
get:Case 3:  both u
get:A simultaneou
get:FIN segments 
get:have been pro
get:has received.
get:[Page 38]        
get:September 1981   
get:TCP A      
get:1.  ESTABLISHED
get:FIN-WAIT-1 
get:3.  FIN-WAIT-2 
get:4.             
get:TIME-WAIT  
get:5.  TIME-WAIT  
get:CLOSED     
get:TCP A      
get:1.  ESTABLISHED
get:2.  (Close)    
get:FIN-WAIT-1 
get:3.  CLOSING    
get:4.  TIME-WAIT  
get:(2 MSL)    
get:CLOSED     
get:Transmission Cont
get:Functional Specif
get:3.6.  Precedence 
get:The intent is t
get:with exactly th
get:higher of the p
get:The precedence 
get:defined in the 
get:specification t
get:the security pa
get:user group, and
get:A connection at
get:lower precedenc
get:a connection du
get:acknowledgment 
get:Note that TCP m
get:precedence will
get:segments and po
get:The security pa
get:(the values wou
get:non-secure envi
get:parameters, tho
get:3.7.  Data Commun
get:Once the connec
get:exchange of seg
get:(checksum test 
get:retransmission 
get:Duplicate segme
get:As discussed in
get:certain tests o
get:segments to ver
get:The sender of d
get:the variable SN
get:sequence number
get:keeps track of 
get:variable SND.UN
get:sent has been a
get:When the sender
get:SND.NXT.  When 
get:sends an acknow
get:[Page 40]        
get:September 1981   
get:acknowledgment 
get:these variables
get:The amount by w
get:data in the seg
get:segments must c
get:The CLOSE user 
get:flag in an inco
get:Retransmission 
get:Because of the 
get:internetwork sy
get:retransmission 
get:for determining
get:An Example Re
get:Measure the
get:particular 
get:covers that
get:segments re
get:Time (RTT).:  Next compute a Smoothed Round Trip Time (SRTT) as
get:SRTT = ( 
get:and based o:n this, compute the retransmission timeout (RTO) as
get:RTO = min
get:where UBOUN
get:LBOUND is a
get:a smoothing
get:factor (e.g
get:The Communicati
get:The objective o
get:to stimulate th
get:permit the rece
get:the currently k
get:This mechanism 
get:the end of urge
get:the receive seq
get:must tell the u
get:number catches 
get:Transmission Cont
get:Functional Specif
get:into "normal mo
get:is in "urgent m
get:The method empl
get:transmitted.  T
get:meaningful and 
get:the urgent poin
get:no urgent data 
get:To send an urge
get:octet.  If the 
get:the urgent info
get:Managing the Wi
get:The window sent
get:numbers the sen
get:prepared to acc
get:the currently a
get:Indicating a la
get:arrives than ca
get:in excessive re
get:network and the
get:transmission of
get:between each ne
get:The mechanisms 
get:subsequently ad
get:that much data.
get:discouraged.  T
get:shrink the wind
get:on the part of 
get:The sending TCP
get:least one octet
get:sending TCP mus
get:the window is z
get:interval when t
get:guarantee that 
get:window will be 
get:When the receiv
get:still send an a
get:and current win
get:The sending TCP
get:[Page 42]        
get:September 1981   
get:which fit the c
get:retransmission 
get:In a connection
get:be carried in a
get:number so there
get:order.  This is
get:information to 
get:the data receiv
get:the window info
get:acknowledgment 
get:equal or greate
get:The window mana
get:communication p
get:Window Manage
get:Allocating 
get:many small 
get:fewer large
get:One suggest
get:defer updat
get:least X per
get:connection 
get:Another sug
get:segments by
get:sending dat
get:data must b
get:Note that t
get:retransmiss
get:acknowledgm
get:window info
get:new window 
get:The segment
get:of transmit
get:segment con
get:is accepted
get:If the send
get:window is n
get:alternating
get:pauses in t
get:Transmission Cont
get:Functional Specif
get:result in b
get:big pair. A
get:mostly smal
get:The suggest
get:actively at
get:windows, si
get:to many sma
get:There are of co:urse two interfaces of concern
get:and the TCP/low
get:of the user/TCP
get:protocol module
get:in detail by th
get:case that the l
get:that TCPs might
get:User/TCP Interf
get:The following
get:at best, fict
get:facilities.  
get:implementatio
get:TCPs must pro
get:that all TCP 
get:hierarchy.  T
get:required of a
get:TCP User Comm
get:The followi
get:interface. 
get:function ca
get:meant to ru
get:The user co
get:TCP must pe
get:Individual 
get:may provide
get:single call
get:automatical
get:issued by t
get:[Page 44]        
get:September 1981   
get:In providin
get:not only ac
get:processes i:t serves.  The latter consists of
get:(a) gener
get:remote cl
get:(b) repli
get:various t
get:Format:  
get:[, timeou
get:-> local 
get:We assume
get:processes
get:to use th
get:implement
get:for the s
get:lower lev
get:result of
get:able to m
get:process c
get:If the ac
get:call to L
get:have eith
get:particula
get:for any c
get:by the su
get:A transmi
get:filled in
get:On an act
get:synchroni
get:The timeo
get:for all d
get:delivered
get:will abor
get:The TCP o
get:the users
get:Transmission Cont
get:Functional Specif
get:precedenc
get:or securi
get:the defau
get:TCP will 
get:security/
get:the prece
get:requested
get:The prece
get:requested
get:request, 
get:connectio
get:this prec
get:allowed t
get:or that a
get:A local c
get:The local
get:for the c
get:Format:  
get:count, PU
get:This call
get:to be sen
get:not been 
get:implement
get:automatic
get:authorize
get:If the PU
get:to the re
get:segment c
get:the data 
get:transmiss
get:If the UR
get:will have
get:the urgen
get:pointer i
get:been cons
get:is to sti
get:indicate 
get:[Page 46]        
get:September 1981   
get:data has 
get:TCP signa
get:of times 
get:urgent da
get:If no for
get:connectio
get:has becom
get:local soc
get:foreign s
get:foreign s
get:knowing t
get:However, 
get:becomes s
get:STATUS ca
get:implement
get:socket is
get:If a time
get:connectio
get:In the si
get:the sendi
get:or the ti
get:is both s
get:connectio
get:offers po
get:sophistic
get:the proce
get:furthermo
get:Multiple 
get:the TCP w
get:We have i
get:which a S
get:pseudo-in
get:return a 
get:immediate
get:been ackn
get:assume ev
get:close any
get:kind (syn
get:signals, 
get:with spec
get:In order 
get:indicatio
get:Transmission Cont
get:Functional Specif
get:buffer ad
get:the SEND 
get:indicatin
get:calling p
get:Format:  
get:count) ->
get:This comm
get:specified
get:calling p
get:error is 
get:In the si
get:calling p
get:error occ
get:A more so
get:RECEIVEs 
get:segments 
get:the cost 
get:notify th
get:If enough
get:the PUSH 
get:The buffe
get:a PUSH is
get:returned 
get:If there 
get:as it arr
get:should th
get:additiona
get:call to R
get:may now l
get:urgent po
get:in the sa
get:boundary 
get:To distin
get:care of t
get:return co
get:count ind
get:Alternati
get:[Page 48]        
get:September 1981   
get:allocate 
get:with the 
get:Format:  
get:This comm
get:the conne
get:authorize
get:Closing c
get:the sense
get:retransmi
get:serviced.
get:calls, fo
get:to the de
get:continue 
get:may be tr
get:means "I 
get:receive a
get:not well 
get:of all it
get:into ABOR
get:The user 
get:initiativ
get:(e.g., re
get:destinati
get:Because c
get:foreign T
get:short tim
get:replies t
get:Close als
get:Format:  
get:This is a
get:excluded 
get:typically
get:This comm
get:informati:on
get:local s
get:Transmission Cont
get:Functional Specif
get:foreign
get:local c
get:receive
get:send wi
get:connect
get:number 
get:number 
get:urgent 
get:precede
get:securit
get:and tra
get:Depending
get:implement
get:available
get:authorize
get:prevents 
get:connectio
get:Format:  
get:This comm
get:aborted, 
get:be sent t
get:Depending
get:indicatio
get:receive a
get:TCP-to-User M
get:It is assum
get:means for t
get:the TCP doe
get:to the user
get:an error me
get:relating to
get:other user 
get:The followi:ng information is provided
get:Local Con
get:Response 
get:Buffer Ad
get:Byte coun
get:Push flag
get:Urgent fl
get:[Page 50]        
get:September 1981   
get:TCP/Lower-Level
get:The TCP calls
get:receive infor
get:internetwork 
get:Protocol (IP)
get:If the lower 
get:of service an
get:for these par:ameters
get:Type of Ser:vice = Precedence: routine, Delay: normal, Throughput
get:normal, Rel:iability
get:Time to Liv
get:Note that
get:Here we e
get:be delive
get:If the lower 
get:feature) and 
get:route informa
get:so that the s
get:checksum be t
get:also importan
get:Any lower lev
get:destination a
get:the "TCP leng
get:of IP and to 
get:Transmission Cont
get:Functional Specif
get:3.9.  Event Proce
get:The processing 
get:implementation.
get:processing sequ
get:section only in
get:The activity of
get:The events that: occur can be cast into three categories
get:arriving segmen
get:processing the 
get:cases the proce
get:Events that o:ccur
get:Arriving Se
get:SEGMENT A
get:USER TIME
get:RETRANSMI
get:TIME-WAIT
get:The model of th
get:immediate retur
get:pseudo interrup
get:means cause a d
get:Error responses
get:commands refere:ncing connections that do not exist receive "error
get:connection not 
get:Please note in 
get:acknowledgment 
get:of the sequence
get:equal to (modul
get:[Page 52]        
get:September 1981   
get:A natural way t
get:imagine that th
get:that their cont
get:in the sequence
get:and processed i
get:When a segment 
get:the segment to 
get:to be consisten
get:Note that if no
get:Transmission Cont
get:Functional Specif
get:CLOSED STATE 
get:Create a ne
get:state infor
get:socket, pre
get:information
get:unspecified
get:parameters 
get:precedence 
get:"error:  pr:ecedence not allowed" or "error
get:not allowed
get:active and :the foreign socket is unspecified, return "error
get:foreign soc
get:specified, 
get:(ISS) is se
get:is sent.  S
get:state, and 
get:If the call
get:return "err:or
get:no room to :create a new connection, return "error
get:resources".
get:If active a
get:connection 
get:segment, se
get:state.  Dat
get:queued for 
get:urgent bit 
get:segments se
get:queue the r:equest, respond with "error
get:If Foreign :socket was not specified, then return "error
get:socket unsp
get:[Page 54]        
get:September 1981   
get:SYN-SENT STAT
get:SYN-RECEIVED 
get:ESTABLISHED S
get:FIN-WAIT-1 ST
get:FIN-WAIT-2 ST
get:CLOSE-WAIT ST
get:CLOSING STATE
get:LAST-ACK STAT
get:TIME-WAIT STA
get:Return "err:or
get:Transmission Cont
get:Functional Specif
get:CLOSED STATE 
get:If the user
get:"error:  co
get:Otherwise, :return "error
get:If the fore
get:from passiv
get:SND.UNA to 
get:associated 
get:transmissio
get:requested i
get:as a result
get:request, re:spond with "error
get:Foreign soc:ket was not specified, then return "error
get:socket unsp
get:SYN-SENT STAT
get:SYN-RECEIVED 
get:Queue the d
get:If no space: to queue, respond with "error
get:resources".
get:ESTABLISHED S
get:CLOSE-WAIT ST
get:Segmentize 
get:acknowledgm
get:insufficien:t space to remember this buffer, simply return "error
get:insufficien
get:If the urge
get:urgent poin
get:[Page 56]        
get:September 1981   
get:FIN-WAIT-1 ST
get:FIN-WAIT-2 ST
get:CLOSING STATE
get:LAST-ACK STAT
get:TIME-WAIT STA
get:Return "err:or
get:Transmission Cont
get:Functional Specif
get:CLOSED STATE 
get:If the user
get:"error:  co
get:Otherwise r:eturn "error
get:SYN-SENT STAT
get:SYN-RECEIVED 
get:Queue for p
get:is no room :to queue this request, respond with "error
get:insufficien
get:ESTABLISHED S
get:FIN-WAIT-1 ST
get:FIN-WAIT-2 ST
get:If insuffic
get:request, qu
get:remember th:e RECEIVE, respond with "error
get:resources".
get:Reassemble 
get:to user.  M
get:If RCV.UP i
get:user notify
get:When the TC
get:that fact m
get:acknowledgm
get:described b
get:[Page 58]        
get:September 1981   
get:CLOSE-WAIT ST
get:Since the r
get:satisfied b
get:user.  If n
get:"error:  co
get:text can be
get:CLOSING STATE
get:LAST-ACK STAT
get:TIME-WAIT STA
get:Return "err:or
get:Transmission Cont
get:Functional Specif
get:CLOSED STATE 
get:If the user
get:"error:  co
get:Otherwise, :return "error
get:Any outstan:ding RECEIVEs are returned with "error
get:responses. 
get:SYN-SENT STAT
get:Delete the :TCB and return "error
get:queued SEND
get:SYN-RECEIVED 
get:If no SENDs
get:then form a
get:otherwise q
get:ESTABLISHED S
get:Queue this 
get:form a FIN 
get:FIN-WAIT-1 ST
get:FIN-WAIT-2 ST
get:Strictly sp:eaking, this is an error and should receive a "error
get:connection 
get:acceptable,
get:FIN may be 
get:[Page 60]        
get:September 1981   
get:CLOSE-WAIT ST
get:Queue this 
get:segmentized
get:CLOSING STATE
get:LAST-ACK STAT
get:TIME-WAIT STA
get:Respond wit:h "error
get:Transmission Cont
get:Functional Specif
get:CLOSED STATE 
get:If the user
get:"error:  co
get:Otherwise r:eturn "error
get:Any outstan:ding RECEIVEs should be returned with "error
get:connection 
get:SYN-SENT STAT
get:All queued 
get:notificatio
get:SYN-RECEIVED 
get:ESTABLISHED S
get:FIN-WAIT-1 ST
get:FIN-WAIT-2 ST
get:CLOSE-WAIT ST
get:Send a rese:t segment
get:<SEQ=SND.
get:All queued 
get:notificatio
get:RST formed 
get:TCB, enter 
get:CLOSING STATE
get:LAST-ACK STAT
get:TIME-WAIT STA
get:Respond wit
get:[Page 62]        
get:September 1981   
get:CLOSED STATE 
get:If the user
get:"error:  co
get:Otherwise r:eturn "error
get:Return "sta
get:SYN-SENT STAT
get:Return "sta
get:SYN-RECEIVED 
get:Return "sta
get:ESTABLISHED S
get:Return "sta
get:FIN-WAIT-1 ST
get:Return "sta
get:FIN-WAIT-2 ST
get:Return "sta
get:CLOSE-WAIT ST
get:Return "sta
get:CLOSING STATE
get:Return "sta
get:LAST-ACK STAT
get:Return "sta
get:Transmission Cont
get:Functional Specif
get:TIME-WAIT STA
get:Return "sta
get:[Page 64]        
get:September 1981   
get:SEGMENT ARRIVES
get:If the state 
get:all data in
get:segment con
get:containing 
get:acknowledgm
get:reset seque
get:If the ACK 
get:<SEQ=0><A
get:If the ACK 
get:<SEQ=SEG.
get:If the state 
get:first check
get:An incomi
get:second chec
get:Any ackno
get:the LISTE
get:for any a
get:formatted: as follows
get:<SEQ=SE
get:third check
get:If the SY
get:security/
get:match the
get:<SEQ=SE
get:Transmission Cont
get:Functional Specif
get:If the SE
get:the user 
get:send a re
get:<SEQ=SE
get:If the SE
get:Set RCV.N
get:control o
get:should be: selected and a SYN segment sent of the form
get:<SEQ=IS
get:SND.NXT i
get:state sho
get:incoming 
get:in the SY
get:not be re
get:the forei
get:unspecifi
get:fourth othe
get:Any other
get:must have
get:processin
get:it could 
get:incarnati
get:but if yo
get:If the state 
get:first check
get:If the AC
get:If SEG.
get:the RST
get:<SEQ=
get:and dis
get:If SND.
get:second chec
get:[Page 66]        
get:September 1981   
get:If the RS
get:If the :ACK was acceptable then signal the user "error
get:connect
get:delete 
get:and ret
get:third check
get:If the se
get:match the
get:If ther
get:<SEQ=
get:Otherwi
get:<SEQ=
get:If there 
get:The pre
get:TCB, if
get:<SEQ=
get:If there 
get:If the 
get:in the 
get:the pre
get:allowed
get:<SEQ=
get:If the 
get:in the 
get:If a rese
get:fourth chec
get:This step
get:no ACK, a
get:If the SY
get:Transmission Cont
get:Functional Specif
get:are accep
get:SEG.SEQ. 
get:is an ACK
get:are there
get:If SND.UN
get:state to 
get:<SEQ=SN
get:and send 
get:transmiss
get:text in t
get:below whe
get:Otherwise
get:<SEQ=IS
get:and send 
get:segment, 
get:has been 
get:fifth, if n
get:segment and
get:[Page 68]        
get:September 1981   
get:first check s
get:SYN-RECEIVE
get:ESTABLISHED
get:FIN-WAIT-1 
get:FIN-WAIT-2 
get:CLOSE-WAIT 
get:CLOSING STA
get:LAST-ACK ST
get:TIME-WAIT S
get:Segments 
get:are used 
get:done in S
get:boundary 
get:processed
get:There are
get:segment
get:Segment R
get:Length  W
get:------- -
get:0     
get:0     
get:>0     
get:>0     
get:If the RC
get:special a
get:If an inc
get:should be
get:the segme:nt and return)
get:<SEQ=SN
get:After sen
get:and retur
get:Transmission Cont
get:Functional Specif
get:In the fo
get:segment t
get:One could
get:trimming 
get:SYN and F
get:begins at
get:numbers m
get:second check 
get:SYN-RECEIVE
get:If the RS
get:If this
get:came fr
get:LISTEN 
get:this co
get:from SY
get:the use
get:on the 
get:active 
get:and ret
get:ESTABLISHED
get:If the RS
get:should re
get:flushed. 
get:"connecti
get:TCB, and 
get:CLOSING STA
get:LAST-ACK ST
get:If the RS
get:TCB, and 
get:[Page 70]        
get:September 1981   
get:third check s
get:SYN-RECEIVE
get:If the se
get:exactly m
get:then send
get:ESTABLISHED
get:If the se
get:exactly m
get:then send
get:receive "
get:flushed. 
get:"connecti
get:TCB, and 
get:Note this c
get:a segment f
get:different s
get:current con
get:fourth, check
get:SYN-RECEIVE
get:ESTABLISHED
get:FIN-WAIT ST
get:FIN-WAIT ST
get:CLOSE-WAIT 
get:CLOSING STA
get:LAST-ACK ST
get:TIME-WAIT S
get:If the SY
get:outstandi
get:all segme
get:receive a
get:the CLOSE
get:If the SY
get:and an ac
get:number ch
get:Transmission Cont
get:Functional Specif
get:fifth check t
get:if the ACK 
get:if the ACK 
get:SYN-RECEI
get:If SND.
get:and con
get:If th
get:reset
get:<SE
get:and s
get:ESTABLISH
get:If SND.
get:Any seg
get:entirel
get:positiv
get:fully a
get:"ok" re
get:(SEG.AC
get:somethi
get:drop th
get:If SND.
get:updated
get:SND.WL2
get:SND.WL1
get:Note th
get:records
get:SND.WND
get:the las
get:prevent
get:[Page 72]        
get:September 1981   
get:FIN-WAIT-
get:In addi
get:our FIN
get:process
get:FIN-WAIT-
get:In addi
get:the ret
get:acknowl
get:CLOSE-WAI
get:Do the 
get:CLOSING S
get:In addi
get:the ACK
get:otherwi
get:LAST-ACK 
get:The onl
get:acknowl
get:delete 
get:TIME-WAIT
get:The onl
get:retrans
get:the 2 M
get:sixth, check 
get:ESTABLISHED
get:FIN-WAIT-1 
get:FIN-WAIT-2 
get:If the UR
get:the user 
get:pointer (
get:user has 
get:mode") fo
get:signal th
get:Transmission Cont
get:Functional Specif
get:CLOSE-WAIT 
get:CLOSING STA
get:LAST-ACK ST
get:This shou
get:remote si
get:seventh, proc
get:ESTABLISHED
get:FIN-WAIT-1 
get:FIN-WAIT-2 
get:Once in t
get:text to u
get:into buff
get:empty.  I
get:the user 
get:has been 
get:When the 
get:user it m
get:Once the 
get:RCV.NXT o
get:apporopri
get:RCV.NXT a
get:Please no
get:Send an a:cknowledgment of the form
get:<SEQ=SN
get:This ackn
get:transmitt
get:[Page 74]        
get:September 1981   
get:CLOSE-WAIT 
get:CLOSING STA
get:LAST-ACK ST
get:TIME-WAIT S
get:This shou
get:remote si
get:eighth, check
get:Do not proc
get:since the S
get:If the FIN 
get:return any 
get:over the FI
get:FIN implies
get:SYN-RECEI
get:ESTABLISH
get:Enter t
get:FIN-WAIT-
get:If our 
get:enter T
get:timers;
get:FIN-WAIT-
get:Enter t
get:off the
get:CLOSE-WAI
get:Remain 
get:CLOSING S
get:Remain 
get:LAST-ACK 
get:Remain 
get:Transmission Cont
get:Functional Specif
get:TIME-WAIT
get:Remain 
get:timeout
get:[Page 76]        
get:September 1981   
get:For any state
get:the user "err:or
get:and for any o
get:state and ret
get:RETRANSMISSION 
get:For any state
get:the retransmi
get:retransmissio
get:TIME-WAIT TIMEO
get:If the time-w
get:enter the CLO
get:Transmission Cont
get:[Page 78]        
get:September 1981   
get:BBN Rep
get:a Host 
get:host an
get:A contr
get:indicat
get:specifi
get:is expe
get:previou
get:The uni
get:ARPANET
get:A unit 
get:IMPs.  
get:A logic
get:A messa
get:network
get:Destination Addre
get:The des
get:identif
get:A contr
get:indicat
get:occupyi
get:A porti
get:fragmen
get:A file 
get:Transmission Cont
get:Control
get:fragmen
get:A compu
get:from th
get:An Inte
get:by the 
get:The Int
get:ARPANET
get:A sourc
get:internet datagram
get:The uni
get:higher 
get:internet fragment
get:A porti
get:header.
get:Interne
get:The Ini
get:number 
get:The Ini
get:on a co
get:based p
get:The Ini
get:used by
get:Control
get:data.  
get:on an A
get:[Page 80]        
get:September 1981   
get:This is
get:data re
get:sequenc
get:of the 
get:The uni
get:An impl
get:procedu
get:Maximum
get:the int
get:An eigh
get:An Opti
get:may be 
get:primari
get:timesta
get:options
get:A packa
get:logical
get:logical
get:The por
get:output 
get:A progr
get:the poi
get:A contr
get:this se
get:receivi
get:receive
get:Transmission Cont
get:receive
get:receive
get:receive next sequ
get:This is
get:receive
get:This re
get:is will
get:segment
get:RCV.NXT
get:Segment
get:range a
get:A contr
get:that th
get:interac
get:sequenc
get:segment
get:it.  In
get:rise to
get:Real Ti:me Protocol
get:of time
get:segment
get:segment
get:segment
get:segment
get:segment
get:[Page 82]        
get:September 1981   
get:segment
get:A logic
get:unit of
get:segment acknowled
get:The seq
get:arrivin
get:The amo
get:includi
get:The num
get:This is
get:use on 
get:initial
get:each oc
get:This re
get:(receiv
get:window 
get:receivi
get:be emit
get:SND.UNA
get:between
get:send se
get:left se
get:send ur
get:segment
get:segment
get:Transmission Cont
get:send wi
get:An addr
get:is, the
get:The sou
get:A contr
get:number,
get:where t
get:Transmi
get:the sta
get:The pre
get:Transmi:ssion Control Protocol
get:reliabl
get:Type of
get:An Inte
get:for thi
get:A contr
get:indicat
get:urgent 
get:sequenc
get:pointer
get:A contr
get:field c
get:indicat
get:urgent 
get:[Page 84]        
get:September 1981   
get:[1]  Cerf, V., an
get:Intercommuni
get:Vol. COM-22,
get:[2]  Postel, J. (
get:Protocol Spe
get:Institute, S
get:[3]  Dalal, Y. an
get:Protocols", 
get:December 197
get:[4]  Postel, J., 
get:Institute, S
get:aRFC
get:aDe
get:aI
get:aSeptember 1981   
get:aPREFACE .....
get:a1.  INTRODUCTION 
get:a1.1  Motivation
get:a1.2  Scope ....
get:a1.3  About This
get:a1.4  Interfaces
get:a1.5  Operation 
get:a2.  PHILOSOPHY ..
get:a2.1  Elements o
get:a2.2  Model of O
get:a2.3  The Host E
get:a2.4  Interfaces
get:a2.5  Relation t
get:a2.6  Reliable C
get:a2.7  Connection
get:a2.8  Data Commu
get:a2.9  Precedence
get:a2.10 Robustness
get:a3.  FUNCTIONAL SP
get:a3.1  Header For
get:a3.2  Terminolog
get:a3.3  Sequence N
get:a3.4  Establishi
get:a3.5  Closing a 
get:a3.6  Precedence
get:a3.7  Data Commu
get:a3.8  Interfaces
get:a3.9  Event Proc
get:aGLOSSARY ........
get:aREFERENCES ......
get:aTransmission Cont
get:a[Page ii]        
get:aSeptember 1981   
get:aThis document des
get:a(TCP).  There hav
get:aspecification on 
get:adraws heavily fro
get:aboth in terms of 
get:aseveral details a
get:aand redescribes t
get:aRFC
get:aReplaces: RFC 761
get:aIENs:  129, 124, 
get:a55, 44, 40, 27, 2
get:aThe Transmission 
get:areliable host-to-
get:acommunication net
get:aThis document des
get:aTransmission Cont
get:ainterface to prog
get:aComputer commun
get:arole in militar
get:adocument focuse
get:acommunication r
get:acommunication u
get:acongestion, but
get:agovernment sect
get:aAs strategic an
get:adeveloped and d
get:ainterconnecting
get:acommunication p
get:aapplications.  
get:aDeputy Undersec
get:adeclared the Tr
get:abe a basis for 
get:astandardization
get:aTCP is a connec
get:afit into a laye
get:aapplications.  
get:acommunication b
get:adistinct but in
get:aassumptions are
get:aprotocols below
get:apotentially unr
get:aprotocols.  In 
get:awide spectrum o
get:aconnections to 
get:aTransmission Cont
get:aTCP is based on
get:aTCP fits into a
get:aInternet Protoc
get:areceive variabl
get:adatagram "envel
get:aaddressing sour
get:ainternet protoc
get:athe TCP segment
get:amultiple networ
get:aalso carries in
get:aand compartment
get:acommunicated en
get:aMuch of this do
get:awhich are co-re
get:acomputer.  Some
get:afront-end compu
get:aas well as netw
get:aan interface to
get:aimplementable e
get:ahost-to-front e
get:aThe TCP is inte
get:acommunication s
get:aintended to be 
get:a1.3.  About this 
get:aThis document r
get:aany TCP impleme
get:aprotocols and i
get:a[Page 2]         
get:aSeptember 1981   
get:asection offers 
get:aoperation.  Sec
get:adesign.  Sectio
get:arequired of TCP
get:auser calls, err
get:aThe TCP interfa
get:athe other side 
get:aThe interface b
get:aillustrated in 
get:acalls much like
get:aapplication pro
get:acalls to open a
get:aestablished con
get:aasynchronously 
get:aconsiderable fr
get:ainterfaces whic
get:aenvironment, a 
get:ainterface for a
get:aThe interface b
get:aunspecified exc
get:atwo levels can 
get:aTypically, one 
get:ainterface.  TCP
get:ainterconnected 
get:athroughout this
get:aAs noted above,
get:asecurable logic
get:aprocesses.  To 
get:acommunication s:ystem requires facilities in the following areas
get:aBasic Data Tr
get:aPrecedence an
get:aThe basic opera
get:athe following p
get:aTransmission Cont
get:aBasic Data Tran:sfer
get:aThe TCP is ab
get:adirection bet
get:asegments for 
get:athe TCPs deci
get:aSometimes use
get:asubmitted to 
get:afunction is d
get:aactually tran
get:apushed throug
get:apromptly forw
get:aThe exact pus
get:athe push func
get:aReliability
get:aThe TCP must 
get:adelivered out
get:ais achieved b
get:atransmitted, 
get:areceiving TCP
get:ainterval, the
get:anumbers are u
get:aout of order 
get:aadding a chec
get:areceiver, and
get:aAs long as th
get:asystem does n
get:aerrors will a
get:ainternet comm
get:aFlow Control
get:aTCP provides 
get:asent by the s
get:aevery ACK ind
get:athe last segm
get:aallowed numbe
get:areceiving fur
get:a[Page 4]         
get:aSeptember 1981   
get:aMultiplexing
get:aTo allow for 
get:acommunication
get:aaddresses or 
get:aand host addr
get:aa socket.  A 
get:aThat is, a so
get:aThe binding o
get:aHost.  Howeve
get:a(e.g., a "log
get:amade known to
get:athrough the k
get:aaddresses of 
get:aConnections
get:aThe reliabili
get:athat TCPs ini
get:aeach data str
get:asockets, sequ
get:aEach connecti
get:aidentifying i
get:aWhen two proc
get:aestablish a c
get:aside).  When 
get:aterminated or
get:aSince connect
get:aover the unre
get:amechanism wit
get:aerroneous ini
get:aPrecedence and :Security
get:aThe users of 
get:acommunication
get:athese feature
get:aTransmission Cont
get:a[Page 6]         
get:aSeptember 1981   
get:a2.1.  Elements of
get:aThe internetwor
get:awhich are in tu
get:athat the networ
get:alarge networks 
get:apacket switchin
get:aconsume message
get:anetworks, the g
get:acommunication s
get:aconnections bet
get:aThe term packet
get:atransaction bet
get:aexchanged withi
get:aHosts are compu
get:anetwork's point
get:aProcesses are v
get:aaccordance with
get:ain execution). 
get:aviewed as commu
get:aThus, all commu
get:aSince a process
get:astreams between
get:athat each proce
get:acommunicates wi
get:a2.2.  Model of Op
get:aProcesses trans
get:adata as argumen
get:asegments and ca
get:athe destination
get:ainto the receiv
get:aTCPs include co
get:aensure reliable
get:aThe model of in
get:aprotocol module
get:ato the local ne
get:ainside internet
get:ainternet module
get:athrough the loc
get:aThe packet swit
get:aTransmission Cont
get:aother operation
get:adestination int
get:aAt a gateway be
get:afrom its local 
get:athe internet da
get:athen "wrapped" 
get:arouted to the n
get:aA gateway is pe
get:ainternet datagr
get:athrough the nex
get:ainternet datagr
get:afurther broken 
get:ainternet datagr
get:ainternet module
get:aA destination i
get:a(after reassemb
get:adestination TCP
get:aThis simple mod
get:aimportant featu
get:ato the gateway 
get:aservice paramet
get:aIncluded in the
get:adatagram.  Data
get:ahost and gatewa
get:aproperly segreg
get:a2.3.  The Host En
get:aThe TCP is assu
get:aaccess the TCP 
get:amay call on oth
get:adata structures
get:acontrolled by a
get:anetwork device 
get:adatagram protoc
get:aThe mechanisms 
get:afront-end proce
get:ahost-to-front-e
get:athe type of TCP
get:a[Page 8]         
get:aSeptember 1981   
get:aThe TCP/user in
get:ato OPEN or CLOS
get:aSTATUS about a 
get:aprograms on the
get:afrom, and close
get:aThe TCP/interne
get:adatagrams addre
get:asystem.  These 
get:aservice, preced
get:a2.5.  Relation to
get:aThe following d
get:ahierarchy
get:a+------+ +
get:a|Telnet| |
get:a+------+ +
get:a|   
get:a+----
get:a| TCP
get:a+----
get:a| 
get:a+----
get:a|    
get:a+----
get:a+--
get:a|  
get:a+--
get:aIt is expected 
get:aprotocols effic
get:aprotocols like 
get:a2.6.  Reliable Co
get:aA stream of dat
get:aorder at the de
get:aTransmission Cont
get:aTransmission is
get:aacknowledgments
get:asequence number
get:asegment is tran
get:asequence number
get:ais the sequence
get:atransmissions i
get:asegment contain
get:astarts a timer;
get:asegment is dele
get:areceived before
get:aAn acknowledgme
get:adelivered to th
get:athe responsibil
get:aTo govern the f
get:aemployed.  The 
get:aThis window spe
get:aacknowledgment 
get:a2.7.  Connection 
get:aTo identify the
get:aprovides a port
get:aindependently b
get:aunique addresse
get:aidentifying the
get:awill be unique 
get:aA connection is
get:alocal socket ma
get:asockets.  A con
get:athat is, it is 
get:aTCPs are free t
get:aHowever, severa
get:aThere must be w
get:athe "appropriat
get:amay "own" ports
get:athe ports they 
get:aissue, but we e
get:auniquely alloca
get:aassociating the
get:aA connection is
get:aforeign socket 
get:a[Page 10]        
get:aSeptember 1981   
get:aconnection name
get:asubsequent call
get:aabout a connect
get:ais a data struc
get:aimplementation 
get:apointer to the 
get:awhether the con
get:abe passively wa
get:aA passive OPEN 
get:aconnection requ
get:aOften the proce
get:arequest from an
get:ais used to deno
get:aare allowed onl
get:aA service proce
get:aprocesses would
get:aforeign socket.
get:arequested a con
get:alocal socket we
get:aWell-known sock
get:aa socket addres
get:a"Telnet-Server"
get:asocket, and oth
get:aEntry, Text Gen
get:abeing for test 
get:aaccess to a "Lo
get:aat which a newl
get:awell-known sock
get:aof sockets to s
get:aProcesses can i
get:afrom other proc
get:abeen establishe
get:aother at the sa
get:ais critical for
get:acomponents act 
get:aThere are two p
get:apassive OPENs a
get:alocal passive O
get:acase, the match
get:aOPENs has left 
get:aforeign socket 
get:aOther possibili
get:aTransmission Cont
get:aIf there are se
get:asame local sock
get:awith the specif
get:aTCB exists, bef
get:aThe procedures 
get:acontrol flag an
get:aexchange has be
get:aA connection is
get:acontaining a SY
get:acommand.  The m
get:aconnection has 
get:awhen sequence n
get:aThe clearing of
get:ain this case ca
get:a2.8.  Data Commun
get:aThe data that f
get:aoctets.  The se
get:ain that call (a
get:athrough to the 
get:aA sending TCP i
get:asend that data 
get:afunction is sig
get:areceiving TCP s
get:athe sending TCP
get:aThere is no nec
get:aboundaries.  Th
get:asingle SEND cal
get:aThe purpose of 
get:afrom the sendin
get:arecord service.
get:aThere is a coup
get:aof data that cr
get:aassociated with
get:abuffer is retur
get:anot filled.  If
get:aPUSH is seen, t
get:aTCP also provid
get:aat some point f
get:a[Page 12]        
get:aSeptember 1981   
get:acurrently readi
get:adefine what the
get:aurgent data, bu
get:atake action to 
get:a2.9.  Precedence 
get:aThe TCP makes u
get:asecurity option
get:abasis to TCP us
get:aa multilevel se
get:ause only, and o
get:acompartment.  C
get:ausers may be li
get:aTCP modules whi
get:aproperly mark o
get:aprecedence.  Su
get:ahigher level pr
get:athem to specify
get:aprecedence of c
get:a2.10.  Robustness
get:aTCP implementat:ions will follow a general principle of robustness
get:aconservative in
get:aTransmission Cont
get:a[Page 14]        
get:aSeptember 1981   
get:a3.1.  Header Form
get:aTCP segments ar
get:aheader carries 
get:adestination hos
get:aheader, supplyi
get:adivision allows
get:aTCP Header Form
get:a0            
get:a0 1 2 3 4 5 6
get:a+-+-+-+-+-+-+-
get:a|          Sou
get:a+-+-+-+-+-+-+-
get:a|             
get:a+-+-+-+-+-+-+-
get:a|             
get:a+-+-+-+-+-+-+-
get:a|  Data |     
get:a| Offset| Rese
get:a|       |     
get:a+-+-+-+-+-+-+-
get:a|           Ch
get:a+-+-+-+-+-+-+-
get:a|             
get:a+-+-+-+-+-+-+-
get:a|             
get:a+-+-+-+-+-+-+-
get:aNote th
get:aSource Port:  1
get:aThe source po
get:aDestination Por:t
get:aThe destinati
get:aTransmission Cont
get:aFunctional Specif
get:aSequence Number:
get:aThe sequence 
get:awhen SYN is p
get:ainitial seque
get:aAcknowledgment :Number
get:aIf the ACK co
get:anext sequence
get:areceive.  Onc
get:aData Offset:  4
get:aThe number of
get:athe data begi
get:aintegral numb
get:aReserved:  6 bi
get:aReserved for 
get:aControl Bits:  :6 bits (from left to right)
get:aURG:  Urgent 
get:aACK:  Acknowl
get:aPSH:  Push Fu
get:aRST:  Reset t
get:aSYN:  Synchro
get:aFIN:  No more
get:aWindow:  16 bit
get:aThe number of
get:aacknowledgmen
get:aChecksum:  16 b
get:aThe checksum 
get:acomplement su
get:asegment conta
get:achecksummed, 
get:aform a 16 bit
get:atransmitted a
get:athe checksum 
get:aThe checksum 
get:a[Page 16]        
get:aSeptember 1981   
get:aprefixed to t
get:aAddress, the 
get:aThis gives th
get:ainformation i
get:aacross the TC
get:acalls by the 
get:aThe TCP Len
get:aoctets (thi
get:acomputed), 
get:aUrgent Pointer:
get:aThis field co
get:apositive offs
get:aurgent pointe
get:athe urgent da
get:athe URG contr
get:aOptions:  varia
get:aOptions may o
get:amultiple of 8
get:achecksum.  An
get:acases for the: format of an option
get:aCase 1:  A 
get:aCase 2:  An
get:ath
get:aThe option-le
get:aoption-length
get:aNote that the
get:afield might i
get:aEnd-of-Option
get:aA TCP must im
get:aTransmission Cont
get:aFunctional Specif
get:aCurrently def:ined options include (kind indicated in octal)
get:aKind     Le
get:a----     --
get:a0         
get:a1         
get:a2         
get:aSpecific Opti
get:aEnd of Opti
get:a+--------
get:a|00000000
get:a+--------
get:aThis opti
get:amight not
get:athe Data 
get:anot the e
get:athe optio
get:aNo-Operatio
get:a+--------
get:a|00000001
get:a+--------
get:aThis opti
get:aalign the
get:aThere is 
get:areceivers
get:anot begin
get:aMaximum Seg
get:a+--------
get:a|00000010
get:a+--------
get:aKind=2  
get:a[Page 18]        
get:aSeptember 1981   
get:aMaximum S:egment Size Option Data
get:aIf this
get:areceive
get:aThis fi
get:a(i.e., 
get:aoption 
get:aPadding:  varia
get:aThe TCP heade
get:aand data begi
get:a3.2.  Terminology
get:aBefore we can d
get:ato introduce so
get:aconnection requ
get:aof these variab
get:aTransmission Co
get:aTCB are the loc
get:aprecedence of t
get:abuffers, pointe
get:aIn addition sev
get:asequence number
get:aSend Sequence
get:aSND.UNA - s
get:aSND.NXT - s
get:aSND.WND - s
get:aSND.UP  - s
get:aSND.WL1 - s
get:aSND.WL2 - s
get:au
get:aISS     - i
get:aReceive Seque
get:aRCV.NXT - r
get:aRCV.WND - r
get:aRCV.UP  - r
get:aIRS     - i
get:aTransmission Cont
get:aFunctional Specif
get:aThe following d
get:athe sequence sp
get:aSend Sequence S
get:a---
get:a1 - old s
get:a2 - seque
get:a3 - seque
get:a4 - futur
get:aThe send window
get:aReceive Sequenc
get:a1 - old s
get:a2 - seque
get:a3 - futur
get:aThe receive win
get:aThere are also 
get:atake their valu
get:a[Page 20]        
get:aSeptember 1981   
get:aCurrent Segme
get:aSEG.SEQ - s
get:aSEG.ACK - s
get:aSEG.LEN - s
get:aSEG.WND - s
get:aSEG.UP  - s
get:aSEG.PRC - s
get:aA connection pr
get:alifetime.  The :states are
get:aESTABLISHED, FI
get:aTIME-WAIT, and 
get:abecause it repr
get:ano connection. : Briefly the meanings of the states are
get:aLISTEN - repr
get:aTCP and port.
get:aSYN-SENT - re
get:aafter having 
get:aSYN-RECEIVED 
get:arequest ackno
get:aconnection re
get:aESTABLISHED -
get:adelivered to 
get:aof the connec
get:aFIN-WAIT-1 - 
get:afrom the remo
get:atermination r
get:aFIN-WAIT-2 - 
get:afrom the remo
get:aCLOSE-WAIT - 
get:afrom the loca
get:aCLOSING - rep
get:aacknowledgmen
get:aLAST-ACK - re
get:aconnection te
get:a(which includ
get:aTransmission Cont
get:aFunctional Specif
get:aTIME-WAIT - r
get:athe remote TC
get:atermination r
get:aCLOSED - repr
get:aA TCP connectio
get:aevents.  The ev
get:aABORT, and STAT
get:acontaining the 
get:aThe state diagr
get:awith the causin
get:aerror condition
get:achanges.  In a 
get:athe reaction of
get:aNOTE BENE:  thi
get:athe total speci
get:a[Page 22]        
get:aSeptember 1981   
get:a+---------+     
get:a|         |<----
get:a|   SYN   |     
get:a|   RCVD  |<----
get:a|         |     
get:a|         |-----
get:a+---------+   rc
get:a|           --
get:a|             
get:a|             
get:a|  CLOSE      
get:a| -------     
get:a| snd FIN     
get:a|             
get:aV             
get:a+---------+     
get:a|  FIN    |<----
get:a| WAIT-1  |-----
get:a+---------+     
get:a| rcv ACK of F
get:a| ------------
get:aV        x    
get:a+---------+     
get:a|FINWAIT-2|     
get:a+---------+     
get:a|             
get:a|  rcv FIN    
get:a|  -------    
get:a\ snd ACK    
get:a------------
get:aTransmission Cont
get:aFunctional Specif
get:a3.3.  Sequence Nu
get:aA fundamental n
get:aover a TCP conn
get:asequenced, each
get:amechanism emplo
get:anumber X indica
get:areceived.  This
get:adetection in th
get:awithin a segmen
get:athe header is t
get:anumbered consec
get:aIt is essential
get:afinite, though 
get:aSince the space
get:anumbers must be
get:apreserves the r
get:a2**32 - 1 to 0 
get:aarithmetic, so 
get:acomparison of s
get:a(modulo 2**32).
get:aThe typical kin
get:aperform include:
get:a(a)  Determin
get:anumber s
get:a(b)  Determin
get:ahave bee
get:aretransm
get:a(c)  Determin
get:awhich ar
get:areceive 
get:a[Page 24]        
get:aSeptember 1981   
get:aIn response to 
get:afollowing compa
get:aSND.UNA = old
get:aSND.NXT = nex
get:aSEG.ACK = ack
get:anum
get:aSEG.SEQ = fir
get:aSEG.LEN = the
get:a(co
get:aSEG.SEQ+SEG.L
get:aA new acknowled
get:athe inequality :below holds
get:aSND.UNA < SEG
get:aA segment on th
get:aof its sequence
get:aacknowledgment 
get:aWhen data is re:ceived the following comparisons are needed
get:aRCV.NXT = nex
get:ais the le
get:aRCV.NXT+RCV.W
get:asegment, 
get:aSEG.SEQ = fir
get:aSEG.SEQ+SEG.L
get:aA segment is ju
get:aRCV.NXT =< SE
get:aRCV.NXT =< SE
get:aTransmission Cont
get:aFunctional Specif
get:aThe first part 
get:asegment falls i
get:aif the end of t
get:aeither part of 
get:aActually, it is
get:awindows and zer
get:aacceptability o:f an incoming segment
get:aSegment Recei
get:aLength  Windo
get:a------- -----
get:a0       0 
get:a0      >0 
get:a>0       0 
get:a>0      >0 
get:aNote that when 
get:aacceptable exce
get:amaintain a zero
get:aACKs.  However,
get:aprocess the RST
get:aWe have taken a
get:acontrol informa
get:asome control fl
get:aand acknowledge
get:acontrol will be
get:acarried in the 
get:afor implicitly 
get:aare the only co
get:aare used only a
get:apurposes, the S
get:aoctet of the se
get:ato occur after 
get:aoccurs.  The se
get:aspace occupying
get:asequence number
get:a[Page 26]        
get:aSeptember 1981   
get:aInitial Sequenc
get:aThe protocol pl
get:aused over and o
get:asockets.  New i
get:aincarnations of
get:a-- "how does th
get:aincarnations of
get:aconnection is b
get:aconnection brea
get:aTo avoid confus
get:aconnection from
get:abe present in t
get:aassure this, ev
get:asequence number
get:aan initial sequ
get:anew 32 bit ISN.
get:abit clock whose
get:amicroseconds.  
get:aSince we assume
get:athe Maximum Seg
get:ahours we can re
get:aFor each connec
get:asequence number
get:athe data sendin
get:alearned during 
get:aFor a connectio
get:asynchronize on 
get:aan exchange of 
get:acalled "SYN" (f
get:ashorthand, segm
get:aHence, the solu
get:ainitial sequenc
get:aThe synchroniza
get:asequence number
get:afrom the other 
get:ainitial sequenc
get:a1) A --> B  S
get:a2) A <-- B  A
get:a3) A <-- B  S
get:a4) A --> B  A
get:aTransmission Cont
get:aFunctional Specif
get:aBecause steps 2
get:acalled the thre
get:aA three way han
get:atied to a globa
get:amechanisms for 
get:ano way of knowi
get:aunless it remem
get:a(which is not a
get:averify this SYN
get:aclock-driven sc
get:aKnowing When to
get:aTo be sure that
get:asequence number
get:athe network, th
get:a(MSL) before as
get:arecovering from
get:alost.  For this
get:ais an engineeri
get:ait is desirable
get:asense, yet reta
get:anot wait at all
get:athan those rece
get:aThe TCP Quiet T
get:aThis specific
get:aretaining any
get:aeach active (
get:aTCP segments 
get:ain the intern
get:aparagraphs be
get:aTCP implement
get:aat the risk o
get:adata rejected
get:aTCPs consume 
get:aentered into 
get:aduplicate det
get:arelies on the
get:athe extent th
get:avalues before
get:abeen delivere
get:acopies of the
get:asuch an assum
get:a[Page 28]        
get:aSeptember 1981   
get:aassigned the 
get:aat the receiv
get:athat each seg
get:aas there are 
get:aUnder normal 
get:ato emit and t
get:amistakenly us
get:abeen acknowle
get:adata is drain
get:avery large to
get:acause trouble
get:ato use up 2**
get:alifetime in t
get:athis is deeme
get:arates escalat
get:acycle time is
get:awithin reason
get:aThe basic dup
get:adefeated, how
get:asequence numb
get:athe TCP were 
get:aupon crashing
get:aconnection (p
get:apackets with 
get:apackets still
get:aincarnation o
get:aabout the seq
get:aspecification
get:abefore emitti
get:asegments from
get:aEven hosts wh
get:ainitial seque
get:a(i.e., even i
get:anumber for ea
get:aSuppose, for 
get:asequence numb
get:aand that even
get:atakes on a va
get:asegment sent 
get:aat this insta
get:aincarnation o
get:aS1 = ISN(t) -
get:aconnection!  
get:aTransmission Cont
get:aFunctional Specif
get:aduplicates in
get:aof S1 may arr
get:athe new incar
get:aThe problem i
get:acrashed nor d
get:athe system fr
get:aOne way to de
get:asegments for 
get:atime" specifi
get:awilling to ri
get:adestination m
get:aImplementors 
get:aconnection by
get:ainformally im
get:aObviously, ev
get:anecessary aft
get:aTo summarize:
get:anumbers in th
get:a"busy" or "in
get:ablock of spac
get:asegment, if a
get:asequence numb
get:athe previous 
get:anumber overla
get:a3.4.  Establishin
get:aThe "three-way 
get:aconnection.  Th
get:aresponded to by
get:asimultaneously 
get:aoccurs, each TC
get:aacknowledgment 
get:aan old duplicat
get:arecipient, that
get:aProper use of "
get:aSeveral example
get:aexamples do not
get:asegments, this 
get:adoesn't deliver
get:avalid (i.e., th
get:aconnection reac
get:areduces the pos
get:a[Page 30]        
get:aSeptember 1981   
get:aimplementation 
get:ainformation for
get:aThe simplest th
get:afigures should 
get:anumbered for re
get:adeparture of a 
get:asegment at B fr
get:aEllipsis (...) 
get:a(delayed).  An 
get:aComments appear
get:athe departure o
get:athe center of e
get:aform, with sequ
get:afields such as 
get:ain the interest
get:aTCP A      
get:a1.  CLOSED     
get:a2.  SYN-SENT   
get:a3.  ESTABLISHED
get:a4.  ESTABLISHED
get:a5.  ESTABLISHED
get:aBasic 3
get:aIn line 2 of fi
get:aindicating that
get:anumber 100.  In
get:areceived from T
get:aB is now expect
get:aoccupied sequen
get:aAt line 4, TCP 
get:aTCP B's SYN; an
get:asequence number
get:abecause the ACK
get:awould wind up A
get:aTransmission Cont
get:aFunctional Specif
get:aSimultaneous in
get:afigure 8.  Each
get:aTCP A      
get:a1.  CLOSED     
get:a2.  SYN-SENT   
get:a3.  SYN-RECEIVE
get:a4.             
get:a5.  SYN-RECEIVE
get:a6.  ESTABLISHED
get:a7.             
get:aS
get:aThe principle r
get:aduplicate conne
get:athis, a special
get:areceiving TCP i
get:aSYN-RECEIVED), 
get:aIf the TCP is i
get:aFIN-WAIT-1, FIN
get:aaborts the conn
get:acase under "hal
get:a[Page 32]        
get:aSeptember 1981   
get:aTCP A      
get:a1.  CLOSED     
get:a2.  SYN-SENT   
get:a3.  (duplicate)
get:a4.  SYN-SENT   
get:a5.  SYN-SENT   
get:a6.             
get:a7.  SYN-SENT   
get:a8.  ESTABLISHED
get:aAs a simple exa
get:afigure 9.  At l
get:acannot tell tha
get:a(line 4).  TCP 
get:aRST (reset) wit
get:abelievable.  TC
get:aWhen the origin
get:asynchronization
get:abefore the RST,
get:asent in both di
get:aHalf-Open Conne
get:aAn established 
get:aTCPs has closed
get:aknowledge of th
get:abecome desynchr
get:amemory.  Such c
get:aattempt is made
get:aconnections are
get:amildly involved
get:aIf at site A th
get:aTransmission Cont
get:aFunctional Specif
get:auser at site B 
get:areceiving a res
get:asite B TCP that
get:aAssume that two
get:aanother when a 
get:aDepending on th
get:athat some error
get:aA is likely to 
get:apoint.  As a re
get:aor try to SEND 
get:acase, it receiv
get:alocal (A's) TCP
get:awill send a seg
get:aexample shown i
get:are-open the con
get:aTCP A      
get:a1.  (CRASH)    
get:a2.  CLOSED     
get:a3.  SYN-SENT --
get:a4.  (!!)     <-
get:a5.  SYN-SENT --
get:a6.  SYN-SENT   
get:a7.  SYN-SENT --
get:aWhen the SYN ar
get:aand the incomin
get:aacknowledgment 
get:a100).  TCP A se
get:asent and, being
get:adetected a half
get:a[Page 34]        
get:aSeptember 1981   
get:acontinue to try
get:areduced to the 
get:aAn interesting 
get:atries to send d
get:aThis is illustr
get:aTCP A from TCP 
get:aexists, so TCP 
get:aprocesses it an
get:aTCP A    
get:a1.  (CRASH)    
get:a2.  (??)    <--
get:a3.          -->
get:aActive
get:aIn figure 12, w
get:awaiting for SYN
get:ainto action.  A
get:agenerate a RST 
get:athe reset and r
get:aTCP A      
get:a1.  LISTEN     
get:a2.       ... <S
get:a3.  (??) <-- <S
get:a4.       --> <S
get:a5.  LISTEN     
get:aOld Duplic
get:aTransmission Cont
get:aFunctional Specif
get:aA variety of ot
get:aby the followin
get:aReset Generatio
get:aAs a general ru
get:awhich apparentl
get:amust not be sen
get:aThere are three: groups of states
get:a1.  If the co
get:ain response t
get:aparticular, S
get:aby this means
get:aIf the incomi
get:asequence numb
get:areset has seq
get:aof the sequen
get:aThe connectio
get:a2.  If the co
get:aSYN-SENT, SYN
get:asomething not
get:aif an incomin
get:adoes not exac
get:aconnection, a
get:aIf our SYN ha
get:aincoming segm
get:aeither raise 
get:athe system) o
get:aincoming segm
get:acontinue as i
get:acannot raise 
get:adetected in t
get:aterminated th
get:aincoming segm
get:amatch the loc
get:amust be sent.
get:aIf the incomi
get:asequence numb
get:areset has seq
get:aof the sequen
get:aThe connectio
get:a[Page 36]        
get:aSeptember 1981   
get:a3.  If the co
get:aFIN-WAIT-1, F
get:aany unaccepta
get:aunacceptible 
get:aacknowledgmen
get:aand an acknow
get:ato be receive
get:aIf an incomin
get:aprecedence wh
get:aand precedenc
get:aconnection go
get:anumber from t
get:aReset Processin
get:aIn all states e
get:aby checking the
get:ais in the windo
get:ato an initial S
get:aacknowledges th
get:aThe receiver of
get:areceiver was in
get:ain SYN-RECEIVED
get:athen the receiv
get:aaborts the conn
get:awas in any othe
get:aand goes to the
get:a3.5.  Closing a C
get:aCLOSE is an ope
get:anotion of closi
get:ainterpretation,
get:athe receiving s
get:ain a simplex fa
get:auntil he is tol
get:acould initiate 
get:aRECEIVE until s
get:ahas CLOSED.  We
get:aRECEIVEs are ou
get:acan terminate h
get:abuffers SENT be
get:adata in return 
get:asuccessfully to
get:aTCP.  Users mus
get:athe TCP says no
get:aTransmission Cont
get:aFunctional Specif
get:aThere are essen:tially three cases
get:a1) The user i
get:a2) The remote
get:a3) Both users
get:aCase 1:  Local 
get:aIn this case,
get:aoutgoing segm
get:aaccepted by t
get:aare allowed i
get:awill be retra
get:aboth acknowle
get:acan ACK this 
get:asend its own 
get:aCase 2:  TCP re
get:aIf an unsolic
get:acan ACK it an
get:auser will res
get:athe other TCP
get:auntil its own
get:aconnection.  
get:athe connectio
get:aCase 3:  both u
get:aA simultaneou
get:aFIN segments 
get:ahave been pro
get:ahas received.
get:a[Page 38]        
get:aSeptember 1981   
get:aTCP A      
get:a1.  ESTABLISHED
get:aFIN-WAIT-1 
get:a3.  FIN-WAIT-2 
get:a4.             
get:aTIME-WAIT  
get:a5.  TIME-WAIT  
get:aCLOSED     
get:aTCP A      
get:a1.  ESTABLISHED
get:a2.  (Close)    
get:aFIN-WAIT-1 
get:a3.  CLOSING    
get:a4.  TIME-WAIT  
get:a(2 MSL)    
get:aCLOSED     
get:aTransmission Cont
get:aFunctional Specif
get:a3.6.  Precedence 
get:aThe intent is t
get:awith exactly th
get:ahigher of the p
get:aThe precedence 
get:adefined in the 
get:aspecification t
get:athe security pa
get:auser group, and
get:aA connection at
get:alower precedenc
get:aa connection du
get:aacknowledgment 
get:aNote that TCP m
get:aprecedence will
get:asegments and po
get:aThe security pa
get:a(the values wou
get:anon-secure envi
get:aparameters, tho
get:a3.7.  Data Commun
get:aOnce the connec
get:aexchange of seg
get:a(checksum test 
get:aretransmission 
get:aDuplicate segme
get:aAs discussed in
get:acertain tests o
get:asegments to ver
get:aThe sender of d
get:athe variable SN
get:asequence number
get:akeeps track of 
get:avariable SND.UN
get:asent has been a
get:aWhen the sender
get:aSND.NXT.  When 
get:asends an acknow
get:a[Page 40]        
get:aSeptember 1981   
get:aacknowledgment 
get:athese variables
get:aThe amount by w
get:adata in the seg
get:asegments must c
get:aThe CLOSE user 
get:aflag in an inco
get:aRetransmission 
get:aBecause of the 
get:ainternetwork sy
get:aretransmission 
get:afor determining
get:aAn Example Re
get:aMeasure the
get:aparticular 
get:acovers that
get:asegments re
get:aTime (RTT).:  Next compute a Smoothed Round Trip Time (SRTT) as
get:aSRTT = ( 
get:aand based o:n this, compute the retransmission timeout (RTO) as
get:aRTO = min
get:awhere UBOUN
get:aLBOUND is a
get:aa smoothing
get:afactor (e.g
get:aThe Communicati
get:aThe objective o
get:ato stimulate th
get:apermit the rece
get:athe currently k
get:aThis mechanism 
get:athe end of urge
get:athe receive seq
get:amust tell the u
get:anumber catches 
get:aTransmission Cont
get:aFunctional Specif
get:ainto "normal mo
get:ais in "urgent m
get:aThe method empl
get:atransmitted.  T
get:ameaningful and 
get:athe urgent poin
get:ano urgent data 
get:aTo send an urge
get:aoctet.  If the 
get:athe urgent info
get:aManaging the Wi
get:aThe window sent
get:anumbers the sen
get:aprepared to acc
get:athe currently a
get:aIndicating a la
get:aarrives than ca
get:ain excessive re
get:anetwork and the
get:atransmission of
get:abetween each ne
get:aThe mechanisms 
get:asubsequently ad
get:athat much data.
get:adiscouraged.  T
get:ashrink the wind
get:aon the part of 
get:aThe sending TCP
get:aleast one octet
get:asending TCP mus
get:athe window is z
get:ainterval when t
get:aguarantee that 
get:awindow will be 
get:aWhen the receiv
get:astill send an a
get:aand current win
get:aThe sending TCP
get:a[Page 42]        
get:aSeptember 1981   
get:awhich fit the c
get:aretransmission 
get:aIn a connection
get:abe carried in a
get:anumber so there
get:aorder.  This is
get:ainformation to 
get:athe data receiv
get:athe window info
get:aacknowledgment 
get:aequal or greate
get:aThe window mana
get:acommunication p
get:aWindow Manage
get:aAllocating 
get:amany small 
get:afewer large
get:aOne suggest
get:adefer updat
get:aleast X per
get:aconnection 
get:aAnother sug
get:asegments by
get:asending dat
get:adata must b
get:aNote that t
get:aretransmiss
get:aacknowledgm
get:awindow info
get:anew window 
get:aThe segment
get:aof transmit
get:asegment con
get:ais accepted
get:aIf the send
get:awindow is n
get:aalternating
get:apauses in t
get:aTransmission Cont
get:aFunctional Specif
get:aresult in b
get:abig pair. A
get:amostly smal
get:aThe suggest
get:aactively at
get:awindows, si
get:ato many sma
get:aThere are of co:urse two interfaces of concern
get:aand the TCP/low
get:aof the user/TCP
get:aprotocol module
get:ain detail by th
get:acase that the l
get:athat TCPs might
get:aUser/TCP Interf
get:aThe following
get:aat best, fict
get:afacilities.  
get:aimplementatio
get:aTCPs must pro
get:athat all TCP 
get:ahierarchy.  T
get:arequired of a
get:aTCP User Comm
get:aThe followi
get:ainterface. 
get:afunction ca
get:ameant to ru
get:aThe user co
get:aTCP must pe
get:aIndividual 
get:amay provide
get:asingle call
get:aautomatical
get:aissued by t
get:a[Page 44]        
get:aSeptember 1981   
get:aIn providin
get:anot only ac
get:aprocesses i:t serves.  The latter consists of
get:a(a) gener
get:aremote cl
get:a(b) repli
get:avarious t
get:aFormat:  
get:a[, timeou
get:a-> local 
get:aWe assume
get:aprocesses
get:ato use th
get:aimplement
get:afor the s
get:alower lev
get:aresult of
get:aable to m
get:aprocess c
get:aIf the ac
get:acall to L
get:ahave eith
get:aparticula
get:afor any c
get:aby the su
get:aA transmi
get:afilled in
get:aOn an act
get:asynchroni
get:aThe timeo
get:afor all d
get:adelivered
get:awill abor
get:aThe TCP o
get:athe users
get:aTransmission Cont
get:aFunctional Specif
get:aprecedenc
get:aor securi
get:athe defau
get:aTCP will 
get:asecurity/
get:athe prece
get:arequested
get:aThe prece
get:arequested
get:arequest, 
get:aconnectio
get:athis prec
get:aallowed t
get:aor that a
get:aA local c
get:aThe local
get:afor the c
get:aFormat:  
get:acount, PU
get:aThis call
get:ato be sen
get:anot been 
get:aimplement
get:aautomatic
get:aauthorize
get:aIf the PU
get:ato the re
get:asegment c
get:athe data 
get:atransmiss
get:aIf the UR
get:awill have
get:athe urgen
get:apointer i
get:abeen cons
get:ais to sti
get:aindicate 
get:a[Page 46]        
get:aSeptember 1981   
get:adata has 
get:aTCP signa
get:aof times 
get:aurgent da
get:aIf no for
get:aconnectio
get:ahas becom
get:alocal soc
get:aforeign s
get:aforeign s
get:aknowing t
get:aHowever, 
get:abecomes s
get:aSTATUS ca
get:aimplement
get:asocket is
get:aIf a time
get:aconnectio
get:aIn the si
get:athe sendi
get:aor the ti
get:ais both s
get:aconnectio
get:aoffers po
get:asophistic
get:athe proce
get:afurthermo
get:aMultiple 
get:athe TCP w
get:aWe have i
get:awhich a S
get:apseudo-in
get:areturn a 
get:aimmediate
get:abeen ackn
get:aassume ev
get:aclose any
get:akind (syn
get:asignals, 
get:awith spec
get:aIn order 
get:aindicatio
get:aTransmission Cont
get:aFunctional Specif
get:abuffer ad
get:athe SEND 
get:aindicatin
get:acalling p
get:aFormat:  
get:acount) ->
get:aThis comm
get:aspecified
get:acalling p
get:aerror is 
get:aIn the si
get:acalling p
get:aerror occ
get:aA more so
get:aRECEIVEs 
get:asegments 
get:athe cost 
get:anotify th
get:aIf enough
get:athe PUSH 
get:aThe buffe
get:aa PUSH is
get:areturned 
get:aIf there 
get:aas it arr
get:ashould th
get:aadditiona
get:acall to R
get:amay now l
get:aurgent po
get:ain the sa
get:aboundary 
get:aTo distin
get:acare of t
get:areturn co
get:acount ind
get:aAlternati
get:a[Page 48]        
get:aSeptember 1981   
get:aallocate 
get:awith the 
get:aFormat:  
get:aThis comm
get:athe conne
get:aauthorize
get:aClosing c
get:athe sense
get:aretransmi
get:aserviced.
get:acalls, fo
get:ato the de
get:acontinue 
get:amay be tr
get:ameans "I 
get:areceive a
get:anot well 
get:aof all it
get:ainto ABOR
get:aThe user 
get:ainitiativ
get:a(e.g., re
get:adestinati
get:aBecause c
get:aforeign T
get:ashort tim
get:areplies t
get:aClose als
get:aFormat:  
get:aThis is a
get:aexcluded 
get:atypically
get:aThis comm
get:ainformati:on
get:alocal s
get:aTransmission Cont
get:aFunctional Specif
get:aforeign
get:alocal c
get:areceive
get:asend wi
get:aconnect
get:anumber 
get:anumber 
get:aurgent 
get:aprecede
get:asecurit
get:aand tra
get:aDepending
get:aimplement
get:aavailable
get:aauthorize
get:aprevents 
get:aconnectio
get:aFormat:  
get:aThis comm
get:aaborted, 
get:abe sent t
get:aDepending
get:aindicatio
get:areceive a
get:aTCP-to-User M
get:aIt is assum
get:ameans for t
get:athe TCP doe
get:ato the user
get:aan error me
get:arelating to
get:aother user 
get:aThe followi:ng information is provided
get:aLocal Con
get:aResponse 
get:aBuffer Ad
get:aByte coun
get:aPush flag
get:aUrgent fl
get:a[Page 50]        
get:aSeptember 1981   
get:aTCP/Lower-Level
get:aThe TCP calls
get:areceive infor
get:ainternetwork 
get:aProtocol (IP)
get:aIf the lower 
get:aof service an
get:afor these par:ameters
get:aType of Ser:vice = Precedence: routine, Delay: normal, Throughput
get:anormal, Rel:iability
get:aTime to Liv
get:aNote that
get:aHere we e
get:abe delive
get:aIf the lower 
get:afeature) and 
get:aroute informa
get:aso that the s
get:achecksum be t
get:aalso importan
get:aAny lower lev
get:adestination a
get:athe "TCP leng
get:aof IP and to 
get:aTransmission Cont
get:aFunctional Specif
get:a3.9.  Event Proce
get:aThe processing 
get:aimplementation.
get:aprocessing sequ
get:asection only in
get:aThe activity of
get:aThe events that: occur can be cast into three categories
get:aarriving segmen
get:aprocessing the 
get:acases the proce
get:aEvents that o:ccur
get:aArriving Se
get:aSEGMENT A
get:aUSER TIME
get:aRETRANSMI
get:aTIME-WAIT
get:aThe model of th
get:aimmediate retur
get:apseudo interrup
get:ameans cause a d
get:aError responses
get:acommands refere:ncing connections that do not exist receive "error
get:aconnection not 
get:aPlease note in 
get:aacknowledgment 
get:aof the sequence
get:aequal to (modul
get:a[Page 52]        
get:aSeptember 1981   
get:aA natural way t
get:aimagine that th
get:athat their cont
get:ain the sequence
get:aand processed i
get:aWhen a segment 
get:athe segment to 
get:ato be consisten
get:aNote that if no
get:aTransmission Cont
get:aFunctional Specif
get:aCLOSED STATE 
get:aCreate a ne
get:astate infor
get:asocket, pre
get:ainformation
get:aunspecified
get:aparameters 
get:aprecedence 
get:a"error:  pr:ecedence not allowed" or "error
get:anot allowed
get:aactive and :the foreign socket is unspecified, return "error
get:aforeign soc
get:aspecified, 
get:a(ISS) is se
get:ais sent.  S
get:astate, and 
get:aIf the call
get:areturn "err:or
get:ano room to :create a new connection, return "error
get:aresources".
get:aIf active a
get:aconnection 
get:asegment, se
get:astate.  Dat
get:aqueued for 
get:aurgent bit 
get:asegments se
get:aqueue the r:equest, respond with "error
get:aIf Foreign :socket was not specified, then return "error
get:asocket unsp
get:a[Page 54]        
get:aSeptember 1981   
get:aSYN-SENT STAT
get:aSYN-RECEIVED 
get:aESTABLISHED S
get:aFIN-WAIT-1 ST
get:aFIN-WAIT-2 ST
get:aCLOSE-WAIT ST
get:aCLOSING STATE
get:aLAST-ACK STAT
get:aTIME-WAIT STA
get:aReturn "err:or
get:aTransmission Cont
get:aFunctional Specif
get:aCLOSED STATE 
get:aIf the user
get:a"error:  co
get:aOtherwise, :return "error
get:aIf the fore
get:afrom passiv
get:aSND.UNA to 
get:aassociated 
get:atransmissio
get:arequested i
get:aas a result
get:arequest, re:spond with "error
get:aForeign soc:ket was not specified, then return "error
get:asocket unsp
get:aSYN-SENT STAT
get:aSYN-RECEIVED 
get:aQueue the d
get:aIf no space: to queue, respond with "error
get:aresources".
get:aESTABLISHED S
get:aCLOSE-WAIT ST
get:aSegmentize 
get:aacknowledgm
get:ainsufficien:t space to remember this buffer, simply return "error
get:ainsufficien
get:aIf the urge
get:aurgent poin
get:a[Page 56]        
get:aSeptember 1981   
get:aFIN-WAIT-1 ST
get:aFIN-WAIT-2 ST
get:aCLOSING STATE
get:aLAST-ACK STAT
get:aTIME-WAIT STA
get:aReturn "err:or
get:aTransmission Cont
get:aFunctional Specif
get:aCLOSED STATE 
get:aIf the user
get:a"error:  co
get:aOtherwise r:eturn "error
get:aSYN-SENT STAT
get:aSYN-RECEIVED 
get:aQueue for p
get:ais no room :to queue this request, respond with "error
get:ainsufficien
get:aESTABLISHED S
get:aFIN-WAIT-1 ST
get:aFIN-WAIT-2 ST
get:aIf insuffic
get:arequest, qu
get:aremember th:e RECEIVE, respond with "error
get:aresources".
get:aReassemble 
get:ato user.  M
get:aIf RCV.UP i
get:auser notify
get:aWhen the TC
get:athat fact m
get:aacknowledgm
get:adescribed b
get:a[Page 58]        
get:aSeptember 1981   
get:aCLOSE-WAIT ST
get:aSince the r
get:asatisfied b
get:auser.  If n
get:a"error:  co
get:atext can be
get:aCLOSING STATE
get:aLAST-ACK STAT
get:aTIME-WAIT STA
get:aReturn "err:or
get:aTransmission Cont
get:aFunctional Specif
get:aCLOSED STATE 
get:aIf the user
get:a"error:  co
get:aOtherwise, :return "error
get:aAny outstan:ding RECEIVEs are returned with "error
get:aresponses. 
get:aSYN-SENT STAT
get:aDelete the :TCB and return "error
get:aqueued SEND
get:aSYN-RECEIVED 
get:aIf no SENDs
get:athen form a
get:aotherwise q
get:aESTABLISHED S
get:aQueue this 
get:aform a FIN 
get:aFIN-WAIT-1 ST
get:aFIN-WAIT-2 ST
get:aStrictly sp:eaking, this is an error and should receive a "error
get:aconnection 
get:aacceptable,
get:aFIN may be 
get:a[Page 60]        
get:aSeptember 1981   
get:aCLOSE-WAIT ST
get:aQueue this 
get:asegmentized
get:aCLOSING STATE
get:aLAST-ACK STAT
get:aTIME-WAIT STA
get:aRespond wit:h "error
get:aTransmission Cont
get:aFunctional Specif
get:aCLOSED STATE 
get:aIf the user
get:a"error:  co
get:aOtherwise r:eturn "error
get:aAny outstan:ding RECEIVEs should be returned with "error
get:aconnection 
get:aSYN-SENT STAT
get:aAll queued 
get:anotificatio
get:aSYN-RECEIVED 
get:aESTABLISHED S
get:aFIN-WAIT-1 ST
get:aFIN-WAIT-2 ST
get:aCLOSE-WAIT ST
get:aSend a rese:t segment
get:a<SEQ=SND.
get:aAll queued 
get:anotificatio
get:aRST formed 
get:aTCB, enter 
get:aCLOSING STATE
get:aLAST-ACK STAT
get:aTIME-WAIT STA
get:aRespond wit
get:a[Page 62]        
get:aSeptember 1981   
get:aCLOSED STATE 
get:aIf the user
get:a"error:  co
get:aOtherwise r:eturn "error
get:aReturn "sta
get:aSYN-SENT STAT
get:aReturn "sta
get:aSYN-RECEIVED 
get:aReturn "sta
get:aESTABLISHED S
get:aReturn "sta
get:aFIN-WAIT-1 ST
get:aReturn "sta
get:aFIN-WAIT-2 ST
get:aReturn "sta
get:aCLOSE-WAIT ST
get:aReturn "sta
get:aCLOSING STATE
get:aReturn "sta
get:aLAST-ACK STAT
get:aReturn "sta
get:aTransmission Cont
get:aFunctional Specif
get:aTIME-WAIT STA
get:aReturn "sta
get:a[Page 64]        
get:aSeptember 1981   
get:aSEGMENT ARRIVES
get:aIf the state 
get:aall data in
get:asegment con
get:acontaining 
get:aacknowledgm
get:areset seque
get:aIf the ACK 
get:a<SEQ=0><A
get:aIf the ACK 
get:a<SEQ=SEG.
get:aIf the state 
get:afirst check
get:aAn incomi
get:asecond chec
get:aAny ackno
get:athe LISTE
get:afor any a
get:aformatted: as follows
get:a<SEQ=SE
get:athird check
get:aIf the SY
get:asecurity/
get:amatch the
get:a<SEQ=SE
get:aTransmission Cont
get:aFunctional Specif
get:aIf the SE
get:athe user 
get:asend a re
get:a<SEQ=SE
get:aIf the SE
get:aSet RCV.N
get:acontrol o
get:ashould be: selected and a SYN segment sent of the form
get:a<SEQ=IS
get:aSND.NXT i
get:astate sho
get:aincoming 
get:ain the SY
get:anot be re
get:athe forei
get:aunspecifi
get:afourth othe
get:aAny other
get:amust have
get:aprocessin
get:ait could 
get:aincarnati
get:abut if yo
get:aIf the state 
get:afirst check
get:aIf the AC
get:aIf SEG.
get:athe RST
get:a<SEQ=
get:aand dis
get:aIf SND.
get:asecond chec
get:a[Page 66]        
get:aSeptember 1981   
get:aIf the RS
get:aIf the :ACK was acceptable then signal the user "error
get:aconnect
get:adelete 
get:aand ret
get:athird check
get:aIf the se
get:amatch the
get:aIf ther
get:a<SEQ=
get:aOtherwi
get:a<SEQ=
get:aIf there 
get:aThe pre
get:aTCB, if
get:a<SEQ=
get:aIf there 
get:aIf the 
get:ain the 
get:athe pre
get:aallowed
get:a<SEQ=
get:aIf the 
get:ain the 
get:aIf a rese
get:afourth chec
get:aThis step
get:ano ACK, a
get:aIf the SY
get:aTransmission Cont
get:aFunctional Specif
get:aare accep
get:aSEG.SEQ. 
get:ais an ACK
get:aare there
get:aIf SND.UN
get:astate to 
get:a<SEQ=SN
get:aand send 
get:atransmiss
get:atext in t
get:abelow whe
get:aOtherwise
get:a<SEQ=IS
get:aand send 
get:asegment, 
get:ahas been 
get:afifth, if n
get:asegment and
get:a[Page 68]        
get:aSeptember 1981   
get:afirst check s
get:aSYN-RECEIVE
get:aESTABLISHED
get:aFIN-WAIT-1 
get:aFIN-WAIT-2 
get:aCLOSE-WAIT 
get:aCLOSING STA
get:aLAST-ACK ST
get:aTIME-WAIT S
get:aSegments 
get:aare used 
get:adone in S
get:aboundary 
get:aprocessed
get:aThere are
get:asegment
get:aSegment R
get:aLength  W
get:a------- -
get:a0     
get:a0     
get:a>0     
get:a>0     
get:aIf the RC
get:aspecial a
get:aIf an inc
get:ashould be
get:athe segme:nt and return)
get:a<SEQ=SN
get:aAfter sen
get:aand retur
get:aTransmission Cont
get:aFunctional Specif
get:aIn the fo
get:asegment t
get:aOne could
get:atrimming 
get:aSYN and F
get:abegins at
get:anumbers m
get:asecond check 
get:aSYN-RECEIVE
get:aIf the RS
get:aIf this
get:acame fr
get:aLISTEN 
get:athis co
get:afrom SY
get:athe use
get:aon the 
get:aactive 
get:aand ret
get:aESTABLISHED
get:aIf the RS
get:ashould re
get:aflushed. 
get:a"connecti
get:aTCB, and 
get:aCLOSING STA
get:aLAST-ACK ST
get:aIf the RS
get:aTCB, and 
get:a[Page 70]        
get:aSeptember 1981   
get:athird check s
get:aSYN-RECEIVE
get:aIf the se
get:aexactly m
get:athen send
get:aESTABLISHED
get:aIf the se
get:aexactly m
get:athen send
get:areceive "
get:aflushed. 
get:a"connecti
get:aTCB, and 
get:aNote this c
get:aa segment f
get:adifferent s
get:acurrent con
get:afourth, check
get:aSYN-RECEIVE
get:aESTABLISHED
get:aFIN-WAIT ST
get:aFIN-WAIT ST
get:aCLOSE-WAIT 
get:aCLOSING STA
get:aLAST-ACK ST
get:aTIME-WAIT S
get:aIf the SY
get:aoutstandi
get:aall segme
get:areceive a
get:athe CLOSE
get:aIf the SY
get:aand an ac
get:anumber ch
get:aTransmission Cont
get:aFunctional Specif
get:afifth check t
get:aif the ACK 
get:aif the ACK 
get:aSYN-RECEI
get:aIf SND.
get:aand con
get:aIf th
get:areset
get:a<SE
get:aand s
get:aESTABLISH
get:aIf SND.
get:aAny seg
get:aentirel
get:apositiv
get:afully a
get:a"ok" re
get:a(SEG.AC
get:asomethi
get:adrop th
get:aIf SND.
get:aupdated
get:aSND.WL2
get:aSND.WL1
get:aNote th
get:arecords
get:aSND.WND
get:athe las
get:aprevent
get:a[Page 72]        
get:aSeptember 1981   
get:aFIN-WAIT-
get:aIn addi
get:aour FIN
get:aprocess
get:aFIN-WAIT-
get:aIn addi
get:athe ret
get:aacknowl
get:aCLOSE-WAI
get:aDo the 
get:aCLOSING S
get:aIn addi
get:athe ACK
get:aotherwi
get:aLAST-ACK 
get:aThe onl
get:aacknowl
get:adelete 
get:aTIME-WAIT
get:aThe onl
get:aretrans
get:athe 2 M
get:asixth, check 
get:aESTABLISHED
get:aFIN-WAIT-1 
get:aFIN-WAIT-2 
get:aIf the UR
get:athe user 
get:apointer (
get:auser has 
get:amode") fo
get:asignal th
get:aTransmission Cont
get:aFunctional Specif
get:aCLOSE-WAIT 
get:aCLOSING STA
get:aLAST-ACK ST
get:aThis shou
get:aremote si
get:aseventh, proc
get:aESTABLISHED
get:aFIN-WAIT-1 
get:aFIN-WAIT-2 
get:aOnce in t
get:atext to u
get:ainto buff
get:aempty.  I
get:athe user 
get:ahas been 
get:aWhen the 
get:auser it m
get:aOnce the 
get:aRCV.NXT o
get:aapporopri
get:aRCV.NXT a
get:aPlease no
get:aSend an a:cknowledgment of the form
get:a<SEQ=SN
get:aThis ackn
get:atransmitt
get:a[Page 74]        
get:aSeptember 1981   
get:aCLOSE-WAIT 
get:aCLOSING STA
get:aLAST-ACK ST
get:aTIME-WAIT S
get:aThis shou
get:aremote si
get:aeighth, check
get:aDo not proc
get:asince the S
get:aIf the FIN 
get:areturn any 
get:aover the FI
get:aFIN implies
get:aSYN-RECEI
get:aESTABLISH
get:aEnter t
get:aFIN-WAIT-
get:aIf our 
get:aenter T
get:atimers;
get:aFIN-WAIT-
get:aEnter t
get:aoff the
get:aCLOSE-WAI
get:aRemain 
get:aCLOSING S
get:aRemain 
get:aLAST-ACK 
get:aRemain 
get:aTransmission Cont
get:aFunctional Specif
get:aTIME-WAIT
get:aRemain 
get:atimeout
get:a[Page 76]        
get:aSeptember 1981   
get:aFor any state
get:athe user "err:or
get:aand for any o
get:astate and ret
get:aRETRANSMISSION 
get:aFor any state
get:athe retransmi
get:aretransmissio
get:aTIME-WAIT TIMEO
get:aIf the time-w
get:aenter the CLO
get:aTransmission Cont
get:a[Page 78]        
get:aSeptember 1981   
get:aBBN Rep
get:aa Host 
get:ahost an
get:aA contr
get:aindicat
get:aspecifi
get:ais expe
get:apreviou
get:aThe uni
get:aARPANET
get:aA unit 
get:aIMPs.  
get:aA logic
get:aA messa
get:anetwork
get:aDestination Addre
get:aThe des
get:aidentif
get:aA contr
get:aindicat
get:aoccupyi
get:aA porti
get:afragmen
get:aA file 
get:aTransmission Cont
get:aControl
get:afragmen
get:aA compu
get:afrom th
get:aAn Inte
get:aby the 
get:aThe Int
get:aARPANET
get:aA sourc
get:ainternet datagram
get:aThe uni
get:ahigher 
get:ainternet fragment
get:aA porti
get:aheader.
get:aInterne
get:aThe Ini
get:anumber 
get:aThe Ini
get:aon a co
get:abased p
get:aThe Ini
get:aused by
get:aControl
get:adata.  
get:aon an A
get:a[Page 80]        
get:aSeptember 1981   
get:aThis is
get:adata re
get:asequenc
get:aof the 
get:aThe uni
get:aAn impl
get:aprocedu
get:aMaximum
get:athe int
get:aAn eigh
get:aAn Opti
get:amay be 
get:aprimari
get:atimesta
get:aoptions
get:aA packa
get:alogical
get:alogical
get:aThe por
get:aoutput 
get:aA progr
get:athe poi
get:aA contr
get:athis se
get:areceivi
get:areceive
get:aTransmission Cont
get:areceive
get:areceive
get:areceive next sequ
get:aThis is
get:areceive
get:aThis re
get:ais will
get:asegment
get:aRCV.NXT
get:aSegment
get:arange a
get:aA contr
get:athat th
get:ainterac
get:asequenc
get:asegment
get:ait.  In
get:arise to
get:aReal Ti:me Protocol
get:aof time
get:asegment
get:asegment
get:asegment
get:asegment
get:asegment
get:a[Page 82]        
get:aSeptember 1981   
get:asegment
get:aA logic
get:aunit of
get:asegment acknowled
get:aThe seq
get:aarrivin
get:aThe amo
get:aincludi
get:aThe num
get:aThis is
get:ause on 
get:ainitial
get:aeach oc
get:aThis re
get:a(receiv
get:awindow 
get:areceivi
get:abe emit
get:aSND.UNA
get:abetween
get:asend se
get:aleft se
get:asend ur
get:asegment
get:asegment
get:aTransmission Cont
get:asend wi
get:aAn addr
get:ais, the
get:aThe sou
get:aA contr
get:anumber,
get:awhere t
get:aTransmi
get:athe sta
get:aThe pre
get:aTransmi:ssion Control Protocol
get:areliabl
get:aType of
get:aAn Inte
get:afor thi
get:aA contr
get:aindicat
get:aurgent 
get:asequenc
get:apointer
get:aA contr
get:afield c
get:aindicat
get:aurgent 
get:a[Page 84]        
get:aSeptember 1981   
get:a[1]  Cerf, V., an
get:aIntercommuni
get:aVol. COM-22,
get:a[2]  Postel, J. (
get:aProtocol Spe
get:aInstitute, S
get:a[3]  Dalal, Y. an
get:aProtocols", 
get:aDecember 197
get:a[4]  Postel, J., 
get:aInstitute, S
get:bRFC
get:bDe
get:bI
get:bSeptember 1981   
get:bPREFACE .....
get:b1.  INTRODUCTION 
get:b1.1  Motivation
get:b1.2  Scope ....
get:b1.3  About This
get:b1.4  Interfaces
get:b1.5  Operation 
get:b2.  PHILOSOPHY ..
get:b2.1  Elements o
get:b2.2  Model of O
get:b2.3  The Host E
get:b2.4  Interfaces
get:b2.5  Relation t
get:b2.6  Reliable C
get:b2.7  Connection
get:b2.8  Data Commu
get:b2.9  Precedence
get:b2.10 Robustness
get:b3.  FUNCTIONAL SP
get:b3.1  Header For
get:b3.2  Terminolog
get:b3.3  Sequence N
get:b3.4  Establishi
get:b3.5  Closing a 
get:b3.6  Precedence
get:b3.7  Data Commu
get:b3.8  Interfaces
get:b3.9  Event Proc
get:bGLOSSARY ........
get:bREFERENCES ......
get:bTransmission Cont
get:b[Page ii]        
get:bSeptember 1981   
get:bThis document des
get:b(TCP).  There hav
get:bspecification on 
get:bdraws heavily fro
get:bboth in terms of 
get:bseveral details a
get:band redescribes t
get:bRFC
get:bReplaces: RFC 761
get:bIENs:  129, 124, 
get:b55, 44, 40, 27, 2
get:bThe Transmission 
get:breliable host-to-
get:bcommunication net
get:bThis document des
get:bTransmission Cont
get:binterface to prog
get:bComputer commun
get:brole in militar
get:bdocument focuse
get:bcommunication r
get:bcommunication u
get:bcongestion, but
get:bgovernment sect
get:bAs strategic an
get:bdeveloped and d
get:binterconnecting
get:bcommunication p
get:bapplications.  
get:bDeputy Undersec
get:bdeclared the Tr
get:bbe a basis for 
get:bstandardization
get:bTCP is a connec
get:bfit into a laye
get:bapplications.  
get:bcommunication b
get:bdistinct but in
get:bassumptions are
get:bprotocols below
get:bpotentially unr
get:bprotocols.  In 
get:bwide spectrum o
get:bconnections to 
get:bTransmission Cont
get:bTCP is based on
get:bTCP fits into a
get:bInternet Protoc
get:breceive variabl
get:bdatagram "envel
get:baddressing sour
get:binternet protoc
get:bthe TCP segment
get:bmultiple networ
get:balso carries in
get:band compartment
get:bcommunicated en
get:bMuch of this do
get:bwhich are co-re
get:bcomputer.  Some
get:bfront-end compu
get:bas well as netw
get:ban interface to
get:bimplementable e
get:bhost-to-front e
get:bThe TCP is inte
get:bcommunication s
get:bintended to be 
get:b1.3.  About this 
get:bThis document r
get:bany TCP impleme
get:bprotocols and i
get:b[Page 2]         
get:bSeptember 1981   
get:bsection offers 
get:boperation.  Sec
get:bdesign.  Sectio
get:brequired of TCP
get:buser calls, err
get:bThe TCP interfa
get:bthe other side 
get:bThe interface b
get:billustrated in 
get:bcalls much like
get:bapplication pro
get:bcalls to open a
get:bestablished con
get:basynchronously 
get:bconsiderable fr
get:binterfaces whic
get:benvironment, a 
get:binterface for a
get:bThe interface b
get:bunspecified exc
get:btwo levels can 
get:bTypically, one 
get:binterface.  TCP
get:binterconnected 
get:bthroughout this
get:bAs noted above,
get:bsecurable logic
get:bprocesses.  To 
get:bcommunication s:ystem requires facilities in the following areas
get:bBasic Data Tr
get:bPrecedence an
get:bThe basic opera
get:bthe following p
get:bTransmission Cont
get:bBasic Data Tran:sfer
get:bThe TCP is ab
get:bdirection bet
get:bsegments for 
get:bthe TCPs deci
get:bSometimes use
get:bsubmitted to 
get:bfunction is d
get:bactually tran
get:bpushed throug
get:bpromptly forw
get:bThe exact pus
get:bthe push func
get:bReliability
get:bThe TCP must 
get:bdelivered out
get:bis achieved b
get:btransmitted, 
get:breceiving TCP
get:binterval, the
get:bnumbers are u
get:bout of order 
get:badding a chec
get:breceiver, and
get:bAs long as th
get:bsystem does n
get:berrors will a
get:binternet comm
get:bFlow Control
get:bTCP provides 
get:bsent by the s
get:bevery ACK ind
get:bthe last segm
get:ballowed numbe
get:breceiving fur
get:b[Page 4]         
get:bSeptember 1981   
get:bMultiplexing
get:bTo allow for 
get:bcommunication
get:baddresses or 
get:band host addr
get:ba socket.  A 
get:bThat is, a so
get:bThe binding o
get:bHost.  Howeve
get:b(e.g., a "log
get:bmade known to
get:bthrough the k
get:baddresses of 
get:bConnections
get:bThe reliabili
get:bthat TCPs ini
get:beach data str
get:bsockets, sequ
get:bEach connecti
get:bidentifying i
get:bWhen two proc
get:bestablish a c
get:bside).  When 
get:bterminated or
get:bSince connect
get:bover the unre
get:bmechanism wit
get:berroneous ini
get:bPrecedence and :Security
get:bThe users of 
get:bcommunication
get:bthese feature
get:bTransmission Cont
get:b[Page 6]         
get:bSeptember 1981   
get:b2.1.  Elements of
get:bThe internetwor
get:bwhich are in tu
get:bthat the networ
get:blarge networks 
get:bpacket switchin
get:bconsume message
get:bnetworks, the g
get:bcommunication s
get:bconnections bet
get:bThe term packet
get:btransaction bet
get:bexchanged withi
get:bHosts are compu
get:bnetwork's point
get:bProcesses are v
get:baccordance with
get:bin execution). 
get:bviewed as commu
get:bThus, all commu
get:bSince a process
get:bstreams between
get:bthat each proce
get:bcommunicates wi
get:b2.2.  Model of Op
get:bProcesses trans
get:bdata as argumen
get:bsegments and ca
get:bthe destination
get:binto the receiv
get:bTCPs include co
get:bensure reliable
get:bThe model of in
get:bprotocol module
get:bto the local ne
get:binside internet
get:binternet module
get:bthrough the loc
get:bThe packet swit
get:bTransmission Cont
get:bother operation
get:bdestination int
get:bAt a gateway be
get:bfrom its local 
get:bthe internet da
get:bthen "wrapped" 
get:brouted to the n
get:bA gateway is pe
get:binternet datagr
get:bthrough the nex
get:binternet datagr
get:bfurther broken 
get:binternet datagr
get:binternet module
get:bA destination i
get:b(after reassemb
get:bdestination TCP
get:bThis simple mod
get:bimportant featu
get:bto the gateway 
get:bservice paramet
get:bIncluded in the
get:bdatagram.  Data
get:bhost and gatewa
get:bproperly segreg
get:b2.3.  The Host En
get:bThe TCP is assu
get:baccess the TCP 
get:bmay call on oth
get:bdata structures
get:bcontrolled by a
get:bnetwork device 
get:bdatagram protoc
get:bThe mechanisms 
get:bfront-end proce
get:bhost-to-front-e
get:bthe type of TCP
get:b[Page 8]         
get:bSeptember 1981   
get:bThe TCP/user in
get:bto OPEN or CLOS
get:bSTATUS about a 
get:bprograms on the
get:bfrom, and close
get:bThe TCP/interne
get:bdatagrams addre
get:bsystem.  These 
get:bservice, preced
get:b2.5.  Relation to
get:bThe following d
get:bhierarchy
get:b+------+ +
get:b|Telnet| |
get:b+------+ +
get:b|   
get:b+----
get:b| TCP
get:b+----
get:b| 
get:b+----
get:b|    
get:b+----
get:b+--
get:b|  
get:b+--
get:bIt is expected 
get:bprotocols effic
get:bprotocols like 
get:b2.6.  Reliable Co
get:bA stream of dat
get:border at the de
get:bTransmission Cont
get:bTransmission is
get:backnowledgments
get:bsequence number
get:bsegment is tran
get:bsequence number
get:bis the sequence
get:btransmissions i
get:bsegment contain
get:bstarts a timer;
get:bsegment is dele
get:breceived before
get:bAn acknowledgme
get:bdelivered to th
get:bthe responsibil
get:bTo govern the f
get:bemployed.  The 
get:bThis window spe
get:backnowledgment 
get:b2.7.  Connection 
get:bTo identify the
get:bprovides a port
get:bindependently b
get:bunique addresse
get:bidentifying the
get:bwill be unique 
get:bA connection is
get:blocal socket ma
get:bsockets.  A con
get:bthat is, it is 
get:bTCPs are free t
get:bHowever, severa
get:bThere must be w
get:bthe "appropriat
get:bmay "own" ports
get:bthe ports they 
get:bissue, but we e
get:buniquely alloca
get:bassociating the
get:bA connection is
get:bforeign socket 
get:b[Page 10]        
get:bSeptember 1981   
get:bconnection name
get:bsubsequent call
get:babout a connect
get:bis a data struc
get:bimplementation 
get:bpointer to the 
get:bwhether the con
get:bbe passively wa
get:bA passive OPEN 
get:bconnection requ
get:bOften the proce
get:brequest from an
get:bis used to deno
get:bare allowed onl
get:bA service proce
get:bprocesses would
get:bforeign socket.
get:brequested a con
get:blocal socket we
get:bWell-known sock
get:ba socket addres
get:b"Telnet-Server"
get:bsocket, and oth
get:bEntry, Text Gen
get:bbeing for test 
get:baccess to a "Lo
get:bat which a newl
get:bwell-known sock
get:bof sockets to s
get:bProcesses can i
get:bfrom other proc
get:bbeen establishe
get:bother at the sa
get:bis critical for
get:bcomponents act 
get:bThere are two p
get:bpassive OPENs a
get:blocal passive O
get:bcase, the match
get:bOPENs has left 
get:bforeign socket 
get:bOther possibili
get:bTransmission Cont
get:bIf there are se
get:bsame local sock
get:bwith the specif
get:bTCB exists, bef
get:bThe procedures 
get:bcontrol flag an
get:bexchange has be
get:bA connection is
get:bcontaining a SY
get:bcommand.  The m
get:bconnection has 
get:bwhen sequence n
get:bThe clearing of
get:bin this case ca
get:b2.8.  Data Commun
get:bThe data that f
get:boctets.  The se
get:bin that call (a
get:bthrough to the 
get:bA sending TCP i
get:bsend that data 
get:bfunction is sig
get:breceiving TCP s
get:bthe sending TCP
get:bThere is no nec
get:bboundaries.  Th
get:bsingle SEND cal
get:bThe purpose of 
get:bfrom the sendin
get:brecord service.
get:bThere is a coup
get:bof data that cr
get:bassociated with
get:bbuffer is retur
get:bnot filled.  If
get:bPUSH is seen, t
get:bTCP also provid
get:bat some point f
get:b[Page 12]        
get:bSeptember 1981   
get:bcurrently readi
get:bdefine what the
get:burgent data, bu
get:btake action to 
get:b2.9.  Precedence 
get:bThe TCP makes u
get:bsecurity option
get:bbasis to TCP us
get:ba multilevel se
get:buse only, and o
get:bcompartment.  C
get:busers may be li
get:bTCP modules whi
get:bproperly mark o
get:bprecedence.  Su
get:bhigher level pr
get:bthem to specify
get:bprecedence of c
get:b2.10.  Robustness
get:bTCP implementat:ions will follow a general principle of robustness
get:bconservative in
get:bTransmission Cont
get:b[Page 14]        
get:bSeptember 1981   
get:b3.1.  Header Form
get:bTCP segments ar
get:bheader carries 
get:bdestination hos
get:bheader, supplyi
get:bdivision allows
get:bTCP Header Form
get:b0            
get:b0 1 2 3 4 5 6
get:b+-+-+-+-+-+-+-
get:b|          Sou
get:b+-+-+-+-+-+-+-
get:b|             
get:b+-+-+-+-+-+-+-
get:b|             
get:b+-+-+-+-+-+-+-
get:b|  Data |     
get:b| Offset| Rese
get:b|       |     
get:b+-+-+-+-+-+-+-
get:b|           Ch
get:b+-+-+-+-+-+-+-
get:b|             
get:b+-+-+-+-+-+-+-
get:b|             
get:b+-+-+-+-+-+-+-
get:bNote th
get:bSource Port:  1
get:bThe source po
get:bDestination Por:t
get:bThe destinati
get:bTransmission Cont
get:bFunctional Specif
get:bSequence Number:
get:bThe sequence 
get:bwhen SYN is p
get:binitial seque
get:bAcknowledgment :Number
get:bIf the ACK co
get:bnext sequence
get:breceive.  Onc
get:bData Offset:  4
get:bThe number of
get:bthe data begi
get:bintegral numb
get:bReserved:  6 bi
get:bReserved for 
get:bControl Bits:  :6 bits (from left to right)
get:bURG:  Urgent 
get:bACK:  Acknowl
get:bPSH:  Push Fu
get:bRST:  Reset t
get:bSYN:  Synchro
get:bFIN:  No more
get:bWindow:  16 bit
get:bThe number of
get:backnowledgmen
get:bChecksum:  16 b
get:bThe checksum 
get:bcomplement su
get:bsegment conta
get:bchecksummed, 
get:bform a 16 bit
get:btransmitted a
get:bthe checksum 
get:bThe checksum 
get:b[Page 16]        
get:bSeptember 1981   
get:bprefixed to t
get:bAddress, the 
get:bThis gives th
get:binformation i
get:bacross the TC
get:bcalls by the 
get:bThe TCP Len
get:boctets (thi
get:bcomputed), 
get:bUrgent Pointer:
get:bThis field co
get:bpositive offs
get:burgent pointe
get:bthe urgent da
get:bthe URG contr
get:bOptions:  varia
get:bOptions may o
get:bmultiple of 8
get:bchecksum.  An
get:bcases for the: format of an option
get:bCase 1:  A 
get:bCase 2:  An
get:bth
get:bThe option-le
get:boption-length
get:bNote that the
get:bfield might i
get:bEnd-of-Option
get:bA TCP must im
get:bTransmission Cont
get:bFunctional Specif
get:bCurrently def:ined options include (kind indicated in octal)
get:bKind     Le
get:b----     --
get:b0         
get:b1         
get:b2         
get:bSpecific Opti
get:bEnd of Opti
get:b+--------
get:b|00000000
get:b+--------
get:bThis opti
get:bmight not
get:bthe Data 
get:bnot the e
get:bthe optio
get:bNo-Operatio
get:b+--------
get:b|00000001
get:b+--------
get:bThis opti
get:balign the
get:bThere is 
get:breceivers
get:bnot begin
get:bMaximum Seg
get:b+--------
get:b|00000010
get:b+--------
get:bKind=2  
get:b[Page 18]        
get:bSeptember 1981   
get:bMaximum S:egment Size Option Data
get:bIf this
get:breceive
get:bThis fi
get:b(i.e., 
get:boption 
get:bPadding:  varia
get:bThe TCP heade
get:band data begi
get:b3.2.  Terminology
get:bBefore we can d
get:bto introduce so
get:bconnection requ
get:bof these variab
get:bTransmission Co
get:bTCB are the loc
get:bprecedence of t
get:bbuffers, pointe
get:bIn addition sev
get:bsequence number
get:bSend Sequence
get:bSND.UNA - s
get:bSND.NXT - s
get:bSND.WND - s
get:bSND.UP  - s
get:bSND.WL1 - s
get:bSND.WL2 - s
get:bu
get:bISS     - i
get:bReceive Seque
get:bRCV.NXT - r
get:bRCV.WND - r
get:bRCV.UP  - r
get:bIRS     - i
get:bTransmission Cont
get:bFunctional Specif
get:bThe following d
get:bthe sequence sp
get:bSend Sequence S
get:b---
get:b1 - old s
get:b2 - seque
get:b3 - seque
get:b4 - futur
get:bThe send window
get:bReceive Sequenc
get:b1 - old s
get:b2 - seque
get:b3 - futur
get:bThe receive win
get:bThere are also 
get:btake their valu
get:b[Page 20]        
get:bSeptember 1981   
get:bCurrent Segme
get:bSEG.SEQ - s
get:bSEG.ACK - s
get:bSEG.LEN - s
get:bSEG.WND - s
get:bSEG.UP  - s
get:bSEG.PRC - s
get:bA connection pr
get:blifetime.  The :states are
get:bESTABLISHED, FI
get:bTIME-WAIT, and 
get:bbecause it repr
get:bno connection. : Briefly the meanings of the states are
get:bLISTEN - repr
get:bTCP and port.
get:bSYN-SENT - re
get:bafter having 
get:bSYN-RECEIVED 
get:brequest ackno
get:bconnection re
get:bESTABLISHED -
get:bdelivered to 
get:bof the connec
get:bFIN-WAIT-1 - 
get:bfrom the remo
get:btermination r
get:bFIN-WAIT-2 - 
get:bfrom the remo
get:bCLOSE-WAIT - 
get:bfrom the loca
get:bCLOSING - rep
get:backnowledgmen
get:bLAST-ACK - re
get:bconnection te
get:b(which includ
get:bTransmission Cont
get:bFunctional Specif
get:bTIME-WAIT - r
get:bthe remote TC
get:btermination r
get:bCLOSED - repr
get:bA TCP connectio
get:bevents.  The ev
get:bABORT, and STAT
get:bcontaining the 
get:bThe state diagr
get:bwith the causin
get:berror condition
get:bchanges.  In a 
get:bthe reaction of
get:bNOTE BENE:  thi
get:bthe total speci
get:b[Page 22]        
get:bSeptember 1981   
get:b+---------+     
get:b|         |<----
get:b|   SYN   |     
get:b|   RCVD  |<----
get:b|         |     
get:b|         |-----
get:b+---------+   rc
get:b|           --
get:b|             
get:b|             
get:b|  CLOSE      
get:b| -------     
get:b| snd FIN     
get:b|             
get:bV             
get:b+---------+     
get:b|  FIN    |<----
get:b| WAIT-1  |-----
get:b+---------+     
get:b| rcv ACK of F
get:b| ------------
get:bV        x    
get:b+---------+     
get:b|FINWAIT-2|     
get:b+---------+     
get:b|             
get:b|  rcv FIN    
get:b|  -------    
get:b\ snd ACK    
get:b------------
get:bTransmission Cont
get:bFunctional Specif
get:b3.3.  Sequence Nu
get:bA fundamental n
get:bover a TCP conn
get:bsequenced, each
get:bmechanism emplo
get:bnumber X indica
get:breceived.  This
get:bdetection in th
get:bwithin a segmen
get:bthe header is t
get:bnumbered consec
get:bIt is essential
get:bfinite, though 
get:bSince the space
get:bnumbers must be
get:bpreserves the r
get:b2**32 - 1 to 0 
get:barithmetic, so 
get:bcomparison of s
get:b(modulo 2**32).
get:bThe typical kin
get:bperform include:
get:b(a)  Determin
get:bnumber s
get:b(b)  Determin
get:bhave bee
get:bretransm
get:b(c)  Determin
get:bwhich ar
get:breceive 
get:b[Page 24]        
get:bSeptember 1981   
get:bIn response to 
get:bfollowing compa
get:bSND.UNA = old
get:bSND.NXT = nex
get:bSEG.ACK = ack
get:bnum
get:bSEG.SEQ = fir
get:bSEG.LEN = the
get:b(co
get:bSEG.SEQ+SEG.L
get:bA new acknowled
get:bthe inequality :below holds
get:bSND.UNA < SEG
get:bA segment on th
get:bof its sequence
get:backnowledgment 
get:bWhen data is re:ceived the following comparisons are needed
get:bRCV.NXT = nex
get:bis the le
get:bRCV.NXT+RCV.W
get:bsegment, 
get:bSEG.SEQ = fir
get:bSEG.SEQ+SEG.L
get:bA segment is ju
get:bRCV.NXT =< SE
get:bRCV.NXT =< SE
get:bTransmission Cont
get:bFunctional Specif
get:bThe first part 
get:bsegment falls i
get:bif the end of t
get:beither part of 
get:bActually, it is
get:bwindows and zer
get:bacceptability o:f an incoming segment
get:bSegment Recei
get:bLength  Windo
get:b------- -----
get:b0       0 
get:b0      >0 
get:b>0       0 
get:b>0      >0 
get:bNote that when 
get:bacceptable exce
get:bmaintain a zero
get:bACKs.  However,
get:bprocess the RST
get:bWe have taken a
get:bcontrol informa
get:bsome control fl
get:band acknowledge
get:bcontrol will be
get:bcarried in the 
get:bfor implicitly 
get:bare the only co
get:bare used only a
get:bpurposes, the S
get:boctet of the se
get:bto occur after 
get:boccurs.  The se
get:bspace occupying
get:bsequence number
get:b[Page 26]        
get:bSeptember 1981   
get:bInitial Sequenc
get:bThe protocol pl
get:bused over and o
get:bsockets.  New i
get:bincarnations of
get:b-- "how does th
get:bincarnations of
get:bconnection is b
get:bconnection brea
get:bTo avoid confus
get:bconnection from
get:bbe present in t
get:bassure this, ev
get:bsequence number
get:ban initial sequ
get:bnew 32 bit ISN.
get:bbit clock whose
get:bmicroseconds.  
get:bSince we assume
get:bthe Maximum Seg
get:bhours we can re
get:bFor each connec
get:bsequence number
get:bthe data sendin
get:blearned during 
get:bFor a connectio
get:bsynchronize on 
get:ban exchange of 
get:bcalled "SYN" (f
get:bshorthand, segm
get:bHence, the solu
get:binitial sequenc
get:bThe synchroniza
get:bsequence number
get:bfrom the other 
get:binitial sequenc
get:b1) A --> B  S
get:b2) A <-- B  A
get:b3) A <-- B  S
get:b4) A --> B  A
get:bTransmission Cont
get:bFunctional Specif
get:bBecause steps 2
get:bcalled the thre
get:bA three way han
get:btied to a globa
get:bmechanisms for 
get:bno way of knowi
get:bunless it remem
get:b(which is not a
get:bverify this SYN
get:bclock-driven sc
get:bKnowing When to
get:bTo be sure that
get:bsequence number
get:bthe network, th
get:b(MSL) before as
get:brecovering from
get:blost.  For this
get:bis an engineeri
get:bit is desirable
get:bsense, yet reta
get:bnot wait at all
get:bthan those rece
get:bThe TCP Quiet T
get:bThis specific
get:bretaining any
get:beach active (
get:bTCP segments 
get:bin the intern
get:bparagraphs be
get:bTCP implement
get:bat the risk o
get:bdata rejected
get:bTCPs consume 
get:bentered into 
get:bduplicate det
get:brelies on the
get:bthe extent th
get:bvalues before
get:bbeen delivere
get:bcopies of the
get:bsuch an assum
get:b[Page 28]        
get:bSeptember 1981   
get:bassigned the 
get:bat the receiv
get:bthat each seg
get:bas there are 
get:bUnder normal 
get:bto emit and t
get:bmistakenly us
get:bbeen acknowle
get:bdata is drain
get:bvery large to
get:bcause trouble
get:bto use up 2**
get:blifetime in t
get:bthis is deeme
get:brates escalat
get:bcycle time is
get:bwithin reason
get:bThe basic dup
get:bdefeated, how
get:bsequence numb
get:bthe TCP were 
get:bupon crashing
get:bconnection (p
get:bpackets with 
get:bpackets still
get:bincarnation o
get:babout the seq
get:bspecification
get:bbefore emitti
get:bsegments from
get:bEven hosts wh
get:binitial seque
get:b(i.e., even i
get:bnumber for ea
get:bSuppose, for 
get:bsequence numb
get:band that even
get:btakes on a va
get:bsegment sent 
get:bat this insta
get:bincarnation o
get:bS1 = ISN(t) -
get:bconnection!  
get:bTransmission Cont
get:bFunctional Specif
get:bduplicates in
get:bof S1 may arr
get:bthe new incar
get:bThe problem i
get:bcrashed nor d
get:bthe system fr
get:bOne way to de
get:bsegments for 
get:btime" specifi
get:bwilling to ri
get:bdestination m
get:bImplementors 
get:bconnection by
get:binformally im
get:bObviously, ev
get:bnecessary aft
get:bTo summarize:
get:bnumbers in th
get:b"busy" or "in
get:bblock of spac
get:bsegment, if a
get:bsequence numb
get:bthe previous 
get:bnumber overla
get:b3.4.  Establishin
get:bThe "three-way 
get:bconnection.  Th
get:bresponded to by
get:bsimultaneously 
get:boccurs, each TC
get:backnowledgment 
get:ban old duplicat
get:brecipient, that
get:bProper use of "
get:bSeveral example
get:bexamples do not
get:bsegments, this 
get:bdoesn't deliver
get:bvalid (i.e., th
get:bconnection reac
get:breduces the pos
get:b[Page 30]        
get:bSeptember 1981   
get:bimplementation 
get:binformation for
get:bThe simplest th
get:bfigures should 
get:bnumbered for re
get:bdeparture of a 
get:bsegment at B fr
get:bEllipsis (...) 
get:b(delayed).  An 
get:bComments appear
get:bthe departure o
get:bthe center of e
get:bform, with sequ
get:bfields such as 
get:bin the interest
get:bTCP A      
get:b1.  CLOSED     
get:b2.  SYN-SENT   
get:b3.  ESTABLISHED
get:b4.  ESTABLISHED
get:b5.  ESTABLISHED
get:bBasic 3
get:bIn line 2 of fi
get:bindicating that
get:bnumber 100.  In
get:breceived from T
get:bB is now expect
get:boccupied sequen
get:bAt line 4, TCP 
get:bTCP B's SYN; an
get:bsequence number
get:bbecause the ACK
get:bwould wind up A
get:bTransmission Cont
get:bFunctional Specif
get:bSimultaneous in
get:bfigure 8.  Each
get:bTCP A      
get:b1.  CLOSED     
get:b2.  SYN-SENT   
get:b3.  SYN-RECEIVE
get:b4.             
get:b5.  SYN-RECEIVE
get:b6.  ESTABLISHED
get:b7.             
get:bS
get:bThe principle r
get:bduplicate conne
get:bthis, a special
get:breceiving TCP i
get:bSYN-RECEIVED), 
get:bIf the TCP is i
get:bFIN-WAIT-1, FIN
get:baborts the conn
get:bcase under "hal
get:b[Page 32]        
get:bSeptember 1981   
get:bTCP A      
get:b1.  CLOSED     
get:b2.  SYN-SENT   
get:b3.  (duplicate)
get:b4.  SYN-SENT   
get:b5.  SYN-SENT   
get:b6.             
get:b7.  SYN-SENT   
get:b8.  ESTABLISHED
get:bAs a simple exa
get:bfigure 9.  At l
get:bcannot tell tha
get:b(line 4).  TCP 
get:bRST (reset) wit
get:bbelievable.  TC
get:bWhen the origin
get:bsynchronization
get:bbefore the RST,
get:bsent in both di
get:bHalf-Open Conne
get:bAn established 
get:bTCPs has closed
get:bknowledge of th
get:bbecome desynchr
get:bmemory.  Such c
get:battempt is made
get:bconnections are
get:bmildly involved
get:bIf at site A th
get:bTransmission Cont
get:bFunctional Specif
get:buser at site B 
get:breceiving a res
get:bsite B TCP that
get:bAssume that two
get:banother when a 
get:bDepending on th
get:bthat some error
get:bA is likely to 
get:bpoint.  As a re
get:bor try to SEND 
get:bcase, it receiv
get:blocal (A's) TCP
get:bwill send a seg
get:bexample shown i
get:bre-open the con
get:bTCP A      
get:b1.  (CRASH)    
get:b2.  CLOSED     
get:b3.  SYN-SENT --
get:b4.  (!!)     <-
get:b5.  SYN-SENT --
get:b6.  SYN-SENT   
get:b7.  SYN-SENT --
get:bWhen the SYN ar
get:band the incomin
get:backnowledgment 
get:b100).  TCP A se
get:bsent and, being
get:bdetected a half
get:b[Page 34]        
get:bSeptember 1981   
get:bcontinue to try
get:breduced to the 
get:bAn interesting 
get:btries to send d
get:bThis is illustr
get:bTCP A from TCP 
get:bexists, so TCP 
get:bprocesses it an
get:bTCP A    
get:b1.  (CRASH)    
get:b2.  (??)    <--
get:b3.          -->
get:bActive
get:bIn figure 12, w
get:bwaiting for SYN
get:binto action.  A
get:bgenerate a RST 
get:bthe reset and r
get:bTCP A      
get:b1.  LISTEN     
get:b2.       ... <S
get:b3.  (??) <-- <S
get:b4.       --> <S
get:b5.  LISTEN     
get:bOld Duplic
get:bTransmission Cont
get:bFunctional Specif
get:bA variety of ot
get:bby the followin
get:bReset Generatio
get:bAs a general ru
get:bwhich apparentl
get:bmust not be sen
get:bThere are three: groups of states
get:b1.  If the co
get:bin response t
get:bparticular, S
get:bby this means
get:bIf the incomi
get:bsequence numb
get:breset has seq
get:bof the sequen
get:bThe connectio
get:b2.  If the co
get:bSYN-SENT, SYN
get:bsomething not
get:bif an incomin
get:bdoes not exac
get:bconnection, a
get:bIf our SYN ha
get:bincoming segm
get:beither raise 
get:bthe system) o
get:bincoming segm
get:bcontinue as i
get:bcannot raise 
get:bdetected in t
get:bterminated th
get:bincoming segm
get:bmatch the loc
get:bmust be sent.
get:bIf the incomi
get:bsequence numb
get:breset has seq
get:bof the sequen
get:bThe connectio
get:b[Page 36]        
get:bSeptember 1981   
get:b3.  If the co
get:bFIN-WAIT-1, F
get:bany unaccepta
get:bunacceptible 
get:backnowledgmen
get:band an acknow
get:bto be receive
get:bIf an incomin
get:bprecedence wh
get:band precedenc
get:bconnection go
get:bnumber from t
get:bReset Processin
get:bIn all states e
get:bby checking the
get:bis in the windo
get:bto an initial S
get:backnowledges th
get:bThe receiver of
get:breceiver was in
get:bin SYN-RECEIVED
get:bthen the receiv
get:baborts the conn
get:bwas in any othe
get:band goes to the
get:b3.5.  Closing a C
get:bCLOSE is an ope
get:bnotion of closi
get:binterpretation,
get:bthe receiving s
get:bin a simplex fa
get:buntil he is tol
get:bcould initiate 
get:bRECEIVE until s
get:bhas CLOSED.  We
get:bRECEIVEs are ou
get:bcan terminate h
get:bbuffers SENT be
get:bdata in return 
get:bsuccessfully to
get:bTCP.  Users mus
get:bthe TCP says no
get:bTransmission Cont
get:bFunctional Specif
get:bThere are essen:tially three cases
get:b1) The user i
get:b2) The remote
get:b3) Both users
get:bCase 1:  Local 
get:bIn this case,
get:boutgoing segm
get:baccepted by t
get:bare allowed i
get:bwill be retra
get:bboth acknowle
get:bcan ACK this 
get:bsend its own 
get:bCase 2:  TCP re
get:bIf an unsolic
get:bcan ACK it an
get:buser will res
get:bthe other TCP
get:buntil its own
get:bconnection.  
get:bthe connectio
get:bCase 3:  both u
get:bA simultaneou
get:bFIN segments 
get:bhave been pro
get:bhas received.
get:b[Page 38]        
get:bSeptember 1981   
get:bTCP A      
get:b1.  ESTABLISHED
get:bFIN-WAIT-1 
get:b3.  FIN-WAIT-2 
get:b4.             
get:bTIME-WAIT  
get:b5.  TIME-WAIT  
get:bCLOSED     
get:bTCP A      
get:b1.  ESTABLISHED
get:b2.  (Close)    
get:bFIN-WAIT-1 
get:b3.  CLOSING    
get:b4.  TIME-WAIT  
get:b(2 MSL)    
get:bCLOSED     
get:bTransmission Cont
get:bFunctional Specif
get:b3.6.  Precedence 
get:bThe intent is t
get:bwith exactly th
get:bhigher of the p
get:bThe precedence 
get:bdefined in the 
get:bspecification t
get:bthe security pa
get:buser group, and
get:bA connection at
get:blower precedenc
get:ba connection du
get:backnowledgment 
get:bNote that TCP m
get:bprecedence will
get:bsegments and po
get:bThe security pa
get:b(the values wou
get:bnon-secure envi
get:bparameters, tho
get:b3.7.  Data Commun
get:bOnce the connec
get:bexchange of seg
get:b(checksum test 
get:bretransmission 
get:bDuplicate segme
get:bAs discussed in
get:bcertain tests o
get:bsegments to ver
get:bThe sender of d
get:bthe variable SN
get:bsequence number
get:bkeeps track of 
get:bvariable SND.UN
get:bsent has been a
get:bWhen the sender
get:bSND.NXT.  When 
get:bsends an acknow
get:b[Page 40]        
get:bSeptember 1981   
get:backnowledgment 
get:bthese variables
get:bThe amount by w
get:bdata in the seg
get:bsegments must c
get:bThe CLOSE user 
get:bflag in an inco
get:bRetransmission 
get:bBecause of the 
get:binternetwork sy
get:bretransmission 
get:bfor determining
get:bAn Example Re
get:bMeasure the
get:bparticular 
get:bcovers that
get:bsegments re
get:bTime (RTT).:  Next compute a Smoothed Round Trip Time (SRTT) as
get:bSRTT = ( 
get:band based o:n this, compute the retransmission timeout (RTO) as
get:bRTO = min
get:bwhere UBOUN
get:bLBOUND is a
get:ba smoothing
get:bfactor (e.g
get:bThe Communicati
get:bThe objective o
get:bto stimulate th
get:bpermit the rece
get:bthe currently k
get:bThis mechanism 
get:bthe end of urge
get:bthe receive seq
get:bmust tell the u
get:bnumber catches 
get:bTransmission Cont
get:bFunctional Specif
get:binto "normal mo
get:bis in "urgent m
get:bThe method empl
get:btransmitted.  T
get:bmeaningful and 
get:bthe urgent poin
get:bno urgent data 
get:bTo send an urge
get:boctet.  If the 
get:bthe urgent info
get:bManaging the Wi
get:bThe window sent
get:bnumbers the sen
get:bprepared to acc
get:bthe currently a
get:bIndicating a la
get:barrives than ca
get:bin excessive re
get:bnetwork and the
get:btransmission of
get:bbetween each ne
get:bThe mechanisms 
get:bsubsequently ad
get:bthat much data.
get:bdiscouraged.  T
get:bshrink the wind
get:bon the part of 
get:bThe sending TCP
get:bleast one octet
get:bsending TCP mus
get:bthe window is z
get:binterval when t
get:bguarantee that 
get:bwindow will be 
get:bWhen the receiv
get:bstill send an a
get:band current win
get:bThe sending TCP
get:b[Page 42]        
get:bSeptember 1981   
get:bwhich fit the c
get:bretransmission 
get:bIn a connection
get:bbe carried in a
get:bnumber so there
get:border.  This is
get:binformation to 
get:bthe data receiv
get:bthe window info
get:backnowledgment 
get:bequal or greate
get:bThe window mana
get:bcommunication p
get:bWindow Manage
get:bAllocating 
get:bmany small 
get:bfewer large
get:bOne suggest
get:bdefer updat
get:bleast X per
get:bconnection 
get:bAnother sug
get:bsegments by
get:bsending dat
get:bdata must b
get:bNote that t
get:bretransmiss
get:backnowledgm
get:bwindow info
get:bnew window 
get:bThe segment
get:bof transmit
get:bsegment con
get:bis accepted
get:bIf the send
get:bwindow is n
get:balternating
get:bpauses in t
get:bTransmission Cont
get:bFunctional Specif
get:bresult in b
get:bbig pair. A
get:bmostly smal
get:bThe suggest
get:bactively at
get:bwindows, si
get:bto many sma
get:bThere are of co:urse two interfaces of concern
get:band the TCP/low
get:bof the user/TCP
get:bprotocol module
get:bin detail by th
get:bcase that the l
get:bthat TCPs might
get:bUser/TCP Interf
get:bThe following
get:bat best, fict
get:bfacilities.  
get:bimplementatio
get:bTCPs must pro
get:bthat all TCP 
get:bhierarchy.  T
get:brequired of a
get:bTCP User Comm
get:bThe followi
get:binterface. 
get:bfunction ca
get:bmeant to ru
get:bThe user co
get:bTCP must pe
get:bIndividual 
get:bmay provide
get:bsingle call
get:bautomatical
get:bissued by t
get:b[Page 44]        
get:bSeptember 1981   
get:bIn providin
get:bnot only ac
get:bprocesses i:t serves.  The latter consists of
get:b(a) gener
get:bremote cl
get:b(b) repli
get:bvarious t
get:bFormat:  
get:b[, timeou
get:b-> local 
get:bWe assume
get:bprocesses
get:bto use th
get:bimplement
get:bfor the s
get:blower lev
get:bresult of
get:bable to m
get:bprocess c
get:bIf the ac
get:bcall to L
get:bhave eith
get:bparticula
get:bfor any c
get:bby the su
get:bA transmi
get:bfilled in
get:bOn an act
get:bsynchroni
get:bThe timeo
get:bfor all d
get:bdelivered
get:bwill abor
get:bThe TCP o
get:bthe users
get:bTransmission Cont
get:bFunctional Specif
get:bprecedenc
get:bor securi
get:bthe defau
get:bTCP will 
get:bsecurity/
get:bthe prece
get:brequested
get:bThe prece
get:brequested
get:brequest, 
get:bconnectio
get:bthis prec
get:ballowed t
get:bor that a
get:bA local c
get:bThe local
get:bfor the c
get:bFormat:  
get:bcount, PU
get:bThis call
get:bto be sen
get:bnot been 
get:bimplement
get:bautomatic
get:bauthorize
get:bIf the PU
get:bto the re
get:bsegment c
get:bthe data 
get:btransmiss
get:bIf the UR
get:bwill have
get:bthe urgen
get:bpointer i
get:bbeen cons
get:bis to sti
get:bindicate 
get:b[Page 46]        
get:bSeptember 1981   
get:bdata has 
get:bTCP signa
get:bof times 
get:burgent da
get:bIf no for
get:bconnectio
get:bhas becom
get:blocal soc
get:bforeign s
get:bforeign s
get:bknowing t
get:bHowever, 
get:bbecomes s
get:bSTATUS ca
get:bimplement
get:bsocket is
get:bIf a time
get:bconnectio
get:bIn the si
get:bthe sendi
get:bor the ti
get:bis both s
get:bconnectio
get:boffers po
get:bsophistic
get:bthe proce
get:bfurthermo
get:bMultiple 
get:bthe TCP w
get:bWe have i
get:bwhich a S
get:bpseudo-in
get:breturn a 
get:bimmediate
get:bbeen ackn
get:bassume ev
get:bclose any
get:bkind (syn
get:bsignals, 
get:bwith spec
get:bIn order 
get:bindicatio
get:bTransmission Cont
get:bFunctional Specif
get:bbuffer ad
get:bthe SEND 
get:bindicatin
get:bcalling p
get:bFormat:  
get:bcount) ->
get:bThis comm
get:bspecified
get:bcalling p
get:berror is 
get:bIn the si
get:bcalling p
get:berror occ
get:bA more so
get:bRECEIVEs 
get:bsegments 
get:bthe cost 
get:bnotify th
get:bIf enough
get:bthe PUSH 
get:bThe buffe
get:ba PUSH is
get:breturned 
get:bIf there 
get:bas it arr
get:bshould th
get:badditiona
get:bcall to R
get:bmay now l
get:burgent po
get:bin the sa
get:bboundary 
get:bTo distin
get:bcare of t
get:breturn co
get:bcount ind
get:bAlternati
get:b[Page 48]        
get:bSeptember 1981   
get:ballocate 
get:bwith the 
get:bFormat:  
get:bThis comm
get:bthe conne
get:bauthorize
get:bClosing c
get:bthe sense
get:bretransmi
get:bserviced.
get:bcalls, fo
get:bto the de
get:bcontinue 
get:bmay be tr
get:bmeans "I 
get:breceive a
get:bnot well 
get:bof all it
get:binto ABOR
get:bThe user 
get:binitiativ
get:b(e.g., re
get:bdestinati
get:bBecause c
get:bforeign T
get:bshort tim
get:breplies t
get:bClose als
get:bFormat:  
get:bThis is a
get:bexcluded 
get:btypically
get:bThis comm
get:binformati:on
get:blocal s
get:bTransmission Cont
get:bFunctional Specif
get:bforeign
get:blocal c
get:breceive
get:bsend wi
get:bconnect
get:bnumber 
get:bnumber 
get:burgent 
get:bprecede
get:bsecurit
get:band tra
get:bDepending
get:bimplement
get:bavailable
get:bauthorize
get:bprevents 
get:bconnectio
get:bFormat:  
get:bThis comm
get:baborted, 
get:bbe sent t
get:bDepending
get:bindicatio
get:breceive a
get:bTCP-to-User M
get:bIt is assum
get:bmeans for t
get:bthe TCP doe
get:bto the user
get:ban error me
get:brelating to
get:bother user 
get:bThe followi:ng information is provided
get:bLocal Con
get:bResponse 
get:bBuffer Ad
get:bByte coun
get:bPush flag
get:bUrgent fl
get:b[Page 50]        
get:bSeptember 1981   
get:bTCP/Lower-Level
get:bThe TCP calls
get:breceive infor
get:binternetwork 
get:bProtocol (IP)
get:bIf the lower 
get:bof service an
get:bfor these par:ameters
get:bType of Ser:vice = Precedence: routine, Delay: normal, Throughput
get:bnormal, Rel:iability
get:bTime to Liv
get:bNote that
get:bHere we e
get:bbe delive
get:bIf the lower 
get:bfeature) and 
get:broute informa
get:bso that the s
get:bchecksum be t
get:balso importan
get:bAny lower lev
get:bdestination a
get:bthe "TCP leng
get:bof IP and to 
get:bTransmission Cont
get:bFunctional Specif
get:b3.9.  Event Proce
get:bThe processing 
get:bimplementation.
get:bprocessing sequ
get:bsection only in
get:bThe activity of
get:bThe events that: occur can be cast into three categories
get:barriving segmen
get:bprocessing the 
get:bcases the proce
get:bEvents that o:ccur
get:bArriving Se
get:bSEGMENT A
get:bUSER TIME
get:bRETRANSMI
get:bTIME-WAIT
get:bThe model of th
get:bimmediate retur
get:bpseudo interrup
get:bmeans cause a d
get:bError responses
get:bcommands refere:ncing connections that do not exist receive "error
get:bconnection not 
get:bPlease note in 
get:backnowledgment 
get:bof the sequence
get:bequal to (modul
get:b[Page 52]        
get:bSeptember 1981   
get:bA natural way t
get:bimagine that th
get:bthat their cont
get:bin the sequence
get:band processed i
get:bWhen a segment 
get:bthe segment to 
get:bto be consisten
get:bNote that if no
get:bTransmission Cont
get:bFunctional Specif
get:bCLOSED STATE 
get:bCreate a ne
get:bstate infor
get:bsocket, pre
get:binformation
get:bunspecified
get:bparameters 
get:bprecedence 
get:b"error:  pr:ecedence not allowed" or "error
get:bnot allowed
get:bactive and :the foreign socket is unspecified, return "error
get:bforeign soc
get:bspecified, 
get:b(ISS) is se
get:bis sent.  S
get:bstate, and 
get:bIf the call
get:breturn "err:or
get:bno room to :create a new connection, return "error
get:bresources".
get:bIf active a
get:bconnection 
get:bsegment, se
get:bstate.  Dat
get:bqueued for 
get:burgent bit 
get:bsegments se
get:bqueue the r:equest, respond with "error
get:bIf Foreign :socket was not specified, then return "error
get:bsocket unsp
get:b[Page 54]        
get:bSeptember 1981   
get:bSYN-SENT STAT
get:bSYN-RECEIVED 
get:bESTABLISHED S
get:bFIN-WAIT-1 ST
get:bFIN-WAIT-2 ST
get:bCLOSE-WAIT ST
get:bCLOSING STATE
get:bLAST-ACK STAT
get:bTIME-WAIT STA
get:bReturn "err:or
get:bTransmission Cont
get:bFunctional Specif
get:bCLOSED STATE 
get:bIf the user
get:b"error:  co
get:bOtherwise, :return "error
get:bIf the fore
get:bfrom passiv
get:bSND.UNA to 
get:bassociated 
get:btransmissio
get:brequested i
get:bas a result
get:brequest, re:spond with "error
get:bForeign soc:ket was not specified, then return "error
get:bsocket unsp
get:bSYN-SENT STAT
get:bSYN-RECEIVED 
get:bQueue the d
get:bIf no space: to queue, respond with "error
get:bresources".
get:bESTABLISHED S
get:bCLOSE-WAIT ST
get:bSegmentize 
get:backnowledgm
get:binsufficien:t space to remember this buffer, simply return "error
get:binsufficien
get:bIf the urge
get:burgent poin
get:b[Page 56]        
get:bSeptember 1981   
get:bFIN-WAIT-1 ST
get:bFIN-WAIT-2 ST
get:bCLOSING STATE
get:bLAST-ACK STAT
get:bTIME-WAIT STA
get:bReturn "err:or
get:bTransmission Cont
get:bFunctional Specif
get:bCLOSED STATE 
get:bIf the user
get:b"error:  co
get:bOtherwise r:eturn "error
get:bSYN-SENT STAT
get:bSYN-RECEIVED 
get:bQueue for p
get:bis no room :to queue this request, respond with "error
get:binsufficien
get:bESTABLISHED S
get:bFIN-WAIT-1 ST
get:bFIN-WAIT-2 ST
get:bIf insuffic
get:brequest, qu
get:bremember th:e RECEIVE, respond with "error
get:bresources".
get:bReassemble 
get:bto user.  M
get:bIf RCV.UP i
get:buser notify
get:bWhen the TC
get:bthat fact m
get:backnowledgm
get:bdescribed b
get:b[Page 58]        
get:bSeptember 1981   
get:bCLOSE-WAIT ST
get:bSince the r
get:bsatisfied b
get:buser.  If n
get:b"error:  co
get:btext can be
get:bCLOSING STATE
get:bLAST-ACK STAT
get:bTIME-WAIT STA
get:bReturn "err:or
get:bTransmission Cont
get:bFunctional Specif
get:bCLOSED STATE 
get:bIf the user
get:b"error:  co
get:bOtherwise, :return "error
get:bAny outstan:ding RECEIVEs are returned with "error
get:bresponses. 
get:bSYN-SENT STAT
get:bDelete the :TCB and return "error
get:bqueued SEND
get:bSYN-RECEIVED 
get:bIf no SENDs
get:bthen form a
get:botherwise q
get:bESTABLISHED S
get:bQueue this 
get:bform a FIN 
get:bFIN-WAIT-1 ST
get:bFIN-WAIT-2 ST
get:bStrictly sp:eaking, this is an error and should receive a "error
get:bconnection 
get:bacceptable,
get:bFIN may be 
get:b[Page 60]        
get:bSeptember 1981   
get:bCLOSE-WAIT ST
get:bQueue this 
get:bsegmentized
get:bCLOSING STATE
get:bLAST-ACK STAT
get:bTIME-WAIT STA
get:bRespond wit:h "error
get:bTransmission Cont
get:bFunctional Specif
get:bCLOSED STATE 
get:bIf the user
get:b"error:  co
get:bOtherwise r:eturn "error
get:bAny outstan:ding RECEIVEs should be returned with "error
get:bconnection 
get:bSYN-SENT STAT
get:bAll queued 
get:bnotificatio
get:bSYN-RECEIVED 
get:bESTABLISHED S
get:bFIN-WAIT-1 ST
get:bFIN-WAIT-2 ST
get:bCLOSE-WAIT ST
get:bSend a rese:t segment
get:b<SEQ=SND.
get:bAll queued 
get:bnotificatio
get:bRST formed 
get:bTCB, enter 
get:bCLOSING STATE
get:bLAST-ACK STAT
get:bTIME-WAIT STA
get:bRespond wit
get:b[Page 62]        
get:bSeptember 1981   
get:bCLOSED STATE 
get:bIf the user
get:b"error:  co
get:bOtherwise r:eturn "error
get:bReturn "sta
get:bSYN-SENT STAT
get:bReturn "sta
get:bSYN-RECEIVED 
get:bReturn "sta
get:bESTABLISHED S
get:bReturn "sta
get:bFIN-WAIT-1 ST
get:bReturn "sta
get:bFIN-WAIT-2 ST
get:bReturn "sta
get:bCLOSE-WAIT ST
get:bReturn "sta
get:bCLOSING STATE
get:bReturn "sta
get:bLAST-ACK STAT
get:bReturn "sta
get:bTransmission Cont
get:bFunctional Specif
get:bTIME-WAIT STA
get:bReturn "sta
get:b[Page 64]        
get:bSeptember 1981   
get:bSEGMENT ARRIVES
get:bIf the state 
get:ball data in
get:bsegment con
get:bcontaining 
get:backnowledgm
get:breset seque
get:bIf the ACK 
get:b<SEQ=0><A
get:bIf the ACK 
get:b<SEQ=SEG.
get:bIf the state 
get:bfirst check
get:bAn incomi
get:bsecond chec
get:bAny ackno
get:bthe LISTE
get:bfor any a
get:bformatted: as follows
get:b<SEQ=SE
get:bthird check
get:bIf the SY
get:bsecurity/
get:bmatch the
get:b<SEQ=SE
get:bTransmission Cont
get:bFunctional Specif
get:bIf the SE
get:bthe user 
get:bsend a re
get:b<SEQ=SE
get:bIf the SE
get:bSet RCV.N
get:bcontrol o
get:bshould be: selected and a SYN segment sent of the form
get:b<SEQ=IS
get:bSND.NXT i
get:bstate sho
get:bincoming 
get:bin the SY
get:bnot be re
get:bthe forei
get:bunspecifi
get:bfourth othe
get:bAny other
get:bmust have
get:bprocessin
get:bit could 
get:bincarnati
get:bbut if yo
get:bIf the state 
get:bfirst check
get:bIf the AC
get:bIf SEG.
get:bthe RST
get:b<SEQ=
get:band dis
get:bIf SND.
get:bsecond chec
get:b[Page 66]        
get:bSeptember 1981   
get:bIf the RS
get:bIf the :ACK was acceptable then signal the user "error
get:bconnect
get:bdelete 
get:band ret
get:bthird check
get:bIf the se
get:bmatch the
get:bIf ther
get:b<SEQ=
get:bOtherwi
get:b<SEQ=
get:bIf there 
get:bThe pre
get:bTCB, if
get:b<SEQ=
get:bIf there 
get:bIf the 
get:bin the 
get:bthe pre
get:ballowed
get:b<SEQ=
get:bIf the 
get:bin the 
get:bIf a rese
get:bfourth chec
get:bThis step
get:bno ACK, a
get:bIf the SY
get:bTransmission Cont
get:bFunctional Specif
get:bare accep
get:bSEG.SEQ. 
get:bis an ACK
get:bare there
get:bIf SND.UN
get:bstate to 
get:b<SEQ=SN
get:band send 
get:btransmiss
get:btext in t
get:bbelow whe
get:bOtherwise
get:b<SEQ=IS
get:band send 
get:bsegment, 
get:bhas been 
get:bfifth, if n
get:bsegment and
get:b[Page 68]        
get:bSeptember 1981   
get:bfirst check s
get:bSYN-RECEIVE
get:bESTABLISHED
get:bFIN-WAIT-1 
get:bFIN-WAIT-2 
get:bCLOSE-WAIT 
get:bCLOSING STA
get:bLAST-ACK ST
get:bTIME-WAIT S
get:bSegments 
get:bare used 
get:bdone in S
get:bboundary 
get:bprocessed
get:bThere are
get:bsegment
get:bSegment R
get:bLength  W
get:b------- -
get:b0     
get:b0     
get:b>0     
get:b>0     
get:bIf the RC
get:bspecial a
get:bIf an inc
get:bshould be
get:bthe segme:nt and return)
get:b<SEQ=SN
get:bAfter sen
get:band retur
get:bTransmission Cont
get:bFunctional Specif
get:bIn the fo
get:bsegment t
get:bOne could
get:btrimming 
get:bSYN and F
get:bbegins at
get:bnumbers m
get:bsecond check 
get:bSYN-RECEIVE
get:bIf the RS
get:bIf this
get:bcame fr
get:bLISTEN 
get:bthis co
get:bfrom SY
get:bthe use
get:bon the 
get:bactive 
get:band ret
get:bESTABLISHED
get:bIf the RS
get:bshould re
get:bflushed. 
get:b"connecti
get:bTCB, and 
get:bCLOSING STA
get:bLAST-ACK ST
get:bIf the RS
get:bTCB, and 
get:b[Page 70]        
get:bSeptember 1981   
get:bthird check s
get:bSYN-RECEIVE
get:bIf the se
get:bexactly m
get:bthen send
get:bESTABLISHED
get:bIf the se
get:bexactly m
get:bthen send
get:breceive "
get:bflushed. 
get:b"connecti
get:bTCB, and 
get:bNote this c
get:ba segment f
get:bdifferent s
get:bcurrent con
get:bfourth, check
get:bSYN-RECEIVE
get:bESTABLISHED
get:bFIN-WAIT ST
get:bFIN-WAIT ST
get:bCLOSE-WAIT 
get:bCLOSING STA
get:bLAST-ACK ST
get:bTIME-WAIT S
get:bIf the SY
get:boutstandi
get:ball segme
get:breceive a
get:bthe CLOSE
get:bIf the SY
get:band an ac
get:bnumber ch
get:bTransmission Cont
get:bFunctional Specif
get:bfifth check t
get:bif the ACK 
get:bif the ACK 
get:bSYN-RECEI
get:bIf SND.
get:band con
get:bIf th
get:breset
get:b<SE
get:band s
get:bESTABLISH
get:bIf SND.
get:bAny seg
get:bentirel
get:bpositiv
get:bfully a
get:b"ok" re
get:b(SEG.AC
get:bsomethi
get:bdrop th
get:bIf SND.
get:bupdated
get:bSND.WL2
get:bSND.WL1
get:bNote th
get:brecords
get:bSND.WND
get:bthe las
get:bprevent
get:b[Page 72]        
get:bSeptember 1981   
get:bFIN-WAIT-
get:bIn addi
get:bour FIN
get:bprocess
get:bFIN-WAIT-
get:bIn addi
get:bthe ret
get:backnowl
get:bCLOSE-WAI
get:bDo the 
get:bCLOSING S
get:bIn addi
get:bthe ACK
get:botherwi
get:bLAST-ACK 
get:bThe onl
get:backnowl
get:bdelete 
get:bTIME-WAIT
get:bThe onl
get:bretrans
get:bthe 2 M
get:bsixth, check 
get:bESTABLISHED
get:bFIN-WAIT-1 
get:bFIN-WAIT-2 
get:bIf the UR
get:bthe user 
get:bpointer (
get:buser has 
get:bmode") fo
get:bsignal th
get:bTransmission Cont
get:bFunctional Specif
get:bCLOSE-WAIT 
get:bCLOSING STA
get:bLAST-ACK ST
get:bThis shou
get:bremote si
get:bseventh, proc
get:bESTABLISHED
get:bFIN-WAIT-1 
get:bFIN-WAIT-2 
get:bOnce in t
get:btext to u
get:binto buff
get:bempty.  I
get:bthe user 
get:bhas been 
get:bWhen the 
get:buser it m
get:bOnce the 
get:bRCV.NXT o
get:bapporopri
get:bRCV.NXT a
get:bPlease no
get:bSend an a:cknowledgment of the form
get:b<SEQ=SN
get:bThis ackn
get:btransmitt
get:b[Page 74]        
get:bSeptember 1981   
get:bCLOSE-WAIT 
get:bCLOSING STA
get:bLAST-ACK ST
get:bTIME-WAIT S
get:bThis shou
get:bremote si
get:beighth, check
get:bDo not proc
get:bsince the S
get:bIf the FIN 
get:breturn any 
get:bover the FI
get:bFIN implies
get:bSYN-RECEI
get:bESTABLISH
get:bEnter t
get:bFIN-WAIT-
get:bIf our 
get:benter T
get:btimers;
get:bFIN-WAIT-
get:bEnter t
get:boff the
get:bCLOSE-WAI
get:bRemain 
get:bCLOSING S
get:bRemain 
get:bLAST-ACK 
get:bRemain 
get:bTransmission Cont
get:bFunctional Specif
get:bTIME-WAIT
get:bRemain 
get:btimeout
get:b[Page 76]        
get:bSeptember 1981   
get:bFor any state
get:bthe user "err:or
get:band for any o
get:bstate and ret
get:bRETRANSMISSION 
get:bFor any state
get:bthe retransmi
get:bretransmissio
get:bTIME-WAIT TIMEO
get:bIf the time-w
get:benter the CLO
get:bTransmission Cont
get:b[Page 78]        
get:bSeptember 1981   
get:bBBN Rep
get:ba Host 
get:bhost an
get:bA contr
get:bindicat
get:bspecifi
get:bis expe
get:bpreviou
get:bThe uni
get:bARPANET
get:bA unit 
get:bIMPs.  
get:bA logic
get:bA messa
get:bnetwork
get:bDestination Addre
get:bThe des
get:bidentif
get:bA contr
get:bindicat
get:boccupyi
get:bA porti
get:bfragmen
get:bA file 
get:bTransmission Cont
get:bControl
get:bfragmen
get:bA compu
get:bfrom th
get:bAn Inte
get:bby the 
get:bThe Int
get:bARPANET
get:bA sourc
get:binternet datagram
get:bThe uni
get:bhigher 
get:binternet fragment
get:bA porti
get:bheader.
get:bInterne
get:bThe Ini
get:bnumber 
get:bThe Ini
get:bon a co
get:bbased p
get:bThe Ini
get:bused by
get:bControl
get:bdata.  
get:bon an A
get:b[Page 80]        
get:bSeptember 1981   
get:bThis is
get:bdata re
get:bsequenc
get:bof the 
get:bThe uni
get:bAn impl
get:bprocedu
get:bMaximum
get:bthe int
get:bAn eigh
get:bAn Opti
get:bmay be 
get:bprimari
get:btimesta
get:boptions
get:bA packa
get:blogical
get:blogical
get:bThe por
get:boutput 
get:bA progr
get:bthe poi
get:bA contr
get:bthis se
get:breceivi
get:breceive
get:bTransmission Cont
get:breceive
get:breceive
get:breceive next sequ
get:bThis is
get:breceive
get:bThis re
get:bis will
get:bsegment
get:bRCV.NXT
get:bSegment
get:brange a
get:bA contr
get:bthat th
get:binterac
get:bsequenc
get:bsegment
get:bit.  In
get:brise to
get:bReal Ti:me Protocol
get:bof time
get:bsegment
get:bsegment
get:bsegment
get:bsegment
get:bsegment
get:b[Page 82]        
get:bSeptember 1981   
get:bsegment
get:bA logic
get:bunit of
get:bsegment acknowled
get:bThe seq
get:barrivin
get:bThe amo
get:bincludi
get:bThe num
get:bThis is
get:buse on 
get:binitial
get:beach oc
get:bThis re
get:b(receiv
get:bwindow 
get:breceivi
get:bbe emit
get:bSND.UNA
get:bbetween
get:bsend se
get:bleft se
get:bsend ur
get:bsegment
get:bsegment
get:bTransmission Cont
get:bsend wi
get:bAn addr
get:bis, the
get:bThe sou
get:bA contr
get:bnumber,
get:bwhere t
get:bTransmi
get:bthe sta
get:bThe pre
get:bTransmi:ssion Control Protocol
get:breliabl
get:bType of
get:bAn Inte
get:bfor thi
get:bA contr
get:bindicat
get:burgent 
get:bsequenc
get:bpointer
get:bA contr
get:bfield c
get:bindicat
get:burgent 
get:b[Page 84]        
get:bSeptember 1981   
get:b[1]  Cerf, V., an
get:bIntercommuni
get:bVol. COM-22,
get:b[2]  Postel, J. (
get:bProtocol Spe
get:bInstitute, S
get:b[3]  Dalal, Y. an
get:bProtocols", 
get:bDecember 197
get:b[4]  Postel, J., 
get:bInstitute, S
get:baRFC
get:baDe
get:baI
get:baSeptember 1981   
get:baPREFACE .....
get:ba1.  INTRODUCTION 
get:ba1.1  Motivation
get:ba1.2  Scope ....
get:ba1.3  About This
get:ba1.4  Interfaces
get:ba1.5  Operation 
get:ba2.  PHILOSOPHY ..
get:ba2.1  Elements o
get:ba2.2  Model of O
get:ba2.3  The Host E
get:ba2.4  Interfaces
get:ba2.5  Relation t
get:ba2.6  Reliable C
get:ba2.7  Connection
get:ba2.8  Data Commu
get:ba2.9  Precedence
get:ba2.10 Robustness
get:ba3.  FUNCTIONAL SP
get:ba3.1  Header For
get:ba3.2  Terminolog
get:ba3.3  Sequence N
get:ba3.4  Establishi
get:ba3.5  Closing a 
get:ba3.6  Precedence
get:ba3.7  Data Commu
get:ba3.8  Interfaces
get:ba3.9  Event Proc
get:baGLOSSARY ........
get:baREFERENCES ......
get:baTransmission Cont
get:ba[Page ii]        
get:baSeptember 1981   
get:baThis document des
get:ba(TCP).  There hav
get:baspecification on 
get:badraws heavily fro
get:baboth in terms of 
get:baseveral details a
get:baand redescribes t
get:baRFC
get:baReplaces: RFC 761
get:baIENs:  129, 124, 
get:ba55, 44, 40, 27, 2
get:baThe Transmission 
get:bareliable host-to-
get:bacommunication net
get:baThis document des
get:baTransmission Cont
get:bainterface to prog
get:baComputer commun
get:barole in militar
get:badocument focuse
get:bacommunication r
get:bacommunication u
get:bacongestion, but
get:bagovernment sect
get:baAs strategic an
get:badeveloped and d
get:bainterconnecting
get:bacommunication p
get:baapplications.  
get:baDeputy Undersec
get:badeclared the Tr
get:babe a basis for 
get:bastandardization
get:baTCP is a connec
get:bafit into a laye
get:baapplications.  
get:bacommunication b
get:badistinct but in
get:baassumptions are
get:baprotocols below
get:bapotentially unr
get:baprotocols.  In 
get:bawide spectrum o
get:baconnections to 
get:baTransmission Cont
get:baTCP is based on
get:baTCP fits into a
get:baInternet Protoc
get:bareceive variabl
get:badatagram "envel
get:baaddressing sour
get:bainternet protoc
get:bathe TCP segment
get:bamultiple networ
get:baalso carries in
get:baand compartment
get:bacommunicated en
get:baMuch of this do
get:bawhich are co-re
get:bacomputer.  Some
get:bafront-end compu
get:baas well as netw
get:baan interface to
get:baimplementable e
get:bahost-to-front e
get:baThe TCP is inte
get:bacommunication s
get:baintended to be 
get:ba1.3.  About this 
get:baThis document r
get:baany TCP impleme
get:baprotocols and i
get:ba[Page 2]         
get:baSeptember 1981   
get:basection offers 
get:baoperation.  Sec
get:badesign.  Sectio
get:barequired of TCP
get:bauser calls, err
get:baThe TCP interfa
get:bathe other side 
get:baThe interface b
get:baillustrated in 
get:bacalls much like
get:baapplication pro
get:bacalls to open a
get:baestablished con
get:baasynchronously 
get:baconsiderable fr
get:bainterfaces whic
get:baenvironment, a 
get:bainterface for a
get:baThe interface b
get:baunspecified exc
get:batwo levels can 
get:baTypically, one 
get:bainterface.  TCP
get:bainterconnected 
get:bathroughout this
get:baAs noted above,
get:basecurable logic
get:baprocesses.  To 
get:bacommunication s:ystem requires facilities in the following areas
get:baBasic Data Tr
get:baPrecedence an
get:baThe basic opera
get:bathe following p
get:baTransmission Cont
get:baBasic Data Tran:sfer
get:baThe TCP is ab
get:badirection bet
get:basegments for 
get:bathe TCPs deci
get:baSometimes use
get:basubmitted to 
get:bafunction is d
get:baactually tran
get:bapushed throug
get:bapromptly forw
get:baThe exact pus
get:bathe push func
get:baReliability
get:baThe TCP must 
get:badelivered out
get:bais achieved b
get:batransmitted, 
get:bareceiving TCP
get:bainterval, the
get:banumbers are u
get:baout of order 
get:baadding a chec
get:bareceiver, and
get:baAs long as th
get:basystem does n
get:baerrors will a
get:bainternet comm
get:baFlow Control
get:baTCP provides 
get:basent by the s
get:baevery ACK ind
get:bathe last segm
get:baallowed numbe
get:bareceiving fur
get:ba[Page 4]         
get:baSeptember 1981   
get:baMultiplexing
get:baTo allow for 
get:bacommunication
get:baaddresses or 
get:baand host addr
get:baa socket.  A 
get:baThat is, a so
get:baThe binding o
get:baHost.  Howeve
get:ba(e.g., a "log
get:bamade known to
get:bathrough the k
get:baaddresses of 
get:baConnections
get:baThe reliabili
get:bathat TCPs ini
get:baeach data str
get:basockets, sequ
get:baEach connecti
get:baidentifying i
get:baWhen two proc
get:baestablish a c
get:baside).  When 
get:baterminated or
get:baSince connect
get:baover the unre
get:bamechanism wit
get:baerroneous ini
get:baPrecedence and :Security
get:baThe users of 
get:bacommunication
get:bathese feature
get:baTransmission Cont
get:ba[Page 6]         
get:baSeptember 1981   
get:ba2.1.  Elements of
get:baThe internetwor
get:bawhich are in tu
get:bathat the networ
get:balarge networks 
get:bapacket switchin
get:baconsume message
get:banetworks, the g
get:bacommunication s
get:baconnections bet
get:baThe term packet
get:batransaction bet
get:baexchanged withi
get:baHosts are compu
get:banetwork's point
get:baProcesses are v
get:baaccordance with
get:bain execution). 
get:baviewed as commu
get:baThus, all commu
get:baSince a process
get:bastreams between
get:bathat each proce
get:bacommunicates wi
get:ba2.2.  Model of Op
get:baProcesses trans
get:badata as argumen
get:basegments and ca
get:bathe destination
get:bainto the receiv
get:baTCPs include co
get:baensure reliable
get:baThe model of in
get:baprotocol module
get:bato the local ne
get:bainside internet
get:bainternet module
get:bathrough the loc
get:baThe packet swit
get:baTransmission Cont
get:baother operation
get:badestination int
get:baAt a gateway be
get:bafrom its local 
get:bathe internet da
get:bathen "wrapped" 
get:barouted to the n
get:baA gateway is pe
get:bainternet datagr
get:bathrough the nex
get:bainternet datagr
get:bafurther broken 
get:bainternet datagr
get:bainternet module
get:baA destination i
get:ba(after reassemb
get:badestination TCP
get:baThis simple mod
get:baimportant featu
get:bato the gateway 
get:baservice paramet
get:baIncluded in the
get:badatagram.  Data
get:bahost and gatewa
get:baproperly segreg
get:ba2.3.  The Host En
get:baThe TCP is assu
get:baaccess the TCP 
get:bamay call on oth
get:badata structures
get:bacontrolled by a
get:banetwork device 
get:badatagram protoc
get:baThe mechanisms 
get:bafront-end proce
get:bahost-to-front-e
get:bathe type of TCP
get:ba[Page 8]         
get:baSeptember 1981   
get:baThe TCP/user in
get:bato OPEN or CLOS
get:baSTATUS about a 
get:baprograms on the
get:bafrom, and close
get:baThe TCP/interne
get:badatagrams addre
get:basystem.  These 
get:baservice, preced
get:ba2.5.  Relation to
get:baThe following d
get:bahierarchy
get:ba+------+ +
get:ba|Telnet| |
get:ba+------+ +
get:ba|   
get:ba+----
get:ba| TCP
get:ba+----
get:ba| 
get:ba+----
get:ba|    
get:ba+----
get:ba+--
get:ba|  
get:ba+--
get:baIt is expected 
get:baprotocols effic
get:baprotocols like 
get:ba2.6.  Reliable Co
get:baA stream of dat
get:baorder at the de
get:baTransmission Cont
get:baTransmission is
get:baacknowledgments
get:basequence number
get:basegment is tran
get:basequence number
get:bais the sequence
get:batransmissions i
get:basegment contain
get:bastarts a timer;
get:basegment is dele
get:bareceived before
get:baAn acknowledgme
get:badelivered to th
get:bathe responsibil
get:baTo govern the f
get:baemployed.  The 
get:baThis window spe
get:baacknowledgment 
get:ba2.7.  Connection 
get:baTo identify the
get:baprovides a port
get:baindependently b
get:baunique addresse
get:baidentifying the
get:bawill be unique 
get:baA connection is
get:balocal socket ma
get:basockets.  A con
get:bathat is, it is 
get:baTCPs are free t
get:baHowever, severa
get:baThere must be w
get:bathe "appropriat
get:bamay "own" ports
get:bathe ports they 
get:baissue, but we e
get:bauniquely alloca
get:baassociating the
get:baA connection is
get:baforeign socket 
get:ba[Page 10]        
get:baSeptember 1981   
get:baconnection name
get:basubsequent call
get:baabout a connect
get:bais a data struc
get:baimplementation 
get:bapointer to the 
get:bawhether the con
get:babe passively wa
get:baA passive OPEN 
get:baconnection requ
get:baOften the proce
get:barequest from an
get:bais used to deno
get:baare allowed onl
get:baA service proce
get:baprocesses would
get:baforeign socket.
get:barequested a con
get:balocal socket we
get:baWell-known sock
get:baa socket addres
get:ba"Telnet-Server"
get:basocket, and oth
get:baEntry, Text Gen
get:babeing for test 
get:baaccess to a "Lo
get:baat which a newl
get:bawell-known sock
get:baof sockets to s
get:baProcesses can i
get:bafrom other proc
get:babeen establishe
get:baother at the sa
get:bais critical for
get:bacomponents act 
get:baThere are two p
get:bapassive OPENs a
get:balocal passive O
get:bacase, the match
get:baOPENs has left 
get:baforeign socket 
get:baOther possibili
get:baTransmission Cont
get:baIf there are se
get:basame local sock
get:bawith the specif
get:baTCB exists, bef
get:baThe procedures 
get:bacontrol flag an
get:baexchange has be
get:baA connection is
get:bacontaining a SY
get:bacommand.  The m
get:baconnection has 
get:bawhen sequence n
get:baThe clearing of
get:bain this case ca
get:ba2.8.  Data Commun
get:baThe data that f
get:baoctets.  The se
get:bain that call (a
get:bathrough to the 
get:baA sending TCP i
get:basend that data 
get:bafunction is sig
get:bareceiving TCP s
get:bathe sending TCP
get:baThere is no nec
get:baboundaries.  Th
get:basingle SEND cal
get:baThe purpose of 
get:bafrom the sendin
get:barecord service.
get:baThere is a coup
get:baof data that cr
get:baassociated with
get:babuffer is retur
get:banot filled.  If
get:baPUSH is seen, t
get:baTCP also provid
get:baat some point f
get:ba[Page 12]        
get:baSeptember 1981   
get:bacurrently readi
get:badefine what the
get:baurgent data, bu
get:batake action to 
get:ba2.9.  Precedence 
get:baThe TCP makes u
get:basecurity option
get:babasis to TCP us
get:baa multilevel se
get:bause only, and o
get:bacompartment.  C
get:bausers may be li
get:baTCP modules whi
get:baproperly mark o
get:baprecedence.  Su
get:bahigher level pr
get:bathem to specify
get:baprecedence of c
get:ba2.10.  Robustness
get:baTCP implementat:ions will follow a general principle of robustness
get:baconservative in
get:baTransmission Cont
get:ba[Page 14]        
get:baSeptember 1981   
get:ba3.1.  Header Form
get:baTCP segments ar
get:baheader carries 
get:badestination hos
get:baheader, supplyi
get:badivision allows
get:baTCP Header Form
get:ba0            
get:ba0 1 2 3 4 5 6
get:ba+-+-+-+-+-+-+-
get:ba|          Sou
get:ba+-+-+-+-+-+-+-
get:ba|             
get:ba+-+-+-+-+-+-+-
get:ba|             
get:ba+-+-+-+-+-+-+-
get:ba|  Data |     
get:ba| Offset| Rese
get:ba|       |     
get:ba+-+-+-+-+-+-+-
get:ba|           Ch
get:ba+-+-+-+-+-+-+-
get:ba|             
get:ba+-+-+-+-+-+-+-
get:ba|             
get:ba+-+-+-+-+-+-+-
get:baNote th
get:baSource Port:  1
get:baThe source po
get:baDestination Por:t
get:baThe destinati
get:baTransmission Cont
get:baFunctional Specif
get:baSequence Number:
get:baThe sequence 
get:bawhen SYN is p
get:bainitial seque
get:baAcknowledgment :Number
get:baIf the ACK co
get:banext sequence
get:bareceive.  Onc
get:baData Offset:  4
get:baThe number of
get:bathe data begi
get:baintegral numb
get:baReserved:  6 bi
get:baReserved for 
get:baControl Bits:  :6 bits (from left to right)
get:baURG:  Urgent 
get:baACK:  Acknowl
get:baPSH:  Push Fu
get:baRST:  Reset t
get:baSYN:  Synchro
get:baFIN:  No more
get:baWindow:  16 bit
get:baThe number of
get:baacknowledgmen
get:baChecksum:  16 b
get:baThe checksum 
get:bacomplement su
get:basegment conta
get:bachecksummed, 
get:baform a 16 bit
get:batransmitted a
get:bathe checksum 
get:baThe checksum 
get:ba[Page 16]        
get:baSeptember 1981   
get:baprefixed to t
get:baAddress, the 
get:baThis gives th
get:bainformation i
get:baacross the TC
get:bacalls by the 
get:baThe TCP Len
get:baoctets (thi
get:bacomputed), 
get:baUrgent Pointer:
get:baThis field co
get:bapositive offs
get:baurgent pointe
get:bathe urgent da
get:bathe URG contr
get:baOptions:  varia
get:baOptions may o
get:bamultiple of 8
get:bachecksum.  An
get:bacases for the: format of an option
get:baCase 1:  A 
get:baCase 2:  An
get:bath
get:baThe option-le
get:baoption-length
get:baNote that the
get:bafield might i
get:baEnd-of-Option
get:baA TCP must im
get:baTransmission Cont
get:baFunctional Specif
get:baCurrently def:ined options include (kind indicated in octal)
get:baKind     Le
get:ba----     --
get:ba0         
get:ba1         
get:ba2         
get:baSpecific Opti
get:baEnd of Opti
get:ba+--------
get:ba|00000000
get:ba+--------
get:baThis opti
get:bamight not
get:bathe Data 
get:banot the e
get:bathe optio
get:baNo-Operatio
get:ba+--------
get:ba|00000001
get:ba+--------
get:baThis opti
get:baalign the
get:baThere is 
get:bareceivers
get:banot begin
get:baMaximum Seg
get:ba+--------
get:ba|00000010
get:ba+--------
get:baKind=2  
get:ba[Page 18]        
get:baSeptember 1981   
get:baMaximum S:egment Size Option Data
get:baIf this
get:bareceive
get:baThis fi
get:ba(i.e., 
get:baoption 
get:baPadding:  varia
get:baThe TCP heade
get:baand data begi
get:ba3.2.  Terminology
get:baBefore we can d
get:bato introduce so
get:baconnection requ
get:baof these variab
get:baTransmission Co
get:baTCB are the loc
get:baprecedence of t
get:babuffers, pointe
get:baIn addition sev
get:basequence number
get:baSend Sequence
get:baSND.UNA - s
get:baSND.NXT - s
get:baSND.WND - s
get:baSND.UP  - s
get:baSND.WL1 - s
get:baSND.WL2 - s
get:bau
get:baISS     - i
get:baReceive Seque
get:baRCV.NXT - r
get:baRCV.WND - r
get:baRCV.UP  - r
get:baIRS     - i
get:baTransmission Cont
get:baFunctional Specif
get:baThe following d
get:bathe sequence sp
get:baSend Sequence S
get:ba---
get:ba1 - old s
get:ba2 - seque
get:ba3 - seque
get:ba4 - futur
get:baThe send window
get:baReceive Sequenc
get:ba1 - old s
get:ba2 - seque
get:ba3 - futur
get:baThe receive win
get:baThere are also 
get:batake their valu
get:ba[Page 20]        
get:baSeptember 1981   
get:baCurrent Segme
get:baSEG.SEQ - s
get:baSEG.ACK - s
get:baSEG.LEN - s
get:baSEG.WND - s
get:baSEG.UP  - s
get:baSEG.PRC - s
get:baA connection pr
get:balifetime.  The :states are
get:baESTABLISHED, FI
get:baTIME-WAIT, and 
get:babecause it repr
get:bano connection. : Briefly the meanings of the states are
get:baLISTEN - repr
get:baTCP and port.
get:baSYN-SENT - re
get:baafter having 
get:baSYN-RECEIVED 
get:barequest ackno
get:baconnection re
get:baESTABLISHED -
get:badelivered to 
get:baof the connec
get:baFIN-WAIT-1 - 
get:bafrom the remo
get:batermination r
get:baFIN-WAIT-2 - 
get:bafrom the remo
get:baCLOSE-WAIT - 
get:bafrom the loca
get:baCLOSING - rep
get:baacknowledgmen
get:baLAST-ACK - re
get:baconnection te
get:ba(which includ
get:baTransmission Cont
get:baFunctional Specif
get:baTIME-WAIT - r
get:bathe remote TC
get:batermination r
get:baCLOSED - repr
get:baA TCP connectio
get:baevents.  The ev
get:baABORT, and STAT
get:bacontaining the 
get:baThe state diagr
get:bawith the causin
get:baerror condition
get:bachanges.  In a 
get:bathe reaction of
get:baNOTE BENE:  thi
get:bathe total speci
get:ba[Page 22]        
get:baSeptember 1981   
get:ba+---------+     
get:ba|         |<----
get:ba|   SYN   |     
get:ba|   RCVD  |<----
get:ba|         |     
get:ba|         |-----
get:ba+---------+   rc
get:ba|           --
get:ba|             
get:ba|             
get:ba|  CLOSE      
get:ba| -------     
get:ba| snd FIN     
get:ba|             
get:baV             
get:ba+---------+     
get:ba|  FIN    |<----
get:ba| WAIT-1  |-----
get:ba+---------+     
get:ba| rcv ACK of F
get:ba| ------------
get:baV        x    
get:ba+---------+     
get:ba|FINWAIT-2|     
get:ba+---------+     
get:ba|             
get:ba|  rcv FIN    
get:ba|  -------    
get:ba\ snd ACK    
get:ba------------
get:baTransmission Cont
get:baFunctional Specif
get:ba3.3.  Sequence Nu
get:baA fundamental n
get:baover a TCP conn
get:basequenced, each
get:bamechanism emplo
get:banumber X indica
get:bareceived.  This
get:badetection in th
get:bawithin a segmen
get:bathe header is t
get:banumbered consec
get:baIt is essential
get:bafinite, though 
get:baSince the space
get:banumbers must be
get:bapreserves the r
get:ba2**32 - 1 to 0 
get:baarithmetic, so 
get:bacomparison of s
get:ba(modulo 2**32).
get:baThe typical kin
get:baperform include:
get:ba(a)  Determin
get:banumber s
get:ba(b)  Determin
get:bahave bee
get:baretransm
get:ba(c)  Determin
get:bawhich ar
get:bareceive 
get:ba[Page 24]        
get:baSeptember 1981   
get:baIn response to 
get:bafollowing compa
get:baSND.UNA = old
get:baSND.NXT = nex
get:baSEG.ACK = ack
get:banum
get:baSEG.SEQ = fir
get:baSEG.LEN = the
get:ba(co
get:baSEG.SEQ+SEG.L
get:baA new acknowled
get:bathe inequality :below holds
get:baSND.UNA < SEG
get:baA segment on th
get:baof its sequence
get:baacknowledgment 
get:baWhen data is re:ceived the following comparisons are needed
get:baRCV.NXT = nex
get:bais the le
get:baRCV.NXT+RCV.W
get:basegment, 
get:baSEG.SEQ = fir
get:baSEG.SEQ+SEG.L
get:baA segment is ju
get:baRCV.NXT =< SE
get:baRCV.NXT =< SE
get:baTransmission Cont
get:baFunctional Specif
get:baThe first part 
get:basegment falls i
get:baif the end of t
get:baeither part of 
get:baActually, it is
get:bawindows and zer
get:baacceptability o:f an incoming segment
get:baSegment Recei
get:baLength  Windo
get:ba------- -----
get:ba0       0 
get:ba0      >0 
get:ba>0       0 
get:ba>0      >0 
get:baNote that when 
get:baacceptable exce
get:bamaintain a zero
get:baACKs.  However,
get:baprocess the RST
get:baWe have taken a
get:bacontrol informa
get:basome control fl
get:baand acknowledge
get:bacontrol will be
get:bacarried in the 
get:bafor implicitly 
get:baare the only co
get:baare used only a
get:bapurposes, the S
get:baoctet of the se
get:bato occur after 
get:baoccurs.  The se
get:baspace occupying
get:basequence number
get:ba[Page 26]        
get:baSeptember 1981   
get:baInitial Sequenc
get:baThe protocol pl
get:baused over and o
get:basockets.  New i
get:baincarnations of
get:ba-- "how does th
get:baincarnations of
get:baconnection is b
get:baconnection brea
get:baTo avoid confus
get:baconnection from
get:babe present in t
get:baassure this, ev
get:basequence number
get:baan initial sequ
get:banew 32 bit ISN.
get:babit clock whose
get:bamicroseconds.  
get:baSince we assume
get:bathe Maximum Seg
get:bahours we can re
get:baFor each connec
get:basequence number
get:bathe data sendin
get:balearned during 
get:baFor a connectio
get:basynchronize on 
get:baan exchange of 
get:bacalled "SYN" (f
get:bashorthand, segm
get:baHence, the solu
get:bainitial sequenc
get:baThe synchroniza
get:basequence number
get:bafrom the other 
get:bainitial sequenc
get:ba1) A --> B  S
get:ba2) A <-- B  A
get:ba3) A <-- B  S
get:ba4) A --> B  A
get:baTransmission Cont
get:baFunctional Specif
get:baBecause steps 2
get:bacalled the thre
get:baA three way han
get:batied to a globa
get:bamechanisms for 
get:bano way of knowi
get:baunless it remem
get:ba(which is not a
get:baverify this SYN
get:baclock-driven sc
get:baKnowing When to
get:baTo be sure that
get:basequence number
get:bathe network, th
get:ba(MSL) before as
get:barecovering from
get:balost.  For this
get:bais an engineeri
get:bait is desirable
get:basense, yet reta
get:banot wait at all
get:bathan those rece
get:baThe TCP Quiet T
get:baThis specific
get:baretaining any
get:baeach active (
get:baTCP segments 
get:bain the intern
get:baparagraphs be
get:baTCP implement
get:baat the risk o
get:badata rejected
get:baTCPs consume 
get:baentered into 
get:baduplicate det
get:barelies on the
get:bathe extent th
get:bavalues before
get:babeen delivere
get:bacopies of the
get:basuch an assum
get:ba[Page 28]        
get:baSeptember 1981   
get:baassigned the 
get:baat the receiv
get:bathat each seg
get:baas there are 
get:baUnder normal 
get:bato emit and t
get:bamistakenly us
get:babeen acknowle
get:badata is drain
get:bavery large to
get:bacause trouble
get:bato use up 2**
get:balifetime in t
get:bathis is deeme
get:barates escalat
get:bacycle time is
get:bawithin reason
get:baThe basic dup
get:badefeated, how
get:basequence numb
get:bathe TCP were 
get:baupon crashing
get:baconnection (p
get:bapackets with 
get:bapackets still
get:baincarnation o
get:baabout the seq
get:baspecification
get:babefore emitti
get:basegments from
get:baEven hosts wh
get:bainitial seque
get:ba(i.e., even i
get:banumber for ea
get:baSuppose, for 
get:basequence numb
get:baand that even
get:batakes on a va
get:basegment sent 
get:baat this insta
get:baincarnation o
get:baS1 = ISN(t) -
get:baconnection!  
get:baTransmission Cont
get:baFunctional Specif
get:baduplicates in
get:baof S1 may arr
get:bathe new incar
get:baThe problem i
get:bacrashed nor d
get:bathe system fr
get:baOne way to de
get:basegments for 
get:batime" specifi
get:bawilling to ri
get:badestination m
get:baImplementors 
get:baconnection by
get:bainformally im
get:baObviously, ev
get:banecessary aft
get:baTo summarize:
get:banumbers in th
get:ba"busy" or "in
get:bablock of spac
get:basegment, if a
get:basequence numb
get:bathe previous 
get:banumber overla
get:ba3.4.  Establishin
get:baThe "three-way 
get:baconnection.  Th
get:baresponded to by
get:basimultaneously 
get:baoccurs, each TC
get:baacknowledgment 
get:baan old duplicat
get:barecipient, that
get:baProper use of "
get:baSeveral example
get:baexamples do not
get:basegments, this 
get:badoesn't deliver
get:bavalid (i.e., th
get:baconnection reac
get:bareduces the pos
get:ba[Page 30]        
get:baSeptember 1981   
get:baimplementation 
get:bainformation for
get:baThe simplest th
get:bafigures should 
get:banumbered for re
get:badeparture of a 
get:basegment at B fr
get:baEllipsis (...) 
get:ba(delayed).  An 
get:baComments appear
get:bathe departure o
get:bathe center of e
get:baform, with sequ
get:bafields such as 
get:bain the interest
get:baTCP A      
get:ba1.  CLOSED     
get:ba2.  SYN-SENT   
get:ba3.  ESTABLISHED
get:ba4.  ESTABLISHED
get:ba5.  ESTABLISHED
get:baBasic 3
get:baIn line 2 of fi
get:baindicating that
get:banumber 100.  In
get:bareceived from T
get:baB is now expect
get:baoccupied sequen
get:baAt line 4, TCP 
get:baTCP B's SYN; an
get:basequence number
get:babecause the ACK
get:bawould wind up A
get:baTransmission Cont
get:baFunctional Specif
get:baSimultaneous in
get:bafigure 8.  Each
get:baTCP A      
get:ba1.  CLOSED     
get:ba2.  SYN-SENT   
get:ba3.  SYN-RECEIVE
get:ba4.             
get:ba5.  SYN-RECEIVE
get:ba6.  ESTABLISHED
get:ba7.             
get:baS
get:baThe principle r
get:baduplicate conne
get:bathis, a special
get:bareceiving TCP i
get:baSYN-RECEIVED), 
get:baIf the TCP is i
get:baFIN-WAIT-1, FIN
get:baaborts the conn
get:bacase under "hal
get:ba[Page 32]        
get:baSeptember 1981   
get:baTCP A      
get:ba1.  CLOSED     
get:ba2.  SYN-SENT   
get:ba3.  (duplicate)
get:ba4.  SYN-SENT   
get:ba5.  SYN-SENT   
get:ba6.             
get:ba7.  SYN-SENT   
get:ba8.  ESTABLISHED
get:baAs a simple exa
get:bafigure 9.  At l
get:bacannot tell tha
get:ba(line 4).  TCP 
get:baRST (reset) wit
get:babelievable.  TC
get:baWhen the origin
get:basynchronization
get:babefore the RST,
get:basent in both di
get:baHalf-Open Conne
get:baAn established 
get:baTCPs has closed
get:baknowledge of th
get:babecome desynchr
get:bamemory.  Such c
get:baattempt is made
get:baconnections are
get:bamildly involved
get:baIf at site A th
get:baTransmission Cont
get:baFunctional Specif
get:bauser at site B 
get:bareceiving a res
get:basite B TCP that
get:baAssume that two
get:baanother when a 
get:baDepending on th
get:bathat some error
get:baA is likely to 
get:bapoint.  As a re
get:baor try to SEND 
get:bacase, it receiv
get:balocal (A's) TCP
get:bawill send a seg
get:baexample shown i
get:bare-open the con
get:baTCP A      
get:ba1.  (CRASH)    
get:ba2.  CLOSED     
get:ba3.  SYN-SENT --
get:ba4.  (!!)     <-
get:ba5.  SYN-SENT --
get:ba6.  SYN-SENT   
get:ba7.  SYN-SENT --
get:baWhen the SYN ar
get:baand the incomin
get:baacknowledgment 
get:ba100).  TCP A se
get:basent and, being
get:badetected a half
get:ba[Page 34]        
get:baSeptember 1981   
get:bacontinue to try
get:bareduced to the 
get:baAn interesting 
get:batries to send d
get:baThis is illustr
get:baTCP A from TCP 
get:baexists, so TCP 
get:baprocesses it an
get:baTCP A    
get:ba1.  (CRASH)    
get:ba2.  (??)    <--
get:ba3.          -->
get:baActive
get:baIn figure 12, w
get:bawaiting for SYN
get:bainto action.  A
get:bagenerate a RST 
get:bathe reset and r
get:baTCP A      
get:ba1.  LISTEN     
get:ba2.       ... <S
get:ba3.  (??) <-- <S
get:ba4.       --> <S
get:ba5.  LISTEN     
get:baOld Duplic
get:baTransmission Cont
get:baFunctional Specif
get:baA variety of ot
get:baby the followin
get:baReset Generatio
get:baAs a general ru
get:bawhich apparentl
get:bamust not be sen
get:baThere are three: groups of states
get:ba1.  If the co
get:bain response t
get:baparticular, S
get:baby this means
get:baIf the incomi
get:basequence numb
get:bareset has seq
get:baof the sequen
get:baThe connectio
get:ba2.  If the co
get:baSYN-SENT, SYN
get:basomething not
get:baif an incomin
get:badoes not exac
get:baconnection, a
get:baIf our SYN ha
get:baincoming segm
get:baeither raise 
get:bathe system) o
get:baincoming segm
get:bacontinue as i
get:bacannot raise 
get:badetected in t
get:baterminated th
get:baincoming segm
get:bamatch the loc
get:bamust be sent.
get:baIf the incomi
get:basequence numb
get:bareset has seq
get:baof the sequen
get:baThe connectio
get:ba[Page 36]        
get:baSeptember 1981   
get:ba3.  If the co
get:baFIN-WAIT-1, F
get:baany unaccepta
get:baunacceptible 
get:baacknowledgmen
get:baand an acknow
get:bato be receive
get:baIf an incomin
get:baprecedence wh
get:baand precedenc
get:baconnection go
get:banumber from t
get:baReset Processin
get:baIn all states e
get:baby checking the
get:bais in the windo
get:bato an initial S
get:baacknowledges th
get:baThe receiver of
get:bareceiver was in
get:bain SYN-RECEIVED
get:bathen the receiv
get:baaborts the conn
get:bawas in any othe
get:baand goes to the
get:ba3.5.  Closing a C
get:baCLOSE is an ope
get:banotion of closi
get:bainterpretation,
get:bathe receiving s
get:bain a simplex fa
get:bauntil he is tol
get:bacould initiate 
get:baRECEIVE until s
get:bahas CLOSED.  We
get:baRECEIVEs are ou
get:bacan terminate h
get:babuffers SENT be
get:badata in return 
get:basuccessfully to
get:baTCP.  Users mus
get:bathe TCP says no
get:baTransmission Cont
get:baFunctional Specif
get:baThere are essen:tially three cases
get:ba1) The user i
get:ba2) The remote
get:ba3) Both users
get:baCase 1:  Local 
get:baIn this case,
get:baoutgoing segm
get:baaccepted by t
get:baare allowed i
get:bawill be retra
get:baboth acknowle
get:bacan ACK this 
get:basend its own 
get:baCase 2:  TCP re
get:baIf an unsolic
get:bacan ACK it an
get:bauser will res
get:bathe other TCP
get:bauntil its own
get:baconnection.  
get:bathe connectio
get:baCase 3:  both u
get:baA simultaneou
get:baFIN segments 
get:bahave been pro
get:bahas received.
get:ba[Page 38]        
get:baSeptember 1981   
get:baTCP A      
get:ba1.  ESTABLISHED
get:baFIN-WAIT-1 
get:ba3.  FIN-WAIT-2 
get:ba4.             
get:baTIME-WAIT  
get:ba5.  TIME-WAIT  
get:baCLOSED     
get:baTCP A      
get:ba1.  ESTABLISHED
get:ba2.  (Close)    
get:baFIN-WAIT-1 
get:ba3.  CLOSING    
get:ba4.  TIME-WAIT  
get:ba(2 MSL)    
get:baCLOSED     
get:baTransmission Cont
get:baFunctional Specif
get:ba3.6.  Precedence 
get:baThe intent is t
get:bawith exactly th
get:bahigher of the p
get:baThe precedence 
get:badefined in the 
get:baspecification t
get:bathe security pa
get:bauser group, and
get:baA connection at
get:balower precedenc
get:baa connection du
get:baacknowledgment 
get:baNote that TCP m
get:baprecedence will
get:basegments and po
get:baThe security pa
get:ba(the values wou
get:banon-secure envi
get:baparameters, tho
get:ba3.7.  Data Commun
get:baOnce the connec
get:baexchange of seg
get:ba(checksum test 
get:baretransmission 
get:baDuplicate segme
get:baAs discussed in
get:bacertain tests o
get:basegments to ver
get:baThe sender of d
get:bathe variable SN
get:basequence number
get:bakeeps track of 
get:bavariable SND.UN
get:basent has been a
get:baWhen the sender
get:baSND.NXT.  When 
get:basends an acknow
get:ba[Page 40]        
get:baSeptember 1981   
get:baacknowledgment 
get:bathese variables
get:baThe amount by w
get:badata in the seg
get:basegments must c
get:baThe CLOSE user 
get:baflag in an inco
get:baRetransmission 
get:baBecause of the 
get:bainternetwork sy
get:baretransmission 
get:bafor determining
get:baAn Example Re
get:baMeasure the
get:baparticular 
get:bacovers that
get:basegments re
get:baTime (RTT).:  Next compute a Smoothed Round Trip Time (SRTT) as
get:baSRTT = ( 
get:baand based o:n this, compute the retransmission timeout (RTO) as
get:baRTO = min
get:bawhere UBOUN
get:baLBOUND is a
get:baa smoothing
get:bafactor (e.g
get:baThe Communicati
get:baThe objective o
get:bato stimulate th
get:bapermit the rece
get:bathe currently k
get:baThis mechanism 
get:bathe end of urge
get:bathe receive seq
get:bamust tell the u
get:banumber catches 
get:baTransmission Cont
get:baFunctional Specif
get:bainto "normal mo
get:bais in "urgent m
get:baThe method empl
get:batransmitted.  T
get:bameaningful and 
get:bathe urgent poin
get:bano urgent data 
get:baTo send an urge
get:baoctet.  If the 
get:bathe urgent info
get:baManaging the Wi
get:baThe window sent
get:banumbers the sen
get:baprepared to acc
get:bathe currently a
get:baIndicating a la
get:baarrives than ca
get:bain excessive re
get:banetwork and the
get:batransmission of
get:babetween each ne
get:baThe mechanisms 
get:basubsequently ad
get:bathat much data.
get:badiscouraged.  T
get:bashrink the wind
get:baon the part of 
get:baThe sending TCP
get:baleast one octet
get:basending TCP mus
get:bathe window is z
get:bainterval when t
get:baguarantee that 
get:bawindow will be 
get:baWhen the receiv
get:bastill send an a
get:baand current win
get:baThe sending TCP
get:ba[Page 42]        
get:baSeptember 1981   
get:bawhich fit the c
get:baretransmission 
get:baIn a connection
get:babe carried in a
get:banumber so there
get:baorder.  This is
get:bainformation to 
get:bathe data receiv
get:bathe window info
get:baacknowledgment 
get:baequal or greate
get:baThe window mana
get:bacommunication p
get:baWindow Manage
get:baAllocating 
get:bamany small 
get:bafewer large
get:baOne suggest
get:badefer updat
get:baleast X per
get:baconnection 
get:baAnother sug
get:basegments by
get:basending dat
get:badata must b
get:baNote that t
get:baretransmiss
get:baacknowledgm
get:bawindow info
get:banew window 
get:baThe segment
get:baof transmit
get:basegment con
get:bais accepted
get:baIf the send
get:bawindow is n
get:baalternating
get:bapauses in t
get:baTransmission Cont
get:baFunctional Specif
get:baresult in b
get:babig pair. A
get:bamostly smal
get:baThe suggest
get:baactively at
get:bawindows, si
get:bato many sma
get:baThere are of co:urse two interfaces of concern
get:baand the TCP/low
get:baof the user/TCP
get:baprotocol module
get:bain detail by th
get:bacase that the l
get:bathat TCPs might
get:baUser/TCP Interf
get:baThe following
get:baat best, fict
get:bafacilities.  
get:baimplementatio
get:baTCPs must pro
get:bathat all TCP 
get:bahierarchy.  T
get:barequired of a
get:baTCP User Comm
get:baThe followi
get:bainterface. 
get:bafunction ca
get:bameant to ru
get:baThe user co
get:baTCP must pe
get:baIndividual 
get:bamay provide
get:basingle call
get:baautomatical
get:baissued by t
get:ba[Page 44]        
get:baSeptember 1981   
get:baIn providin
get:banot only ac
get:baprocesses i:t serves.  The latter consists of
get:ba(a) gener
get:baremote cl
get:ba(b) repli
get:bavarious t
get:baFormat:  
get:ba[, timeou
get:ba-> local 
get:baWe assume
get:baprocesses
get:bato use th
get:baimplement
get:bafor the s
get:balower lev
get:baresult of
get:baable to m
get:baprocess c
get:baIf the ac
get:bacall to L
get:bahave eith
get:baparticula
get:bafor any c
get:baby the su
get:baA transmi
get:bafilled in
get:baOn an act
get:basynchroni
get:baThe timeo
get:bafor all d
get:badelivered
get:bawill abor
get:baThe TCP o
get:bathe users
get:baTransmission Cont
get:baFunctional Specif
get:baprecedenc
get:baor securi
get:bathe defau
get:baTCP will 
get:basecurity/
get:bathe prece
get:barequested
get:baThe prece
get:barequested
get:barequest, 
get:baconnectio
get:bathis prec
get:baallowed t
get:baor that a
get:baA local c
get:baThe local
get:bafor the c
get:baFormat:  
get:bacount, PU
get:baThis call
get:bato be sen
get:banot been 
get:baimplement
get:baautomatic
get:baauthorize
get:baIf the PU
get:bato the re
get:basegment c
get:bathe data 
get:batransmiss
get:baIf the UR
get:bawill have
get:bathe urgen
get:bapointer i
get:babeen cons
get:bais to sti
get:baindicate 
get:ba[Page 46]        
get:baSeptember 1981   
get:badata has 
get:baTCP signa
get:baof times 
get:baurgent da
get:baIf no for
get:baconnectio
get:bahas becom
get:balocal soc
get:baforeign s
get:baforeign s
get:baknowing t
get:baHowever, 
get:babecomes s
get:baSTATUS ca
get:baimplement
get:basocket is
get:baIf a time
get:baconnectio
get:baIn the si
get:bathe sendi
get:baor the ti
get:bais both s
get:baconnectio
get:baoffers po
get:basophistic
get:bathe proce
get:bafurthermo
get:baMultiple 
get:bathe TCP w
get:baWe have i
get:bawhich a S
get:bapseudo-in
get:bareturn a 
get:baimmediate
get:babeen ackn
get:baassume ev
get:baclose any
get:bakind (syn
get:basignals, 
get:bawith spec
get:baIn order 
get:baindicatio
get:baTransmission Cont
get:baFunctional Specif
get:babuffer ad
get:bathe SEND 
get:baindicatin
get:bacalling p
get:baFormat:  
get:bacount) ->
get:baThis comm
get:baspecified
get:bacalling p
get:baerror is 
get:baIn the si
get:bacalling p
get:baerror occ
get:baA more so
get:baRECEIVEs 
get:basegments 
get:bathe cost 
get:banotify th
get:baIf enough
get:bathe PUSH 
get:baThe buffe
get:baa PUSH is
get:bareturned 
get:baIf there 
get:baas it arr
get:bashould th
get:baadditiona
get:bacall to R
get:bamay now l
get:baurgent po
get:bain the sa
get:baboundary 
get:baTo distin
get:bacare of t
get:bareturn co
get:bacount ind
get:baAlternati
get:ba[Page 48]        
get:baSeptember 1981   
get:baallocate 
get:bawith the 
get:baFormat:  
get:baThis comm
get:bathe conne
get:baauthorize
get:baClosing c
get:bathe sense
get:baretransmi
get:baserviced.
get:bacalls, fo
get:bato the de
get:bacontinue 
get:bamay be tr
get:bameans "I 
get:bareceive a
get:banot well 
get:baof all it
get:bainto ABOR
get:baThe user 
get:bainitiativ
get:ba(e.g., re
get:badestinati
get:baBecause c
get:baforeign T
get:bashort tim
get:bareplies t
get:baClose als
get:baFormat:  
get:baThis is a
get:baexcluded 
get:batypically
get:baThis comm
get:bainformati:on
get:balocal s
get:baTransmission Cont
get:baFunctional Specif
get:baforeign
get:balocal c
get:bareceive
get:basend wi
get:baconnect
get:banumber 
get:banumber 
get:baurgent 
get:baprecede
get:basecurit
get:baand tra
get:baDepending
get:baimplement
get:baavailable
get:baauthorize
get:baprevents 
get:baconnectio
get:baFormat:  
get:baThis comm
get:baaborted, 
get:babe sent t
get:baDepending
get:baindicatio
get:bareceive a
get:baTCP-to-User M
get:baIt is assum
get:bameans for t
get:bathe TCP doe
get:bato the user
get:baan error me
get:barelating to
get:baother user 
get:baThe followi:ng information is provided
get:baLocal Con
get:baResponse 
get:baBuffer Ad
get:baByte coun
get:baPush flag
get:baUrgent fl
get:ba[Page 50]        
get:baSeptember 1981   
get:baTCP/Lower-Level
get:baThe TCP calls
get:bareceive infor
get:bainternetwork 
get:baProtocol (IP)
get:baIf the lower 
get:baof service an
get:bafor these par:ameters
get:baType of Ser:vice = Precedence: routine, Delay: normal, Throughput
get:banormal, Rel:iability
get:baTime to Liv
get:baNote that
get:baHere we e
get:babe delive
get:baIf the lower 
get:bafeature) and 
get:baroute informa
get:baso that the s
get:bachecksum be t
get:baalso importan
get:baAny lower lev
get:badestination a
get:bathe "TCP leng
get:baof IP and to 
get:baTransmission Cont
get:baFunctional Specif
get:ba3.9.  Event Proce
get:baThe processing 
get:baimplementation.
get:baprocessing sequ
get:basection only in
get:baThe activity of
get:baThe events that: occur can be cast into three categories
get:baarriving segmen
get:baprocessing the 
get:bacases the proce
get:baEvents that o:ccur
get:baArriving Se
get:baSEGMENT A
get:baUSER TIME
get:baRETRANSMI
get:baTIME-WAIT
get:baThe model of th
get:baimmediate retur
get:bapseudo interrup
get:bameans cause a d
get:baError responses
get:bacommands refere:ncing connections that do not exist receive "error
get:baconnection not 
get:baPlease note in 
get:baacknowledgment 
get:baof the sequence
get:baequal to (modul
get:ba[Page 52]        
get:baSeptember 1981   
get:baA natural way t
get:baimagine that th
get:bathat their cont
get:bain the sequence
get:baand processed i
get:baWhen a segment 
get:bathe segment to 
get:bato be consisten
get:baNote that if no
get:baTransmission Cont
get:baFunctional Specif
get:baCLOSED STATE 
get:baCreate a ne
get:bastate infor
get:basocket, pre
get:bainformation
get:baunspecified
get:baparameters 
get:baprecedence 
get:ba"error:  pr:ecedence not allowed" or "error
get:banot allowed
get:baactive and :the foreign socket is unspecified, return "error
get:baforeign soc
get:baspecified, 
get:ba(ISS) is se
get:bais sent.  S
get:bastate, and 
get:baIf the call
get:bareturn "err:or
get:bano room to :create a new connection, return "error
get:baresources".
get:baIf active a
get:baconnection 
get:basegment, se
get:bastate.  Dat
get:baqueued for 
get:baurgent bit 
get:basegments se
get:baqueue the r:equest, respond with "error
get:baIf Foreign :socket was not specified, then return "error
get:basocket unsp
get:ba[Page 54]        
get:baSeptember 1981   
get:baSYN-SENT STAT
get:baSYN-RECEIVED 
get:baESTABLISHED S
get:baFIN-WAIT-1 ST
get:baFIN-WAIT-2 ST
get:baCLOSE-WAIT ST
get:baCLOSING STATE
get:baLAST-ACK STAT
get:baTIME-WAIT STA
get:baReturn "err:or
get:baTransmission Cont
get:baFunctional Specif
get:baCLOSED STATE 
get:baIf the user
get:ba"error:  co
get:baOtherwise, :return "error
get:baIf the fore
get:bafrom passiv
get:baSND.UNA to 
get:baassociated 
get:batransmissio
get:barequested i
get:baas a result
get:barequest, re:spond with "error
get:baForeign soc:ket was not specified, then return "error
get:basocket unsp
get:baSYN-SENT STAT
get:baSYN-RECEIVED 
get:baQueue the d
get:baIf no space: to queue, respond with "error
get:baresources".
get:baESTABLISHED S
get:baCLOSE-WAIT ST
get:baSegmentize 
get:baacknowledgm
get:bainsufficien:t space to remember this buffer, simply return "error
get:bainsufficien
get:baIf the urge
get:baurgent poin
get:ba[Page 56]        
get:baSeptember 1981   
get:baFIN-WAIT-1 ST
get:baFIN-WAIT-2 ST
get:baCLOSING STATE
get:baLAST-ACK STAT
get:baTIME-WAIT STA
get:baReturn "err:or
get:baTransmission Cont
get:baFunctional Specif
get:baCLOSED STATE 
get:baIf the user
get:ba"error:  co
get:baOtherwise r:eturn "error
get:baSYN-SENT STAT
get:baSYN-RECEIVED 
get:baQueue for p
get:bais no room :to queue this request, respond with "error
get:bainsufficien
get:baESTABLISHED S
get:baFIN-WAIT-1 ST
get:baFIN-WAIT-2 ST
get:baIf insuffic
get:barequest, qu
get:baremember th:e RECEIVE, respond with "error
get:baresources".
get:baReassemble 
get:bato user.  M
get:baIf RCV.UP i
get:bauser notify
get:baWhen the TC
get:bathat fact m
get:baacknowledgm
get:badescribed b
get:ba[Page 58]        
get:baSeptember 1981   
get:baCLOSE-WAIT ST
get:baSince the r
get:basatisfied b
get:bauser.  If n
get:ba"error:  co
get:batext can be
get:baCLOSING STATE
get:baLAST-ACK STAT
get:baTIME-WAIT STA
get:baReturn "err:or
get:baTransmission Cont
get:baFunctional Specif
get:baCLOSED STATE 
get:baIf the user
get:ba"error:  co
get:baOtherwise, :return "error
get:baAny outstan:ding RECEIVEs are returned with "error
get:baresponses. 
get:baSYN-SENT STAT
get:baDelete the :TCB and return "error
get:baqueued SEND
get:baSYN-RECEIVED 
get:baIf no SENDs
get:bathen form a
get:baotherwise q
get:baESTABLISHED S
get:baQueue this 
get:baform a FIN 
get:baFIN-WAIT-1 ST
get:baFIN-WAIT-2 ST
get:baStrictly sp:eaking, this is an error and should receive a "error
get:baconnection 
get:baacceptable,
get:baFIN may be 
get:ba[Page 60]        
get:baSeptember 1981   
get:baCLOSE-WAIT ST
get:baQueue this 
get:basegmentized
get:baCLOSING STATE
get:baLAST-ACK STAT
get:baTIME-WAIT STA
get:baRespond wit:h "error
get:baTransmission Cont
get:baFunctional Specif
get:baCLOSED STATE 
get:baIf the user
get:ba"error:  co
get:baOtherwise r:eturn "error
get:baAny outstan:ding RECEIVEs should be returned with "error
get:baconnection 
get:baSYN-SENT STAT
get:baAll queued 
get:banotificatio
get:baSYN-RECEIVED 
get:baESTABLISHED S
get:baFIN-WAIT-1 ST
get:baFIN-WAIT-2 ST
get:baCLOSE-WAIT ST
get:baSend a rese:t segment
get:ba<SEQ=SND.
get:baAll queued 
get:banotificatio
get:baRST formed 
get:baTCB, enter 
get:baCLOSING STATE
get:baLAST-ACK STAT
get:baTIME-WAIT STA
get:baRespond wit
get:ba[Page 62]        
get:baSeptember 1981   
get:baCLOSED STATE 
get:baIf the user
get:ba"error:  co
get:baOtherwise r:eturn "error
get:baReturn "sta
get:baSYN-SENT STAT
get:baReturn "sta
get:baSYN-RECEIVED 
get:baReturn "sta
get:baESTABLISHED S
get:baReturn "sta
get:baFIN-WAIT-1 ST
get:baReturn "sta
get:baFIN-WAIT-2 ST
get:baReturn "sta
get:baCLOSE-WAIT ST
get:baReturn "sta
get:baCLOSING STATE
get:baReturn "sta
get:baLAST-ACK STAT
get:baReturn "sta
get:baTransmission Cont
get:baFunctional Specif
get:baTIME-WAIT STA
get:baReturn "sta
get:ba[Page 64]        
get:baSeptember 1981   
get:baSEGMENT ARRIVES
get:baIf the state 
get:baall data in
get:basegment con
get:bacontaining 
get:baacknowledgm
get:bareset seque
get:baIf the ACK 
get:ba<SEQ=0><A
get:baIf the ACK 
get:ba<SEQ=SEG.
get:baIf the state 
get:bafirst check
get:baAn incomi
get:basecond chec
get:baAny ackno
get:bathe LISTE
get:bafor any a
get:baformatted: as follows
get:ba<SEQ=SE
get:bathird check
get:baIf the SY
get:basecurity/
get:bamatch the
get:ba<SEQ=SE
get:baTransmission Cont
get:baFunctional Specif
get:baIf the SE
get:bathe user 
get:basend a re
get:ba<SEQ=SE
get:baIf the SE
get:baSet RCV.N
get:bacontrol o
get:bashould be: selected and a SYN segment sent of the form
get:ba<SEQ=IS
get:baSND.NXT i
get:bastate sho
get:baincoming 
get:bain the SY
get:banot be re
get:bathe forei
get:baunspecifi
get:bafourth othe
get:baAny other
get:bamust have
get:baprocessin
get:bait could 
get:baincarnati
get:babut if yo
get:baIf the state 
get:bafirst check
get:baIf the AC
get:baIf SEG.
get:bathe RST
get:ba<SEQ=
get:baand dis
get:baIf SND.
get:basecond chec
get:ba[Page 66]        
get:baSeptember 1981   
get:baIf the RS
get:baIf the :ACK was acceptable then signal the user "error
get:baconnect
get:badelete 
get:baand ret
get:bathird check
get:baIf the se
get:bamatch the
get:baIf ther
get:ba<SEQ=
get:baOtherwi
get:ba<SEQ=
get:baIf there 
get:baThe pre
get:baTCB, if
get:ba<SEQ=
get:baIf there 
get:baIf the 
get:bain the 
get:bathe pre
get:baallowed
get:ba<SEQ=
get:baIf the 
get:bain the 
get:baIf a rese
get:bafourth chec
get:baThis step
get:bano ACK, a
get:baIf the SY
get:baTransmission Cont
get:baFunctional Specif
get:baare accep
get:baSEG.SEQ. 
get:bais an ACK
get:baare there
get:baIf SND.UN
get:bastate to 
get:ba<SEQ=SN
get:baand send 
get:batransmiss
get:batext in t
get:babelow whe
get:baOtherwise
get:ba<SEQ=IS
get:baand send 
get:basegment, 
get:bahas been 
get:bafifth, if n
get:basegment and
get:ba[Page 68]        
get:baSeptember 1981   
get:bafirst check s
get:baSYN-RECEIVE
get:baESTABLISHED
get:baFIN-WAIT-1 
get:baFIN-WAIT-2 
get:baCLOSE-WAIT 
get:baCLOSING STA
get:baLAST-ACK ST
get:baTIME-WAIT S
get:baSegments 
get:baare used 
get:badone in S
get:baboundary 
get:baprocessed
get:baThere are
get:basegment
get:baSegment R
get:baLength  W
get:ba------- -
get:ba0     
get:ba0     
get:ba>0     
get:ba>0     
get:baIf the RC
get:baspecial a
get:baIf an inc
get:bashould be
get:bathe segme:nt and return)
get:ba<SEQ=SN
get:baAfter sen
get:baand retur
get:baTransmission Cont
get:baFunctional Specif
get:baIn the fo
get:basegment t
get:baOne could
get:batrimming 
get:baSYN and F
get:babegins at
get:banumbers m
get:basecond check 
get:baSYN-RECEIVE
get:baIf the RS
get:baIf this
get:bacame fr
get:baLISTEN 
get:bathis co
get:bafrom SY
get:bathe use
get:baon the 
get:baactive 
get:baand ret
get:baESTABLISHED
get:baIf the RS
get:bashould re
get:baflushed. 
get:ba"connecti
get:baTCB, and 
get:baCLOSING STA
get:baLAST-ACK ST
get:baIf the RS
get:baTCB, and 
get:ba[Page 70]        
get:baSeptember 1981   
get:bathird check s
get:baSYN-RECEIVE
get:baIf the se
get:baexactly m
get:bathen send
get:baESTABLISHED
get:baIf the se
get:baexactly m
get:bathen send
get:bareceive "
get:baflushed. 
get:ba"connecti
get:baTCB, and 
get:baNote this c
get:baa segment f
get:badifferent s
get:bacurrent con
get:bafourth, check
get:baSYN-RECEIVE
get:baESTABLISHED
get:baFIN-WAIT ST
get:baFIN-WAIT ST
get:baCLOSE-WAIT 
get:baCLOSING STA
get:baLAST-ACK ST
get:baTIME-WAIT S
get:baIf the SY
get:baoutstandi
get:baall segme
get:bareceive a
get:bathe CLOSE
get:baIf the SY
get:baand an ac
get:banumber ch
get:baTransmission Cont
get:baFunctional Specif
get:bafifth check t
get:baif the ACK 
get:baif the ACK 
get:baSYN-RECEI
get:baIf SND.
get:baand con
get:baIf th
get:bareset
get:ba<SE
get:baand s
get:baESTABLISH
get:baIf SND.
get:baAny seg
get:baentirel
get:bapositiv
get:bafully a
get:ba"ok" re
get:ba(SEG.AC
get:basomethi
get:badrop th
get:baIf SND.
get:baupdated
get:baSND.WL2
get:baSND.WL1
get:baNote th
get:barecords
get:baSND.WND
get:bathe las
get:baprevent
get:ba[Page 72]        
get:baSeptember 1981   
get:baFIN-WAIT-
get:baIn addi
get:baour FIN
get:baprocess
get:baFIN-WAIT-
get:baIn addi
get:bathe ret
get:baacknowl
get:baCLOSE-WAI
get:baDo the 
get:baCLOSING S
get:baIn addi
get:bathe ACK
get:baotherwi
get:baLAST-ACK 
get:baThe onl
get:baacknowl
get:badelete 
get:baTIME-WAIT
get:baThe onl
get:baretrans
get:bathe 2 M
get:basixth, check 
get:baESTABLISHED
get:baFIN-WAIT-1 
get:baFIN-WAIT-2 
get:baIf the UR
get:bathe user 
get:bapointer (
get:bauser has 
get:bamode") fo
get:basignal th
get:baTransmission Cont
get:baFunctional Specif
get:baCLOSE-WAIT 
get:baCLOSING STA
get:baLAST-ACK ST
get:baThis shou
get:baremote si
get:baseventh, proc
get:baESTABLISHED
get:baFIN-WAIT-1 
get:baFIN-WAIT-2 
get:baOnce in t
get:batext to u
get:bainto buff
get:baempty.  I
get:bathe user 
get:bahas been 
get:baWhen the 
get:bauser it m
get:baOnce the 
get:baRCV.NXT o
get:baapporopri
get:baRCV.NXT a
get:baPlease no
get:baSend an a:cknowledgment of the form
get:ba<SEQ=SN
get:baThis ackn
get:batransmitt
get:ba[Page 74]        
get:baSeptember 1981   
get:baCLOSE-WAIT 
get:baCLOSING STA
get:baLAST-ACK ST
get:baTIME-WAIT S
get:baThis shou
get:baremote si
get:baeighth, check
get:baDo not proc
get:basince the S
get:baIf the FIN 
get:bareturn any 
get:baover the FI
get:baFIN implies
get:baSYN-RECEI
get:baESTABLISH
get:baEnter t
get:baFIN-WAIT-
get:baIf our 
get:baenter T
get:batimers;
get:baFIN-WAIT-
get:baEnter t
get:baoff the
get:baCLOSE-WAI
get:baRemain 
get:baCLOSING S
get:baRemain 
get:baLAST-ACK 
get:baRemain 
get:baTransmission Cont
get:baFunctional Specif
get:baTIME-WAIT
get:baRemain 
get:batimeout
get:ba[Page 76]        
get:baSeptember 1981   
get:baFor any state
get:bathe user "err:or
get:baand for any o
get:bastate and ret
get:baRETRANSMISSION 
get:baFor any state
get:bathe retransmi
get:baretransmissio
get:baTIME-WAIT TIMEO
get:baIf the time-w
get:baenter the CLO
get:baTransmission Cont
get:ba[Page 78]        
get:baSeptember 1981   
get:baBBN Rep
get:baa Host 
get:bahost an
get:baA contr
get:baindicat
get:baspecifi
get:bais expe
get:bapreviou
get:baThe uni
get:baARPANET
get:baA unit 
get:baIMPs.  
get:baA logic
get:baA messa
get:banetwork
get:baDestination Addre
get:baThe des
get:baidentif
get:baA contr
get:baindicat
get:baoccupyi
get:baA porti
get:bafragmen
get:baA file 
get:baTransmission Cont
get:baControl
get:bafragmen
get:baA compu
get:bafrom th
get:baAn Inte
get:baby the 
get:baThe Int
get:baARPANET
get:baA sourc
get:bainternet datagram
get:baThe uni
get:bahigher 
get:bainternet fragment
get:baA porti
get:baheader.
get:baInterne
get:baThe Ini
get:banumber 
get:baThe Ini
get:baon a co
get:babased p
get:baThe Ini
get:baused by
get:baControl
get:badata.  
get:baon an A
get:ba[Page 80]        
get:baSeptember 1981   
get:baThis is
get:badata re
get:basequenc
get:baof the 
get:baThe uni
get:baAn impl
get:baprocedu
get:baMaximum
get:bathe int
get:baAn eigh
get:baAn Opti
get:bamay be 
get:baprimari
get:batimesta
get:baoptions
get:baA packa
get:balogical
get:balogical
get:baThe por
get:baoutput 
get:baA progr
get:bathe poi
get:baA contr
get:bathis se
get:bareceivi
get:bareceive
get:baTransmission Cont
get:bareceive

